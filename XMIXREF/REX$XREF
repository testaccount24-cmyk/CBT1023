   ==> Scan of exec succeeded (rc <= 4)
   -------------------------------------------------
    1) See trace 's' exec in:
          SFRH66.PUBLIC.REXXXREF.SAMPLE.SCAN(REX$XREF)

    2) Trace listing + XREF listing in:
          SFRH66.PUBLIC.REXXXREF.SAMPLE.XREF(REX$XREF)
   -----------------------------------------

READY
    REX$XREF
    Generated scan code/comment:   trace 's'
    Generated scan code/comment:   /*  rexx member for scan/xref was: */
    Generated scan code/comment:   /*     "SFRH66.PUBLIC.REXXXREF.REXX(REX$XREF)"      */
    Generated scan code/comment:   /*      -------------------------------------       */
    Generated scan code/comment:   /*  date/time of XREF was:                          */
    Generated scan code/comment:   /*     20231220 12:35:31                            */
    Generated scan code/comment:   /*      -------------------------------------       */
     1 *-* /* REXX */
     2 *-* /*                                                                           */
     3 *-* /* written by:  Richard Humphris                                             */
     4 *-* /* email:       richard.humphris@netnitco.net                                */
     5 *-* /* cell:        219-707-1409                                                 */
     6 *-* /*                                                                           */
     7 *-* /* version      change                                                       */
     8 *-* /* -------      ------------------------------------------------------------ */
     9 *-* /* 1.02         update "address" command:                                    */
    10 *-* /*              1. add explicit address commands to xreference for ease of use*/
    11 *-* /*              2. fix:  address syntax                                      */
    12 *-* /*                                                                           */
    13 *-* /*                 syntax 1:  address environment [exprc]                    */
    14 *-* /*                 syntax 2:  address [VALUE] exprv                          */
    15 *-* /*                    a) environment names                                   */
    16 *-* /*                         1) environment (1st format) is an environment if  */
    17 *-* /*                        it 1st word is a symbol or a constant.  In either  */
    18 *-* /*                        case, a symbol is treated as a constant, not a     */
    19 *-* /*                        variable.                                          */
    20 *-* /*                         2) exprv is an expression that evaluates to a     */
    21 *-* /*                        environment name if 1st word is not a symbol or    */
    22 *-* /*                        a constant.  Or if "VALUE" is explicitly specified.*/
    23 *-* /*                    b) command to be executed [exprc] only is an option w/ */
    24 *-* /*                      the 1st syntax of the address command.               */
    25 *-* /*                    c) The fixes to the address command:                   */
    26 *-* /*                         1) if VALUE was not specified, we always treated  */
    27 *-* /*                        the implied syntax 2 (w/o VALUE) as syntax 1.      */
    28 *-* /*                         2) environment (in syntax 1) is specified as a    */
    29 *-* /*                        constant did not appear in the xref, only "variables"*/
    30 *-* /*                        did.  But "variables" as "environment" in syntax 1 */
    31 *-* /*               3. new function.                                            */
    32 *-* /*                    a)  we will add a xref section for address environments*/
    33 *-* /*                   like:                                                   */
    34 *-* /*                       address 'environment'                               */
    35 *-* /*                       address 'environment' <cmd>                         */
    36 *-* /*                       address VALUE exprv                                 */
    37 *-* /*                                                                           */
    38 *-* /*              4. internal changes include:                                 */
    39 *-* /*                 a.  variableAddrDef.      stem added                      */
    40 *-* /*                     variableAddrDefValue. stem added                      */
    41 *-* /*                 b.  called routine "c0480AddressDefine:" created          */
    42 *-* /*                 c.  code for ADDRESS command modified.                    */
    43 *-* /*                           among other things, to call c0480               */
    44 *-* /*                           and it will use variable "line_without_comments"*/
    45 *-* /*                           for "ADDRESS VALUE" syntax.                     */
    46 *-* /*                 d.  xref code updated to output address info.             */
    47 *-* /*                 e.  change routine c0070ParseLinePass1:                   */
    48 *-* /*                     1.  remove comments and labels to set variable:       */
    49 *-* /*                            "LineWithoutCommentsNlabels"                   */
    50 *-* /*                     2.  Then continue parsing as before with the other    */
    51 *-* /*                            variables.                                     */
    52 *-* /*                                                                           */
    53 *-* /*              5. fix test for a variable/stem assignment                   */
    54 *-* /*                                                                           */
    55 *-* /* 1.01         initial "release"                                            */
    56 *-* /*                                                                           */
    57 *-* /*                                                                           */
    58 *-* /*    summarize process:                                                     */
    59 *-* /*    ------------------                                                     */
    60 *-* /*          Input:  a rexx exec you want a cross reference for.              */
    61 *-* /*                                                                           */
    62 *-* /*          process:                                                         */
    63 *-* /*             1) read rexx exec from libraryX.(member) (your exec library)  */
    64 *-* /*                                                                           */
    65 *-* /*             2) create member in hlq.SCAN(member)                          */
    66 *-* /*                                                                           */
    67 *-* /*                a) if fb, change to vb (hlq.SCAN) is vb                    */
    68 *-* /*                                                                           */
    69 *-* /*                b) remove seq #'s (either fb or vb)                        */
    70 *-* /*                                                                           */
    71 *-* /*                c) add header information (comments) to converted exec     */
    72 *-* /*                                                                           */
    73 *-* /*                d) add trace 's' after header        in converted exec     */
    74 *-* /*                                                                           */
    75 *-* /*             3) run converted member with/  trace 's'                      */
    76 *-* /*                                                                           */
    77 *-* /*                a) save output in a temporary file.                        */
    78 *-* /*                                                                           */
    79 *-* /*                b) if trace unsuccessful, update hlq.XREF with scan        */
    80 *-* /*                 output and we're done.                                    */
    81 *-* /*                                                                           */
    82 *-* /* ====>       4) run REX$XREF (this exec) to create the cross reference     */
    83 *-* /*                                                                           */
    84 *-* /*                a) save xref in a temporary file.                          */
    85 *-* /*                                                                           */
    86 *-* /*             5) create header, copy scan output, copy xref output and      */
    87 *-* /*               create a member in hlq.XREF(member)                         */
    88 *-* /*                                                                           */
    89 *-* /*    purpose of REX$XREF:                                                   */
    90 *-* /*    --------------------                                                   */
    91 *-* /*                                                                           */
    92 *-* /*         1)  input:  trace 's' output of exec; we want to gen a xref for.  */
    93 *-* /*                                                                           */
    94 *-* /*         2)  process trace 's' output and create s xref                    */
    95 *-* /*                                                                           */
    96 *-* /*             a)  "pass 1" reads rexx code and looks for labels, call       */
    97 *-* /*            instructions, function calls, signal instructions, variables   */
    98 *-* /*            used (assigned and/or referrenced) and stems used and/or       */
    99 *-* /*            referenced.  All labels, variable and stems are saved in       */
   100 *-* /*                                                                           */
   101 *-* /*                 1)  all labels, variables, stems (with variables used)    */
   102 *-* /*                are all saved in upperCase.                                */
   103 *-* /*                                                                           */
   104 *-* /*                 2)  stems with numeric values after the period are changed*/
   105 *-* /*                to # (except for 0).                                       */
   106 *-* /*                                                                           */
   107 *-* /*                    For example:                                           */
   108 *-* /*                                                                           */
   109 *-* /*                     stem as used     stem as saved for xref               */
   110 *-* /*                     ------------     ----------------------               */
   111 *-* /*                     xyz.var1.0       XYZ.VAR1.0                           */
   112 *-* /*                     xyz.var1.1       XYZ.VAR1.#                           */
   113 *-* /*                     xyz.var1.2         (see above)                        */
   114 *-* /*                     xyz.var1.3         (see above)                        */
   115 *-* /*                                                                           */
   116 *-* /*                                                                           */
   117 *-* /*             b)  "pass 2" the "output pass"                                */
   118 *-* /*                                                                           */
   119 *-* /*                 1) the "constant" xref section 1                          */
   120 *-* /*                                                                           */
   121 *-* /*                    a) variables are sorted                                */
   122 *-* /*                                                                           */
   123 *-* /*                    b) only variables that aren't assigned in rexx code    */
   124 *-* /*                   appear here.                                            */
   125 *-* /*                                                                           */
   126 *-* /*                    c) so labels (also used as variables) are only reported*/
   127 *-* /*                   here if the variable use was only a reference.          */
   128 *-* /*                                                                           */
   129 *-* /*                                                                           */
   130 *-* /*                                                                           */
   131 *-* /*    Note:                                                                  */
   132 *-* /*          NO syntax checking is done.  We ran the rexx syntax checker and  */
   133 *-* /*         what's "good" for rexx is "good" for us.                          */
   134 *-* /*                                                                           */
   135 *-* /*          Therefore, it greatly simplifies code.  For example, if you put  */
   136 *-* /*         a variable on a "ITERATE" statement, for example, we just assume  */
   137 *-* /*         it will be a single variable and references a active do loop. BUT */
   138 *-* /*         to simplify this code, we treat value like any other expression   */
   139 *-* /*         on the right hand side of an assignment statement say.  We depend */
   140 *-* /*         on REXX to pick up syntax problems.                               */
   141 *-* /*                                                                           */
   142 *-* /*          Also, we do NOT look at "constants" enclosed in quotes.  So if   */
   143 *-* /*         for example,you code a "EXECIO" command with STEM X. in quotes    */
   144 *-* /*         we will NOT generate a assignment for the rexx stem X. (for that  */
   145 *-* /*         statement).                                                       */
   146 *-* /*                                                                           */
   147 *-* /*                                                                           */
   149 *-* signal on syntax /* set trap for syntax errors */
   150 *-* parse source . . . . . . . addressSpace .
   151 *-* if addressSpace = 'OMVS'
   152 *-*  then
       *-*  do
   153 *-*   omvsSeg = 1 /* user can use bpxwunix() function */
   154 *-*  end
   155 *-* else
       *-*  do
   156 *-*   x = syscalls('ON')
   157 *-*   if x = 0
   158 *-*    then
       *-*    do
   159 *-*     omvsSeg = 1 /* user can use bpxwunix function */
   160 *-*     x = syscalls('OFF')
   161 *-*    end
   162 *-*   else
       *-*    omvsSeg = 0 /* will have to use rexx subroutine to do sorting (slow)*/
   163 *-*  end
   165 *-* say ' '
   166 *-* if omvsSeg = 1
   167 *-*  then
       *-*  say 'XREF will be able to use a fast omvs sort, as we have an OMVS segment)'
   168 *-* else
       *-*  say 'XREF can''t do a fast omvs sort (no OMVS segment); will use rexx code to sort'
   169 *-* say ' '
   171 *-* signal startUp      /* "branch" over the syntax handling routine */
   173 *-* syntax:
   174 *-* /*-------*/
   175 *-* /*-------*/
   176 *-* /* syntax:  error handling */
   177 *-* /*   rc    is set to the syntax error number;                        */
   178 *-* /*         ... equivelent to IRX00nnL as rc = 00, 01 to 99           */
   179 *-* /*   sigl  is set to the line number in error                        */
   180 *-* parse source . . execname .
   181 *-* say 'IRX00'right('00'rc,2)'I Error running exec' ,              execName 'line' sigl':' errortext(rc)
   183 *-* syntaxLow = max(sigl-7,1)            /* -7 before (or pgm start) */
   184 *-* syntaxHigh= min(sigl+7,sourceline()) /* +7 after  (or pgm end)   */
   185 *-* do syntaxII = syntaxLow to syntaxHigh/* -7 lines back to +7 lines*/
   186 *-*  if syntaxII <> sigl
   187 *-*   then
       *-*   say 'line   ' right(syntaxii,length(syntaxHigh))':' ,                     sourceline(syntaxII)
   189 *-*  else
       *-*   say 'line==>' right(syntaxii,length(syntaxHigh))':' ,                     sourceline(syntaxII)
   191 *-* end
   192 *-* say 'exiting exec with rc=12'
   193 *-* exit 12
   195 *-* startUp:
   196 *-* /*--------*/
   197 *-* /*--------*/
   198 *-* /* start of pgm... skipped error routine "syntax:" */
   199 *-* /* ----------------------------------------------- */
   201 *-* /* handle arguments/options for the execution of this exec */
   202 *-* /* ------------------------------------------------------- */
   203 *-* debug = 'OFF'  /* set to ON or OFF; will do more say statements if ON */
   204 *-* parse upper arg . 'DEBUG=' valuex .
   205 *-* parse upper arg . 'REXXLINE=' valuey .
   206 *-* parse upper arg . 'WIDTH=' valuez .
   207 *-* parse upper arg . 'BLANK=' valueb .
   209 *-* say ' '
   210 *-* say 'Options used:'
   211 *-* say '-------------'
   212 *-* say ' '
   214 *-* if valuex = 'ON' | valuex = 'OFF'
   215 *-*  then
       *-*  debug = valuex
   216 *-* else
       *-*  debug = 'OFF'
   217 *-* say 'DEBUG option is DEBUG='debug
   218 *-* say '   For DEBUG=ON, you will have to look at SYSTSPRT in step //XREF for debug output'
   220 *-* if datatype(valueY,'W') = 0 | valueY < 0
   221 *-*  then
       *-*  TraceRexxLine = 0
   222 *-* else
       *-*  TraceRexxline = valueY  /* line of input exec to trace */
   224 *-* if traceRexxLine > 0
   225 *-*  then
       *-*  do
   226 *-*   say ' '
   227 *-*   say 'REXXLINE='tracerexxLine'; we will turn on:  trace ''r'' while processing line' tracerexxline 'of input exec'
   228 *-*   say 'REXXLINE trace, you will have to look at SYSTSPRT in step //XREF for debug output'
   229 *-*  end
   231 *-* say ' '
   232 *-* if datatype(valuez,'W') = 0 | valuez = ''
   233 *-*  then
       *-*  do
   234 *-*   say 'WIDTH option:  we will be using default width = 150'
   235 *-*   width = 150
   236 *-*   defaultMaxoutputvar = 50 /* use longer default */
   237 *-*  end
   238 *-* else
       *-*  if valuez < 130
   239 *-*   then
       *-*   do
   240 *-*    say 'WIDTH optione:  width='valuez 'specified, but minimum width=130 used instead'
   241 *-*    width = 130
   242 *-*    defaultMaxoutputvar = 30 /* shorten default size */
   243 *-*   end
   244 *-*  else
       *-*   do
   245 *-*    say 'WIDTH option:  width='valuez 'will be used'
   246 *-*    width = valuez
   247 *-*    defaultMaxoutputvar = 50 /* use longer default */
   248 *-*   end
   250 *-* say ' '
   251 *-* if valueb = 'BYVAR'
   252 *-*  then
       *-*  do
   253 *-*   blankOption = valueb
   254 *-*   say 'Blank=BYVAR, indicates there will be a blank line between groups of xref lines w/same variable/label name'
   255 *-*  end
   256 *-* else
       *-*  if valueB = 'NONE'
   257 *-*   then
       *-*   do
   258 *-*    blankOption = valueb
   259 *-*    say 'Blank=NONE, indicates there will be no blank lines in XREF'
   260 *-*   end
   261 *-*  else
       *-*   do
   262 *-*    blankOption = 'BYVAR'
   263 *-*    say 'Blank="'valueb'" was an invalid option, using Blank=BYVAR instead'
   264 *-*    say 'Blank=BYVAR, indicates there will be a blank line between groups of xref lines w/same variable/label name'
   265 *-*   end
   267 *-* say 'finished process options'
   268 *-* say ' '
   270 *-* /* end of options handling */
   271 *-* /* ----------------------- */
   273 *-* /* define some "special" variable handling for xref */
   274 *-* /* ------------------------------------------------ */
   275 *-* specialVar. = 0 /* default (not special) */
   276 *-* /* --------------------- */
   277 *-* special = 'RC'
   278 *-* specialVar.special = 1   /* set specialVar.RC = 1  */
   280 *-* special = 'SIGL'
   281 *-* specialVar.special = 1   /* set specialVar.SIGL =1 */
   283 *-* special = 'RESULT'
   284 *-* specialVar.special = 1   /* set specialVar.RESULT = 1 */
   286 *-* special = 'SQLCODE'
   287 *-* specialVar.special = 1   /* set specialVar.SQLCODE = 1   (db2) dsnrexx */
   289 *-* special = 'SQLERRMC'
   290 *-* specialVar.special = 1   /* set specialVar.SQLERRMC = 1  (db2) dsnrexx */
   292 *-* special = 'SQLERRP'
   293 *-* specialVar.special = 1   /* set specialVar.SQLERRP  = 1  (db2) dsnrexx */
   295 *-* special = 'SQLSTATE'
   296 *-* specialVar.special = 1   /* set specialVar.SQLSTATE = 1  (db2) dsnrexx */
   298 *-* specialStem. = 0
   299 *-* specialStem.SQLERRD = 1
   300 *-* specialStem.SQLWARN = 1
   301 *-* /* end of special xref defaults */
   302 *-* /* ---------------------------= */
   304 *-* /* define rexx statement keywords we will handle */
   305 *-* /* --------------------------------------------- */
   306 *-* rexxStmt. = 0
   307 *-* rexxStmt = 'ADDRESS'
       *-* rexxStmt.rexxStmt = 1
   308 *-* rexxStmt = 'ARG'
       *-* rexxStmt.rexxStmt = 1
   309 *-* rexxStmt = 'CALL'
       *-* rexxStmt.rexxStmt = 1
   310 *-* rexxStmt = 'DO'
       *-* rexxStmt.rexxStmt = 1
   311 *-* rexxStmt = 'END'
       *-* rexxStmt.rexxStmt = 1 /* not really a stmt, but 'end'(s) DO or SELECT */
   312 *-* rexxStmt = 'DROP'
       *-* rexxStmt.rexxStmt = 1
   313 *-* rexxStmt = 'EXIT'
       *-* rexxStmt.rexxStmt = 1
   314 *-* rexxStmt = 'IF'
       *-* rexxStmt.rexxStmt = 1
   315 *-* rexxStmt = 'THEN'
       *-* rexxStmt.rexxStmt = 1 /* not really a stmt, but used in IF or SELECT */
   316 *-* rexxStmt = 'ELSE'
       *-* rexxStmt.rexxStmt = 1 /* not really a stmt, but used with IF stmt    */
   317 *-* rexxStmt = 'INTERPRET'
       *-* rexxStmt.rexxStmt = 1
   318 *-* rexxStmt = 'ITERATE'
       *-* rexxStmt.rexxStmt = 1
   319 *-* rexxStmt = 'LEAVE'
       *-* rexxStmt.rexxStmt = 1
   320 *-* rexxStmt = 'NOP'
       *-* rexxStmt.rexxStmt = 1
   321 *-* rexxStmt = 'NUMERIC'
       *-* rexxStmt.rexxStmt = 1
   322 *-* rexxStmt = 'OPTIONS'
       *-* rexxStmt.rexxStmt = 1
   323 *-* rexxStmt = 'PARSE'
       *-* rexxStmt.rexxStmt = 1
   324 *-* rexxStmt = 'PROCEDURE'
       *-* rexxStmt.rexxStmt = 1
   325 *-* rexxStmt = 'PULL'
       *-* rexxStmt.rexxStmt = 1
   326 *-* rexxStmt = 'PUSH'
       *-* rexxStmt.rexxStmt = 1
   327 *-* rexxStmt = 'QUEUE'
       *-* rexxStmt.rexxStmt = 1
   328 *-* rexxStmt = 'RETURN'
       *-* rexxStmt.rexxStmt = 1
   329 *-* rexxStmt = 'SAY'
       *-* rexxStmt.rexxStmt = 1
   330 *-* rexxStmt = 'SELECT'
       *-* rexxStmt.rexxStmt = 1
   331 *-* rexxStmt = 'WHEN'
       *-* rexxStmt.rexxStmt = 1 /* not really a stmt, but used with SELECT stmt */
   332 *-* rexxStmt = 'OTHERWISE'
       *-* rexxStmt.rexxStmt = 1 /* not really a stmt, but used with SELECT stmt */
   333 *-* rexxStmt = 'SIGNAL'
       *-* rexxStmt.rexxStmt = 1
   334 *-* rexxStmt = 'TRACE'
       *-* rexxStmt.rexxStmt = 1
   335 *-* rexxStmt = 'UPPER'
       *-* rexxStmt.rexxStmt = 1
   336 *-* /* end of special rexxStmt. keywords. */
   337 *-* /* ---------------------------------- */
   339 *-* validSymbolChars  ='ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$¢.!?_' /* full set of valid symbol chars */
   340 *-* validVariableStart='ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$¢!?_'            /* variable can't start with . or digit */
   342 *-* 'EXECIO 0 DISKW RESULTS (OPEN'
   343 *-* if rc <> 0
   344 *-*  then
       *-*  do
   345 *-*   say 'DDname RESULTS failed to open for output; rc='rc
   346 *-*   say 'exit 8'
   347 *-*   'EXECIO 0 DISKW RESULTS (FINIS'
   348 *-*   exit 8
   349 *-*  end
   351 *-* call c0050Pass1 /* find and identify variables */
   352 *-* call c9900OutputResults /* now, output our results */
   353 *-* exit 0
   355 *-* c0050Pass1:
   356 *-* 'EXECIO 100 DISKR SCANINP (OPEN STEM IN.'
   357 *-* inRc = rc
   358 *-* if inRc = 0 | inRc = 2
   359 *-*  then
       *-*  nop
   360 *-* else
       *-*  do
   361 *-*   say 'error opening ddname=SCANINP; rc='inRc
   362 *-*   say 'exiting w/rc=8'
   363 *-*   'EXECIO 0 DISKR SCANINP (FINIS'
   364 *-*   exit 8
   365 *-*  end
   366 *-* if in.0 > 0 /* in input read, copy to output */
   367 *-*  then
       *-*  do
   368 *-*   /* copy scan to output member, followed by xref */
   369 *-*   'EXECIO' in.0 'DISKW RESULTS (STEM IN.'
   370 *-*   if rc <> 0
   371 *-*    then
       *-*    do
   372 *-*     say 'error writing to ddname=RESULTS, rc='rc
   373 *-*     say 'exiting w/rc=8'
   374 *-*     'EXECIO 0 DISKR SCANINP (FINIS'
   375 *-*     'EXECIO 0 DISKW RESULTS  (FINIS'
   376 *-*     exit 8
   377 *-*    end
   378 *-*  end
   379 *-* variablesIndx. = 0
   380 *-* variable = 0
   381 *-* /* define defaults for structures associated with "variable." */
   382 *-* /* ---------------------------------------------------------- */
   383 *-* variable.          = '' /* name of variable like USER; always UpperCase*/
   384 *-* variableRef.       = '' /* referencing a variable,   list of line #'s */
   385 *-* variableExposeRef. = '' /* expose list ref. variable,list of line #'s */
   386 *-* variableSet.       = '' /* setting     a variable,   list of line #'s */
   387 *-* variableStemSet.   = '' /* used in setting stem var, list of line #'s */
   388 *-* variableStemRef.   = '' /* used in ref.    stem var, list of line #'s */
   389 *-* variableLabelDef.  = '' /* label definition,         list of line #'s */
   390 *-* variableLabelRef.  = '' /* label reference,          list of line #'s */
   391 *-* variableAddrDef.      = '' /* address definition,        list of line #'s */ /* v1.02 update */
   392 *-* variableAddrDefValue. = '' /* address value definition,  list of line #'s */ /* v1.02 update */
   393 *-* /* end of defaults */
   395 *-* stemIndx.      = 0
   396 *-* stem     = 0
   397 *-* /* define defaults for structures associated with "stem." */
   398 *-* /* ------------------------------------------------------ */
   399 *-* stemVariable.     = '' /* name of stem variable (like NAME.FIRST.LAST) always upper case */
   400 *-* stemPeriods.      = '' /* # of periods used in stem variable */
   401 *-* stemRef.          = '' /* stem variable references, list of line #'s */
   402 *-* stemExposeRef.    = '' /* stem variable references, list of line #'s */
   403 *-* StemAsg.          = '' /* stem variable assignment, list of line #'s */
   404 *-* /* end of defaults */
   406 *-* exposeRef = 0 /* only set to 1 when reference "PROCEDURE EXPOSE" list of variables */
   407 *-* line = ''
   408 *-* startcmd = 0
   409 *-* totalLine= 0
   410 *-* in = 0
   411 *-* do forever /* identify variables / stems */
   412 *-*  in = in + 1
   413 *-*  if in > in.0
   414 *-*   then
       *-*   do
   415 *-*    /* need another buffer */
   416 *-*    if inRc = 2/* finished using last buffer? */
   417 *-*     then
       *-*     leave /* ...yes, time to leave.      */
   419 *-*     /* get next buffer */
   420 *-*    in = 0 /* reset buffer pointer, very important for forever loop */
   421 *-*    'EXECIO 100 DISKR SCANINP (STEM IN.'
   422 *-*    inRc = rc /* save read rc */
   423 *-*    if inRc = 0 | inRc = 2
   424 *-*     then
       *-*     do /* got next input buffer */
   425 *-*      if in.0 > 0 /* if input recs, copy to output */
   426 *-*       then
       *-*       do
   427 *-*        /* copy scan to output member, followed by xref */
   428 *-*        'EXECIO' in.0 'DISKW RESULTS (STEM IN.'
   429 *-*        if rc <> 0
   430 *-*         then
       *-*         do
   431 *-*          say 'error writing to ddname=RESULTS, rc='rc
   432 *-*          say 'exiting w/rc=8'
   433 *-*          'EXECIO 0 DISKR SCANINP (FINIS'
   434 *-*          'EXECIO 0 DISKW RESULTS  (FINIS'
   435 *-*          exit 8
   436 *-*         end
   437 *-*       end
   438 *-*       /* normal, we read buffer successfully */
   439 *-*       /*         we wrote buffer successfully*/
   440 *-*       /*         time to resume loop         */
   441 *-*       /*         and variable "in" equals zero*/
   442 *-*      iterate /* got next input buffer, resume forever loop*/
   443 *-*     end
   445 *-*     /* bad read rc */
   446 *-*    say 'error reading from ddname=SCANINP; rc='rc
   447 *-*    say 'exit w/rc=8'
   448 *-*    'EXECIO 0 DISKR SCANINP (FINIS'
   449 *-*    exit 8
   450 *-*   end
   452 *-*   /* next input line in "in.in" is ready to process */
   453 *-*  totalLine = totalLine + 1
   454 *-*  if startcmd = 1
   455 *-*   then
       *-*   do /* put most likely choice first */
   456 *-*    parse var in.in rexxLine2 8 cmd 12 pendingCmd
   457 *-*    if datatype(strip(rexxLine2),'W') & cmd = '*-* '
   458 *-*     then
       *-*     do /* we have start of a "command" to process */
   459 *-*      call c0070ParseLinePass1 /* process previous line first */
   460 *-*      rexxline = strip(rexxline2)
   461 *-*      line = pendingCmd   /* now save start of next cmd  */
   462 *-*      iterate
   463 *-*     end
   465 *-*     /* command continued, add to line, for full line to parse*/
   466 *-*    if left(in.in,10) = '*-*'
   467 *-*     then
       *-*     do
   468 *-*      call c0070ParseLinePass1 /* process previous cmd first */
   469 *-*      /* rexxline is still set... multiple cmds on same line  */
   470 *-*      line = pendingCmd   /* now save start of next cmd  */
   471 *-*      iterate
   472 *-*     end
   473 *-*    else
       *-*     line = line || in.in /* continuation of a command, append it together */
   474 *-*    iterate
   475 *-*   end
   476 *-*  else
       *-*   do
   477 *-*    /* this happens first, but once we set startcmd to 1*/
   478 *-*    /* ... it will never be reset.  So this is least used*/
   479 *-*    /* portion of this loop.                             */
   480 *-*    parse var in.in rexxline 8 cmd 12 rest
   481 *-*    if datatype(strip(rexxline),'W') & cmd = '*-* '
   482 *-*     then
       *-*     do /* we have start of a "command" to process */
   483 *-*      startcmd = 1
   484 *-*      line = rest
   485 *-*      rexxline = strip(rexxline)
   486 *-*      iterate
   487 *-*     end
   488 *-*    else
       *-*     iterate /* ignore nonsense */
   489 *-*   end
   490 *-* end
   491 *-* if startcmd = 1
   492 *-*  then
       *-*  do
   493 *-*   if right(line,8) = 'READYEND' & length(line) > 8 /* sure it is */
   494 *-*    then
       *-*    line = left(line,length(line)-8) /* remove "READYEND" */
   495 *-*   call c0070ParseLinePass1
   496 *-*  end
   497 *-* 'EXECIO 0 DISKR SCANINP (FINIS'
   498 *-* return /* 1st pass is complete */
   500 *-* c0070ParseLinePass1:
   501 *-* /* 1.  remove comments from line, as they just confuse things. */
   502 *-* /*                                                             */
   503 *-* /* 2.  replace 'all literals'               with " 'LIT###     */
   504 *-* /* 2.  replace 'all literal functions       with " 'FUN###(    */
   505 *-* /*     replace '0101 1100'b BINARY literals with " 'LIT###B    */
   506 *-* /*     replace '04E3 DD3C'x HEX literals    with " 'LIT###X    */
   507 *-* /*     ... as they just confuse things.                        */
   508 *-* /*                                                             */
   509 *-* /* After this, any digits left in "line" are digits used by    */
   510 *-* /* rexx, as opposed to those that used to be in:               */
   511 *-* /*          1. comments (removed)                              */
   512 *-* /*          2. literals (removed)                              */
   513 *-* /*                                                             */
   514 *-* if traceRexxLine > 0
   515 *-*  then
       *-*  if rexxLine = traceRexxLine
   516 *-*   then
       *-*   do
   517 *-*    trace 'n'
   518 *-*    say ' '
   519 *-*    say 'Turning on and/or continuing Tracing while processing line' rexxline 'of the input exec'
   520 *-*    trace 'i' /* turn on tracing for this one line of 'input' rexx code */
   521 *-*   end
   522 *-*  else
       *-*   if rexxLine > traceRexxLine
   523 *-*    then
       *-*    do
   524 *-*     traceRexxLine = 0 /* nothing more to trace */
   525 *-*     trace 'n'         /* keep tracing off      */
   526 *-*    end
   528 *-* originalLine = line /* save original line  */
   529 *-* if debug = 'ON'
   530 *-*  then
       *-*  do
   531 *-*   say ' '
   532 *-*   say 'rexxline='rexxline
   533 *-*   say 'debug:  originalLine="'originalLine'"'
   534 *-*  end
   536 *-*  /* v1.02 ... remove comments first */
   537 *-*  /* ------------------------------- */
   539 *-* lowerLine    = line /* in case of literals */
   540 *-* upper line /* just upper case it */
   541 *-* startPos = 1
   542 *-* commentNested = 0
   543 *-* commentStart  = 0
   544 *-* literalStart  = 0
   545 *-* LitValue. = ''   /* save lit values here */
   546 *-* litNext    = 0   /* # of lit values saved*/
   547 *-* do while pos('/*',line,startPos) > 0 ,                  | pos('*/',line,startPos) > 0 ,                  | pos("'",line,
startPos)  > 0 ,                  | pos('"',line,startPos)  > 0
   551 *-*  /* we have a possible comment and/or literal */
   552 *-*  x1= pos('/*',line'/*',startPos)
   553 *-*  x2= pos('*/',line'*/',startPos)
   554 *-*  y1= pos("'",line"'",startPos)
   555 *-*  y2= pos('"',line'"',startPos)
   557 *-*  x = min(x1,x2)
   558 *-*  y = min(y1,y2)
   560 *-*  if commentStart > 0 /* at least one comment active */
   561 *-*   then
       *-*   do
   562 *-*    /* ignore "y" literals inside of comments */
   563 *-*    if x1 = x2 /* should be impossible */
   564 *-*     then
       *-*     leave /* ... rexx syntax should have found this */
   565 *-*    if x1 = x  /* start of another nested comment? */
   566 *-*     then
       *-*     do
   567 *-*      commentNested = commentNested + 1 /* bump number nested*/
   568 *-*      startPos = x + 2 /* skip past this comment delimiter */
   569 *-*      iterate
   570 *-*     end
   571 *-*     /* found end of a comment */
   572 *-*    commentNested = commentNested - 1 /* decrement number of active comments*/
   574 *-*    if commentNested > 0
   575 *-*     then
       *-*     do
   576 *-*      /* nested comments, we need to find more end of comment literals */
   577 *-*      startPos = x + 2 /* skip past this comment delimiter */
   578 *-*      iterate
   579 *-*     end
   580 *-*     /* finally entire comment "commentStart to x" can be removed */
   581 *-*     /* replace with a blank, if imbedded comment                 */
   582 *-*    if commentStart = 1
   583 *-*     then
       *-*     do
   584 *-*      /* remove comment from start of line */
   585 *-*      line      = strip(substr(line,x+2))
   586 *-*      lowerLine = strip(substr(lowerLine,x+2))
   587 *-*      startPos = 1
   588 *-*      commentStart = 0 /* with no comment active any longer, this is now zero */
   589 *-*      iterate
   590 *-*     end
   591 *-*     /* remove comment from middle of line; replace with blank */
   592 *-*    line      = left(line,commentStart-1)      substr(line,x+2)
   593 *-*    lowerLine = left(lowerLine,commentStart-1) substr(lowerLine,x+2)
   594 *-*    startPos = commentStart + 1
   595 *-*    commentStart = 0 /* with no comment active any longer, this is now zero */
   596 *-*    iterate
   597 *-*   end
   599 *-*  if x < y /* comment started before literal? */
   600 *-*   then
       *-*   do
   601 *-*    /* logic says (see prior "if commentNested > 0" that commentNested must be zero */
   602 *-*    if substr(line,x,2) = '/*'
   603 *-*     then
       *-*     do
   604 *-*      /* this must be true for rexx syntax approved code */
   605 *-*      commentNested = 1 /* this is start of a comment */
   606 *-*      commentStart  = x /* ... and started here       */
   607 *-*      startPos = x + 2  /* start looking for end of comment here */
   608 *-*      iterate
   609 *-*     end
   610 *-*    call logicMsg 'how can a comment end, that was never started?'
   611 *-*    startPos = x+2
   612 *-*    iterate
   613 *-*   end
   615 *-*   /* start of literal found, it may be a:            */
   616 *-*   /*    'some literal value' a regular literal       */
   617 *-*   /* or '1010 1100'b         a binary  literal       */
   618 *-*   /* or '03ef ff'x           a hex     literal       */
   619 *-*   /*                                                 */
   620 *-*   /* note:  we won't verify contents of binary or hex*/
   621 *-*   /*    literals, the rexx syntax checker did that.  */
   622 *-*   /*                                                 */
   623 *-*   /* so we will remove literal and replace it with   */
   624 *-*   /*    " 'LIT' "  i.e. with 'LIT' with blanks around*/
   625 *-*   /*    it.                                          */
   626 *-*   /*                                                 */
   627 *-*  LiteralStart = y
   628 *-*  LitQuote = substr(line,y,1)
   629 *-*  do forever /* find end of literal */
   630 *-*   yy= pos(litQuote,line,y+1) /* find ending quote */
   631 *-*   if yy = 0
   632 *-*    then
       *-*    do
   633 *-*     /* literal should have ended, if syntax corrrect */
   634 *-*     /* add closing quote (that should have been in literal */
   635 *-*     litValue = substr(lowerLine,LiteralStart) || litQuote
   636 *-*     litNext = litNext + 1
   637 *-*     litValue.litNext = litValue
   639 *-*     call logicMsg 'Why didn''t literal end'
   640 *-*     if LiteralStart = 1
   641 *-*      then
       *-*      return /* basically one long literal, even if it didn't end */
   643 *-*     line = left(line,y-1) " 'LIT"||litnext
   644 *-*     literalStart = 0          /* basically end of parsing */
   645 *-*     startPos = length(line)+1 /* basically end of parsing */
   646 *-*     leave
   647 *-*    end
   648 *-*   if substr(line,yy,1) = substr(line,yy+1,1) /* double " or double ' */
   649 *-*    then
       *-*    do
   650 *-*     /* skip them by */
   651 *-*     y = yy + 2
   652 *-*     iterate
   653 *-*    end
   654 *-*    /* we found end of literal at yy*/
   655 *-*   leave
   656 *-*  end
   657 *-*  if literalStart = 0
   658 *-*   then
       *-*   leave
   660 *-*   /* normal case, found end of literal */
   662 *-*   /* is it really a binary literal.... don't want "b" to be a variable */
   663 *-*  if  substr(line,yy+1,2) = 'B ' ,                                       /* if B<blank>                    then a binary
literal */       | (substr(line,yy+1,1) = 'B'  & datatype(substr(line,yy+1,2),'S')= 0) /* or B<?>     is not a symbol... then a bin
ary literal */
   665 *-*   then
       *-*   do
   666 *-*    startPos = yy+2
   667 *-*    literalStart = 0
   668 *-*    iterate
   669 *-*   end
   671 *-*   /* is it really a hex literal.... don't want "x" to be a variable */
   672 *-*  if  substr(line,yy+1,2) = 'X ' ,                                       /* if X<blank>                    then a hex lit
eral */       | (substr(line,yy+1,1) = 'X'  & datatype(substr(line,yy+1,2),'S')= 0) /* or X<?>     is not a symbol... then a hex li
teral */
   674 *-*   then
       *-*   do
   675 *-*    startPos = yy+2
   676 *-*    literalStart = 0
   677 *-*    iterate
   678 *-*   end
   680 *-*   /* just a simple literal */
   681 *-*  startPos = yy+1
   682 *-*  literalStart = 0
   683 *-*  iterate
   684 *-* end
   686 *-* /* now comments have been removed */
   687 *-* if line = ''
       *-*  then
       *-*  return
   689 *-*  /* remove label(s), if found, from lineWithoutCommentsNLabels */
   690 *-* LineWithoutCommentsNlabels = line
   691 *-* do forever
   692 *-*  LineWithoutCommentsNlabels = strip(LineWithoutCommentsNlabels)
   693 *-*  if LineWithoutCommentsNlabels = ''
       *-*   then
       *-*   leave
   695 *-*   /* v1.02 line could have been continued (multiple times) with commas, eliminate commas before start of labels */
   696 *-*  if left(lineWithoutCommentsNlabels,1) = ','  /* could be multiple commas before / after labels, get rid of them */
   697 *-*   then
       *-*   do
   698 *-*    lineWithoutCommentsNlabels = strip(substr(lineWithoutCommentsNlabels,2))
   699 *-*    iterate
   700 *-*   end
   702 *-*  if pos(':',LineWithoutCommentsNlabels) = 0
   703 *-*   then
       *-*   leave
   705 *-*  parse var LineWithoutCommentsNlabels varX ':' rest
   706 *-*  if words(varx) = 1
   707 *-*   then
       *-*   if datatype(varx,'s') = 1
   708 *-*    then
       *-*    do
   709 *-*     LineWithoutCommentsNlabels = rest /* remove label:      */
   710 *-*     iterate                           /* continue looking for more labels */
   711 *-*    end
   712 *-*   else
       *-*    leave /* we've removed all labels, LineWithoutCommentsNlabels variable set correctly */
   713 *-*  else
       *-*   leave    /* we've removed all labels, LineWithoutCommentsNlabels variable set correctly */
   714 *-* end
   715 *-* lineWithoutCommentsNlabels = strip(LineWithoutCommentsNlabels) /* keep this for address command */
   716 *-* if debug = 'ON'
   717 *-*  then
       *-*  say 'debug:  LineWithoutCommentsNlabels="'LineWithoutCommentsNlabels'"'
   720 *-*  /* ===>  comments, if any, now removed from "line", but labels and literals are still in "line" */
   721 *-*  /* ===>  -------------------------------------------------------------------------------------- */
   723 *-*  /* end of V1.02 ... now do the "traditional"  c0070 code */
   724 *-*  /* ----------------------------------------------------- */
   726 *-* lowerLine    = line /* in case of literals */
   727 *-* upper line /* just upper case it */
   728 *-* startPos = 1
   729 *-* commentNested = 0
   730 *-* commentStart  = 0
   731 *-* literalStart  = 0
   732 *-* LitValue. = ''   /* save lit values here */
   733 *-* litNext    = 0   /* # of lit values saved*/
   734 *-* do while pos('/*',line,startPos) > 0 ,                  | pos('*/',line,startPos) > 0 ,                  | pos("'",line,
startPos)  > 0 ,                  | pos('"',line,startPos)  > 0
   738 *-*  /* we have a possible comment and/or literal */
   739 *-*  x1= pos('/*',line'/*',startPos)
   740 *-*  x2= pos('*/',line'*/',startPos)
   741 *-*  y1= pos("'",line"'",startPos)
   742 *-*  y2= pos('"',line'"',startPos)
   744 *-*  x = min(x1,x2)
   745 *-*  y = min(y1,y2)
   747 *-*  if commentStart > 0 /* at least one comment active */
   748 *-*   then
       *-*   do
   749 *-*    /* ignore "y" literals inside of comments */
   750 *-*    if x1 = x2 /* should be impossible */
   751 *-*     then
       *-*     leave /* ... rexx syntax should have found this */
   752 *-*    if x1 = x  /* start of another nested comment? */
   753 *-*     then
       *-*     do
   754 *-*      commentNested = commentNested + 1 /* bump number nested*/
   755 *-*      startPos = x + 2 /* skip past this comment delimiter */
   756 *-*      iterate
   757 *-*     end
   758 *-*     /* found end of a comment */
   759 *-*    commentNested = commentNested - 1 /* decrement number of active comments*/
   761 *-*    if commentNested > 0
   762 *-*     then
       *-*     do
   763 *-*      /* nested comments, we need to find more end of comment literals */
   764 *-*      startPos = x + 2 /* skip past this comment delimiter */
   765 *-*      iterate
   766 *-*     end
   767 *-*     /* finally entire comment "commentStart to x" can be removed */
   768 *-*     /* replace with a blank, if imbedded comment                 */
   769 *-*    if commentStart = 1
   770 *-*     then
       *-*     do
   771 *-*      /* remove comment from start of line */
   772 *-*      line      = strip(substr(line,x+2))
   773 *-*      lowerLine = strip(substr(lowerLine,x+2))
   774 *-*      startPos = 1
   775 *-*      commentStart = 0 /* with no comment active any longer, this is now zero */
   776 *-*      iterate
   777 *-*     end
   778 *-*     /* remove comment from middle of line; replace with blank */
   779 *-*    line      = left(line,commentStart-1)      substr(line,x+2)
   780 *-*    lowerLine = left(lowerLine,commentStart-1) substr(lowerLine,x+2)
   781 *-*    startPos = commentStart + 1
   782 *-*    commentStart = 0 /* with no comment active any longer, this is now zero */
   783 *-*    iterate
   784 *-*   end
   786 *-*  if x < y /* comment started before literal? */
   787 *-*   then
       *-*   do
   788 *-*    /* logic says (see prior "if commentNested > 0" that commentNested must be zero */
   789 *-*    if substr(line,x,2) = '/*'
   790 *-*     then
       *-*     do
   791 *-*      /* this must be true for rexx syntax approved code */
   792 *-*      commentNested = 1 /* this is start of a comment */
   793 *-*      commentStart  = x /* ... and started here       */
   794 *-*      startPos = x + 2  /* start looking for end of comment here */
   795 *-*      iterate
   796 *-*     end
   797 *-*    call logicMsg 'how can a comment end, that was never started?'
   798 *-*    startPos = x+2
   799 *-*    iterate
   800 *-*   end
   802 *-*   /* start of literal found, it may be a:            */
   803 *-*   /*    'some literal value' a regular literal       */
   804 *-*   /* or '1010 1100'b         a binary  literal       */
   805 *-*   /* or '03ef ff'x           a hex     literal       */
   806 *-*   /*                                                 */
   807 *-*   /* note:  we won't verify contents of binary or hex*/
   808 *-*   /*    literals, the rexx syntax checker did that.  */
   809 *-*   /*                                                 */
   810 *-*   /* so we will remove literal and replace it with   */
   811 *-*   /*    " 'LIT' "  i.e. with 'LIT' with blanks around*/
   812 *-*   /*    it.                                          */
   813 *-*   /*                                                 */
   814 *-*  LiteralStart = y
   815 *-*  LitQuote = substr(line,y,1)
   816 *-*  do forever /* find end of literal */
   817 *-*   yy= pos(litQuote,line,y+1) /* find ending quote */
   818 *-*   if yy = 0
   819 *-*    then
       *-*    do
   820 *-*     /* literal should have ended, if syntax corrrect */
   821 *-*     /* add closing quote (that should have been in literal */
   822 *-*     litValue = substr(lowerLine,LiteralStart) || litQuote
   823 *-*     litNext = litNext + 1
   824 *-*     litValue.litNext = litValue
   826 *-*     call logicMsg 'Why didn''t literal end'
   827 *-*     if LiteralStart = 1
   828 *-*      then
       *-*      return /* basically one long literal, even if it didn't end */
   830 *-*     line = left(line,y-1) " 'LIT"||litnext
   831 *-*     literalStart = 0          /* basically end of parsing */
   832 *-*     startPos = length(line)+1 /* basically end of parsing */
   833 *-*     leave
   834 *-*    end
   835 *-*   if substr(line,yy,1) = substr(line,yy+1,1) /* double " or double ' */
   836 *-*    then
       *-*    do
   837 *-*     /* skip them by */
   838 *-*     y = yy + 2
   839 *-*     iterate
   840 *-*    end
   841 *-*    /* we found end of literal at yy*/
   842 *-*   leave
   843 *-*  end
   844 *-*  if literalStart = 0
   845 *-*   then
       *-*   leave
   847 *-*   /* normal case, found end of literal */
   848 *-*  Litvalue = substr(lowerLine,LiteralStart,yy-literalStart+1)
   850 *-*  /* is it really a binary literal.... don't want "b" to be a variable */
   851 *-*  if  substr(line,yy+1,2) = 'B ' ,                                       /* if B<blank>                    then a binary
literal */       | (substr(line,yy+1,1) = 'B'  & datatype(substr(line,yy+1,2),'S')= 0) /* or B<?>     is not a symbol... then a bin
ary literal */
   853 *-*   then
       *-*   do
   854 *-*    /* it's a binary/hex literal */
   855 *-*    litValue = litValue||'B'
   856 *-*    litNext = litNext + 1
   857 *-*    litValue.litNext = litValue /* save literal value */
   859 *-*    /* now replace literal with " 'LIT#' " in line/lowerLine */
   860 *-*    if literalStart = 1
   861 *-*     then
       *-*     do
   862 *-*      line      = "'LITB"||litNext strip(substr(line,yy+2))
   863 *-*      lowerLine = "'LITB"||litNext strip(substr(lowerLine,yy+2))
   864 *-*      startPos = 6 + length(litNext)
   865 *-*      literalStart = 0
   866 *-*      iterate
   867 *-*     end
   869 *-*    line      = left(line,literalStart-1) "'LITB"litNext substr(line,yy+2)
   870 *-*    lowerline = left(line,literalStart-1) "'LITB"litNext substr(lowerline,yy+2)
   871 *-*    startPos = literalStart + 6 + length(litNext)
   872 *-*    literalStart = 0
   873 *-*    iterate
   874 *-*   end
   876 *-*   /* is it really a hex literal.... don't want "x" to be a variable */
   877 *-*  if  substr(line,yy+1,2) = 'X ' ,                                       /* if X<blank>                    then a hex lit
eral */       | (substr(line,yy+1,1) = 'X'  & datatype(substr(line,yy+1,2),'S')= 0) /* or X<?>     is not a symbol... then a hex li
teral */
   879 *-*   then
       *-*   do
   880 *-*    /* it's a binary/hex literal */
   881 *-*    litValue = litValue||'X'
   882 *-*    litNext = litNext + 1
   883 *-*    litValue.litNext = litValue /* save literal value */
   885 *-*    /* now replace literal with " 'LIT#' " in line/lowerLine */
   886 *-*    if literalStart = 1
   887 *-*     then
       *-*     do
   888 *-*      line      = "'LITX"||litNext strip(substr(line,yy+2))
   889 *-*      lowerLine = "'LITX"||litNext strip(substr(lowerLine,yy+2))
   890 *-*      startPos = 6 + length(litNext)
   891 *-*      iterate
   892 *-*     end
   894 *-*    line      = left(line,literalStart-1) "'LITX"litNext substr(line,yy+2)
   895 *-*    lowerline = left(line,literalStart-1) "'LITX"litNext substr(lowerline,yy+2)
   896 *-*    startPos = literalStart + 6 + length(litNext)
   897 *-*    literalStart = 0
   898 *-*    iterate
   899 *-*   end
   901 *-*   /* just a simple literal */
   902 *-*  litNext = litNext + 1
   903 *-*  litValue.litNext = litValue /* save literal value */
   905 *-*  if literalStart = 1
   906 *-*   then
       *-*   do
   907 *-*    if substr(line,yy+1) = '(' /* looks like a function? */
   908 *-*     then
       *-*     do /*function... remove left paren...add space before/after like 'FUN# ... */
   909 *-*      line      = "'FUN"||litNext strip(substr(line,yy+2))
   910 *-*      lowerLine = "'FUN"||litNext strip(substr(lowerLine,yy+2))
   911 *-*      startPos = 5 + length(litNext)
   912 *-*     end
   913 *-*    else
       *-*     do /* not a function... add space before/after              like 'LIT# ... */
   914 *-*      line      = "'LIT"||litNext strip(substr(line,yy+1))
   915 *-*      lowerLine = "'LIT"||litNext strip(substr(lowerLine,yy+1))
   916 *-*      startPos = 5 + length(litNext)
   917 *-*     end
   918 *-*    literalStart = 0
   919 *-*    iterate
   920 *-*   end
   922 *-*   /* insert literal in middle of line */
   923 *-*  if substr(line,yy+1,1) = '(' /* looks like a function? */
   924 *-*   then
       *-*   do /* function... remove left paren.. add space before/after like 'FUN# ... */
   925 *-*    line      = left(line,literalStart-1)      "'FUN"||litnext substr(line,yy+2)
   926 *-*    lowerLine = left(lowerLine,LiteralStart-1) "'FUN"||litnext substr(lowerLine,yy+2)
   927 *-*    startPos = literalStart + 5 + length(litNext)
   928 *-*   end
   929 *-*  else
       *-*   do /* not a function... add space before/after               like 'LIT# ... */
   930 *-*    line      = left(line,literalStart-1)      "'LIT"||litnext substr(line,yy+1)
   931 *-*    lowerLine = left(lowerLine,LiteralStart-1) "'LIT"||litnext substr(lowerLine,yy+1)
   932 *-*    startPos = literalStart + 5 + length(litNext)
   933 *-*   end
   934 *-*  literalStart = 0
   935 *-*  iterate
   936 *-* end
   938 *-* /* now comments have been removed */
   939 *-* /* literals changed to 'LIT'      */
   940 *-* if line = ''
       *-*  then
       *-*  return
   942 *-*  /* handle label(s), and if found, remove them from line */
   943 *-* do forever
   944 *-*  line = strip(line)
   945 *-*  lowerline = strip(lowerline)
   946 *-*  if line = ''
       *-*   then
       *-*   return
   948 *-*   /* v1.02 line could have been continued (multiple times) with commas, eliminate commas before start of labels */
   949 *-*  if left(line,1) = ','
   950 *-*   then
       *-*   do
   951 *-*    line = strip(substr(line,2))
   952 *-*    lowerLine = strip(substr(lowerLine,2))
   953 *-*    iterate
   954 *-*   end
   956 *-*  if pos(':',line) = 0
   957 *-*   then
       *-*   leave
   959 *-*  parse var line varX ':' rest
   960 *-*  if words(varx) = 1
   961 *-*   then
       *-*   if datatype(varx,'s') = 1
   962 *-*    then
       *-*    do
   963 *-*     call c0470LabelDefine /* define this internal label */
   964 *-*     line = rest           /* remove label:              */
   965 *-*     parse var lowerLine . ':' lowerline /* remove label */
   966 *-*     iterate               /* continue looking for more labels */
   967 *-*    end
   968 *-*   else
       *-*    leave /* we've removed all labels, line variable set correctly */
   969 *-*  else
       *-*   leave    /* we've removed all labels, line variable set correctly */
   970 *-* end
   971 *-* line = strip(line)
   972 *-* lowerLine = strip(lowerLine)
   973 *-* if line = ''
       *-*  then
       *-*  return
   977 *-*  /* ===>  comments, if any, now removed */
   978 *-*  /* ===>  literals changed to 'LIT'     */
   979 *-*  /* ===>  scientific notation #E# change to # before E   */
   980 *-*  /* ===>  scientific notation #E+# changed to # before E */
   981 *-*  /* ===>  scientific notation #E-# changed to # before E */
   982 *-* call c0100ParseStatement
   983 *-* return
   985 *-* c0100ParseStatement:
   986 *-* /* handle statement */
   987 *-* /* Note:   to handle if expression THEN statement      */
   988 *-* /*                   or else statement                 */
   989 *-* /*                   or when expression THEN statement */
   990 *-* /*         we need the c0100var loop                   */
   991 *-* /* look at line, rid us of scientific notation; don't want extra variable 'E' in xref */
   992 *-* /* for scientic notation just get rid of E# or E+# or E-# (keep preceding #)          */
   993 *-* /*                                                                                    */
   994 *-* /* ---------------------------------------------------------------------------------- */
   996 *-* /* handle first symbol in line:  */
   997 *-* /*    1)  an assignment statement*/
   998 *-* /*    2)  a rexx statement       */
   999 *-* /*    3)  or a command for env.  */
  1001 *-* if debug = 'ON'
  1002 *-*  then
       *-*  do
  1003 *-*   say 'debug:     lowerLine="'lowerLine'"'
  1004 *-*   say 'debug:          line="'line'"'
  1005 *-*  end
  1007 *-*  /* v1.02 line could have been continued (multiple times) with commas, eliminate commas before start of command */
  1008 *-* line = strip(line)
  1009 *-* lowerline = strip(lowerline)
  1010 *-* do while left(line,1) = ','
  1011 *-*  line = strip(substr(line,2))
  1012 *-*  lowerline = strip(substr(lowerLine,2))
  1013 *-* end
  1015 *-* rexxStmt = ''     /* assume not processing a rexx statement  */
  1016 *-* if left(line,4) = "'LIT"
  1017 *-*  then
       *-*  nop /* can't be assignment and/or rexx statement */
  1018 *-* else
       *-*  do
  1019 *-*   x = verify(line'+',validSymbolChars,,1) /* find where it is no longer a symbol*/
  1020 *-*   if x = 1 , /* = 1, it's not a symbol */                                     | pos(left(line,1),validVariableStart) = 0
 /* v1.02 fix test.  A variable/stem had to start with one of these*/
  1022 *-*    then
       *-*    nop /* can't be an assignment stmt (has to start with a variable and/or stem */
  1023 *-*   else
       *-*    do /* it's the start of a symbol & symbol looks like a variable and/or stem */
  1024 *-*     /* we have start of a symbol   */
  1026 *-*     /* but it could be an assignment statement */
  1027 *-*     /*              or an rexx       statement */
  1028 *-*     /*              or a command for envirnoment*/
  1029 *-*     theSymbol = substr(line,1,x-1) /* we have stem and/or variable (or rexx stmt)*/
  1030 *-*     if substr(line,x,1) = '='   , /* looks like variable/stem = something ? */          & substr(line,x,2) <> '=='   /*
... except variable/stem == somthing is not an assignment */
  1032 *-*      then
       *-*      do
  1033 *-*       /* it's an assignment statement; handle it and return   */
  1034 *-*       varx = theSymbol
  1035 *-*       call c0500AddVarStemAssignment /* varx being assigned a value */
  1037 *-*       line = strip(substr(line,x+1))
  1038 *-*       if line <> ''
  1039 *-*        then
       *-*        call c0300ParseRemaining /* expression to be evaluated */
  1040 *-*       return
  1041 *-*      end
  1042 *-*     else
       *-*      if substr(line,x,1) = ' ' /* could be a rexx stmt or an assignment statement or command */
  1043 *-*       then
       *-*       do
  1044 *-*        y = verify(line'+',' ',,x)      /* find next position of non-blank after x */
  1045 *-*        if substr(line,y,1) = '='     , /* looks like an assignment statement? */               & substr(line,y,2) <> '==
'   /* ... == (says its not)               */
  1047 *-*         then
       *-*         do
  1048 *-*          /* it's an assignment statement; handle it and return   */
  1049 *-*          varx = theSymbol
  1050 *-*          call c0500AddVarStemAssignment /* varx being assigned a value */
  1052 *-*          line = strip(substr(line,y+1))
  1053 *-*          if line <> ''
  1054 *-*           then
       *-*           call c0300ParseRemaining /* expression to be evaluated */
  1055 *-*          return
  1056 *-*         end
  1057 *-*       end
  1059 *-*       /* could be a rexx statement */
  1060 *-*     if rexxStmt.theSymbol = 1
  1061 *-*      then
       *-*      rexxStmt = theSymbol /* it is, set rexxStmt to theSymbol */
  1062 *-*    end
  1063 *-*  end
  1065 *-* if rexxStmt <> ''
  1066 *-*  then
       *-*  do /* we know we are processing a rexx statement. */
  1067 *-*   /* start processing REXX statements */
  1068 *-*   /* -------------------------------- */
  1069 *-*   if rexxStmt = 'ADDRESS'
  1070 *-*    then
       *-*    do
  1071 *-*     /* v1.02 fix address command */
  1072 *-*     testline = strip(lineWithoutCommentsNlabels)
  1073 *-*     parse var testline 1 . 8 testline
  1074 *-*     testline = strip(testline)
  1075 *-*     if left(testline,1) = '"' | left(testline,1) = "'"
  1076 *-*      then
       *-*      do
  1077 *-*       /* start of a literal, and literal can contain blanks */
  1078 *-*       /* and literal can be a literal, hex literal or a binary literal */
  1080 *-*       /* since we verified that the first character is ACTUALLY a literal... we can depend on 'LIT 'LITB or 'LITX in lin
e */
  1081 *-*       parse var line . littype line /* get rid of "address" and lit */
  1082 *-*       say 'litvalue.1="'litvalue.1'"'
  1083 *-*       if right(litvalue.1,1) = "'" | right(litvalue.1,1) = '"'
  1084 *-*        then
       *-*        do
  1085 *-*         if length(litvalue.1) <=2
  1086 *-*          then
       *-*          tempvalue = ''
  1087 *-*         else
       *-*          tempvalue = substr(litvalue.1,2,length(litvalue.1)-2)
  1088 *-*        end
  1089 *-*       else
       *-*        if right(litvalue.1,1) = 'B'
  1090 *-*         then
       *-*         do
  1091 *-*          if length(litvalue.1) <=3
  1092 *-*           then
       *-*           tempvalue = ''
  1093 *-*          else
       *-*           tempvalue = b2c(substr(litvalue.1,2,length(litvalue.1)-3))
  1094 *-*         end
  1095 *-*        else
       *-*         do /* must be x literal */
  1096 *-*          if length(litvalue.1) <=3
  1097 *-*           then
       *-*           tempvalue = ''
  1098 *-*          else
       *-*           tempvalue = x2c(substr(litvalue.1,2,length(litvalue.1)-3))
  1099 *-*         end
  1100 *-*       parse var tempvalue tempenv tempRest
  1102 *-*       if tempenv = '' & line <> ''
  1103 *-*        then
       *-*        varx = 'ADDRESS' litvalue.1 '<cmd>'
  1104 *-*       else
       *-*        if tempenv = ''
  1105 *-*         then
       *-*         varx = 'ADDRESS' litvalue.1
  1106 *-*        else
       *-*         if right(litvalue.1,1) = 'B' & temprest line <> ''
  1107 *-*          then
       *-*          varx = 'ADDRESS' litvalue.1 '<cmd>'
  1108 *-*         else
       *-*          if right(litvalue.1,1) = 'B'
  1109 *-*           then
       *-*           varx = 'ADDRESS' litvalue.1
  1110 *-*          else
       *-*           if right(litvalue.1,1) = 'X' & temprest line <> ''
  1111 *-*            then
       *-*            varx = 'ADDRESS' litvalue.1 '<cmd>'
  1112 *-*           else
       *-*            if right(litvalue.1,1) = 'X'
  1113 *-*             then
       *-*             varx = 'ADDRESS' litvalue.1
  1114 *-*            else
       *-*             if temprest line <> ''
  1115 *-*              then
       *-*              varx = 'ADDRESS' "'"tempenv"' <cmd>"
  1116 *-*             else
       *-*              varx = 'ADDRESS' litvalue.1
  1117 *-*       call c0480AddrDefine         /* set up for address xref */
  1119 *-*       call c0300ParseRemaining     /* parse line for references */
  1120 *-*       return
  1121 *-*      end
  1122 *-*     else
       *-*      if left(testline,1) = '('  /* address ( something ) something2 ... is equivlent to ... address value something some
thing2 */
  1123 *-*       then
       *-*       do
  1124 *-*        /* this is exactly like an address value expression */
  1125 *-*        varx = 'ADDRESS' testline /* expression w/ any operators */
  1126 *-*        call c0482AddrDefineValue /* set up for special address xref */
  1128 *-*        parse var line . line     /* remove "address" */
  1129 *-*        call c0300ParseRemaining  /* parse line for references */
  1130 *-*        return
  1131 *-*       end
  1132 *-*      else
       *-*       do
  1133 *-*        if      pos("'",word(testline,1)) > 0
  1134 *-*         then
       *-*         parse var testline addrenv "'" testline
  1135 *-*        else
       *-*         if pos('"',word(testline,1)) > 0
  1136 *-*          then
       *-*          parse var testline addrenv '"' testline
  1137 *-*         else
       *-*          parse var testline addrenv testline
  1138 *-*        addrenv = strip(addrenv)
  1139 *-*        upper addrenv
  1140 *-*        if addrenv = 'VALUE'
  1141 *-*         then
       *-*         do
  1142 *-*          /* address value expression */
  1143 *-*          varx = 'ADDRESS VALUE' testline /* expression w/ any operators */
  1144 *-*          call c0482AddrDefineValue    /* set up for special address xref */
  1146 *-*          parse var line . . line      /* remove "address" and "value */
  1147 *-*          call c0300ParseRemaining     /* parse line for references */
  1148 *-*          return
  1149 *-*         end
  1150 *-*        parse var line . . line      /* remove "address" and "environment" */
  1152 *-*        if      addrenv = ''
  1153 *-*         then
       *-*         varx = 'ADDRESS'
  1154 *-*        else
       *-*         if line = ''
  1155 *-*          then
       *-*          varx = 'ADDRESS' "'"addrenv"'"
  1156 *-*         else
       *-*          varx = 'ADDRESS' "'"addrenv"' <cmd>"
  1157 *-*        call c0480AddrDefine         /* set up for address xref */
  1159 *-*        call c0300ParseRemaining     /* parse line for references */
  1160 *-*        return
  1161 *-*       end
  1162 *-*    end
  1163 *-*   else
       *-*    if rexxStmt = 'ARG'
  1164 *-*     then
       *-*     do
  1165 *-*      parse var line . template /* remove ARG */
  1166 *-*      call c0325TemplateAssignments /* handle parse template */
  1167 *-*      return
  1168 *-*     end
  1169 *-*    else
       *-*     if rexxStmt = 'CALL'
  1170 *-*      then
       *-*      do
  1171 *-*       parse var line . line /* remove 'call' from line */
  1172 *-*       if left(line,4) = 'OFF'
  1173 *-*        then
       *-*        return /* since valid syntax, must all be valid keywords, just return */
  1174 *-*       if left(line,3) = 'ON' /* this may specify a "trapname" */
  1175 *-*        then
       *-*        do
  1176 *-*         parse var Line onx verbx namex trapname
  1177 *-*         /* verbx must have been ERROR, FAILURE or HALT ... for rexx to like syntax */
  1178 *-*         /* if trapname <> '' then namex must have been NAME ... for rexx to like syntax */
  1179 *-*         if trapname <> ''
  1180 *-*          then
       *-*          do
  1181 *-*           if left(trapName,4) = "'LIT"
  1182 *-*            then
       *-*            do
  1183 *-*             parse var trapName . 'LIT' litNum "'" .
  1184 *-*             varX = litValue.Litnum
  1185 *-*            end
  1186 *-*           else
       *-*            varX = strip(trapName)
  1187 *-*           varx = varx '(CALL ON' verbx')'
  1188 *-*           call c0400CallReference
  1189 *-*           return /* and we're done here */
  1190 *-*          end
  1191 *-*         else
       *-*          do
  1192 *-*           varx = verbx '(CALL ON' verbx')'
  1193 *-*           call c0400CallReference
  1194 *-*           return /* and we're done here */
  1195 *-*          end
  1196 *-*        end
  1197 *-*       parse var line namex expression
  1198 *-*       if left(namex,4) = "'LIT"
  1199 *-*        then
       *-*        do
  1200 *-*         parse var namex . 'LIT' litNum "'" .
  1201 *-*         varX = litValue.LitNum
  1202 *-*         line = strip(expression)
  1203 *-*        end
  1204 *-*       else
       *-*        do
  1205 *-*         x = verify(line'+',validSymbolChars,,1) /* find where it is no longer a symbol*/
  1206 *-*         varX = left(line,x-1)
  1207 *-*         line = strip(substr(line,x))
  1208 *-*        end
  1209 *-*       call C0400CallReference /* reference call to routine in "varx" */
  1211 *-*       call c0300ParseRemaining
  1212 *-*       return
  1213 *-*      end
  1214 *-*     else
       *-*      if rexxStmt = 'DO'
  1215 *-*       then
       *-*       do
  1217 *-*        doLine = subword(line,2)  /* start with everything after "DO" */
  1219 *-*        if doLine = '' | doline = 'FOREVER'
  1220 *-*         then
       *-*         return  /* nothing more to do */
  1222 *-*        if word(doline,1) = 'WHILE' ,          | word(doline,1) = 'UNTIL'
  1224 *-*         then
       *-*         do
  1225 *-*          /* it began with WHILE expr or UNTIL expr; handle it quickly */
  1226 *-*          parse var doline . line
  1227 *-*          if line <> ''
  1228 *-*           then
       *-*           call c0300ParseRemaining
  1229 *-*          return
  1230 *-*         end
  1232 *-*        if subword(doline,1,2) = 'FOREVER WHILE' ,          | subword(doline,1,2) = 'FOREVER UNTIL'
  1234 *-*         then
       *-*         do
  1235 *-*          /* remove 'forever while' or 'forever until' and process remaining expression */
  1236 *-*          parse var doline . . line
  1237 *-*          if line <> ''
  1238 *-*           then
       *-*           call c0300ParseRemaining
  1239 *-*          return
  1240 *-*         end
  1242 *-*         /* figure out if we have a conditional expression (and remove word) */
  1243 *-*         /* ---------------------------------------------------------------- */
  1244 *-*        x1 = wordpos('WHILE',doline 'WHILE') /* note:  illegal to have both WHILE and UNTIL in same do stmt */
  1245 *-*        x2 = wordpos('UNTIL',doline 'UNTIL') /* note:  illegal to have both WHILE and UNTIL in same do stmt */
  1247 *-*        if x1 < x2
  1248 *-*         then
       *-*         doline = subword(doline,1,x1-1) subword(doline,x1+1) /* just make longer expression, remove WHILE */
  1249 *-*        else
       *-*         if x1 > x2
  1250 *-*          then
       *-*          doline = subword(doline,1,x2-1) subword(doline,x2+1) /* just make longer expression, remove UNTIL */
  1253 *-*          /* now, let's look at 'repetitor */
  1254 *-*          /* ----------------------------- */
  1255 *-*        repetitor = doLine
  1256 *-*        if repetitor = '' | repetitor = 'FOREVER'
  1257 *-*         then
       *-*         return
  1259 *-*        parse var repetitor namex '=' doRest
  1260 *-*        if namex <> '' & f9920VerifyRexxSymbol(nameX,'S') = 1 ,                                                & dorest <
> ''                                       ,          & left(strip(doRest),1) <> '=' /* variable/Stem '=' expri (not == expr) */
  1263 *-*         then
       *-*         do
  1264 *-*          /* we've got:  do name=expri <TO exprt> <BY exprb> <FOR exprf> */
  1265 *-*          /* ... eliminate 'TO' 'BY' or 'FOR' */
  1266 *-*          /* and use one big expression */
  1268 *-*          /* namex used in an assignement */
  1269 *-*          varx = namex
  1270 *-*          call c0500AddVarStemAssignment /* add assignment reference */
  1272 *-*          /* TO exprt (BY exprb) or (FOR exprf) can occur in any order */
  1273 *-*          x = min(wordpos('TO',dorest' TO'),wordpos('BY',dorest' BY'),wordpos('FOR',dorest' FOR'))
  1275 *-*          if x > words(dorest)
  1276 *-*           then
       *-*           do
  1277 *-*            line = strip(dorest)
  1278 *-*            if line <> ''
  1279 *-*             then
       *-*             call c0300ParseRemaining /* parse expri for references */
  1280 *-*            return
  1281 *-*           end
  1283 *-*          doKeyword = word(dorest,x)    /* remember keyword (TO, BY or FOR */
  1284 *-*          dorest = subword(dorest,1,x-1) subword(dorest,x+1) /* just remove keyword, make longer expression */
  1286 *-*          /* find end of next expression, at unused 'TO' 'BY' or 'FOR' */
  1287 *-*          if doKeyword = 'TO'
  1288 *-*           then
       *-*           x = min(wordpos('BY',dorest' BY'),wordpos('FOR',dorest' FOR'))
  1289 *-*          else
       *-*           if doKeyword = 'BY'
  1290 *-*            then
       *-*            x = min(wordpos('TO',dorest' TO'),wordpos('FOR',dorest' FOR'))
  1291 *-*           else
       *-*            if doKeyword = 'FOR'
  1292 *-*             then
       *-*             x = min(wordpos('TO',dorest' TO'),wordpos('BY',dorest' BY'))
  1293 *-*            else
       *-*             x = words(dorest) + 1 /* this can't happen, but looks good */
  1295 *-*          if x > words(dorest)
  1296 *-*           then
       *-*           do /* just one more expression to process */
  1297 *-*            line = strip(dorest)
  1298 *-*            if line <> ''
  1299 *-*             then
       *-*             call c0300ParseRemaining /* process this expression */
  1300 *-*            return
  1301 *-*           end
  1303 *-*           /* multiple expressions */
  1304 *-*           /* ... just remove keyword... and make a longer expression */
  1305 *-*          doKeyword = doKeyword word(dorest,x)
  1306 *-*          dorest = subword(dorest,1,x-1) subword(dorest,x+1) /* just remove keyword, make longer expression */
  1308 *-*          /* find end of next expression, at unused 'TO' 'BY' or 'FOR' */
  1309 *-*          if wordpos('TO',doKeyword)  = 0
       *-*           then
       *-*           x = wordpos('TO',dorest)
  1310 *-*          else
       *-*           if wordpos('BY',doKeyword)  = 0
       *-*            then
       *-*            x = wordpos('BY',dorest)
  1311 *-*           else
       *-*            if wordpos('FOR',doKeyword) = 0
       *-*             then
       *-*             x = wordpos('FOR',dorest)
  1312 *-*            else
       *-*             x = 0 /* just looks good */
  1314 *-*          if x > 0
  1315 *-*           then
       *-*           dorest = subword(dorest,1,x-1) subword(dorest,x+1) /* just remove keyword, make longer expression */
  1317 *-*          line = strip(dorest)
  1318 *-*          if line <> ''
  1319 *-*           then
       *-*           call c0300ParseRemaining /* parse references to one big expression */
  1320 *-*          return
  1321 *-*         end
  1322 *-*        else
       *-*         do
  1323 *-*          line = strip(repetitor)
  1324 *-*          if line = ''
  1325 *-*           then
       *-*           return
  1327 *-*          call c0300ParseRemaining /* parse line for references */
  1328 *-*          return
  1329 *-*         end
  1330 *-*       end
  1331 *-*      else
       *-*       if rexxStmt = 'END' /* end could be for "do" or for "select" */
  1332 *-*        then
       *-*        do
  1333 *-*         parse var line . line . /* remove 'end' */
  1334 *-*         if line <> ''
  1335 *-*          then
       *-*          call c0300ParseRemaining /* might have been:  end <name> */
  1336 *-*         return
  1337 *-*        end
  1338 *-*       else
       *-*        if rexxStmt = 'DROP'
  1339 *-*         then
       *-*         do
  1340 *-*          parse var line . line
  1341 *-*          line = translate(line,'  ','()') /* remove parens */
  1342 *-*          call c0300ParseRemaining /* parse line for references */
  1343 *-*          return
  1344 *-*         end
  1345 *-*        else
       *-*         if rexxStmt = 'EXIT'
  1346 *-*          then
       *-*          do
  1347 *-*           parse var line . line
  1348 *-*           call c0300ParseRemaining /* parse line for references */
  1349 *-*           return
  1350 *-*          end
  1351 *-*         else
       *-*          if rexxStmt = 'IF'
  1352 *-*           then
       *-*           do
  1353 *-*            parse var line . line
  1354 *-*            call c0300ParseRemaining /* parse line for references */
  1355 *-*            return
  1356 *-*           end
  1357 *-*          else
       *-*           if rexxStmt = 'THEN' /* it's either just "THEN" or "THEN ," */
  1358 *-*            then
       *-*            return
  1359 *-*           else
       *-*            if rexxStmt = 'ELSE' /* it's either just "ELSE" or "ELSE ," */
  1360 *-*             then
       *-*             return
  1361 *-*            else
       *-*             if rexxStmt = 'INTERPRET'
  1362 *-*              then
       *-*              do
  1363 *-*               parse var line . line
  1364 *-*               call c0300ParseRemaining /* parse line for references */
  1365 *-*               return
  1366 *-*              end
  1367 *-*             else
       *-*              if rexxStmt = 'ITERATE'
  1368 *-*               then
       *-*               do
  1369 *-*                parse var line . line
  1370 *-*                call c0300ParseRemaining /* parse line for references */
  1371 *-*                return
  1372 *-*               end
  1373 *-*              else
       *-*               if rexxStmt = 'LEAVE'
  1374 *-*                then
       *-*                do
  1375 *-*                 parse var line . line
  1376 *-*                 call c0300ParseRemaining /* parse line for references */
  1377 *-*                 return
  1378 *-*                end
  1379 *-*               else
       *-*                if rexxStmt = 'NOP'
  1380 *-*                 then
       *-*                 return
  1381 *-*                else
       *-*                 if rexxStmt = 'NUMERIC'
  1382 *-*                  then
       *-*                  do
  1383 *-*                   parse var line word1 word2 word3 .
  1385 *-*                   if word2 word3 = 'FORM SCIENTIFIC'
       *-*                    then
       *-*                    return
  1386 *-*                   if word2 word3 = 'FORM ENGINEERING'
       *-*                    then
       *-*                    return
  1388 *-*                   if word2 word3 = 'FORM VALUE'
       *-*                    then
       *-*                    parse var line . . . line
  1389 *-*                   else
       *-*                    if word2  = 'FORM'
       *-*                     then
       *-*                     parse var line . . line
  1390 *-*                    else
       *-*                     if word2  = 'DIGITS'
       *-*                      then
       *-*                      parse var line . . line
  1391 *-*                     else
       *-*                      if word2  = 'FUZZ'
       *-*                       then
       *-*                       parse var line . . line
  1392 *-*                      else
       *-*                       return /* this looks wrong, but can't happen with syntax checking*/
  1394 *-*                   call c0300ParseRemaining /* parse line for references */
  1395 *-*                   return
  1396 *-*                  end
  1397 *-*                 else
       *-*                  if rexxStmt = 'OPTIONS'
  1398 *-*                   then
       *-*                   return /* we don't handle the options statement */
  1399 *-*                  else
       *-*                   if rexxStmt = 'PARSE'
  1400 *-*                    then
       *-*                    do
  1401 *-*                     parse var line . line      /* remove 'parse' from line */
  1403 *-*                     if word(line,1) = 'UPPER'
  1404 *-*                      then
       *-*                      parse var line . line /* remove 'upper' from line */
  1406 *-*                     if wordpos(word(line,1),'ARG EXTERNAL NUMERIC PULL SOURCE VERSION') > 0
  1407 *-*                      then
       *-*                      do
  1408 *-*                       parse var line . template     /* get template */
  1409 *-*                       call c0325TemplateAssignments /* handle parse template */
  1410 *-*                       return
  1411 *-*                      end
  1412 *-*                     if word(line,1) = 'VALUE'
  1413 *-*                      then
       *-*                      do
  1414 *-*                       /* parse ... VALUE expression WITH template */
  1415 *-*                       parse var line . expression ' WITH ' template
  1416 *-*                       line = expression
  1417 *-*                       call c0300ParseRemaining      /* handle references in expression */
  1419 *-*                       call c0325TemplateAssignments /* handle parse template */
  1420 *-*                       return
  1421 *-*                      end
  1422 *-*                     if word(line,1) = 'VAR'
  1423 *-*                      then
       *-*                      do
  1424 *-*                       /* parse ... VAR name template */
  1425 *-*                       parse var line . name template
  1426 *-*                       line = name
  1427 *-*                       call c0300ParseRemaining      /* handle references in expression */
  1429 *-*                       call c0325TemplateAssignments /* handle parse template */
  1430 *-*                       return
  1431 *-*                      end
  1432 *-*                     return /* this would be invalid syntax (which can't happen) but it looks better */
  1433 *-*                    end
  1434 *-*                   else
       *-*                    if rexxStmt = 'PROCEDURE'
  1435 *-*                     then
       *-*                     do
  1436 *-*                      parse var line . line      /* remove 'procedure' from line */
  1438 *-*                      if word(line,1) = 'EXPOSE'
  1439 *-*                       then
       *-*                       do
  1440 *-*                        parse var line . line /* remove 'expose' from line */
  1441 *-*                        line = translate(line,'  ','()') /* remove any parens from line */
  1442 *-*                        if line <> ''
  1443 *-*                         then
       *-*                         do
  1444 *-*                          exposeRef = 1 /* turn on now */
  1445 *-*                          template = line
  1446 *-*                          call c0326TemplateList   /* handle references in rest of line */
  1447 *-*                          exposeRef = 0 /* turn off now */
  1448 *-*                         end
  1449 *-*                        return
  1450 *-*                       end
  1451 *-*                      return
  1452 *-*                     end
  1453 *-*                    else
       *-*                     if rexxStmt = 'PULL'
  1454 *-*                      then
       *-*                      do
  1455 *-*                       parse var line . template  /* remove 'pull' from line, put rest into template */
  1456 *-*                       if template <> ''
  1457 *-*                        then
       *-*                        call c0325TemplateAssignments /* handle parse template */
  1458 *-*                       return
  1459 *-*                      end
  1460 *-*                     else
       *-*                      if rexxStmt = 'PUSH'
  1461 *-*                       then
       *-*                       do
  1462 *-*                        parse var line . line      /* remove 'push' from line */
  1463 *-*                        if line <> ''
  1464 *-*                         then
       *-*                         call c0300ParseRemaining /* handle references in expression */
  1465 *-*                        return
  1466 *-*                       end
  1467 *-*                      else
       *-*                       if rexxStmt = 'QUEUE'
  1468 *-*                        then
       *-*                        do
  1469 *-*                         parse var line . line      /* remove 'queue' from line */
  1470 *-*                         if line <> ''
  1471 *-*                          then
       *-*                          call c0300ParseRemaining /* handle references in expression */
  1472 *-*                         return
  1473 *-*                        end
  1474 *-*                       else
       *-*                        if rexxStmt = 'RETURN'
  1475 *-*                         then
       *-*                         do
  1476 *-*                          parse var line . line      /* remove 'return' from line */
  1477 *-*                          if line <> ''
  1478 *-*                           then
       *-*                           call c0300ParseRemaining /* handle references in expression */
  1479 *-*                          return
  1480 *-*                         end
  1481 *-*                        else
       *-*                         if rexxStmt = 'SAY'
  1482 *-*                          then
       *-*                          do
  1483 *-*                           parse var line . line      /* remove 'say' from line */
  1484 *-*                           if line <> ''
  1485 *-*                            then
       *-*                            call c0300ParseRemaining /* handle references in expression */
  1486 *-*                           return
  1487 *-*                          end
  1488 *-*                         else
       *-*                          if rexxStmt = 'SELECT'
  1489 *-*                           then
       *-*                           do
  1490 *-*                            parse var line . ' WHEN ' expression ' THEN ' statement
  1491 *-*                            if expression <> ''
  1492 *-*                             then
       *-*                             do
  1493 *-*                              line = expression
  1494 *-*                              call c0300ParseRemaining /* handle references in expression */
  1496 *-*                              if statement <> ''
  1497 *-*                               then
       *-*                               do
  1498 *-*                                line = statement
  1499 *-*                                call c0100ParseStatement /* recursive call to ourselves */
  1500 *-*                               end
  1501 *-*                             end
  1502 *-*                            return
  1503 *-*                           end
  1504 *-*                          else
       *-*                           if rexxStmt = 'UPPER'
  1505 *-*                            then
       *-*                            do
  1506 *-*                             parse var line . template /* get template */
  1507 *-*                             if template <> ''
  1508 *-*                              then
       *-*                              call c0325TemplateAssignments /* handle parse template */
  1509 *-*                             return
  1510 *-*                            end
  1511 *-*                           else
       *-*                            if rexxStmt = 'WHEN'
  1512 *-*                             then
       *-*                             do
  1513 *-*                              parse var line . line /* remove 'when' from line */
  1514 *-*                              if line <> ''
  1515 *-*                               then
       *-*                               call c0300ParseRemaining /* handle references in expression */
  1516 *-*                              return
  1517 *-*                             end
  1518 *-*                            else
       *-*                             if rexxStmt = 'OTHERWISE'
  1519 *-*                              then
       *-*                              return /* trace 's' puts 'select' by itself.  "when expression" by itself. "otherwise" by i
tself. */
  1520 *-*                             else
       *-*                              if rexxStmt = 'SIGNAL'
  1521 *-*                               then
       *-*                               do
  1522 *-*                                parse var line . line      /* remove 'signal' from line */
  1523 *-*                                parse var line word1 word2 word3 word4 word5
  1524 *-*                                if word1 = 'VALUE'
  1525 *-*                                 then
       *-*                                 do
  1526 *-*                                  parse var line . line /* remove 'value' */
  1527 *-*                                  call c0300ParseRemaining /* handle references in expression */
  1528 *-*                                  return
  1529 *-*                                 end
  1530 *-*                                if word1 = 'OFF'
  1531 *-*                                 then
       *-*                                 do
  1532 *-*                                  parse var line . sType . /* sType will = ERROR, FAILURE, HALT, NOVALUE or SYNTAX */
  1533 *-*                                  varX = sType '(SIGNAL OFF' stype')'
  1534 *-*                                  call c0430SignalReference
  1535 *-*                                  return
  1536 *-*                                 end
  1537 *-*                                if word1 = 'ON'
  1538 *-*                                 then
       *-*                                 do
  1539 *-*                                  /* sType will = ERROR, FAILURE, HALT, NOVALUE or SYNTAX */
  1540 *-*                                  /* if namex and/or trapname not null; then NAMEX=NAME and trapname will be routine for
sType */
  1541 *-*                                  parse var line . sType namex trapname
  1542 *-*                                  if namex = 'NAME' & trapname <> ''
  1543 *-*                                   then
       *-*                                   do
  1544 *-*                                    varx = trapname '(SIGNAL ON' stype trapname')'
  1545 *-*                                    call c0430SignalReference
  1546 *-*                                   end
  1547 *-*                                  else
       *-*                                   do
  1548 *-*                                    varx = stype '(SIGNAL ON' stype')'
  1549 *-*                                    call c0430SignalReference
  1550 *-*                                   end
  1551 *-*                                  return
  1552 *-*                                 end
  1553 *-*                                 /* line has label */
  1554 *-*                                parse var line varx .
  1555 *-*                                if varx <> ''
  1556 *-*                                 then
       *-*                                 call c0430SignalReference /* generate reference for: signal labelname */
  1557 *-*                                return
  1558 *-*                               end
  1559 *-*                              else
       *-*                               if rexxStmt = 'TRACE'
  1560 *-*                                then
       *-*                                return
  1561 *-*  end /* end of handling rexx commands */
  1563 *-*  /* anything else is just an expression/command for the enviornment */
  1564 *-* call c0300ParseRemaining
  1565 *-* return
  1567 *-* c0300ParseRemaining:
  1568 *-* /* this is an expression */
  1569 *-* /*    1.  let's remove operators  */
  1570 *-* /*    2.  let's remove functions  */
  1571 *-* /*    3.  let's remove literals   */
  1572 *-* /* then look for variables and reference them */
  1574 *-* /* remove the "easy" operators to remove */
  1575 *-* line = translate(line,'            ','+-*/%=<>,|&¬\;)')
  1576 *-* /*   say 'rexxline='rexxline 'line="'line'"' */
  1578 *-* /* now, (easier) find and remove literals and (literal)functions */
  1579 *-* /*   while removing 'LIT### or 'FUN### from expression           */
  1580 *-* /* ------------------------------------------------------------- */
  1581 *-* do while pos("'",line) > 0
  1583 *-*  /* starting at "'" get LIT### or FUN### */
  1584 *-*  /* ...and remove it from 'line'         */
  1585 *-*  parse var line leftLine "'" litFun rightline
  1586 *-*  line = leftLine rightLine
  1588 *-*  /* either LIT### or FUN### */
  1589 *-*  if left(litFun,3) = 'LIT'
  1590 *-*   then
       *-*   iterate
  1592 *-*   /* FUN### */
  1593 *-*  parse var litfun . 4 functionNum .
  1594 *-*  varx = litValue.functionNum /* reference the function name */
  1595 *-*  call c0415FunctionReference
  1596 *-* end
  1598 *-* /* now, find variable/stem and/or built=in or internal functions */
  1599 *-* /* ------------------------------------------------------------- */
  1600 *-* line = strip(line)
  1601 *-* do forever
  1602 *-*  if line = ''
  1603 *-*   then
       *-*   return
  1605 *-*  line = strip(line)
  1606 *-*  if left(line,1) = '('
  1607 *-*   then
       *-*   do
  1608 *-*    line = strip(substr(line,2))
  1609 *-*    iterate
  1610 *-*   end
  1612 *-*  x = min(pos(' ',line' '),pos('(',line'('))
  1613 *-*  if substr(line,x,1) = '('
  1614 *-*   then
       *-*   do                            /* token(something*/
  1615 *-*    token = left(line,x)            /* token = token( */
  1616 *-*    line  = strip(substr(line,x+1)) /* line  = something */
  1617 *-*   end
  1618 *-*  else
       *-*   parse var line token line     /* token something*/
  1620 *-*  if right(token,1) = '('
  1621 *-*   then
       *-*   do
  1622 *-*    /* potential built-in and/or internal function */
  1623 *-*    varX = substr(token,1,length(token)-1)
  1624 *-*    if f9920VerifyRexxSymbol(varX,'S') = 1   /* valid symbol */
  1625 *-*     then
       *-*     do
  1626 *-*      /* token looks good */
  1627 *-*      if pos('.',varX) = 0
  1628 *-*       then
       *-*       do
  1629 *-*        /* we have a built-in or internal function call */
  1630 *-*        varx = substr(token,1,length(token)-1)
  1631 *-*        call c0415FunctionReference
  1632 *-*        line = strip(line)
  1633 *-*        iterate
  1634 *-*       end
  1635 *-*       /* we have a stem variable followed by a ( paren */
  1636 *-*       /* ... just ignore paren and handle stem         */
  1637 *-*      call c0510AddVarStemReference
  1638 *-*      line = strip(line)
  1639 *-*      iterate
  1640 *-*     end
  1642 *-*    iterate
  1643 *-*   end
  1646 *-*   /* if token is a valid variable/stem then reference it */
  1647 *-*   /* --------------------------------------------------- */
  1648 *-*  varX = token
  1649 *-*  if f9920VerifyRexxSymbol(varX,'S') = 1   /* valid symbol */
  1650 *-*   then
       *-*   do
  1651 *-*    call c0510AddVarStemReference /* add reference */
  1652 *-*    line = strip(line)
  1653 *-*    iterate
  1654 *-*   end
  1656 *-*  iterate
  1657 *-* end
  1659 *-* return
  1661 *-* c0325TemplateAssignments:
       *-* /* these variables are assigned values */
  1662 *-* /* this is an template   */
  1663 *-* /*    1.  let's remove operators  */
  1664 *-* /*    2.  let's remove literals   */
  1665 *-* /* then look for variables and reference them */
  1667 *-* /* remove the operators (but not parens) */
  1668 *-* template = translate(template,'              ','+-*/%=<>,|&;,')
  1670 *-* /* look for and remove (var) */
  1671 *-* /* these are references, not assignments */
  1672 *-* do while pos('(',template) > 0
  1673 *-*  parse var template leftTemplate '(' expression ')' rightTemplate
  1674 *-*  template = leftTemplate rightTemplate
  1676 *-*  do while expression <> ''
  1677 *-*   parse var expression word1 expression
  1678 *-*   if left(word1,1) = "'"
  1679 *-*    then
       *-*    iterate
  1681 *-*   if f9920VerifyRexxSymbol(word1,'S') = 1 /* valid symbol? */
  1682 *-*    then
       *-*    do
  1683 *-*     varX = word1
  1684 *-*     call c0510AddVarStemReference /* reference var */
  1685 *-*    end
  1686 *-*  end
  1687 *-* end
  1689 *-* /* we turned literals into 'LIT just ignore those */
  1690 *-* do while template <> ''
  1691 *-*  parse var template word1 template
  1692 *-*  if left(word1,1) = "'"
  1693 *-*   then
       *-*   iterate
  1694 *-*  if f9920VerifyRexxSymbol(word1,'S') = 1 /* valid symbol */
  1695 *-*   then
       *-*   do
  1696 *-*    /* we have a variable / stem reference */
  1697 *-*    varX = word1
  1698 *-*    call c0500AddVarStemAssignment /* this is assigned a value */
  1699 *-*   end
  1700 *-* end
  1701 *-* return
  1703 *-* c0326TemplateList:
       *-* /* these variables are referenced */
  1704 *-* /* this is an template   */
  1705 *-* /*    1.  let's remove operators  */
  1706 *-* /*    2.  let's remove literals   */
  1707 *-* /* then look for variables and reference them */
  1709 *-* /* remove the operators */
  1710 *-* template = translate(template,'                ','+-*/%=<>,|&;,()')
  1713 *-* /* we turned literals into 'LIT just ignore those */
  1714 *-* do while template <> ''
  1715 *-*  parse var template word1 template
  1716 *-*  if left(word1,1) = "'"
  1717 *-*   then
       *-*   iterate
  1718 *-*  if f9920VerifyRexxSymbol(word1,'S') = 1 /* valid symbol */
  1719 *-*   then
       *-*   do
  1720 *-*    /* we have a variable / stem reference */
  1721 *-*    varX = word1
  1722 *-*    call c0510AddVarStemReference  /* this variable is being referenced */
  1723 *-*   end
  1724 *-* end
  1725 *-* return
  1727 *-* /* these routine handle references to a varx subroutine:  CALL varx        */
  1728 *-* /*                                 to a varx function:    varx()           */
  1729 *-* /*                                 to a signal:           SIGNAL varx      */
  1730 *-* /*                                 to a signal on:        SIGNAL ON  varx  */
  1731 *-* /*                                 to a signal off:       SIGNAL OFF varx  */
  1732 *-* /*                   or defining a label                                   */
  1734 *-* c0400CallReference:
  1735 *-* /* make a reference for:  call varx */
  1736 *-* labelRefx = 'C('rexxline')'
  1737 *-* call c0450LabelReference
  1738 *-* return
  1740 *-* c0415FunctionReference:
  1741 *-* /* make a reference for function:  varx() */
  1742 *-* LabelRefx = 'F('rexxline')'
  1743 *-* call c0450LabelReference
  1744 *-* return
  1746 *-* c0430SignalReference:
  1747 *-* /* make a reference for signal  :  varx   */
  1748 *-* labelRefx = 'S('rexxline')'
  1749 *-* call c0450LabelReference
  1750 *-* return
  1752 *-* c0450LabelReference:
  1753 *-* /* code to update label references for calls, functions and/or signals */
  1754 *-* varX = strip(varX)
  1755 *-* upper varX
  1757 *-* /* note:  all valid symbols including numbers, periods, etc, are used "as is" */
  1758 *-* /* this is a simple variable (label)*/
  1759 *-* if variablesIndx.varX = 0
  1760 *-*  then
       *-*  do /* we need to add variable */
  1761 *-*   variable = variable + 1
  1762 *-*   variable.variable = varX
  1763 *-*   variableLabelRef.variable = labelRefx
  1764 *-*   /* we need to define quick lookup (index) to find this entry */
  1765 *-*   variablesIndx.varX = variable        /* create quick index .Varx to # (variable) */
  1767 *-*   if debug = 'ON'
  1768 *-*    then
       *-*    say 'debug:  c0450LabelReference: ('labelRefx') label='varx
  1770 *-*  end
  1771 *-* else
       *-*  do
  1772 *-*   /* known simple var re-referenced */
  1773 *-*   /*    this is illegal, but reference it anyway */
  1774 *-*   /*    this is illegal, but reference it anyway */
  1775 *-*   indx = variablesINdx.varX
  1777 *-*   /* make sure we only add one RexxLine reference */
  1778 *-*   if wordpos(labelRefx,variableLabelRef.indx) = 0
  1779 *-*    then
       *-*    do
  1780 *-*     variableLabelRef.indx = variableLabelRef.indx labelRefx
  1782 *-*     if debug = 'ON'
  1783 *-*      then
       *-*      say 'debug:  c0450LabelReference: ('labelRefx') label='varx
  1784 *-*    end
  1785 *-*  end
  1786 *-* return
  1788 *-* c0470LabelDefine:
  1789 *-* /* code to define a label used in the rexx code */
  1790 *-* varX = strip(varX)
  1791 *-* upper varX
  1792 *-* if datatype(varX,'S') <> 1
  1793 *-*  then
       *-*  return /* if not a symbol, return */
  1795 *-*  /* but all symbols including .123 or X.Y.Z etc are allowed */
  1796 *-*  /* this is a simple variable (label)*/
  1797 *-* if variablesIndx.varX = 0
  1798 *-*  then
       *-*  do /* we need to add variable */
  1799 *-*   variable = variable + 1
  1800 *-*   variable.variable = varX             /* remember label */
  1801 *-*   variableLabelDef.variable= rexxline  /* remember where defined          */
  1802 *-*   /* we need to define quick lookup (index) to find this entry */
  1803 *-*   variablesIndx.varX = variable        /* create quick index .Varx to # (variable) */
  1805 *-*   if debug = 'ON'
  1806 *-*    then
       *-*    say 'debug:  c0470LabelDefine: ('rexxline') label='varx
  1807 *-*  end
  1808 *-* else
       *-*  do
  1809 *-*   /* known simple var re-referenced */
  1810 *-*   /*    it can be defined multiple times, but only first label used in call/function/signal */
  1811 *-*   /*    will actually be used.                                                              */
  1812 *-*   indx = variablesINdx.varX
  1814 *-*   /* make sure we only add one RexxLine reference */
  1815 *-*   if wordpos(rexxline,variableLabelDef.indx) = 0
  1816 *-*    then
       *-*    do
  1817 *-*     if words(variableLabelDef.indx) = 1
  1818 *-*      then
       *-*      do
  1819 *-*       /* start of (potentially) many duplicate labels */
  1820 *-*       variableLabelDef.indx = variableLabelDef.indx ,                                     '///Dup. IGNORED LABEL def''s:
'
  1822 *-*      end
  1823 *-*     variableLabelDef.indx = variableLabelDef.indx rexxline
  1825 *-*     if debug = 'ON'
  1826 *-*      then
       *-*      say 'debug:  c0470LabelDefine: ('rexxline') label='varx
  1827 *-*    end
  1828 *-*  end
  1829 *-* return
  1831 *-* /* v1.02 update... c0480AddrDefine: added */
  1832 *-* /* -------------------------------------- */
  1833 *-* c0480AddrDefine:
  1834 *-* /* code to define a address 'constant' used in the rexx code */
  1835 *-* /*   caller set varx to something like:  address 'TSO'              for:  address TSO               OR address 'TSO'
      */
  1836 *-* /*   caller set varx to something like:  address 'TSO' expression   for:  address TSO anything      OR address 'TSO' any
thing */
  1837 *-* /*   caller set varx to something like:  address VALUE environment  for:  address VALUE environment
      */
  1838 *-* /*   caller set varx to something like:  address VALUE environment expression
      */
  1839 *-* /*                                                                  for:  address VALUE environement anything
      */
  1841 *-* if variablesIndx.varX = 0
  1842 *-*  then
       *-*  do /* we need to add variable */
  1843 *-*   variable = variable + 1
  1844 *-*   variable.variable = varX            /* remember addr def */
  1845 *-*   variableAddrDef.variable= rexxline  /* remember where defined          */
  1846 *-*   /* we need to define quick lookup (index) to find this entry */
  1847 *-*   variablesIndx.varX = variable        /* create quick index .Varx to # (variable) */
  1849 *-*   if debug = 'ON'
  1850 *-*    then
       *-*    say 'debug:  c0480AddrDefine: ('rexxline') addr='varx
  1851 *-*  end
  1852 *-* else
       *-*  do
  1853 *-*   /* add to references of this type of address command */
  1854 *-*   indx = variablesINdx.varX
  1855 *-*   variableAddrDef.indx = variableAddrDef.indx rexxline /* keep adding references */
  1857 *-*   if debug = 'ON'
  1858 *-*    then
       *-*    say 'debug:  c0480AddrDefine: ('rexxline') addr='varx
  1859 *-*  end
  1860 *-* return
  1862 *-* /* v1.02 update... c0480AddrDefine: added */
  1863 *-* /* -------------------------------------- */
  1864 *-* c0482AddrDefineValue:
  1865 *-* /* code to define a address value expression used in the rexx code */
  1866 *-* /*   caller set varx to something like:  address 'TSO'              for:  address TSO               OR address 'TSO'
      */
  1867 *-* /*   caller set varx to something like:  address 'TSO' expression   for:  address TSO anything      OR address 'TSO' any
thing */
  1868 *-* /*   caller set varx to something like:  address VALUE environment  for:  address VALUE environment
      */
  1869 *-* /*   caller set varx to something like:  address VALUE environment expression
      */
  1870 *-* /*                                                                  for:  address VALUE environement anything
      */
  1872 *-* if variablesIndx.varX = 0
  1873 *-*  then
       *-*  do /* we need to add variable */
  1874 *-*   variable = variable + 1
  1875 *-*   variable.variable = varX                 /* remember addr def */
  1876 *-*   variableAddrDefValue.variable= rexxline  /* remember where defined          */
  1877 *-*   /* we need to define quick lookup (index) to find this entry */
  1878 *-*   variablesIndx.varX = variable        /* create quick index .Varx to # (variable) */
  1880 *-*   if debug = 'ON'
  1881 *-*    then
       *-*    say 'debug:  c0480AddrDefine: ('rexxline') addr='varx
  1882 *-*  end
  1883 *-* else
       *-*  do
  1884 *-*   /* add to references of this type of address command */
  1885 *-*   indx = variablesINdx.varX
  1886 *-*   variableAddrDefValue.indx = variableAddrDefValue.indx rexxline /* keep adding references */
  1888 *-*   if debug = 'ON'
  1889 *-*    then
       *-*    say 'debug:  c0480AddrDefine: ('rexxline') addr='varx
  1890 *-*  end
  1891 *-* return
  1894 *-* c0500AddVarStemAssignment:
  1895 *-* /* this could be a "simple" variable in varx or a "stem" variable being set */
  1896 *-* /* ... we need to keep track of assignments (and in case of a stem, also    */
  1897 *-* /* ... variables and/or constants referenced in the stem).                  */
  1898 *-* /* */
  1899 *-* varX = strip(varX)
  1900 *-* upper varX
  1901 *-* if pos('.',varX) = 0
  1902 *-*  then
       *-*  do
  1903 *-*   /* this is a simple variable */
  1904 *-*   if variablesIndx.varX = 0
  1905 *-*    then
       *-*    do /* we need to add variable */
  1906 *-*     variable = variable + 1
  1907 *-*     variable.variable = varX        /* remember variable name */
  1908 *-*     variableSet.variable = rexxLine /* remember where it was set */
  1909 *-*     /* we need to define quick lookup (index) to find this entry */
  1910 *-*     variablesIndx.varX = variable        /* create quick index .Varx to # (variable) */
  1912 *-*     if debug = 'ON'
  1913 *-*      then
       *-*      say 'debug:  c0500AddVarStemAssignment: ('rexxline') var='varx
  1914 *-*    end
  1915 *-*   else
       *-*    do
  1916 *-*     /* known simple var re-referenced */
  1917 *-*     indx = variablesINdx.varX
  1919 *-*     /* make sure we only add one RexxLine reference */
  1920 *-*     if wordpos(rexxLine,variableSet.indx) = 0
  1921 *-*      then
       *-*      do
  1922 *-*       variableSet.indx = variableSet.indx rexxline
  1924 *-*       if debug = 'ON'
  1925 *-*        then
       *-*        say 'debug:  c0500AddVarStemAssignment: ('rexxline') var='varx
  1926 *-*      end
  1927 *-*    end
  1928 *-*   return
  1929 *-*  end
  1931 *-*  /* this is a stem variable */
  1932 *-* periods = 0
  1933 *-* pPos = pos('.',varX)
  1934 *-* do while pPos <> 0
  1935 *-*  periods = periods + 1
  1936 *-*  pPos = pos('.',varX,pPos+1)
  1937 *-* end
  1939 *-* /* if part of stem is a hard coded # (other than zero), replace with # sign*/
  1940 *-* parse var varx psuedoVar '.' rest
  1941 *-* do while rest <> ''
  1942 *-*  psuedoVar = psuedoVar'.'
  1943 *-*  parse var rest stemPortion '.' rest
  1944 *-*  if datatype(stemPortion,'W')
  1945 *-*   then
       *-*   if stemPortion == '0'
  1946 *-*    then
       *-*    psuedoVar = psuedoVar || '0'
  1947 *-*   else
       *-*    psuedoVar = psuedoVar || '#'
  1948 *-*  else
       *-*   psuedoVar = psuedoVar || stemPortion
  1949 *-* end
  1950 *-* if right(varx,1) = '.'
  1951 *-*  then
       *-*  psuedoVar = psuedoVar'.'
  1953 *-*  /* define psuedoVar for tracking stems */
  1954 *-* if stemIndx.psuedoVar = 0
  1955 *-*  then
       *-*  do
  1956 *-*   /* add to stem variables */
  1957 *-*   stem = stem + 1
  1958 *-*   stemVariable.stem = psuedoVar
  1959 *-*   stemPeriods.stem  = periods
  1960 *-*   stemRef.stem= ''
  1961 *-*   StemAsg.stem= RexxLine
  1962 *-*   /* we need to define quick lookup (index) to find this psuedoVar */
  1963 *-*   stemIndx.psuedoVar = stem
  1965 *-*   if debug = 'ON'
  1966 *-*    then
       *-*    say 'debug:  c0500AddVarStemAssignment: ('rexxline') var='psuedoVar
  1967 *-*  end
  1968 *-* else
       *-*  do
  1969 *-*   /* known stem var re-referenced */
  1970 *-*   indx = stemIndx.psuedoVar
  1972 *-*   /* only one RexxLine assignment needed */
  1973 *-*   if wordpos(rexxLine,stemAsg.indx) = 0
  1974 *-*    then
       *-*    do
  1975 *-*     stemAsg.indx= stemAsg.indx rexxLine
  1977 *-*     if debug = 'ON'
  1978 *-*      then
       *-*      say 'debug:  c0500AddVarStemAssignment: ('rexxline') var='psuedoVar
  1979 *-*    end
  1980 *-*  end
  1982 *-* /* now go thru stem's and "reference" those vars */
  1983 *-* parse var varX . '.' varX /* throw away top level */
  1984 *-* do while varX <> ''
  1985 *-*  parse var varX simpleVar '.' varX /* get next potential stem var */
  1986 *-*  if f9920VerifyRexxSymbol(simpleVar,'S') = 1 /* if a symbol and not a digit */
  1987 *-*   then
       *-*   do
  1988 *-*    /* add simple variable reference's from the stem */
  1989 *-*    if variablesIndx.simpleVar = 0
  1990 *-*     then
       *-*     do /* we need to add variable */
  1991 *-*      variable = variable + 1
  1992 *-*      variable.variable     = simpleVar   /* remember the name */
  1993 *-*      variableStemSet.variable = rexxline /* remember where it was used to help set stem var */
  1994 *-*      /* we need to define quick lookup (index) to find this simpleVar */
  1995 *-*      variablesIndx.simpleVar = variable
  1997 *-*      if debug = 'ON'
  1998 *-*       then
       *-*       say 'debug:  (VarRef In stem) c0500AddVarStemAssignment: ('rexxline') var='simpleVar
  1999 *-*     end
  2000 *-*    else
       *-*     do
  2001 *-*      /* known simple var re-referenced */
  2002 *-*      indx = variablesINdx.simpleVar
  2004 *-*      /* make sure we only add one RexxLine reference */
  2005 *-*      if wordpos(rexxLine,variableStemRef.indx) = 0
  2006 *-*       then
       *-*       do
  2007 *-*        variableStemSet.indx = variableStemSet.indx rexxline
  2009 *-*        if debug = 'ON'
  2010 *-*         then
       *-*         say 'debug:  (VarRef in stem) c0500AddVarStemAssignment: ('rexxline') var='simpleVar
  2011 *-*       end
  2012 *-*     end
  2013 *-*   end
  2014 *-* end
  2015 *-* return
  2018 *-* c0510AddVarStemReference:
  2019 *-* /* this could be a "simple" variable in varx or a "stem" variable reference */
  2020 *-* /* ... we need to keep track of references  (and in case of a stem, also    */
  2021 *-* /* ... variables and/or constants referenced in the stem).                  */
  2022 *-* /* */
  2023 *-* varX = strip(varX)
  2024 *-* upper varX
  2026 *-* if pos('.',varX) = 0  /* not stem variable by definition */
  2027 *-*  then
       *-*  do
  2028 *-*   /* this is a simple variable */
  2029 *-*   if variablesIndx.varX = 0
  2030 *-*    then
       *-*    do /* we need to add variable */
  2031 *-*     variable = variable + 1
  2032 *-*     variable.variable = varX              /* remember the name */
  2033 *-*     if exposeRef = 1
  2034 *-*      then
       *-*      variableExposeRef.variable = rexxLine /* remember line # in reference */
  2035 *-*     else
       *-*      variableRef.variable       = rexxLine /* remember line # in reference */
  2036 *-*     /* we need to define quick lookup (index) to find this entry */
  2037 *-*     variablesIndx.varX = variable        /* create quick index .Varx to # (variable) */
  2039 *-*     if debug = 'ON'
  2040 *-*      then
       *-*      say 'debug:  (Var.Ref) c0510AddVarStemReference: ('rexxline') var='varx
  2041 *-*    end
  2042 *-*   else
       *-*    do
  2043 *-*     /* known simple var re-referenced */
  2044 *-*     indx = variablesINdx.varX
  2046 *-*     /* make sure we only add one RexxLine reference */
  2047 *-*     if exposeref = 1
  2048 *-*      then
       *-*      do
  2049 *-*       if wordpos(rexxLine,variableExposeRef.indx) = 0
  2050 *-*        then
       *-*        do
  2051 *-*         variableExposeRef.indx = variableExposeRef.indx rexxline
  2053 *-*         if debug = 'ON'
  2054 *-*          then
       *-*          say 'debug:  (Var.Ref) c0510AddVarStemReference: ('rexxline') var='varx
  2055 *-*        end
  2056 *-*      end
  2057 *-*     else
       *-*      do
  2058 *-*       if wordpos(rexxLine,variableRef.indx) = 0
  2059 *-*        then
       *-*        do
  2060 *-*         variableRef.indx = variableRef.indx rexxline
  2062 *-*         if debug = 'ON'
  2063 *-*          then
       *-*          say 'debug:  (Var.Ref) c0510AddVarStemReference: ('rexxline') var='varx
  2064 *-*        end
  2065 *-*      end
  2066 *-*    end
  2067 *-*   return
  2068 *-*  end
  2070 *-*  /* this is a stem variable */
  2071 *-* periods = 0
  2072 *-* pPos = pos('.',varX)
  2073 *-* do while pPos <> 0
  2074 *-*  periods = periods + 1
  2075 *-*  pPos = pos('.',varX,pPos+1)
  2076 *-* end
  2078 *-* /* if part of stem is a hard coded # (other than zero), replace with # sign*/
  2079 *-* parse var varx psuedoVar '.' rest
  2080 *-* do while rest <> ''
  2081 *-*  psuedoVar = psuedoVar'.'
  2082 *-*  parse var rest stemPortion '.' rest
  2083 *-*  if datatype(stemPortion,'W')
  2084 *-*   then
       *-*   if stemPortion == '0'
  2085 *-*    then
       *-*    psuedoVar = psuedoVar || '0'
  2086 *-*   else
       *-*    psuedoVar = psuedoVar || '#'
  2087 *-*  else
       *-*   psuedoVar = psuedoVar || stemPortion
  2088 *-* end
  2089 *-* if right(varx,1) = '.'
  2090 *-*  then
       *-*  psuedoVar = psuedoVar'.'
  2092 *-*  /* define psuedoVar for tracking stems */
  2093 *-* if stemIndx.psuedoVar = 0
  2094 *-*  then
       *-*  do
  2095 *-*   /* add to stem variables */
  2096 *-*   stem = stem + 1
  2097 *-*   stemVariable.stem = psuedoVar
  2098 *-*   stemPeriods.stem  = periods
  2099 *-*   if exposeRef = 1
  2100 *-*    then
       *-*    stemExposeRef.stem = RexxLine
  2101 *-*   else
       *-*    stemRef.stem       = RexxLine
  2102 *-*   /* we need to define quick lookup (index) to find this psuedoVar */
  2103 *-*   stemIndx.psuedoVar = stem
  2105 *-*   if debug = 'ON'
  2106 *-*    then
       *-*    say 'debug:  (StemRef) c0510AddVarStemReference: ('rexxline') var='psuedoVar
  2107 *-*  end
  2108 *-* else
       *-*  do
  2109 *-*   /* known stem var re-referenced */
  2110 *-*   indx = stemIndx.psuedoVar
  2112 *-*   /* only one RexxLine reference needed */
  2113 *-*   if exposeRef = 1
  2114 *-*    then
       *-*    do
  2115 *-*     if wordpos(rexxLine,stemExposeRef.indx) = 0
  2116 *-*      then
       *-*      do
  2117 *-*       stemExposeRef.indx= stemExposeRef.indx rexxLine
  2119 *-*       if debug = 'ON'
  2120 *-*        then
       *-*        say 'debug:  (StemRef) c0510AddVarStemReference: ('rexxline') var='psuedoVar
  2121 *-*      end
  2122 *-*    end
  2123 *-*   else
       *-*    do
  2124 *-*     if wordpos(rexxLine,stemRef.indx) = 0
  2125 *-*      then
       *-*      do
  2126 *-*       stemRef.indx= stemRef.indx rexxLine
  2128 *-*       if debug = 'ON'
  2129 *-*        then
       *-*        say 'debug:  (StemRef) c0510AddVarStemReference: ('rexxline') var='psuedoVar
  2130 *-*      end
  2131 *-*    end
  2132 *-*  end
  2134 *-* /* now go thru stem's and "reference" those vars */
  2135 *-* parse var varX . '.' varX /* throw away top level */
  2136 *-* do while varX <> ''
  2137 *-*  parse var varX simpleVar '.' varX /* get next potential stem var */
  2138 *-*  if f9920VerifyRexxSymbol(simpleVar,'S') = 1 /* if a symbol and not a digit */
  2139 *-*   then
       *-*   do
  2140 *-*    /* add simple variable reference's from the stem */
  2141 *-*    if variablesIndx.simpleVar = 0
  2142 *-*     then
       *-*     do /* we need to add variable */
  2143 *-*      variable = variable + 1
  2144 *-*      variable.variable     = simpleVar    /* remember the name */
  2145 *-*      variableStemRef.variable = rexxline  /* used in stem */
  2146 *-*      /* we need to define quick lookup (index) to find this simpleVar */
  2147 *-*      variablesIndx.simpleVar = variable
  2149 *-*      if debug = 'ON'
  2150 *-*       then
       *-*       say 'debug:  (varRef in stem) c0510AddVarStemReference: ('rexxline') var='simpleVar
  2151 *-*     end
  2152 *-*    else
       *-*     do
  2153 *-*      /* known simple var re-referenced */
  2154 *-*      indx = variablesINdx.simpleVar
  2156 *-*      /* make sure we only add one RexxLine reference */
  2157 *-*      if wordpos(rexxLine,variableStemRef.indx) = 0
  2158 *-*       then
       *-*       do
  2159 *-*        variableStemRef.indx = variableStemRef.indx rexxline
  2161 *-*        if debug = 'ON'
  2162 *-*         then
       *-*         say 'debug:  (varRef in stem) C0510AddVarStemReference: ('rexxline') var='simpleVar
  2163 *-*       end
  2164 *-*     end
  2165 *-*   end
  2166 *-* end
  2167 *-* return
  2169 *-* c9900OutputResults:
  2170 *-* if debug = 'ON'
  2171 *-*  then
       *-*  say 'debug:  before variable sort'
  2172 *-* maxVarLength = 0
  2173 *-* do sortedVariable = 1 by 1 for variable
  2174 *-*  sortedVariable.sortedVariable = variable.sortedVariable /* copy variable name */
  2175 *-*  if length(sortedVariable.sortedVariable) > maxVarLength
  2176 *-*   then
       *-*   maxVarLength = length(sortedVariable.sortedVariable)
  2177 *-*  if debug = 'ON'
  2178 *-*   then
       *-*   say 'debug:  sortedVariable.'sortedVariable'='sortedVariable.sortedVariable
  2179 *-* end
  2180 *-* sortedVariable.0 = variable
  2182 *-* /* sort variables for xref listing */
  2183 *-* /* ------------------------------- */
  2184 *-* if omvsSeg = 1
  2185 *-*  then
       *-*  y2=      BPXWUNIX('sort','sortedVariable.','sortedVariable.') /* fast omvs sort */
  2186 *-* else
       *-*  y2= f9910SlowSort('sort','sortedVariable.','sortedVariable.') /* slow rexx sort */
  2188 *-* if y2<> 0
       *-*  then
       *-*  say 'error:  stemsort returned y2='y2'; omvsSeg='omvsSeg
  2189 *-* if debug = 'ON'
  2190 *-*  then
       *-*  do
  2191 *-*   say ' '
  2192 *-*   say 'debug:  after variable sort'
  2193 *-*   do sortedVariable = 1 by 1 for variable
  2194 *-*    say 'debug:  SortedVariable.'sortedVariable'='SortedVariable.sortedVariable
  2195 *-*   end
  2196 *-*   say ' '
  2197 *-*  end
  2199 *-* if debug = 'ON'
  2200 *-*  then
       *-*  say 'debug:  before stem sort'
  2201 *-* maxStemLength = 0
  2202 *-* do sortedStemVariable = 1 by 1 for stem
  2203 *-*  sortedStemVariable.sortedStemVariable = StemVariable.sortedStemVariable /* copy stem name */
  2204 *-*  if length(sortedStemVariable.sortedStemVariable) > maxStemLength
  2205 *-*   then
       *-*   maxStemLength = length(sortedStemVariable.sortedStemVariable)
  2206 *-*  if debug = 'ON'
  2207 *-*   then
       *-*   say 'debug:  sortedStemVariable.'sortedStemVariable'='sortedStemVariable.sortedStemVariable
  2208 *-* end
  2209 *-* sortedStemVariable.0 = stem
  2211 *-* /* sort stem variables for xref listing */
  2212 *-* /* ------------------------------------ */
  2213 *-* if omvsSeg = 1
  2214 *-*  then
       *-*  y3=      BPXWUNIX('sort','sortedStemVariable.','sortedStemVariable.') /* fast omvs sort */
  2215 *-* else
       *-*  y3= f9910SlowSort('sort','sortedStemVariable.','sortedStemVariable.') /* slow rexx sort */
  2217 *-* if y3<> 0
       *-*  then
       *-*  say 'error:  stemsort returned y3='y3'; omvsSeg='omvsSeg
  2218 *-* if debug = 'ON'
  2219 *-*  then
       *-*  do
  2220 *-*   say ' '
  2221 *-*   say 'debug:  after stem sort'
  2222 *-*   do sortedStemVariable = 1 by 1 for stem
  2223 *-*    say 'debug:  SortedStemVariable.'sortedStemVariable'='SortedStemVariable.sortedStemVariable
  2224 *-*   end
  2225 *-*   say ' '
  2226 *-*  end
  2228 *-* out = 0
  2229 *-* x = f9970Card(' ')
  2230 *-* x = f9970Card(' ')
  2231 *-* x = f9970Card(' ------------ now xreference begins -----------------------')
  2232 *-* x = f9970Card(' ------------ now xreference begins -----------------------')
  2233 *-* x = f9970Card(' ')
  2234 *-* x = f9970Card('                                                                 ')
  2235 *-* x = f9970Card('    xref (1 of 2) section 1 is for variables (not stem.''s)       ')
  2236 *-* x = f9970Card('    xref (1 of 2) section 1 is for variables (not stem.''s)       ')
  2237 *-* x = f9970Card('    ----------------------------------------------------------   ')
  2238 *-* x = f9970Card('                                                                 ')
  2239 *-* x = f9970Card('       variables/labels are in "upperCase" if variable was never ')
  2240 *-* x = f9970Card('                       assigned a value.                         ')
  2241 *-* x = f9970Card('                                                                 ')
  2242 *-* x = f9970Card('                        they are in "lowercase", otherwise.      ')
  2243 *-* x = f9970Card('                                                                 ')
  2244 *-* x = f9970Card('       variables/stems set via a command, like EXECIO for        ')
  2245 *-* x = f9970Card('                       example, where the stem is within quotes  ')
  2246 *-* x = f9970Card('                       will not be shown in the xref as either   ')
  2247 *-* x = f9970Card('                       an assignment or a reference.             ')
  2248 *-* x = f9970Card('                                                                 ')
  2249 *-* x = f9970Card('       Note special variables like:  RC, SIGL, can be assigned   ')
  2250 *-* x = f9970Card('                       values explictly.  But rexx can set them  ')
  2251 *-* x = f9970Card('                       as well implicitly.  Implicit assignments ')
  2252 *-* x = f9970Card('                       are not in the xref.                      ')
  2253 *-* x = f9970Card('    ----------------------------------------------------------   ')
  2254 *-* x = f9970Card('                                                                 ')
  2255 *-* x = f9970Card(' ')
  2256 *-* x = f9970Card(' ')
  2257 *-* /* variables used as constants */
  2258 *-* maxOutputVar = min(DefaultMaxOutputVar,maxVarLength+5) /* maxoutputvar was 30, 40 or 50 */
  2259 *-* do indx2 = 1 by 1 for variable
  2260 *-*  /* get next sorted variable, then report it's information */
  2261 *-*  sortedVariable =  SortedVariable.indx2
  2262 *-*  indx = variablesIndx.sortedVariable /* use indx to info for this variable */
  2264 *-*  if variableSet.indx <> ''     /* if assigned a value, make variable name "lowerCase */
  2265 *-*   then
       *-*   tempname = translate(variable.indx,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')
  2266 *-*  else
       *-*   if right(sortedVariable,1) = '+' /* v1.02 */
  2267 *-*    then
       *-*    tempname = left(sortedVariable,length(sortedVariable)-1)
  2268 *-*   else
       *-*    tempname = variable.indx /* else, keep upper case */
  2270 *-*  if specialVar.sortedVariable > 0
  2271 *-*   then
       *-*   do
  2273 *-*    if variableSet.indx <> ''       , /* if special variable used in rexx somehow; mention it's special attributes */
      | variableRef.indx <> ''       , /* if special variable used in rexx somehow; mention it's special attributes */          | v
ariableExposeRef.indx <> '' , /* if special variable used in rexx somehow; mention it's special attributes */          | variableSt
emSet.indx   <> '' , /* if special variable used in rexx somehow; mention it's special attributes */          | variableStemRef.ind
x   <> ''   /* if special variable used in rexx somehow; mention it's special attributes */
  2278 *-*     then
       *-*     x = f9930OutputVarInfo('SpecialVar(set no-XREF)',tempName,' *Special:',' No xref; set w/ADDR env cmd and/or REXX its
elf')
  2280 *-*    if variableSet.indx <> ''
  2281 *-*     then
       *-*     x = f9930OutputVarInfo('SpecialVar(set w/ code)',tempName,'Assigned :',variableSet.indx)
  2283 *-*    if variableRef.indx <> ''
  2284 *-*     then
       *-*     x = f9930OutputVarInfo('SpecialVar(used w/rexx)',tempName,'Reference:',variableRef.indx)
  2286 *-*    if variableExposeRef.indx <> ''
  2287 *-*     then
       *-*     x = f9930OutputVarInfo('SpecialVar(used w/rexx)',tempName,'Expose Ref:',variableExposeRef.indx)
  2289 *-*    if variableStemSet.indx   <> ''
  2290 *-*     then
       *-*     x = f9930OutputVarInfo('SpecialVar(w/stem set):',tempName,'w/Stem set',variableStemSet.indx)
  2292 *-*    if variableStemRef.indx   <> ''
  2293 *-*     then
       *-*     x = f9930OutputVarInfo('SpecialVar(w/stem ref):',tempName,'W/Stem ref',variableStemRef.indx)
  2295 *-*    if variableLabelDef.indx  <> ''
  2296 *-*     then
       *-*     x = f9930OutputVarInfo('Label (internal label) ',variable.indx,'Defined  :',variableLabelDef.indx)
  2298 *-*    if variableLabelRef.indx  <> '' & variableLabelDef.indx <> ''
  2299 *-*     then
       *-*     x = f9930OutputVarInfo('Label (int. label ref) ',variable.indx,'Reference:',variableLabelRef.indx)
  2301 *-*    if variableLabelRef.indx  <> '' & variableLabelDef.indx = ''
  2302 *-*     then
       *-*     x = f9930OutputVarInfo('BuiltoIn+/External use ',variable.indx,'Reference:',variableLabelRef.indx)
  2304 *-*     /* v1.02 if an address reference, report it */
  2305 *-*    if variableAddrDef.indx   <> ''
  2306 *-*     then
       *-*     x = f9930OutputVarInfo('Address Envir.Constant:',variable.indx,'Reference:',variableAddrDef.indx)
  2307 *-*    if variableAddrDefValue.indx <> ''
  2308 *-*     then
       *-*     x = f9930OutputVarInfo('Address Envir.ValueExp:',variable.indx,'Reference:',variableAddrDefValue.indx)
  2310 *-*    iterate
  2312 *-*   end
  2314 *-*   /* if not assigned a value... but referenced "as a variable" in rexx code... report it */
  2315 *-*  if variableSet.indx = '' ,         & ( variableRef.indx <> '' | variableStemSet.indx   <> '' | variableStemRef.indx   <
> '' ,                |variableExposeRef.indx <> '')
  2318 *-*   then
       *-*   x = f9930OutputVarInfo('Variable (NEVER SET)   ',tempName,'Not Assgn:',' EITHER used as upper case value OR set via cm
d')
  2320 *-*   /* if assigned a value, report it */
  2321 *-*  if variableSet.indx <> ''                                          /* assigned a value, report it */
  2322 *-*   then
       *-*   x = f9930OutputVarInfo('Variable (set w/rexx)  ',tempName,'Assigned :',variableSet.indx)
  2324 *-*  if variableRef.indx       <> '' ,       | variableExposeRef.indx <> '' ,       | variableStemSet.indx   <> '' ,       |
 variableStemRef.indx   <> ''
  2328 *-*   then
       *-*   do
  2329 *-*    /* if variable refernce, report it*/
  2330 *-*    if variableRef.indx <> ''
  2331 *-*     then
       *-*     x = f9930OutputVarInfo('Variable (used in/rexx)',tempName,'Reference:',variableRef.indx)
  2333 *-*     /* if variable expose refernce, report it*/
  2334 *-*    if variableExposeRef.indx <> ''
  2335 *-*     then
       *-*     x = f9930OutputVarInfo('Variable (used in/rexx)',tempName,'Expose Ref:',variableExposeRef.indx)
  2337 *-*     /* if variable used in stem, report it */
  2338 *-*    if variableStemSet.indx   <> ''
  2339 *-*     then
       *-*     x = f9930OutputVarInfo('Variable (in Stem Set) ',tempName,'Assigned :',variableStemSet.indx)
  2341 *-*     /* if variable used in stem, report it */
  2342 *-*    if variableStemRef.indx   <> ''
  2343 *-*     then
       *-*     x = f9930OutputVarInfo('Variable (in Stem Ref) ',tempName,'Reference:',variableStemRef.indx)
  2344 *-*   end
  2345 *-*  else
       *-*   if variableSet.Indx <> '' /* if wasn't referenced, but it was assigned a value */
  2346 *-*    then
       *-*    x = f9930OutputVarInfo('Variable (NEVER USED)  ',tempName,'No Ref.  :',' If actually referenced, it must be via a cmd
.')
  2348 *-*    /* if it's an internal label, report it */
  2349 *-*  if variableLabelDef.indx  <> ''
  2350 *-*   then
       *-*   x = f9930OutputVarInfo('Label (internal label) ',variable.indx,'Defined  :',variableLabelDef.indx)
  2352 *-*   /* if label (internal or external) is used, report it */
  2353 *-*  if 7ariableLabelRef.indx  <> '' & variableLabelDef.Indx <> ''
  2354 *-*   then
       *-*   x = f9930OutputVarInfo('Label (int. label ref) ',variable.indx,'Reference:',variableLabelRef.indx)
  2355 *-*  else
       *-*   if variableLabelRef.indx  <> ''
  2356 *-*    then
       *-*    x = f9930OutputVarInfo('Built-In+/External use ',variable.indx,'Reference:',variableLabelRef.indx)
  2358 *-*    /* v1.02 if an address reference, report it */
  2359 *-*  if variableAddrDef.indx   <> ''
  2360 *-*   then
       *-*   x = f9930OutputVarInfo('Address Envir.Constant:',variable.indx,'Reference:',variableAddrDef.indx)
  2361 *-*  if variableAddrDefValue.indx <> ''
  2362 *-*   then
       *-*   x = f9930OutputVarInfo('Address Envir.ValueExp:',variable.indx,'Reference:',variableAddrDefValue.indx)
  2365 *-* end
  2367 *-* 'EXECIO' out 'DISKW RESULTS (STEM OUT.'
  2368 *-* if rc <> 0
  2369 *-*  then
       *-*  do
  2370 *-*   say 'error writing to RESULTS ddname; rc='rc
  2371 *-*   say 'exit 8'
  2372 *-*   'EXECIO 0 DISKW RESULTS (FINIS'
  2373 *-*   exit 8
  2374 *-*  end
  2376 *-*  /* variables used as variables */
  2377 *-* out = 0
  2378 *-* x = f9970Card('    xref (1 of 2) ends here                                      ')
  2379 *-* x = f9970Card('    xref (1 of 2) ends here                                      ')
  2380 *-* x = f9970Card('    -----------------------                                      ')
  2381 *-* x = f9970Card('                                                                 ')
  2382 *-* x = f9970Card('    xref (2 of 2) section 2 is for stem variable xreference.     ')
  2383 *-* x = f9970Card('    xref (2 of 2) section 2 is for stem variable xreference.     ')
  2384 *-* x = f9970Card('    ----------------------------------------------------------   ')
  2385 *-* x = f9970Card('       note:     Assignments/references to rexx stems            ')
  2386 *-* x = f9970Card('              is only for stem references in rexx code           ')
  2387 *-* x = f9970Card('              itself.                                            ')
  2388 *-* x = f9970Card('                                                                 ')
  2389 *-* x = f9970Card('                 Therefore, references to stem variables         ')
  2390 *-* x = f9970Card('              that are made INSIDE of quotes, say as             ')
  2391 *-* x = f9970Card('              part of an EXECIO command, will NOT show           ')
  2392 *-* x = f9970Card('              up in the XREF as they are part of a "string       ')
  2393 *-* x = f9970Card('              constant" and not used as a rexx variable or       ')
  2394 *-* x = f9970Card('              rexx stem directly.                                ')
  2395 *-* x = f9970Card('                                                                 ')
  2396 *-* x = f9970Card('                 This is because it often may not be obvious     ')
  2397 *-* x = f9970Card('              which address environment a command may (or may    ')
  2398 *-* x = f9970Card('              not) be valid in.  Or for us to know all the       ')
  2399 *-* x = f9970Card('              ways a rexx stem might be used.                    ')
  2400 *-* x = f9970Card('                                                                 ')
  2401 *-* x = f9970Card('    ----------------------------------------------------------   ')
  2402 *-* x = f9970Card('                                                                 ')
  2403 *-* x = f9970Card(' ')
  2404 *-* x = f9970Card(' ')
  2405 *-* x = f9970Card(' ')
  2406 *-* x = f9970Card(' ')
  2407 *-* x = f9970Card(' ')
  2408 *-* maxOutputVar = min(defaultMaxOutputVar,maxStemLength+5)
  2409 *-* do indx2 = 1 by 1 for stem
  2410 *-*  /* get next sorted stem variable, then report it's information */
  2411 *-*  sortedStemVariable =  SortedStemVariable.indx2
  2412 *-*  indx = stemIndx.sortedStemVariable /* use indx to info for this variable */
  2414 *-*  /* now report on it */
  2415 *-*  tempname = stemVariable.indx /* get name of stem variable w/all variables*/
  2416 *-*  parse var tempname buildname '.' rest
  2417 *-*  stemName = buildName
  2418 *-*  do while rest <> ''
  2419 *-*   parse var rest tempname '.' rest
  2420 *-*   x = variablesIndx.tempname
  2421 *-*   if variableSet.x <> '' | specialVar.tempname = 1 /* upper case to lower case */
  2422 *-*    then
       *-*    tempname = translate(tempname,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')
  2423 *-*   buildname = buildname'.'tempname
  2424 *-*  end
  2425 *-*  if substr(stemVariable.indx,length(stemVariable.indx),1) = '.'
  2426 *-*   then
       *-*   buildname = buildname'.'
  2428 *-*  if specialStem.stemName
  2429 *-*   then
       *-*   x = f9930OutputVarInfo('Stem-'stemPeriods.indx,buildname,' *Special:',' Assigned via an ADDR env cmd and/or REXX itsel
f')
  2431 *-*  if stemAsg.indx <> ' '
  2432 *-*   then
       *-*   x = f9930OutputVarInfo('Stem-'stemPeriods.indx,buildname,'Assigned :',stemAsg.indx)
  2434 *-*  if stemRef.indx <>  ' '
  2435 *-*   then
       *-*   x = f9930OutputVarInfo('Stem-'stemPeriods.indx,buildname,'Reference:',stemRef.indx)
  2437 *-*  if stemExposeRef.indx <>  ' '
  2438 *-*   then
       *-*   x = f9930OutputVarInfo('Stem-'stemPeriods.indx,buildname,'Expose Ref:',stemExposeRef.indx)
  2440 *-*  if out > 99
  2441 *-*   then
       *-*   do
  2442 *-*    'EXECIO' out 'DISKW RESULTS (STEM OUT.'
  2443 *-*    if rc <> 0
  2444 *-*     then
       *-*     do
  2445 *-*      say 'error writing to ddname= RESULTS; rc='rc
  2446 *-*      say 'exit 8'
  2447 *-*      'EXECIO 0 DISKW RESULTS (FINIS'
  2448 *-*      exit 8
  2449 *-*     end
  2450 *-*    out = 0
  2451 *-*   end
  2452 *-* end
  2453 *-* 'EXECIO' out 'DISKW RESULTS (STEM OUT.'
  2454 *-* out = 0
  2455 *-* x = f9970Card('    xref (2 of 2) ends here                                      ')
  2456 *-* x = f9970Card('    xref (2 of 2) ends here                                      ')
  2457 *-* x = f9970Card('    -----------------------                                      ')
  2458 *-* x = f9970Card(' ')
  2459 *-* x = f9970Card(' ')
  2460 *-* x = f9970Card(' ------------ tips for label references ----------------------------')
  2461 *-* x = f9970Card(' ------------ tips for label references ----------------------------')
  2462 *-* x = f9970Card('     tip:  c# is a ref to CALL stmt to this   internal/external name')
  2463 *-* x = f9970Card('     tip:  f# is a ref to FUNCTION call to    internal/external function')
  2464 *-* x = f9970Card('     tip:  s# is a ref to SIGNAL stmt to this internal label     ')
  2465 *-* x = f9970Card(' ')
  2466 *-* x = f9970Card(' ')
  2467 *-* x = f9970Card(' ------------ now xreference for stem variables (tips) -------------')
  2468 *-* x = f9970Card(' ------------ now xreference for stem variables (tips) -------------')
  2469 *-* x = f9970Card('     tip:     Note:- stem variables (after 1st period) are in lower case  ')
  2470 *-* x = f9970Card('     tip:          - stem "constants" (will be shown in UPPER case)       ')
  2471 *-* x = f9970Card('     tip:          - stem "constants" that are whole numbers (and not 0)  ')
  2472 *-* x = f9970Card('     tip:               will be summarized as a # sign (in place of       ')
  2473 *-* x = f9970Card('     tip:               individual digits/numbers) so it summarizes them. ')
  2474 *-* x = f9970Card('     tip:     What XREF for stems can help you fix:                       ')
  2475 *-* x = f9970Card('     tip:     -------------------------------------                       ')
  2476 *-* x = f9970Card('     tip:      - seeing a variable (lower case) used in a stem where you  ')
  2477 *-* x = f9970Card('     tip:       EXPECTED it to always be a constant.                      ')
  2478 *-* x = f9970Card('     tip:      - seeing a constant (upper case) used in a stem where you  ')
  2479 *-* x = f9970Card('     tip:       EXPECTED it to be a variable (maybe it was misspelled).   ')
  2480 *-* x = f9970Card('     tip:                                              )                  ')
  2481 *-* x = f9970Card('     tip:line sample rexx code (followed by sample xref)                  ')
  2482 *-* x = f9970Card('     tip:---- ------------                                                ')
  2483 *-* x = f9970Card('     tip:  1     x = "Richard"                                            ')
  2484 *-* x = f9970Card('     tip:  2     firstName.y.x.1 = "Hi"                                   ')
  2485 *-* x = f9970Card('     tip:  3     firstName.y.x.2 = "Buddy"                                ')
  2486 *-* x = f9970Card('     tip:  4     firstName.y.x.0 = 2                                      ')
  2487 *-* x = f9970Card('     tip:                                                                 ')
  2488 *-* x = f9970Card('     tip:sample xref listing                                              ')
  2489 *-* x = f9970Card('     tip:-----------                                                      ')
  2490 *-* x = f9970Card('     tip:  --xref section 1 (variables)                                   ')
  2491 *-* x = f9970Card('     tip:  --xref section 1 (variables)                                   ')
  2492 *-* x = f9970Card('     tip:                                                         ')
  2493 *-* x = f9970Card('     tip:Variable (set)         X               Assigned : 1      ')
  2494 *-* x = f9970Card('     tip:Variable(w/ stem use): X               Reference: 2 3 4  ')
  2495 *-* x = f9970Card('     tip:Constant(w/ stem use): Y               Reference: 2 3 4  ')
  2496 *-* x = f9970Card('     tip:                                                         ')
  2497 *-* x = f9970Card('     tip:  --xref section 2 (stem variables)                              ')
  2498 *-* x = f9970Card('     tip:  --xref section 2 (stem variables)                              ')
  2499 *-* x = f9970Card('     tip:                                                         ')
  2500 *-* x = f9970Card('     tip:Stem-3 FIRSTNAME.Y.x.#                 Assigned : 2 3    ')
  2501 *-* x = f9970Card('     tip:Stem-3 FIRSTNAME.Y.x.0                 Assigned : 4      ')
  2502 *-* x = f9970Card('     tip:                                       Reference: 2 3 4  ')
  2503 *-* x = f9970Card('     tip:     note:  Stem-3 refers to # of periods in the stem.           ')
  2504 *-* x = f9970Card('     tip:                                                                 ')
  2505 *-* x = f9970Card('     tip:  rexx tip: remember stem value on the right is "tricky":        ')
  2506 *-* x = f9970Card('     tip:        Given following rexx code:                               ')
  2507 *-* x = f9970Card('     tip:             x = "RICHARD.HUMPHRIS"                              ')
  2508 *-* x = f9970Card('     tip:             y = "RICHARD"                                       ')
  2509 *-* x = f9970Card('     tip:             z = "HUMPHRIS"                                      ')
  2510 *-* x = f9970Card('     tip:        References to a stem variable, as shown below, are       ')
  2511 *-* x = f9970Card('     tip:          referring to the SAME stem variable:                   ')
  2512 *-* x = f9970Card('     tip:             stem.x     refers to STEM.RICHARD.HUMPHRIS          ')
  2513 *-* x = f9970Card('     tip:             stem.y.z   refers to STEM.RICHARD.HUMPHRIS          ')
  2514 *-* x = f9970Card('     tip:        This is because x contains a period.  And because      ')
  2515 *-* x = f9970Card('     tip:          everything to the right of the first period is evaluated')
  2516 *-* x = f9970Card('     tip:          first.  Then the stem variable is "looked up".         ')
  2517 *-* x = f9970Card('     tip:                                                                 ')
  2518 *-* x = f9970Card('     tip:   rexx tip:  referencing pgm above, if you set variable "a"     ')
  2519 *-* x = f9970Card('     tip:         to a upper/lower case value.  The stem will NOT upper   ')
  2520 *-* x = f9970Card('     tip:         case it.                                                ')
  2521 *-* x = f9970Card('     tip:        So if assignment statement set "a" to "richard"          ')
  2522 *-* x = f9970Card('     tip:         then stem.y is NOT the same as stem.a                   ')
  2523 *-* x = f9970Card('     tip:        Because stem.y    refers to STEM.RICHARD                 ')
  2524 *-* x = f9970Card('     tip:        and     stem.a    refers to STEM.richard                 ')
  2525 *-* x = f9970Card('     tip:                                                                 ')
  2526 *-* 'EXECIO' out 'DISKW RESULTS (STEM OUT. FINIS'
  2527 *-* if rc <> 0
  2528 *-*  then
       *-*  do
  2529 *-*   say 'error writing/closing ddname= RESULTS; rc='rc
  2530 *-*   say 'exit 8'
  2531 *-*   'EXECIO 0 DISKW RESULTS (FINIS'
  2532 *-*   exit 8
  2533 *-*  end
  2534 *-* return
  2536 *-* f9910SlowSort:
  2537 *-* /* x = f9910SlowSort('sort','unsortedVariable.','sortedVariable.') */ /* slow rexx sort */
  2538 *-* /* ... */
  2539 *-* /* we don't have an omvs segment... so we have to do sort (slowly) using rexx code instead*/
  2540 *-* /* ---------------------------------------------------------------------------------------*/
  2542 *-* parse upper arg f9910_sort . , f9910_Stem1 . , f9910_Stem2 .
  2544 *-* /* need to verify 1st parm is "SORT" */
  2545 *-* /* --------------------------------- */
  2546 *-* if f9910_sort <> 'SORT'
  2547 *-*  then
       *-*  return 1  /* error, 1st parm must be "sort" */
  2549 *-*  /* need to verify f9910_stem1 is not null */
  2550 *-*  /* -------------------------------------- */
  2551 *-* if f9910_Stem1 = ''
  2552 *-*  then
       *-*  return 2  /* error, 2nd parm must be specified */
  2554 *-*  /* need to verify f9910_stem1 is a valid symbol */
  2555 *-*  /* -------------------------------------------- */
  2556 *-* if f9920VerifyRexxSymbol(f9910_Stem1,'S') <> 1
  2557 *-*  then
       *-*  return 3                    /* invalid symbol */
  2559 *-*  /* default stem2 and/or verify it's a symbol */
  2560 *-*  /* ----------------------------------------- */
  2561 *-* if f9910_stem2 = ''
  2562 *-*  then
       *-*  f9910_stem2 = f9910_stem1 /* default to stem1 */
  2563 *-* else
       *-*  do
  2564 *-*   /* need to verify f9910_stem2 is a valid symbol */
  2565 *-*   /* -------------------------------------------- */
  2566 *-*   if f9920VerifyRexxSymbol(f9910_Stem2,'S') <> 1
  2567 *-*    then
       *-*    return 3                    /* invalid symbol */
  2568 *-*  end
  2570 *-* /* verify stem1.0 coutains a valid whole number >= 0 */
  2571 *-* /* ------------------------------------------------- */
  2572 *-* if value(f9910_stem1||'0') = ''
  2573 *-*  then
       *-*  return 4
  2574 *-* if datatype(value(f9910_Stem1 || '0'),'W') = 0 | value(f9910_Stem1 || '0') < 0
  2575 *-*  then
       *-*  return 4  /* error, stem 0 must be numeric and a whole number*/
  2577 *-*  /* anything to sort? */
  2578 *-*  /* ----------------- */
  2579 *-* if value(f9910_Stem1 || '0') = 0
  2580 *-*  then
       *-*  do
  2581 *-*   /* nothing to sort, return 0 */
  2582 *-*   if f9910_Stem2 <> f9910_Stem1
  2583 *-*    then
       *-*    x = value(f9910_Stem2 || '0','0') /* set f9910_stem2.0 = 0 */
  2584 *-*   return 0
  2585 *-*  end
  2587 *-*  /* time to sort stems */
  2588 *-*  /* ------------------ */
  2589 *-* top = value(f9910_Stem1||'0')
  2590 *-* if f9910_Stem2 <> f9910_Stem1
  2591 *-*  then
       *-*  do
  2592 *-*   /* 1st copy stem1 into stem2; as stem2 should get sorted output */
  2593 *-*   do f9910_k = 0 by 1 while f9910_k <= top
  2594 *-*    x = value(f9910_stem2||f9910_k,value(f9910_stem1||f9910_k))
  2595 *-*   end
  2596 *-*  end
  2598 *-*  /* now sort stems in output stem f9910_stem2 */
  2599 *-*  /* ----------------------------------------- */
  2600 *-* f9910_varX = top /* all stem rows need to be checked */
  2601 *-* do until f9910_varX < 2
  2602 *-*  f9910_LastSwap = 1 /* set to 1, if never changed it's all sorted */
  2603 *-*  f9910_varX_minus1 = f9910_varX - 1
  2604 *-*  do f9910_VarY = 1 until f9910_VarY >= f9910_VarX_minus1
  2605 *-*   if value(f9910_Stem2||f9910_VarY) > value(f9910_Stem2||f9910_VarY+1)
  2606 *-*    then
       *-*    do
  2607 *-*     swap = value(f9910_Stem2||f9910_VarY+1,value(f9910_Stem2||f9910_VarY))
  2608 *-*     x    = value(f9910_Stem2||f9910_VarY,swap)
  2609 *-*     f9910_LastSwap = f9910_VarY /* last swap occured here */
  2610 *-*    end
  2611 *-*  end
  2612 *-*  f9910_VarX = f9910_LastSwap /* next loop, only have to check from 1 to here */
  2613 *-* end
  2614 *-* return 0
  2616 *-* f9920VerifyRexxSymbol:
  2617 *-* /* datatype(var,'s') returns a 1 even for numeric symbols starting with 0-9 or a period */
  2618 *-* /*            ... so we need to consistently check if numeric (and if truly a symbol).  */
  2620 *-* arg f9920_symbol . , f9920_option .
  2622 *-* if f9920_option <> 'S'
  2623 *-*  then
       *-*  do
  2624 *-*   say "someone called function f9920VerifyRexxSymbol without the 'S' option"
  2625 *-*   say 'function called from line' sigl
  2626 *-*   say 'f9920_option = "'f9920_option'" expected "S"'
  2627 *-*   say 'exiting w/rc=12'
  2628 *-*   exit 12
  2629 *-*  end
  2631 *-* if f9920_symbol = ''
  2632 *-*  then
       *-*  return 0 /* not a symbol, return 0 */
  2634 *-* if datatype(f9920_symbol,'S') = 0
  2635 *-*  then
       *-*  return 0 /* not a symbol, return 0 */
  2637 *-* if pos(left(f9920_symbol,1),'0123456789.') > 0
  2638 *-*  then
       *-*  return 0 /* not a symbol (looks numeric), return 0 */
  2639 *-* return 1      /* this is a real rexx symbol */
  2641 *-* f9930OutputVarInfo:
  2642 *-* parse arg f9930LHS, f9930Var, f9930RHS, f9930Ref
  2644 *-* if firstTime = 'FIRSTTIME'
  2645 *-*  then
       *-*  do
  2646 *-*   parse upper var f9930Var lastF9930Var '.' .
  2647 *-*   firstTime = ''
  2648 *-*  end
  2650 *-* if blankOption = 'BYVAR'
  2651 *-*  then
       *-*  do
  2652 *-*   parse upper var f9930Var leftSide '.' .
  2653 *-*   if leftSide <> lastF9930Var
  2654 *-*    then
       *-*    do /* add a blank line between variables */
  2655 *-*     out = out + 1.
  2656 *-*     out.out = ' '
  2657 *-*     lastF9930Var = leftSide
  2658 *-*    end
  2659 *-*  end
  2661 *-* if length(f9930Var) > maxOutputVar
  2662 *-*  then
       *-*  do  /* have var and contents on seperate lines */
  2663 *-*   out = out + 1 /* output variable, of any length */
  2664 *-*   out.out = f9930LHS f9930Var /* output long variable name */
  2665 *-*   f9930Lhs = left('',length(f9930LHS))
  2666 *-*   f9930Var = left('...',maxoutputvar)
  2667 *-*  end
  2668 *-* else
       *-*  f9930var = left(f9930Var,maxoutputvar)
  2670 *-* spaceremaining = width - length(f9930lhs f9930var f9930rhs) - 3
  2672 *-* if length(f9930ref) < spaceRemaining
  2673 *-*  then
       *-*  wordx = words(f9930ref)
  2674 *-* else
       *-*  wordx = words(left(f9930ref,spaceRemaining)) - 1
  2676 *-* if wordx < 1
  2677 *-*  then
       *-*  wordx = 1
  2679 *-* leftwords = subword(f9930ref,1,wordx)
  2680 *-* f9930ref  = subword(f9930ref,wordx+1)
  2682 *-* out = out+1 /* output 1st (or 2nd) line */
  2683 *-* out.out = f9930LHS f9930var f9930rhs leftwords
  2685 *-* f9930Lhs = left('',length(f9930LHS))
  2686 *-* f9930Var = left('...',maxoutputvar)
  2687 *-* f9930Rhs = left('',length(f9930RHS))
  2688 *-* spaceremaining = width - length(f9930lhs f9930var f9930rhs) - 3
  2690 *-* do while f9930ref <> ''
  2691 *-*  if length(f9930ref) < spaceRemaining
  2692 *-*   then
       *-*   wordx = words(f9930ref)
  2693 *-*  else
       *-*   wordx = words(left(f9930ref,spaceRemaining)) - 1
  2695 *-*  if wordx < 1
  2696 *-*   then
       *-*   wordx = 1
  2698 *-*  leftwords = subword(f9930ref,1,wordx)
  2699 *-*  f9930ref  = subword(f9930ref,wordx+1)
  2701 *-*  out = out+1 /* output continuation lines*/
  2702 *-*  out.out = f9930LHS f9930var f9930rhs leftwords
  2703 *-* end
  2705 *-* return 0
  2708 *-* f9970Card:
  2709 *-* /* just output info */
  2710 *-* parse arg cardx
  2711 *-* /* we only need one out.out stem created for this call */
  2712 *-* out = out + 1
  2713 *-* out.out = cardx
  2714 *-* return 0
  2716 *-* logicMsg:
  2717 *-* parse arg logicMsg1
  2718 *-* say 'LogicMsg001I line('sigl')' logicMsg1 /* give logic message w/line + msg */
  2719 *-* return
READY
END


 ------------ now xreference begins -----------------------
 ------------ now xreference begins -----------------------


    xref (1 of 2) section 1 is for variables (not stem.'s)
    xref (1 of 2) section 1 is for variables (not stem.'s)
    ----------------------------------------------------------

       variables/labels are in "upperCase" if variable was never
                       assigned a value.

                        they are in "lowercase", otherwise.

       variables/stems set via a command, like EXECIO for
                       example, where the stem is within quotes
                       will not be shown in the xref as either
                       an assignment or a reference.

       Note special variables like:  RC, SIGL, can be assigned
                       values explictly.  But rexx can set them
                       as well implicitly.  Implicit assignments
                       are not in the xref.
    ----------------------------------------------------------



Variable (set w/rexx)   addrenv                         Assigned : 1134 1136 1137 1138 1139
Variable (used in/rexx) addrenv                         Reference: 1138 1140 1152 1155 1156

Variable (set w/rexx)   addressspace                    Assigned : 150
Variable (used in/rexx) addressspace                    Reference: 151

Built-In+/External use  B2C                             Reference: F(1093)

Variable (set w/rexx)   blankoption                     Assigned : 253 258 262
Variable (used in/rexx) blankoption                     Reference: 2650

Built-In+/External use  BPXWUNIX                        Reference: F(2185) F(2214)

Variable (set w/rexx)   buildname                       Assigned : 2416 2423 2426
Variable (used in/rexx) buildname                       Reference: 2417 2423 2426 2429 2432 2435 2438

Label (internal label)  C0050PASS1                      Defined  : 355
Label (int. label ref)  C0050PASS1                      Reference: C(351)

Label (internal label)  C0070PARSELINEPASS1             Defined  : 500
Label (int. label ref)  C0070PARSELINEPASS1             Reference: C(459) C(468) C(495)

Label (internal label)  C0100PARSESTATEMENT             Defined  : 985
Label (int. label ref)  C0100PARSESTATEMENT             Reference: C(982) C(1499)

Label (internal label)  C0300PARSEREMAINING             Defined  : 1567
Label (int. label ref)  C0300PARSEREMAINING             Reference: C(1039) C(1054) C(1119) C(1129) C(1147) C(1159) C(1211) C(1228) C(1238) C(1279)
                        ...                                        C(1299) C(1319) C(1327) C(1335) C(1342) C(1348) C(1354) C(1364) C(1370) C(1376)
                        ...                                        C(1394) C(1417) C(1427) C(1464) C(1471) C(1478) C(1485) C(1494) C(1515) C(1527)
                        ...                                        C(1564)

Label (internal label)  C0325TEMPLATEASSIGNMENTS        Defined  : 1661
Label (int. label ref)  C0325TEMPLATEASSIGNMENTS        Reference: C(1166) C(1409) C(1419) C(1429) C(1457) C(1508)

Label (internal label)  C0326TEMPLATELIST               Defined  : 1703
Label (int. label ref)  C0326TEMPLATELIST               Reference: C(1446)

Label (internal label)  C0400CALLREFERENCE              Defined  : 1734
Label (int. label ref)  C0400CALLREFERENCE              Reference: C(1188) C(1193) C(1209)

Label (internal label)  C0415FUNCTIONREFERENCE          Defined  : 1740
Label (int. label ref)  C0415FUNCTIONREFERENCE          Reference: C(1595) C(1631)

Label (internal label)  C0430SIGNALREFERENCE            Defined  : 1746
Label (int. label ref)  C0430SIGNALREFERENCE            Reference: C(1534) C(1545) C(1549) C(1556)

Label (internal label)  C0450LABELREFERENCE             Defined  : 1752
Label (int. label ref)  C0450LABELREFERENCE             Reference: C(1737) C(1743) C(1749)

Label (internal label)  C0470LABELDEFINE                Defined  : 1788
Label (int. label ref)  C0470LABELDEFINE                Reference: C(963)

Label (internal label)  C0480ADDRDEFINE                 Defined  : 1833
Label (int. label ref)  C0480ADDRDEFINE                 Reference: C(1117) C(1157)

Label (internal label)  C0482ADDRDEFINEVALUE            Defined  : 1864
Label (int. label ref)  C0482ADDRDEFINEVALUE            Reference: C(1126) C(1144)

Label (internal label)  C0500ADDVARSTEMASSIGNMENT       Defined  : 1894
Label (int. label ref)  C0500ADDVARSTEMASSIGNMENT       Reference: C(1035) C(1050) C(1270) C(1698)

Label (internal label)  C0510ADDVARSTEMREFERENCE        Defined  : 2018
Label (int. label ref)  C0510ADDVARSTEMREFERENCE        Reference: C(1637) C(1651) C(1684) C(1722)

Label (internal label)  C9900OUTPUTRESULTS              Defined  : 2169
Label (int. label ref)  C9900OUTPUTRESULTS              Reference: C(352)

Variable (set w/rexx)   cardx                           Assigned : 2710
Variable (used in/rexx) cardx                           Reference: 2713

Variable (set w/rexx)   cmd                             Assigned : 456 480
Variable (used in/rexx) cmd                             Reference: 457 481

Variable (set w/rexx)   commentnested                   Assigned : 542 567 572 605 729 754 759 792
Variable (used in/rexx) commentnested                   Reference: 567 572 574 754 759 761

Variable (set w/rexx)   commentstart                    Assigned : 543 588 595 606 730 775 782 793
Variable (used in/rexx) commentstart                    Reference: 560 582 592 593 594 747 769 779 780 781

Built-In+/External use  DATATYPE                        Reference: F(220) F(232) F(457) F(481) F(663) F(672) F(707) F(851) F(877) F(961) F(1792)
                        ...                                        F(1944) F(2083) F(2574) F(2634)

Variable (set w/rexx)   debug                           Assigned : 203 215 216
Variable (used in/rexx) debug                           Reference: 217 529 716 1001 1767 1782 1805 1825 1849 1857 1880 1888 1912 1924 1965 1977
                        ...                                        1997 2009 2039 2053 2062 2105 2119 2128 2149 2161 2170 2177 2189 2199 2206 2218

Variable (set w/rexx)   defaultmaxoutputvar             Assigned : 236 242 247
Variable (used in/rexx) defaultmaxoutputvar             Reference: 2258 2408

Variable (set w/rexx)   dokeyword                       Assigned : 1283 1305
Variable (used in/rexx) dokeyword                       Reference: 1287 1289 1291 1305 1309 1310 1311

Variable (set w/rexx)   doline                          Assigned : 1217 1248 1250
Variable (used in/rexx) doline                          Reference: 1219 1222 1226 1232 1236 1244 1245 1248 1250 1255

Variable (set w/rexx)   dorest                          Assigned : 1259 1284 1306 1315
Variable (used in/rexx) dorest                          Reference: 1260 1273 1275 1277 1283 1284 1288 1290 1292 1293 1295 1297 1305 1306 1309
                        ...                                        1310 1311 1315 1317

Built-In+/External use  ERRORTEXT                       Reference: F(181)

Variable (set w/rexx)   execname                        Assigned : 180
Variable (used in/rexx) execname                        Reference: 181

Variable (set w/rexx)   exposeref                       Assigned : 406 1444 1447
Variable (used in/rexx) exposeref                       Reference: 2033 2047 2099 2113

Variable (set w/rexx)   expression                      Assigned : 1197 1415 1490 1673 1677
Variable (used in/rexx) expression                      Reference: 1202 1416 1491 1493 1676 1677

Label (internal label)  F9910SLOWSORT                   Defined  : 2536
Label (int. label ref)  F9910SLOWSORT                   Reference: F(2186) F(2215)

Variable (set w/rexx)   f9910_k                         Assigned : 2593
Variable (used in/rexx) f9910_k                         Reference: 2593 2594

Variable (set w/rexx)   f9910_lastswap                  Assigned : 2602 2609
Variable (used in/rexx) f9910_lastswap                  Reference: 2612

Variable (set w/rexx)   f9910_sort                      Assigned : 2542
Variable (used in/rexx) f9910_sort                      Reference: 2546

Variable (set w/rexx)   f9910_stem1                     Assigned : 2542
Variable (used in/rexx) f9910_stem1                     Reference: 2551 2556 2562 2572 2574 2579 2582 2589 2590 2594

Variable (set w/rexx)   f9910_stem2                     Assigned : 2542 2562
Variable (used in/rexx) f9910_stem2                     Reference: 2561 2566 2582 2583 2590 2594 2605 2607 2608

Variable (set w/rexx)   f9910_varx                      Assigned : 2600 2612
Variable (used in/rexx) f9910_varx                      Reference: 2601 2603

Variable (set w/rexx)   f9910_varx_minus1               Assigned : 2603
Variable (used in/rexx) f9910_varx_minus1               Reference: 2604

Variable (set w/rexx)   f9910_vary                      Assigned : 2604
Variable (used in/rexx) f9910_vary                      Reference: 2604 2605 2607 2608 2609

Label (internal label)  F9920VERIFYREXXSYMBOL           Defined  : 2616
Label (int. label ref)  F9920VERIFYREXXSYMBOL           Reference: F(1260) F(1624) F(1649) F(1681) F(1694) F(1718) F(1986) F(2138) F(2556) F(2566)

Variable (set w/rexx)   f9920_option                    Assigned : 2620
Variable (used in/rexx) f9920_option                    Reference: 2622 2626

Variable (set w/rexx)   f9920_symbol                    Assigned : 2620
Variable (used in/rexx) f9920_symbol                    Reference: 2631 2634 2637

Variable (set w/rexx)   f9930lhs                        Assigned : 2642 2665 2685
Variable (used in/rexx) f9930lhs                        Reference: 2664 2665 2670 2683 2685 2688 2702

Label (internal label)  F9930OUTPUTVARINFO              Defined  : 2641
Label (int. label ref)  F9930OUTPUTVARINFO              Reference: F(2278) F(2281) F(2284) F(2287) F(2290) F(2293) F(2296) F(2299) F(2302) F(2306)
                        ...                                        F(2308) F(2318) F(2322) F(2331) F(2335) F(2339) F(2343) F(2346) F(2350) F(2354)
                        ...                                        F(2356) F(2360) F(2362) F(2429) F(2432) F(2435) F(2438)

Variable (set w/rexx)   f9930ref                        Assigned : 2642 2680 2699
Variable (used in/rexx) f9930ref                        Reference: 2672 2673 2674 2679 2680 2690 2691 2692 2693 2698 2699

Variable (set w/rexx)   f9930rhs                        Assigned : 2642 2687
Variable (used in/rexx) f9930rhs                        Reference: 2670 2683 2687 2688 2702

Variable (set w/rexx)   f9930var                        Assigned : 2642 2666 2668 2686
Variable (used in/rexx) f9930var                        Reference: 2646 2652 2661 2664 2668 2670 2683 2688 2702

Label (internal label)  F9970CARD                       Defined  : 2708
Label (int. label ref)  F9970CARD                       Reference: F(2229) F(2230) F(2231) F(2232) F(2233) F(2234) F(2235) F(2236) F(2237) F(2238)
                        ...                                        F(2239) F(2240) F(2241) F(2242) F(2243) F(2244) F(2245) F(2246) F(2247) F(2248)
                        ...                                        F(2249) F(2250) F(2251) F(2252) F(2253) F(2254) F(2255) F(2256) F(2378) F(2379)
                        ...                                        F(2380) F(2381) F(2382) F(2383) F(2384) F(2385) F(2386) F(2387) F(2388) F(2389)
                        ...                                        F(2390) F(2391) F(2392) F(2393) F(2394) F(2395) F(2396) F(2397) F(2398) F(2399)
                        ...                                        F(2400) F(2401) F(2402) F(2403) F(2404) F(2405) F(2406) F(2407) F(2455) F(2456)
                        ...                                        F(2457) F(2458) F(2459) F(2460) F(2461) F(2462) F(2463) F(2464) F(2465) F(2466)
                        ...                                        F(2467) F(2468) F(2469) F(2470) F(2471) F(2472) F(2473) F(2474) F(2475) F(2476)
                        ...                                        F(2477) F(2478) F(2479) F(2480) F(2481) F(2482) F(2483) F(2484) F(2485) F(2486)
                        ...                                        F(2487) F(2488) F(2489) F(2490) F(2491) F(2492) F(2493) F(2494) F(2495) F(2496)
                        ...                                        F(2497) F(2498) F(2499) F(2500) F(2501) F(2502) F(2503) F(2504) F(2505) F(2506)
                        ...                                        F(2507) F(2508) F(2509) F(2510) F(2511) F(2512) F(2513) F(2514) F(2515) F(2516)
                        ...                                        F(2517) F(2518) F(2519) F(2520) F(2521) F(2522) F(2523) F(2524) F(2525)

Variable (set w/rexx)   firsttime                       Assigned : 2647
Variable (used in/rexx) firsttime                       Reference: 2644

Variable (set w/rexx)   functionnum                     Assigned : 1593
Variable (in Stem Ref)  functionnum                     Reference: 1594

Variable (set w/rexx)   in                              Assigned : 410 412 420
Variable (used in/rexx) in                              Reference: 412 413
Variable (in Stem Ref)  in                              Reference: 456 466 473 480

Variable (set w/rexx)   indx                            Assigned : 1775 1812 1854 1885 1917 1970 2002 2044 2110 2154 2262 2412
Variable (in Stem Set)  indx                            Assigned : 1780 1820 1823 1855 1886 1922 1975 2007 2051 2060 2117 2126 2159
Variable (in Stem Ref)  indx                            Reference: 1778 1780 1815 1817 1820 1823 1855 1886 1920 1922 1973 1975 2005 2007 2049
                        ...                                        2051 2058 2060 2115 2117 2124 2126 2157 2159 2264 2265 2268 2273 2280 2281 2283
                        ...                                        2284 2286 2287 2289 2290 2292 2293 2295 2296 2298 2299 2301 2302 2305 2306 2307
                        ...                                        2308 2315 2321 2322 2324 2330 2331 2334 2335 2338 2339 2342 2343 2345 2349 2350
                        ...                                        2353 2354 2355 2356 2359 2360 2361 2362 2415 2425 2429 2431 2432 2434 2435 2437
                        ...                                        2438

Variable (set w/rexx)   indx2                           Assigned : 2259 2409
Variable (in Stem Ref)  indx2                           Reference: 2261 2411

Variable (set w/rexx)   inrc                            Assigned : 357 422
Variable (used in/rexx) inrc                            Reference: 358 361 416 423

Variable (set w/rexx)   labelrefx                       Assigned : 1736 1742 1748
Variable (used in/rexx) labelrefx                       Reference: 1763 1768 1778 1780 1783

Variable (set w/rexx)   lastf9930var                    Assigned : 2646 2657
Variable (used in/rexx) lastf9930var                    Reference: 2653

Built-In+/External use  LEFT                            Reference: F(466) F(494) F(592) F(593) F(643) F(696) F(779) F(780) F(830) F(869) F(870)
                        ...                                        F(894) F(895) F(925) F(926) F(930) F(931) F(949) F(1010) F(1016) F(1020)
                        ...                                        F(1075) F(1122) F(1172) F(1174) F(1181) F(1198) F(1206) F(1260) F(1589) F(1606)
                        ...                                        F(1615) F(1678) F(1692) F(1716) F(2267) F(2637) F(2665) F(2666) F(2668) F(2674)
                        ...                                        F(2685) F(2686) F(2687) F(2693)

Variable (set w/rexx)   leftline                        Assigned : 1585
Variable (used in/rexx) leftline                        Reference: 1586

Variable (set w/rexx)   leftside                        Assigned : 2652
Variable (used in/rexx) leftside                        Reference: 2653 2657

Variable (set w/rexx)   lefttemplate                    Assigned : 1673
Variable (used in/rexx) lefttemplate                    Reference: 1674

Variable (set w/rexx)   leftwords                       Assigned : 2679 2698
Variable (used in/rexx) leftwords                       Reference: 2683 2702

Built-In+/External use  LENGTH                          Reference: F(187) F(189) F(493) F(494) F(645) F(832) F(864) F(871) F(890) F(896) F(911)
                        ...                                        F(916) F(927) F(932) F(1085) F(1087) F(1091) F(1093) F(1096) F(1098) F(1623)
                        ...                                        F(1630) F(2175) F(2176) F(2204) F(2205) F(2267) F(2425) F(2661) F(2665) F(2670)
                        ...                                        F(2672) F(2685) F(2687) F(2688) F(2691)

Variable (set w/rexx)   line                            Assigned : 407 461 470 473 484 494 540 585 592 643 727 772 779 830 862 869 888 894 909 914
                        ...                                        925 930 944 951 964 971 1008 1011 1037 1052 1081 1128 1146 1150 1171 1202 1207
                        ...                                        1226 1236 1277 1297 1317 1323 1333 1340 1341 1347 1353 1363 1369 1375 1388 1389
                        ...                                        1390 1391 1401 1404 1416 1426 1436 1440 1441 1462 1469 1476 1483 1493 1498 1513
                        ...                                        1522 1526 1575 1586 1600 1605 1608 1616 1618 1632 1638 1652
Variable (used in/rexx) line                            Reference: 473 493 494 528 539 547 552 553 554 555 585 592 602 628 630 643 645 648 663
                        ...                                        672 687 690 726 734 739 740 741 742 772 779 789 815 817 830 832 835 851 862 869
                        ...                                        870 877 888 894 895 907 909 914 923 925 930 940 944 946 949 951 956 959 971 973
                        ...                                        1004 1008 1010 1011 1016 1019 1020 1029 1030 1037 1038 1042 1044 1045 1052 1053
                        ...                                        1081 1102 1106 1110 1114 1128 1146 1150 1154 1165 1171 1172 1174 1176 1197 1205
                        ...                                        1206 1207 1217 1227 1237 1278 1298 1318 1324 1333 1334 1340 1341 1347 1353 1363
                        ...                                        1369 1375 1383 1388 1389 1390 1391 1401 1403 1404 1406 1408 1412 1415 1422 1425
                        ...                                        1436 1438 1440 1441 1442 1445 1455 1462 1463 1469 1470 1476 1477 1483 1484 1490
                        ...                                        1506 1513 1514 1522 1523 1526 1532 1541 1554 1575 1581 1585 1600 1602 1605 1606
                        ...                                        1608 1612 1613 1615 1616 1618 1632 1638 1652

Variable (set w/rexx)   linewithoutcommentsnlabels      Assigned : 690 692 698 709 715
Variable (used in/rexx) linewithoutcommentsnlabels      Reference: 692 693 696 698 702 705 715 717 1072

Variable (set w/rexx)   literalstart                    Assigned : 544 627 644 667 676 682 731 814 831 865 872 897 918 934
Variable (used in/rexx) literalstart                    Reference: 635 640 657 822 827 844 848 860 869 870 871 886 894 895 896 905 925 926 927
                        ...                                        930 931 932

Variable (set w/rexx)   litfun                          Assigned : 1585
Variable (used in/rexx) litfun                          Reference: 1589 1593

Variable (set w/rexx)   litnext                         Assigned : 546 636 733 823 856 882 902
Variable (used in/rexx) litnext                         Reference: 636 643 823 830 856 862 863 864 869 870 871 882 888 889 890 894 895 896 902
                        ...                                        909 910 911 914 915 916 925 926 927 930 931 932
Variable (in Stem Set)  litnext                         Assigned : 637 824 857 883 903

Variable (set w/rexx)   litnum                          Assigned : 1183 1200
Variable (in Stem Ref)  litnum                          Reference: 1184 1201

Variable (set w/rexx)   litquote                        Assigned : 628 815
Variable (used in/rexx) litquote                        Reference: 630 635 817 822

Variable (set w/rexx)   littype                         Assigned : 1081
Variable (NEVER USED)   littype                         No Ref.  : If actually referenced, it must be via a cmd.

Variable (set w/rexx)   litvalue                        Assigned : 635 822 848 855 881
Variable (used in/rexx) litvalue                        Reference: 637 824 855 857 881 883 903

Label (internal label)  LOGICMSG                        Defined  : 2716
Label (int. label ref)  LOGICMSG                        Reference: C(610) C(639) C(797) C(826)

Variable (set w/rexx)   logicmsg1                       Assigned : 2717
Variable (used in/rexx) logicmsg1                       Reference: 2718

Variable (set w/rexx)   lowerline                       Assigned : 539 586 593 726 773 780 863 870 889 895 910 915 926 931 945 952 965 972 1009
                        ...                                        1012
Variable (used in/rexx) lowerline                       Reference: 586 593 635 773 780 822 848 863 870 889 895 910 915 926 931 945 952 965 972
                        ...                                        1003 1009 1012

Built-In+/External use  MAX                             Reference: F(183)

Variable (set w/rexx)   maxoutputvar                    Assigned : 2258 2408
Variable (used in/rexx) maxoutputvar                    Reference: 2661 2666 2668 2686

Variable (set w/rexx)   maxstemlength                   Assigned : 2201 2205
Variable (used in/rexx) maxstemlength                   Reference: 2204 2408

Variable (set w/rexx)   maxvarlength                    Assigned : 2172 2176
Variable (used in/rexx) maxvarlength                    Reference: 2175 2258

Built-In+/External use  MIN                             Reference: F(184) F(557) F(558) F(744) F(745) F(1273) F(1288) F(1290) F(1292) F(1612)
                        ...                                        F(2258) F(2408)

Variable (set w/rexx)   name                            Assigned : 1425
Variable (used in/rexx) name                            Reference: 1426

Variable (set w/rexx)   namex                           Assigned : 1176 1197 1259 1541
Variable (used in/rexx) namex                           Reference: 1198 1200 1260 1269 1542

Variable (set w/rexx)   omvsseg                         Assigned : 153 159 162
Variable (used in/rexx) omvsseg                         Reference: 166 2184 2188 2213 2217

Variable (set w/rexx)   onx                             Assigned : 1176
Variable (NEVER USED)   onx                             No Ref.  : If actually referenced, it must be via a cmd.

Variable (set w/rexx)   originalline                    Assigned : 528
Variable (used in/rexx) originalline                    Reference: 533

Variable (set w/rexx)   out                             Assigned : 2228 2377 2450 2454 2655 2663 2682 2701 2712
Variable (used in/rexx) out                             Reference: 2367 2440 2442 2453 2526 2655 2663 2682 2701 2712
Variable (in Stem Set)  out                             Assigned : 2656 2664 2683 2702 2713

Variable (set w/rexx)   pendingcmd                      Assigned : 456
Variable (used in/rexx) pendingcmd                      Reference: 461 470

Variable (set w/rexx)   periods                         Assigned : 1932 1935 2071 2074
Variable (used in/rexx) periods                         Reference: 1935 1959 2074 2098

Built-In+/External use  POS                             Reference: F(547) F(552) F(553) F(554) F(555) F(630) F(702) F(734) F(739) F(740) F(741)
                        ...                                        F(742) F(817) F(956) F(1020) F(1133) F(1135) F(1581) F(1612) F(1627) F(1672)
                        ...                                        F(1901) F(1933) F(1936) F(2026) F(2072) F(2075) F(2637)

Variable (set w/rexx)   ppos                            Assigned : 1933 1936 2072 2075
Variable (used in/rexx) ppos                            Reference: 1934 1936 2073 2075

Variable (set w/rexx)   psuedovar                       Assigned : 1940 1942 1946 1947 1948 1951 2079 2081 2085 2086 2087 2090
Variable (used in/rexx) psuedovar                       Reference: 1942 1946 1947 1948 1951 1958 1966 1978 2081 2085 2086 2087 2090 2097 2106
                        ...                                        2120 2129
Variable (in Stem Set)  psuedovar                       Assigned : 1963 2103
Variable (in Stem Ref)  psuedovar                       Reference: 1954 1970 2093 2110

SpecialVar(set no-XREF) RC                               *Special: No xref; set w/ADDR env cmd and/or REXX itself
SpecialVar(used w/rexx) RC                              Reference: 181 343 345 357 370 372 422 429 431 446 2368 2370 2443 2445 2527 2529

Variable (set w/rexx)   repetitor                       Assigned : 1255
Variable (used in/rexx) repetitor                       Reference: 1256 1259 1323

Variable (set w/rexx)   rest                            Assigned : 480 705 959 1940 1943 2079 2082 2416 2419
Variable (used in/rexx) rest                            Reference: 484 709 964 1941 1943 2080 2082 2418 2419

Variable (set w/rexx)   rexxline                        Assigned : 460 480 485
Variable (used in/rexx) rexxline                        Reference: 481 485 515 519 522 532 1736 1742 1748 1801 1806 1815 1823 1826 1845 1850 1855
                        ...                                        1858 1876 1881 1886 1889 1908 1913 1920 1922 1925 1961 1966 1973 1975 1978 1993
                        ...                                        1998 2005 2007 2010 2034 2035 2040 2049 2051 2054 2058 2060 2063 2100 2101 2106
                        ...                                        2115 2117 2120 2124 2126 2129 2145 2150 2157 2159 2162

Variable (set w/rexx)   rexxline2                       Assigned : 456
Variable (used in/rexx) rexxline2                       Reference: 457 460

Variable (set w/rexx)   rexxstmt                        Assigned : 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326
                        ...                                        327 328 329 330 331 332 333 334 335 1015 1061
Variable (used in/rexx) rexxstmt                        Reference: 1065 1069 1163 1169 1214 1331 1338 1345 1351 1357 1359 1361 1367 1373 1379
                        ...                                        1381 1397 1399 1434 1453 1460 1467 1474 1481 1488 1504 1511 1518 1520 1559
Variable (in Stem Set)  rexxstmt                        Assigned : 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325
                        ...                                        326 327 328 329 330 331 332 333 334 335

Built-In+/External use  RIGHT                           Reference: F(181) F(187) F(189) F(493) F(1083) F(1089) F(1106) F(1108) F(1110) F(1112)
                        ...                                        F(1620) F(1950) F(2089) F(2266)

Variable (set w/rexx)   rightline                       Assigned : 1585
Variable (used in/rexx) rightline                       Reference: 1586

Variable (set w/rexx)   righttemplate                   Assigned : 1673
Variable (used in/rexx) righttemplate                   Reference: 1674

SpecialVar(set no-XREF) SIGL                             *Special: No xref; set w/ADDR env cmd and/or REXX itself
SpecialVar(used w/rexx) SIGL                            Reference: 181 183 184 186 2625 2718

Variable (set w/rexx)   simplevar                       Assigned : 1985 2137
Variable (used in/rexx) simplevar                       Reference: 1986 1992 1998 2010 2138 2144 2150 2162
Variable (in Stem Set)  simplevar                       Assigned : 1995 2147
Variable (in Stem Ref)  simplevar                       Reference: 1989 2002 2141 2154

Variable (set w/rexx)   sortedstemvariable              Assigned : 2202 2222 2411
Variable (used in/rexx) sortedstemvariable              Reference: 2207 2223
Variable (in Stem Set)  sortedstemvariable              Assigned : 2203
Variable (in Stem Ref)  sortedstemvariable              Reference: 2203 2204 2205 2207 2223 2412

Variable (set w/rexx)   sortedvariable                  Assigned : 2173 2193 2261
Variable (used in/rexx) sortedvariable                  Reference: 2178 2194 2266 2267
Variable (in Stem Set)  sortedvariable                  Assigned : 2174
Variable (in Stem Ref)  sortedvariable                  Reference: 2174 2175 2176 2178 2194 2262 2270

Built-In+/External use  SOURCELINE                      Reference: F(184) F(187) F(189)

Variable (set w/rexx)   spaceremaining                  Assigned : 2670 2688
Variable (used in/rexx) spaceremaining                  Reference: 2672 2674 2691 2693

Variable (set w/rexx)   special                         Assigned : 277 280 283 286 289 292 295
Variable (in Stem Set)  special                         Assigned : 278 281 284 287 290 293 296

Variable (NEVER SET)    SQLERRD                         Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  SQLERRD                         Assigned : 299

Variable (NEVER SET)    SQLWARN                         Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  SQLWARN                         Assigned : 300

Variable (set w/rexx)   startcmd                        Assigned : 408 483
Variable (used in/rexx) startcmd                        Reference: 454 491

Variable (set w/rexx)   startpos                        Assigned : 541 568 577 587 594 607 611 645 666 675 681 728 755 764 774 781 794 798 832 864
                        ...                                        871 890 896 911 916 927 932
Variable (used in/rexx) startpos                        Reference: 547 552 553 554 555 734 739 740 741 742

Label (internal label)  STARTUP                         Defined  : 195
Label (int. label ref)  STARTUP                         Reference: S(171)

Variable (set w/rexx)   statement                       Assigned : 1490
Variable (used in/rexx) statement                       Reference: 1496 1498

Variable (set w/rexx)   stem                            Assigned : 396 1957 2096
Variable (used in/rexx) stem                            Reference: 1957 1963 2096 2103 2202 2209 2222 2409
Variable (in Stem Set)  stem                            Assigned : 1958 1959 1960 1961 2097 2098 2100 2101

Variable (set w/rexx)   stemname                        Assigned : 2417
Variable (in Stem Ref)  stemname                        Reference: 2428

Variable (set w/rexx)   stemportion                     Assigned : 1943 2082
Variable (used in/rexx) stemportion                     Reference: 1944 1945 1948 2083 2084 2087

Built-In+/External use  STRIP                           Reference: F(457) F(460) F(481) F(485) F(585) F(586) F(692) F(698) F(715) F(772) F(773)
                        ...                                        F(862) F(863) F(888) F(889) F(909) F(910) F(914) F(915) F(944) F(945) F(951)
                        ...                                        F(952) F(971) F(972) F(1008) F(1009) F(1011) F(1012) F(1037) F(1052) F(1072)
                        ...                                        F(1074) F(1138) F(1186) F(1202) F(1207) F(1260) F(1277) F(1297) F(1317) F(1323)
                        ...                                        F(1600) F(1605) F(1608) F(1616) F(1632) F(1638) F(1652) F(1754) F(1790) F(1899)
                        ...                                        F(2023)

Variable (set w/rexx)   stype                           Assigned : 1532 1541
Variable (used in/rexx) stype                           Reference: 1533 1544 1548

Built-In+/External use  SUBSTR                          Reference: F(585) F(586) F(592) F(593) F(602) F(628) F(635) F(648) F(663) F(672) F(698)
                        ...                                        F(772) F(773) F(779) F(780) F(789) F(815) F(822) F(835) F(848) F(851) F(862)
                        ...                                        F(863) F(869) F(870) F(877) F(888) F(889) F(894) F(895) F(907) F(909) F(910)
                        ...                                        F(914) F(915) F(923) F(925) F(926) F(930) F(931) F(951) F(952) F(1011) F(1012)
                        ...                                        F(1029) F(1030) F(1037) F(1042) F(1045) F(1052) F(1087) F(1093) F(1098) F(1207)
                        ...                                        F(1608) F(1613) F(1616) F(1623) F(1630) F(2425)

Built-In+/External use  SUBWORD                         Reference: F(1217) F(1232) F(1248) F(1250) F(1284) F(1306) F(1315) F(2679) F(2680) F(2698)
                        ...                                        F(2699)

Variable (set w/rexx)   swap                            Assigned : 2607
Variable (used in/rexx) swap                            Reference: 2608

Label (internal label)  SYNTAX                          Defined  : 173
Label (int. label ref)  SYNTAX                          Reference:

Built-In+/External use  SYNTAX (SIGNAL ON SYNTAX)       Reference: S(149)

Variable (set w/rexx)   syntaxhigh                      Assigned : 184
Variable (used in/rexx) syntaxhigh                      Reference: 185 187 189

Variable (set w/rexx)   syntaxii                        Assigned : 185
Variable (used in/rexx) syntaxii                        Reference: 186 187 189

Variable (set w/rexx)   syntaxlow                       Assigned : 183
Variable (used in/rexx) syntaxlow                       Reference: 185

Built-In+/External use  SYSCALLS                        Reference: F(156) F(160)

Variable (set w/rexx)   tempenv                         Assigned : 1100
Variable (used in/rexx) tempenv                         Reference: 1102 1104 1115

Variable (set w/rexx)   template                        Assigned : 1165 1408 1415 1425 1445 1455 1506 1668 1674 1691 1710 1715
Variable (used in/rexx) template                        Reference: 1456 1507 1668 1672 1673 1690 1691 1710 1714 1715

Variable (set w/rexx)   tempname                        Assigned : 2265 2267 2268 2415 2419 2422
Variable (used in/rexx) tempname                        Reference: 2278 2281 2284 2287 2290 2293 2318 2322 2331 2335 2339 2343 2346 2416 2422 2423
Variable (in Stem Ref)  tempname                        Reference: 2420 2421

Variable (set w/rexx)   temprest                        Assigned : 1100
Variable (used in/rexx) temprest                        Reference: 1106 1110 1114

Variable (set w/rexx)   tempvalue                       Assigned : 1086 1087 1092 1093 1097 1098
Variable (used in/rexx) tempvalue                       Reference: 1100

Variable (set w/rexx)   testline                        Assigned : 1072 1073 1074 1134 1136 1137
Variable (used in/rexx) testline                        Reference: 1073 1074 1075 1122 1125 1133 1134 1135 1136 1137 1143

Variable (set w/rexx)   thesymbol                       Assigned : 1029
Variable (used in/rexx) thesymbol                       Reference: 1034 1049 1061
Variable (in Stem Ref)  thesymbol                       Reference: 1060

Variable (set w/rexx)   token                           Assigned : 1615 1618
Variable (used in/rexx) token                           Reference: 1620 1623 1630 1648

Variable (set w/rexx)   top                             Assigned : 2589
Variable (used in/rexx) top                             Reference: 2593 2600

Variable (set w/rexx)   totalline                       Assigned : 409 453
Variable (used in/rexx) totalline                       Reference: 453

Variable (set w/rexx)   tracerexxline                   Assigned : 221 222 524
Variable (used in/rexx) tracerexxline                   Reference: 224 227 514 515 522

Built-In+/External use  TRANSLATE                       Reference: F(1341) F(1441) F(1575) F(1668) F(1710) F(2265) F(2422)

Variable (set w/rexx)   trapname                        Assigned : 1176 1541
Variable (used in/rexx) trapname                        Reference: 1179 1181 1183 1186 1542 1544

Variable (set w/rexx)   validsymbolchars                Assigned : 339
Variable (used in/rexx) validsymbolchars                Reference: 1019 1205

Variable (set w/rexx)   validvariablestart              Assigned : 340
Variable (used in/rexx) validvariablestart              Reference: 1020

Built-In+/External use  VALUE                           Reference: F(2572) F(2574) F(2579) F(2583) F(2589) F(2594) F(2605) F(2607) F(2608)

Variable (set w/rexx)   valueb                          Assigned : 207
Variable (used in/rexx) valueb                          Reference: 251 253 256 258 263

Variable (set w/rexx)   valuex                          Assigned : 204
Variable (used in/rexx) valuex                          Reference: 214 215

Variable (set w/rexx)   valuey                          Assigned : 205
Variable (used in/rexx) valuey                          Reference: 220 222

Variable (set w/rexx)   valuez                          Assigned : 206
Variable (used in/rexx) valuez                          Reference: 232 238 240 245 246

Variable (set w/rexx)   variable                        Assigned : 380 1761 1799 1843 1874 1906 1991 2031 2143
Variable (used in/rexx) variable                        Reference: 1761 1765 1799 1803 1843 1847 1874 1878 1906 1910 1991 1995 2031 2037 2143
                        ...                                        2147 2173 2180 2193 2259
Variable (in Stem Set)  variable                        Assigned : 1762 1763 1800 1801 1844 1845 1875 1876 1907 1908 1992 1993 2032 2034 2035
                        ...                                        2144 2145

Variable (set w/rexx)   varx                            Assigned : 705 959 1034 1049 1103 1105 1107 1109 1111 1113 1115 1116 1125 1143 1153 1155
                        ...                                        1156 1184 1186 1187 1192 1201 1206 1269 1533 1544 1548 1554 1594 1623 1630 1648
                        ...                                        1683 1697 1721 1754 1755 1790 1791 1899 1900 1983 1985 2023 2024 2135 2137
Variable (used in/rexx) varx                            Reference: 706 707 960 961 1187 1555 1624 1627 1649 1754 1762 1768 1783 1790 1792 1800
                        ...                                        1806 1826 1844 1850 1858 1875 1881 1889 1899 1901 1907 1913 1925 1933 1936 1940
                        ...                                        1950 1983 1984 1985 2023 2026 2032 2040 2054 2063 2072 2075 2079 2089 2135 2136
                        ...                                        2137
Variable (in Stem Set)  varx                            Assigned : 1765 1803 1847 1878 1910 2037
Variable (in Stem Ref)  varx                            Reference: 1759 1775 1797 1812 1841 1854 1872 1885 1904 1917 2029 2044

Variable (set w/rexx)   verbx                           Assigned : 1176
Variable (used in/rexx) verbx                           Reference: 1187 1192

Built-In+/External use  VERIFY                          Reference: F(1019) F(1044) F(1205)

Variable (set w/rexx)   width                           Assigned : 235 241 246
Variable (used in/rexx) width                           Reference: 2670 2688

Built-In+/External use  WORD                            Reference: F(1133) F(1135) F(1222) F(1283) F(1305) F(1403) F(1406) F(1412) F(1422) F(1438)

Variable (set w/rexx)   word1                           Assigned : 1383 1523 1677 1691 1715
Variable (used in/rexx) word1                           Reference: 1524 1530 1537 1678 1681 1683 1692 1694 1697 1716 1718 1721

Variable (set w/rexx)   word2                           Assigned : 1383 1523
Variable (used in/rexx) word2                           Reference: 1385 1386 1388 1389 1390 1391

Variable (set w/rexx)   word3                           Assigned : 1383 1523
Variable (used in/rexx) word3                           Reference: 1385 1386 1388

Variable (set w/rexx)   word4                           Assigned : 1523
Variable (NEVER USED)   word4                           No Ref.  : If actually referenced, it must be via a cmd.

Variable (set w/rexx)   word5                           Assigned : 1523
Variable (NEVER USED)   word5                           No Ref.  : If actually referenced, it must be via a cmd.

Built-In+/External use  WORDPOS                         Reference: F(1244) F(1245) F(1273) F(1288) F(1290) F(1292) F(1309) F(1310) F(1311) F(1406)
                        ...                                        F(1778) F(1815) F(1920) F(1973) F(2005) F(2049) F(2058) F(2115) F(2124) F(2157)

Built-In+/External use  WORDS                           Reference: F(706) F(960) F(1275) F(1293) F(1295) F(1817) F(2673) F(2674) F(2692) F(2693)

Variable (set w/rexx)   wordx                           Assigned : 2673 2674 2677 2692 2693 2696
Variable (used in/rexx) wordx                           Reference: 2676 2679 2680 2695 2698 2699

Variable (set w/rexx)   x                               Assigned : 156 160 557 744 1019 1205 1273 1288 1290 1292 1293 1309 1310 1311 1312 1612
                        ...                                        2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244
                        ...                                        2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2278 2281 2284 2287
                        ...                                        2290 2293 2296 2299 2302 2306 2308 2318 2322 2331 2335 2339 2343 2346 2350 2354
                        ...                                        2356 2360 2362 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390
                        ...                                        2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406
                        ...                                        2407 2420 2429 2432 2435 2438 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464
                        ...                                        2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480
                        ...                                        2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496
                        ...                                        2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512
                        ...                                        2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2583 2594 2608
Variable (used in/rexx) x                               Reference: 157 565 568 577 585 586 592 593 599 602 606 607 611 752 755 764 772 773 779
                        ...                                        780 786 789 793 794 798 1020 1029 1030 1037 1042 1044 1206 1207 1275 1283 1284
                        ...                                        1295 1305 1306 1314 1315 1613 1615 1616
Variable (in Stem Ref)  x                               Reference: 2421

Variable (set w/rexx)   x1                              Assigned : 552 739 1244
Variable (used in/rexx) x1                              Reference: 557 563 565 744 750 752 1247 1248 1249

Variable (set w/rexx)   x2                              Assigned : 553 740 1245
Variable (used in/rexx) x2                              Reference: 557 563 744 750 1247 1249 1250

Built-In+/External use  X2C                             Reference: F(1098)

Variable (set w/rexx)   y                               Assigned : 558 651 745 838 1044
Variable (used in/rexx) y                               Reference: 599 627 628 630 643 786 814 815 817 830 1045 1052

Variable (set w/rexx)   y1                              Assigned : 554 741
Variable (used in/rexx) y1                              Reference: 558 745

Variable (set w/rexx)   y2                              Assigned : 555 742 2185 2186
Variable (used in/rexx) y2                              Reference: 558 745 2188

Variable (set w/rexx)   y3                              Assigned : 2214 2215
Variable (used in/rexx) y3                              Reference: 2217

Variable (set w/rexx)   yy                              Assigned : 630 817
Variable (used in/rexx) yy                              Reference: 631 648 651 663 666 672 675 681 818 835 838 848 851 862 863 869 870 877 888
                        ...                                        889 894 895 907 909 910 914 915 923 925 926 930 931
    xref (1 of 2) ends here
    xref (1 of 2) ends here
    -----------------------

    xref (2 of 2) section 2 is for stem variable xreference.
    xref (2 of 2) section 2 is for stem variable xreference.
    ----------------------------------------------------------
       note:     Assignments/references to rexx stems
              is only for stem references in rexx code
              itself.

                 Therefore, references to stem variables
              that are made INSIDE of quotes, say as
              part of an EXECIO command, will NOT show
              up in the XREF as they are part of a "string
              constant" and not used as a rexx variable or
              rexx stem directly.

                 This is because it often may not be obvious
              which address environment a command may (or may
              not) be valid in.  Or for us to know all the
              ways a rexx stem might be used.

    ----------------------------------------------------------







Stem-1 IN.0                                       Reference: 366 369 413 425 428
Stem-1 IN.in                                      Reference: 456 466 473 480

Stem-1 LITVALUE.                                  Assigned : 545 732
Stem-1 LITVALUE.#                                 Reference: 1082 1083 1085 1087 1089 1091 1093 1096 1098 1103 1105 1106 1107 1108 1109 1110 1111
       ...                                                   1112 1113 1116
Stem-1 LITVALUE.functionnum                       Reference: 1594
Stem-1 LITVALUE.litnext                           Assigned : 637 824 857 883 903
Stem-1 LITVALUE.litnum                            Reference: 1184 1201

Stem-1 OUT.out                                    Assigned : 2656 2664 2683 2702 2713

Stem-1 REXXSTMT.                                  Assigned : 306
Stem-1 REXXSTMT.rexxstmt                          Assigned : 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327
       ...                                                   328 329 330 331 332 333 334 335
Stem-1 REXXSTMT.thesymbol                         Reference: 1060

Stem-1 SORTEDSTEMVARIABLE.0                       Assigned : 2209
Stem-1 SORTEDSTEMVARIABLE.indx2                   Reference: 2411
Stem-1 SORTEDSTEMVARIABLE.sortedstemvariable      Assigned : 2203
Stem-1 SORTEDSTEMVARIABLE.sortedstemvariable      Reference: 2204 2205 2207 2223

Stem-1 SORTEDVARIABLE.0                           Assigned : 2180
Stem-1 SORTEDVARIABLE.indx2                       Reference: 2261
Stem-1 SORTEDVARIABLE.sortedvariable              Assigned : 2174
Stem-1 SORTEDVARIABLE.sortedvariable              Reference: 2175 2176 2178 2194

Stem-1 SPECIALSTEM.                               Assigned : 298
Stem-1 SPECIALSTEM.SQLERRD                        Assigned : 299
Stem-1 SPECIALSTEM.SQLWARN                        Assigned : 300
Stem-1 SPECIALSTEM.stemname                       Reference: 2428

Stem-1 SPECIALVAR.                                Assigned : 275
Stem-1 SPECIALVAR.sortedvariable                  Reference: 2270
Stem-1 SPECIALVAR.special                         Assigned : 278 281 284 287 290 293 296
Stem-1 SPECIALVAR.tempname                        Reference: 2421

Stem-1 STEMASG.                                   Assigned : 403
Stem-1 STEMASG.indx                               Assigned : 1975
Stem-1 STEMASG.indx                               Reference: 1973 1975 2431 2432
Stem-1 STEMASG.stem                               Assigned : 1961

Stem-1 STEMEXPOSEREF.                             Assigned : 402
Stem-1 STEMEXPOSEREF.indx                         Assigned : 2117
Stem-1 STEMEXPOSEREF.indx                         Reference: 2115 2117 2437 2438
Stem-1 STEMEXPOSEREF.stem                         Assigned : 2100

Stem-1 STEMINDX.                                  Assigned : 395
Stem-1 STEMINDX.psuedovar                         Assigned : 1963 2103
Stem-1 STEMINDX.psuedovar                         Reference: 1954 1970 2093 2110
Stem-1 STEMINDX.sortedstemvariable                Reference: 2412

Stem-1 STEMPERIODS.                               Assigned : 400
Stem-1 STEMPERIODS.indx                           Reference: 2429 2432 2435 2438
Stem-1 STEMPERIODS.stem                           Assigned : 1959 2098

Stem-1 STEMREF.                                   Assigned : 401
Stem-1 STEMREF.indx                               Assigned : 2126
Stem-1 STEMREF.indx                               Reference: 2124 2126 2434 2435
Stem-1 STEMREF.stem                               Assigned : 1960 2101

Stem-1 STEMVARIABLE.                              Assigned : 399
Stem-1 STEMVARIABLE.indx                          Reference: 2415 2425
Stem-1 STEMVARIABLE.sortedstemvariable            Reference: 2203
Stem-1 STEMVARIABLE.stem                          Assigned : 1958 2097

Stem-1 VARIABLE.                                  Assigned : 383
Stem-1 VARIABLE.indx                              Reference: 2265 2268 2296 2299 2302 2306 2308 2350 2354 2356 2360 2362
Stem-1 VARIABLE.sortedvariable                    Reference: 2174
Stem-1 VARIABLE.variable                          Assigned : 1762 1800 1844 1875 1907 1992 2032 2144

Stem-1 VARIABLEADDRDEF.                           Assigned : 391
Stem-1 VARIABLEADDRDEF.indx                       Assigned : 1855
Stem-1 VARIABLEADDRDEF.indx                       Reference: 1855 2305 2306 2359 2360
Stem-1 VARIABLEADDRDEF.variable                   Assigned : 1845

Stem-1 VARIABLEADDRDEFVALUE.                      Assigned : 392
Stem-1 VARIABLEADDRDEFVALUE.indx                  Assigned : 1886
Stem-1 VARIABLEADDRDEFVALUE.indx                  Reference: 1886 2307 2308 2361 2362
Stem-1 VARIABLEADDRDEFVALUE.variable              Assigned : 1876

Stem-1 VARIABLEEXPOSEREF.                         Assigned : 385
Stem-1 VARIABLEEXPOSEREF.indx                     Assigned : 2051
Stem-1 VARIABLEEXPOSEREF.indx                     Reference: 2049 2051 2273 2286 2287 2315 2324 2334 2335
Stem-1 VARIABLEEXPOSEREF.variable                 Assigned : 2034

Stem-1 VARIABLELABELDEF.                          Assigned : 389
Stem-1 VARIABLELABELDEF.indx                      Assigned : 1820 1823
Stem-1 VARIABLELABELDEF.indx                      Reference: 1815 1817 1820 1823 2295 2296 2298 2301 2349 2350 2353
Stem-1 VARIABLELABELDEF.variable                  Assigned : 1801

Stem-1 VARIABLELABELREF.                          Assigned : 390
Stem-1 VARIABLELABELREF.indx                      Assigned : 1780
Stem-1 VARIABLELABELREF.indx                      Reference: 1778 1780 2298 2299 2301 2302 2354 2355 2356
Stem-1 VARIABLELABELREF.variable                  Assigned : 1763

Stem-1 VARIABLEREF.                               Assigned : 384
Stem-1 VARIABLEREF.indx                           Assigned : 2060
Stem-1 VARIABLEREF.indx                           Reference: 2058 2060 2273 2283 2284 2315 2324 2330 2331
Stem-1 VARIABLEREF.variable                       Assigned : 2035

Stem-1 VARIABLESET.                               Assigned : 386
Stem-1 VARIABLESET.indx                           Assigned : 1922
Stem-1 VARIABLESET.indx                           Reference: 1920 1922 2264 2273 2280 2281 2315 2321 2322 2345
Stem-1 VARIABLESET.variable                       Assigned : 1908
Stem-1 VARIABLESET.x                              Reference: 2421

Stem-1 VARIABLESINDX.                             Assigned : 379
Stem-1 VARIABLESINDX.simplevar                    Assigned : 1995 2147
Stem-1 VARIABLESINDX.simplevar                    Reference: 1989 2002 2141 2154
Stem-1 VARIABLESINDX.sortedvariable               Reference: 2262
Stem-1 VARIABLESINDX.tempname                     Reference: 2420
Stem-1 VARIABLESINDX.varx                         Assigned : 1765 1803 1847 1878 1910 2037
Stem-1 VARIABLESINDX.varx                         Reference: 1759 1775 1797 1812 1841 1854 1872 1885 1904 1917 2029 2044

Stem-1 VARIABLESTEMREF.                           Assigned : 388
Stem-1 VARIABLESTEMREF.indx                       Assigned : 2159
Stem-1 VARIABLESTEMREF.indx                       Reference: 2005 2157 2159 2273 2292 2293 2315 2324 2342 2343
Stem-1 VARIABLESTEMREF.variable                   Assigned : 2145

Stem-1 VARIABLESTEMSET.                           Assigned : 387
Stem-1 VARIABLESTEMSET.indx                       Assigned : 2007
Stem-1 VARIABLESTEMSET.indx                       Reference: 2007 2273 2289 2290 2315 2324 2338 2339
Stem-1 VARIABLESTEMSET.variable                   Assigned : 1993
    xref (2 of 2) ends here
    xref (2 of 2) ends here
    -----------------------


 ------------ tips for label references ----------------------------
 ------------ tips for label references ----------------------------
     tip:  c# is a ref to CALL stmt to this   internal/external name
     tip:  f# is a ref to FUNCTION call to    internal/external function
     tip:  s# is a ref to SIGNAL stmt to this internal label


 ------------ now xreference for stem variables (tips) -------------
 ------------ now xreference for stem variables (tips) -------------
     tip:     Note:- stem variables (after 1st period) are in lower case
     tip:          - stem "constants" (will be shown in UPPER case)
     tip:          - stem "constants" that are whole numbers (and not 0)
     tip:               will be summarized as a # sign (in place of
     tip:               individual digits/numbers) so it summarizes them.
     tip:     What XREF for stems can help you fix:
     tip:     -------------------------------------
     tip:      - seeing a variable (lower case) used in a stem where you
     tip:       EXPECTED it to always be a constant.
     tip:      - seeing a constant (upper case) used in a stem where you
     tip:       EXPECTED it to be a variable (maybe it was misspelled).
     tip:                                              )
     tip:line sample rexx code (followed by sample xref)
     tip:---- ------------
     tip:  1     x = "Richard"
     tip:  2     firstName.y.x.1 = "Hi"
     tip:  3     firstName.y.x.2 = "Buddy"
     tip:  4     firstName.y.x.0 = 2
     tip:
     tip:sample xref listing
     tip:-----------
     tip:  --xref section 1 (variables)
     tip:  --xref section 1 (variables)
     tip:
     tip:Variable (set)         X               Assigned : 1
     tip:Variable(w/ stem use): X               Reference: 2 3 4
     tip:Constant(w/ stem use): Y               Reference: 2 3 4
     tip:
     tip:  --xref section 2 (stem variables)
     tip:  --xref section 2 (stem variables)
     tip:
     tip:Stem-3 FIRSTNAME.Y.x.#                 Assigned : 2 3
     tip:Stem-3 FIRSTNAME.Y.x.0                 Assigned : 4
     tip:                                       Reference: 2 3 4
     tip:     note:  Stem-3 refers to # of periods in the stem.
     tip:
     tip:  rexx tip: remember stem value on the right is "tricky":
     tip:        Given following rexx code:
     tip:             x = "RICHARD.HUMPHRIS"
     tip:             y = "RICHARD"
     tip:             z = "HUMPHRIS"
     tip:        References to a stem variable, as shown below, are
     tip:          referring to the SAME stem variable:
     tip:             stem.x     refers to STEM.RICHARD.HUMPHRIS
     tip:             stem.y.z   refers to STEM.RICHARD.HUMPHRIS
     tip:        This is because x contains a period.  And because
     tip:          everything to the right of the first period is evaluated
     tip:          first.  Then the stem variable is "looked up".
     tip:
     tip:   rexx tip:  referencing pgm above, if you set variable "a"
     tip:         to a upper/lower case value.  The stem will NOT upper
     tip:         case it.
     tip:        So if assignment statement set "a" to "richard"
     tip:         then stem.y is NOT the same as stem.a
     tip:        Because stem.y    refers to STEM.RICHARD
     tip:        and     stem.a    refers to STEM.richard
     tip:
