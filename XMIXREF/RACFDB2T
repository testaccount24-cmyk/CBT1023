   ==> Scan of exec succeeded (rc <= 4)
   -------------------------------------------------
    1) See trace 's' exec in:
          SFRH66.PUBLIC.REXXXREF.SAMPLE.SCAN(RACFDB2T)

    2) Trace listing + XREF listing in:
          SFRH66.PUBLIC.REXXXREF.SAMPLE.XREF(RACFDB2T)
   -----------------------------------------

READY
    RACFDB2T
    Generated scan code/comment:   trace 's'
    Generated scan code/comment:   /*  rexx member for scan/xref was: */
    Generated scan code/comment:   /*     "SFRH66.CNTL.RACFDB2.PDS(RACFDB2T)"      */
    Generated scan code/comment:   /*      ---------------------------------       */
    Generated scan code/comment:   /*  date/time of XREF was:                      */
    Generated scan code/comment:   /*     20231217 23:04:31                        */
    Generated scan code/comment:   /*      ---------------------------------       */
     1 *-* /*Rexx*/
     2 *-* /*                                                                 */
     3 *-* /*                               -----------                       */
     4 *-* /* ==> when edit'ing issue cmd:  hilite rexx                       */
     5 *-* /*                               -----------                       */
     6 *-* /*                                                                 */
     7 *-* /* written by:  - Peter Harroun   IBM Global Services-West (Boulder)*/
     8 *-* /*                                                                 */
     9 *-* /* modified by: - Richard Humphris  State of Indiana               */
    10 *-* /*                added db2 security support up to db2 v12.        */
    11 *-* /*                                                                 */
    12 *-* /*              - Christopher Tee, pointed out updateable views    */
    13 *-* /*                for insert/delete/update grants need an          */
    14 *-* /*                additional formatting for RACF.  This code has   */
    15 *-* /*                been added.                                      */
    16 *-* /*                - routine:  tab_priv for insert, delete and update*/
    17 *-* /*                     was modified to exclude grants on views.    */
    18 *-* /*                - routine:  tab_priv also called for:            */
    19 *-* /*                     'view_insert', 'view_delete' and            */
    20 *-* /*                     'view_update' to handle racf differences.   */
    21 *-* /*                                                                 */
    22 *-* /*    ***       - change-08/15/2023 added option RESET/NORESET     */
    23 *-* /* For:  RESET/NORESET option (default NORESET)  change-08/15/2023 */
    24 *-* /*              -  RESET (prior code, always generated a PERMIT    */
    25 *-* /*               with a RESET option (to throw away previous       */
    26 *-* /*               permits) followed by (new) permits.               */
    27 *-* /*                 RESET has become an option; and not the default.*/
    28 *-* /*              -  NORESET will not generate a PERMIT with a RESET.*/
    29 *-* /*               this will add new permits to any existing RDEF    */
    30 *-* /*               profile, but not delete any existing permits.     */
    31 *-* /*                 NORESET will be the default option.             */
    32 *-* /*                                                                 */
    33 *-* /*    ***       - change-07/25/2023 added more fixes to the code   */
    34 *-* /*                and more comments.                               */
    35 *-* /*                   - corrected code for package collid.*         */
    36 *-* /*                        where for grant to public used wrong     */
    37 *-* /*                        variable.                                */
    38 *-* /*                   - for package collid.specificName permits     */
    39 *-* /*                        simplified code to add generic permits   */
    40 *-* /*                        to the explicit package (this is so      */
    41 *-* /*                        racf works like db2).  Before code       */
    42 *-* /*                        could run for an excessive amt of time). */
    43 *-* /*                        This is a performance fix.               */
    44 *-* /*                   - for package collid.specificName permits     */
    45 *-* /*                        if permits in specific name were covered */
    46 *-* /*                        by the generic collid.* rdef, we will    */
    47 *-* /*                        no longer create the specific rdef and   */
    48 *-* /*                        let it default to the generic one.  Thus */
    49 *-* /*                        reducing racf maintenance in future.     */
    50 *-* /*                   - for package one of the rexx statements      */
    51 *-* /*                        generating permits was missing           */
    52 *-* /*                        "ACC(READ)".  This has been fixed.       */
    53 *-* /*                   - for more info, issue edit/browse cmd:       */
    54 *-* /*                        find 'change-07/25/2023'                 */
    55 *-* /*                                                                 */
    56 *-* /*    ***       - change-06/06/2023 added more fixes to the code   */
    57 *-* /*                and more comments.                               */
    58 *-* /*                   - for more info, issue edit/browse cmd:       */
    59 *-* /*                        find 'change-06/06/2023'                 */
    60 *-* /*                                                                 */
    61 *-* /* For:  PE/noPE option (default noPE)  change-06/06/2023          */
    62 *-* /*       PE seperates permits into the *$PE files.                 */
    63 *-* /*       noPE has RDEFs and PERMITS in the RDEF files.             */
    64 *-* /*                                                                 */
    65 *-* /*                                                                 */
    66 *-* /* For:  GENERIC/NoGENERIC option, add GenericNoAudit option       */
    67 *-* /*    GenericNoAudit ignores AUDITING column when generating       */
    68 *-* /*    table access rules.                                          */
    69 *-* /*       With Generic option, tables that are being audited are    */
    70 *-* /*    excluded from the generic table access.                      */
    71 *-* /*       With GenericNoAudit option, AUDITING column is ignored.   */
    72 *-* /*                                                                 */
    73 *-* /* For   GENERIC and GenericNoAudit processing:                    */
    74 *-* /*        if less than 100% of a schemas (for tables with schema)  */
    75 *-* /*    can be grouped into one default.  List the access for the    */
    76 *-* /*    top 4 contenders for the generic table access rules.         */
    77 *-* /*        And write the results to the OPTCLIST ddname.            */
    78 *-* /*                                                                 */
    79 *-* /* Now supports DB2 V12 and earlier.                               */
    80 *-* /*    = minus support for "ROLES".                                 */
    81 *-* /*                                                                 */
    82 *-* /* Generated rules are appropriate for zparm settings:             */
    83 *-* /*    AUTHEXIT_CACHEREFRESH=ALL,  (or =NONE)                       */
    84 *-* /*    AUTHEXIT_CHECK=DB2,                                          */
    85 *-* /*                                                                 */
    86 *-* /* Note:  either AUTHEXIT_CHECK=DB2 or AUTHEXIT_CHECK=PRIMARY      */
    87 *-* /*    (especially production db2's) you'd want plans/packages      */
    88 *-* /*    to be bound by a group-id (and not an individual userid).    */
    89 *-* /*    Otherwise, when the individual is "revoked" and/or "removed" */
    90 *-* /*    you may find plans to become unuseable (for example).        */
    91 *-* /*                                                                 */
    92 *-* /* Note: changing AUTHEXIT_CHECK= from DB2 to PRIMARY may result   */
    93 *-* /*    in additional racf work that this exec cannot provide.  See  */
    94 *-* /*    the DB2/RACF manual for more information.                    */
    95 *-* /*                                                                 */
    96 *-* /* --------------------------------------------------------------- */
    97 *-* /* For original code see:  RACFDB2                                 */
    98 *-* /* --------------------------------------------------------------- */
    99 *-* /*                                                                 */
   100 *-* /* %RACFDB2T owner ssid <classmnt> <model> <charopt> options       */
   101 *-* /*                      <  DSN   > <  2  >                         */
   102 *-* /*                      <  ---   > <  -  >                         */
   103 *-* /*                                                                 */
   104 *-* /*    example:                                                     */
   105 *-* /*         %RACFDB2T DB2ADM DB2X SQL NOWARN                        */
   106 *-* /*                                                                 */
   107 *-* /*         1)  SQL option selected (removed from arg line)         */
   108 *-* /*         2)  GENERIC/NOGENERIC not specified, default GENERIC    */
   109 *-* /*         2)  NOWARN option selected (removed from arg line)      */
   110 *-* /*                                                                 */
   111 *-* /*         resulting arg line:  %RACFDB2T DB2ADM DB2X              */
   112 *-* /*         3)  owner is DB2ADM                                     */
   113 *-* /*         4)  ssid  is DB2X                                       */
   114 *-* /*         5)  classmnt not specified, DSN is default              */
   115 *-* /*         6)  model    not specified, 2 is default                */
   116 *-* /*         7)  charopt  not specified, null is default.            */
   117 *-* /*                                                                 */
   118 *-* /*    Options you can specify:                                     */
   119 *-* /*    ----------------------------------------------------------   */
   120 *-* /*                       can appear anywhere; these options will   */
   121 *-* /*                       be "removed" from "arg line" so that      */
   122 *-* /*                       positional arguments (OWNER, SSID,        */
   123 *-* /*                       CLASSMNT, MODEL and CHAROPT) can be       */
   124 *-* /*                       specified (or not) without these options  */
   125 *-* /*                       effecting those positional args.          */
   126 *-* /*                                                                 */
   127 *-* /*       SQL/NOSQL  - SQL will add (comments) to output showing    */
   128 *-* /*               the sql this exec used to build the RDEF(s) and   */
   129 *-* /*               PERMITs we are creating.                          */
   130 *-* /*                  - default NOSQL                                */
   131 *-* /*                  - but SQL is nice too.                         */
   132 *-* /*                                                                 */
   133 *-* /*       GENERIC/NOGENERIC/GENERICNOAUDIT                          */
   134 *-* /*                  - GENERIC option will try and reduce the       */
   135 *-* /*               number of RDEF's needed for table access, etc.    */
   136 *-* /*               For example, if 90% of creator-x's tables give    */
   137 *-* /*               x,y and z DELETE access.  This it will create a   */
   138 *-* /*               generic RDEF for ssid.creator-x.*.DELETE for users*/
   139 *-* /*               x, y, z.  And create specific RDEF's for other    */
   140 *-* /*               tables created by sssid.creator-x.  Note:  for    */
   141 *-* /*               tables being audited, then specific RDEF's will   */
   142 *-* /*               always be created for those tables.               */
   143 *-* /*                                                                 */
   144 *-* /*                  - GenericNoAudit is like the generic option    */
   145 *-* /*               except GENERIC will exclude audit'ed tables from a*/
   146 *-* /*               generic RDEF (and always create a specific one for*/
   147 *-* /*               the audit'ed table.                               */
   148 *-* /*                                                                 */
   149 *-* /*               RDEFs can be reduced (eliminated) by a generic one*/
   150 *-* /*                  - Default:  GENERIC                            */
   151 *-* /*                                                                 */
   152 *-* /*        WARN/NOWARN                                              */
   153 *-* /*                  - WARN will generate RDEFs with the WARN       */
   154 *-* /*               option.  I don't think this is useful, really,    */
   155 *-* /*               but it is an option.  I recommend "NOWARN".       */
   156 *-* /*                  - WARN also allows access even when it shouldn't*/
   157 *-* /*               plus it does this before checking all the other   */
   158 *-* /*               'options' that might have provided access.  It    */
   159 *-* /*               just doesn't seem useful (to me) in the db2 world.*/
   160 *-* /*                  - Default:  NOWARN                             */
   161 *-* /*                                                                 */
   162 *-* /*        SlimAdm/NoSlimAdm                                        */
   163 *-* /*                  - SlimAdm will skip explicit permits on RDEFs  */
   164 *-* /*               if a userid is a SYSADM and already has the priv. */
   165 *-* /*               if a userid is a DBADM  and already has the priv. */
   166 *-* /*                                                                 */
   167 *-* /*                  - NoSlimAdm will create all permits even if id */
   168 *-* /*               is a SYSADM and already has the priv.             */
   169 *-* /*               is a DBADM  and already has the priv.             */
   170 *-* /*                                                                 */
   171 *-* /*                                                                 */
   172 *-* /*  "positional arguments"                                         */
   173 *-* /*  ----------------------                                         */
   174 *-* /*    owner (required)                                             */
   175 *-* /*        1-8 characters.  The userid and/or group id to be used   */
   176 *-* /*        when creating RDEF statements.  It will be the id used   */
   177 *-* /*        for the OWNER(id) in the RDEF.                           */
   178 *-* /*                                                                 */
   179 *-* /*    ssid  (required)                                             */
   180 *-* /*        1-4 character (db2) ssid to identify the db2 system to   */
   181 *-* /*        be converted to RACF.  This is used to connect to that   */
   182 *-* /*        db2 subsystem so that we can see the db2 security tables,*/
   183 *-* /*        etc..                                                    */
   184 *-* /*                                                                 */
   185 *-* /*    classmnt (optional)                                          */
   186 *-* /*        1-4 characters.  Default=DSN.  Unless modifying the      */
   187 *-* /*                         RACF security exit, you should specify  */
   188 *-* /*                         "DSN".                                  */
   189 *-* /*        Racf security exit is in hlq.SDSNSAMP(DSNXRXAC).         */
   190 *-* /*        Note:  at beginning of assembler code DSNXRXAC it        */
   191 *-* /*        sets &CLASSMNT to 'DSN'.  If you change the exit you     */
   192 *-* /*        will have to specify the same value you use in the RACF  */
   193 *-* /*        exit.                                                    */
   194 *-* /*                                                                 */
   195 *-* /*    model    (optional)                                          */
   196 *-* /*        1 character.  If specified, must be "1" or "2".          */
   197 *-* /*                      Defaults to '2'.  As does the RACF security*/
   198 *-* /*                      exit.                                      */
   199 *-* /*        Therefore, you should specify 2 unless you plan on       */
   200 *-* /*        modifying the RACF security exit to change it to '1'.    */
   201 *-* /*                                                                 */
   202 *-* /*        Source is in hlq.SDSNSAMP(DSNXRXAC) although if you      */
   203 *-* /*        modify it you should move source to a non-smp/e maintained*/
   204 *-* /*        library.                                                 */
   205 *-* /*                                                                 */
   206 *-* /*        setting to a 1 will generate model 1 rdefs/permits       */
   207 *-* /*        setting to a 2 will generate model 2 rdefs/permits       */
   208 *-* /*                                                                 */
   209 *-* /*                                                                 */
   210 *-* /*    Charopt  (optional)                                          */
   211 *-* /*        1 character.  If specified, must be 0-9, #, @ or $.      */
   212 *-* /*                      The RACF security exit defaults this to a  */
   213 *-* /*                      "1".                                       */
   214 *-* /*                      However, this exit accepts a null if       */
   215 *-* /*                         1) classmnt = 'DSN' (exit default)      */
   216 *-* /*                         2) model    = 2     (exit default)      */
   217 *-* /*                         3) charopt  = '' or 1 (1=exit default)  */
   218 *-* /*                      because the charopt is ignored when        */
   219 *-* /*                      classmnt = DSN and model = 2.              */
   220 *-* /*                                                                 */
   221 *-* /*                      In fact, if you specify a 1 (where         */
   222 *-* /*                      classmnt=DSN and model=2, we will change   */
   223 *-* /*                      charopt to a null (as expected by exit).   */
   224 *-* /*                                                                 */
   225 *-* /*                      IF classmnt set to other than DSN or       */
   226 *-* /*                      using model 1, then you will have to       */
   227 *-* /*                      modify the racf exit and then a non-null   */
   228 *-* /*                      charopt must be set in the exit and spec-  */
   229 *-* /*                      ified for this exec run.                   */
   230 *-* /*                                                                 */
   231 *-* /*        Source is in hlq.SDSNSAMP(DSNXRXAC) although if you      */
   232 *-* /*        modify it you should move source to a non-smp/e maintained*/
   233 *-* /*        library.                                                 */
   234 *-* /*                                                                 */
   235 *-* /*                                                                 */
   236 *-* /* --------------------------------------------------------------- */
   237 *-* /*                                                                 */
   238 *-* /* Error recovery improvements:                                    */
   239 *-* /* Error recovery improvements:                                    */
   240 *-* /*    1.  Default command enviornment changed to TSO               */
   241 *-* /*                                                                 */
   242 *-* /*        a.  This improves error recovery as "unknown" commands   */
   243 *-* /*           are reported under TSO.  Which were "ignored" under   */
   244 *-* /*           address 'dsnrexx'.                                    */
   245 *-* /*        b.  Actual db2 commands are executed explicity as:       */
   246 *-* /*                address 'dsnrexx' ...db2 command ...             */
   247 *-* /*                                                                 */
   248 *-* /*    2.  rexx syntax error recovery provided.  Instead of one     */
   249 *-* /*        line of code, it provides a glimpse into the rexx program*/
   250 *-* /*        around the line that got the syntax error.               */
   251 *-* /*                                                                 */
   252 *-* /*    3.  improvement when sql fails, as we can display sql in     */
   253 *-* /*        a nicer format.  (see "building SQL has changed).        */
   254 *-* /*                                                                 */
   255 *-* /* --------------------------------------------------------------- */
   256 *-* /*                                                                 */
   257 *-* /* Building sql has changed:                                       */
   258 *-* /* Building sql has changed:                                       */
   259 *-* /*                                                                 */
   260 *-* /*   BEFORE:                                                       */
   261 *-* /*   BEFORE:                                                       */
   262 *-* /*    Before we simply set a variable "SQL" to a sql statement.    */
   263 *-* /*    And the assignment statement typically was composed of       */
   264 *-* /*    multiple lines of sql code (ending with rexx commas to       */
   265 *-* /*    continue the rexx assignment statement.                      */
   266 *-* /*                                                                 */
   267 *-* /*    Then we called zsql to prepare and open the cursor, like     */
   268 *-* /*    this:                                                        */
   269 *-* /*                                                                 */
   270 *-* /*        sql = 'line of sql code'  ,                              */
   271 *-* /*              'line of sql code'  ,                              */
   272 *-* /*              '...             '  ,                              */
   273 *-* /*              'line of sql code'                                 */
   274 *-* /*        call zsql                                                */
   275 *-* /*                                                                 */
   276 *-* /*    But this had two problems:                                   */
   277 *-* /*                                                                 */
   278 *-* /*        a.  confusing, because sometimes commas were embedded    */
   279 *-* /*          and meant for SQL code.  And sometimes commas were     */
   280 *-* /*          "rexx commas" to continue the rexx assignement stmt.   */
   281 *-* /*                                                                 */
   282 *-* /*        b.  and if an error occured in zsql, the sql statement   */
   283 *-* /*          was hard to read as all the "line" formatting          */
   284 *-* /*          disappeared when rexx created the SQL variable.        */
   285 *-* /*                                                                 */
   286 *-* /*   NOW:                                                          */
   287 *-* /*   NOW:                                                          */
   288 *-* /*    This was solved by having seperate function calls to "sql"   */
   289 *-* /*    for each line of sql code.                                   */
   290 *-* /*                                                                 */
   291 *-* /*       aa. problem (a) is solved.  No confusing rexx commas to   */
   292 *-* /*          continue SQL statement.                                */
   293 *-* /*                                                                 */
   294 *-* /*       bb. no problems with an extra "ending" rexx comma or      */
   295 *-* /*          forgetting to add a rexx comma.                        */
   296 *-* /*                                                                 */
   297 *-* /*       cc. problem (b) is solved.  The sql function addes code   */
   298 *-* /*          to automatically allow error recovery to be able to    */
   299 *-* /*          produce more readable (formatted) sql code that was    */
   300 *-* /*          executed.  And it also provides all the rexx code      */
   301 *-* /*          involved with creating the sql statement ... including */
   302 *-* /*          condional rexx code which may have (or may not have)   */
   303 *-* /*          contributed to creating the entire sql statement.      */
   304 *-* /*                                                                 */
   305 *-* /*       dd.  The SQL option allows you to see the sql as comments */
   306 *-* /*          in the generated racf rules.  It allows you to see the */
   307 *-* /*          rexx code (with variables) and the final generated SQL>*/
   308 *-* /*          This is "especially" nice in that the rexx code may be */
   309 *-* /*          conditional code (with some optional clauses) that you */
   310 *-* /*          may (or may not) find in the generated sql code.  In   */
   311 *-* /*          addition, it is fairly easy to extract the generated   */
   312 *-* /*          code to run in SPUFI or QMF (etc) if you want to see   */
   313 *-* /*          what was actually returned to this rexx exec.          */
   314 *-* /*            In addition, the rexx code/sql code has line numbers */
   315 *-* /*          so you can easily find which statement in this rexx    */
   316 *-* /*          exec was executed.  Note:  as a lot of the code is     */
   317 *-* /*          written as a subroutine, the same sql may be executed  */
   318 *-* /*          more than once but checking a different authority; for */
   319 *-* /*          example:  routine sys_attr checks many different       */
   320 *-* /*          authorities like SYSADMAUTH, SYSOPRAUTH, SYSCTRLAUTH   */
   321 *-* /*          etc..                                                  */
   322 *-* /*                                                                 */
   323 *-* /*    So now the way or preparing a sql statement and opening a    */
   324 *-* /*    cursor looks like this:                                      */
   325 *-* /*        x=sql('New statement')      /* required for new stmt*/   */
   326 *-* /*        x=sql('line of sql code')                                */
   327 *-* /*        x=sql('line of sql code')                                */
   328 *-* /*        if something then x=sql('line of sql code')              */
   329 *-* /*        x=sql('line of sql code')                                */
   330 *-* /*        x=sql('line of sql code')                                */
   331 *-* /*        call zsql                                                */
   332 *-* /*                                                                 */
   333 *-* /*                                                                 */
   334 *-* /*    In addition.                                                 */
   335 *-* /*    ------------ before we only allowed one cursor to be open    */
   336 *-* /*    at a time.  Now, there is an option on the "New Statement"   */
   337 *-* /*    that allows you to specify a different cursor.               */
   338 *-* /*                                                                 */
   339 *-* /*    The default for x=sql("New Statement") is for cursor 1       */
   340 *-* /*                                                                 */
   341 *-* /*    BUT NOW you can explicitly specify cursor 1 like:            */
   342 *-* /*                    x=sql("New Statement; Stmt/Cursor=1')        */
   343 *-* /*                                                                 */
   344 *-* /*    OR you can specify a different cursor like:                  */
   345 *-* /*                    x=xql("New Statement; Stmt/Cursor=2')        */
   346 *-* /*                                                                 */
   347 *-* /*    The only restrictions are:                                   */
   348 *-* /*           1) Stmt/cursor=#:  the number must be between 1 to 100*/
   349 *-* /*           2) after the x=('New statement<; Stmt/cursor=#>')     */
   350 *-* /*          that you must add all sql statements for this cursor   */
   351 *-* /*          before "call zsql" which will create/open cursor for   */
   352 *-* /*          this statement.                                        */
   353 *-* /*           3) when calling prtsqlca it should specify which      */
   354 *-* /*          cursor the failing sqlerror is for.                    */
   355 *-* /*                                                                 */
   356 *-* /*        x=sql('New statement')      /* required for new stmt*/   */
   357 *-* /*    OR  x=sql('New statement; stmt/cursor=#')                    */
   358 *-* /*                                                                 */
   359 *-* /*    then...                                                      */
   360 *-* /*        x=sql('line of sql code')                                */
   361 *-* /*        x=sql('line of sql code')                                */
   362 *-* /*        if something then x=sql('line of sql code')              */
   363 *-* /*        x=sql('line of sql code')                                */
   364 *-* /*        x=sql('line of sql code')                                */
   365 *-* /*        call zsql                                                */
   366 *-* /*                                                                 */
   367 *-* /*                                                                 */
   368 *-* /* --------------------------------------------------------------- */
   369 *-* /*                                                                 */
   370 *-* /*  additional db2 priviledges added for conversion                */
   371 *-* /*  -----------------------------------------------                */
   372 *-* /*                                                                 */
   373 *-* /*    call sys_attr "SYSDBADM","SDBADMAUTH"                        */
   374 *-* /*    call sys_attr "DATAACCESS","DATAACCESSAUTH"                  */
   375 *-* /*    call sys_attr "ACCESSCTRL","ACCESSCTRLAUTH"                  */
   376 *-* /*                                                                 */
   377 *-* /*    (call db_option removed; no longer needed).                  */
   378 *-* /*                                                                 */
   379 *-* /*          Schema   privileges;  rh:  add schema privs class "SC" */
   380 *-* /*          ------------------------------------------------------ */
   381 *-* /*    call schema_attr "ALTERIN","ALTERINAUTH"                     */
   382 *-* /*    call schema_attr "CREATEIN","CREATEINAUTH"                   */
   383 *-* /*    call schema_attr "DROPIN","DROPINAUTH"                       */
   384 *-* /*                                                                 */
   385 *-* /*          resources                                              */
   386 *-* /*          ---------                                              */
   387 *-* /*    call sys_attr "SQLADM","SQLADMAUTH"                          */
   388 *-* /*    call sys_attr "CREATESECUREOBJECT","CREATESECUREAUTH"        */
   389 *-* /*    call sys_attr "DEBUGSESSION","DEBUGSESSIONAUTH"              */
   390 *-* /*    call sys_attr "EXPLAIN","EXPLAINAUTH"                        */
   391 *-* /*    call sys_attr "BSDS","BSDSAUTH"                              */
   392 *-* /*                                                                 */
   393 *-* /*          table privs                                            */
   394 *-* /*          -----------                                            */
   395 *-* /*    call tab_priv "TRIGGER","TRIGGERAUTH"                        */
   396 *-* /*    call tab_priv "UNLOAD","UNLOADAUTH"                          */
   397 *-* /*    call tab_priv "VIEW_INSERT","INSERTAUTH"                     */
   398 *-* /*    call tab_priv "VIEW_UPDATE","UPDATEAUTH"                     */
   399 *-* /*    call tab_priv "VIEW_DELETE","DELETEAUTH"                     */
   400 *-* /*                                                                 */
   401 *-* /*          add usage privs                                        */
   402 *-* /*          ---------------                                        */
   403 *-* /*    call use_priv "USAGE","J","JR" /* jar */                     */
   404 *-* /*    call use_priv "USAGE","D","UT" /* distinct type */           */
   405 *-* /*                                                                 */
   406 *-* /*          add global variable support                            */
   407 *-* /*          ---------------------------                            */
   408 *-* /*    call gv_attr "READ","READAUTH"                               */
   409 *-* /*    call gv_attr "WRITE","WRITEAUTH"                             */
   410 *-* /*                                                                 */
   411 *-* /*          add sequence support                                   */
   412 *-* /*          ---------------------------                            */
   413 *-* /*    call seq_attr "ALTER","ALTERAUTH"                            */
   414 *-* /*    call seq_attr "USAGE","USEAUTH"                              */
   415 *-* /*                                                                 */
   416 *-* /*          add stored procedure support                           */
   417 *-* /*          ----------------------------                           */
   418 *-* /*    call routine_attr "EXECUTE","EXECUTEAUTH","P"                */
   419 *-* /*                                                                 */
   420 *-* /*          add User defined function                              */
   421 *-* /*          ----------------------------                           */
   422 *-* /*    call routine_attr "EXECUTE","EXECUTEAUTH","F"                */
   423 *-* /*                                                                 */
   424 *-* /* --------------------------------------------------------------- */
   425 *-* /*                                                                 */
   426 *-* /* Additional RACF intelligence.                                   */
   427 *-* /* -----------------------------                                   */
   428 *-* /*                                                                 */
   429 *-* /*    Benefit 1:                                                   */
   430 *-* /*    ==========                                                   */
   431 *-* /*                                                                 */
   432 *-* /*    This can help you identify all the privs held by a userid    */
   433 *-* /* and/or a group, IF you run the exec with option "NoSlimAdm".    */
   434 *-* /*                                                                 */
   435 *-* /* As output in the ddname=OPT will contain a summary of userid's  */
   436 *-* /* and where they are used in permits (in the variety of output    */
   437 *-* /* files).  With option "SlimAdm" you won't see all the explicit   */
   438 *-* /* permits for a userid with SYSADM, but it will still have a      */
   439 *-* /* line in the DSNADM ddname to give it the SYSADM priv.           */
   440 *-* /*                                                                 */
   441 *-* /*                                                                 */
   442 *-* /*    Benefit 2:                                                   */
   443 *-* /*    ==========                                                   */
   444 *-* /*    If you supply the job with a unload of the RACF database     */
   445 *-* /* (where we collected userid/group information) and use that      */
   446 *-* /* dataset for (input) ddname=RACFSMRY ... then this exec will help*/
   447 *-* /* identify missing (obsolete) userids and/or groups that we would */
   448 *-* /* be generating permits for.                                      */
   449 *-* /*    If you wish to ignore any grants for these userids and/or    */
   450 *-* /* groups, you can then add them as "delete userid" entries in the */
   451 *-* /* input ddname=EXCLUDE                                            */
   452 *-* /*                                                                 */
   453 *-* /*    Benefit 3:                                                   */
   454 *-* /*    ==========                                                   */
   455 *-* /*    If you have a revoked RACF userid we will report that too.   */
   456 *-* /* Note:  if a plan is using the authority of a revoked userid then*/
   457 *-* /* that plan will be unuseable.  It's really better to bind plans  */
   458 *-* /* under a group userid, so the plan won't become unuseable if a   */
   459 *-* /* userid is revoked for any reason.                               */
   460 *-* /*                                                                 */
   461 *-* /*    Benefit 4:                                                   */
   462 *-* /*    ==========                                                   */
   463 *-* /*     1. we add comments under a permit to give you information   */
   464 *-* /* about a racf userid and/or group.                               */
   465 *-* /*                                                                 */
   466 *-* /*  Add code at beginning to read in ddname=RACFSMRY            */
   467 *-* /*  ... and create variables so that we know info about real    */
   468 *-* /*  ... racf userid's and groups ... so we know how valid or not*/
   469 *-* /*  ... commands would be (and add comments to racf commands OR */
   470 *-* /*  ... make racf "commands" into comments if they are not valid*/
   471 *-* /* --------------------------------------------------------------- */
   472 *-* /*                                                                 */
   473 *-* /* additional notes:                                               */
   474 *-* /*  - add comments to most RDEF's which go into RACF database      */
   475 *-* /*                                                                 */
   476 *-* /*  - (comments only) for PERMIT's with RACF userid/group info     */
   477 *-* /*                                                                 */
   478 *-* /*  - Treats most grants as READ (and virtually never uses ALTER)  */
   479 *-* /*    except for sysadm's.                                         */
   480 *-* /*                                                                 */
   481 *-* /*  - For implicit databases, only do grants for DSNDB04 as racf   */
   482 *-* /*    does all implicit database checking off of database DSNDB04  */
   483 *-* /*    (no matter what generated implicit database name db2 uses).  */
   484 *-* /*                                                                 */
   485 *-* /*  - add backstop (catch all) RDEF's so access attempts for       */
   486 *-* /*    non-specific access are rejected.  For example:              */
   487 *-* /*                                                                 */
   488 *-* /*       RDEF MDSNTB DSN2.*.*.ALTER UACC(NONE) AUDIT(ALL(READ)) -  */
   489 *-* /*          OWNER(xxx) -                                           */
   490 *-* /*          DATA('Backstop for ALTER on table(s) *.*')             */
   491 *-* /*       (and of course, we have no permits for this)              */
   492 *-* /*                                                                 */
   493 *-* /*                                                                 */
   494 *-* /*-------------------------                                    */
   495 *-* /*  a.  Try to eliminate creating RACF permits                 */
   496 *-* /*    1. for example, a user with SYSADM doesn't need (almost) */
   497 *-* /*      and other authorities.  (with option SlimAdm)          */
   498 *-* /*    2. for example, a user with dbadm doesn't need other db  */
   499 *-* /*      authorities.            (with option SlimAdm)          */
   500 *-* /*  b.  For Packadm, ignore collection id's that don't exist   */
   501 *-* /*    unless *SETS* or IVR*.                                   */
   502 *-* /*  c.  For tables.                                            */
   503 *-* /*         select distinct owner                               */
   504 *-* /*            from sysibm.syspackage                           */
   505 *-* /*            order by owner                                   */
   506 *-* /*      Then only generate table rules for owner's of packages */
   507 *-* /*      and/or valid racf userid's and/or groups; when specified*/
   508 *-* /*      in systabauth.                                         */
   509 *-* /*  c.  Add Java archive file support (OBTYPE='J') in          */
   510 *-* /*      SYSIBM.SYSRESAUTH                                      */
   511 *-* /*                                                             */
   512 *-* /*  d.  if user has say packadm on ISETS.* ... then any        */
   513 *-* /*      sepecific packadm rule will need to have that userid   */
   514 *-* /*      added to the rule for specific access.                 */
   515 *-* /*                                                             */
   516 *-* /*  e.  create files for RDEFS, by class.                      */
   517 *-* /*      create files for PERMITS, by class.                    */
   518 *-* /*      split rdefs/permits with continuation at ' DATA()      */
   519 *-* /*                                                             */
   520 *-* /*  f.  if table is granted to "public" for say "selectauth"   */
   521 *-* /*      then don't generate unneccessary permits for groups/   */
   522 *-* /*      users for the same table.                              */
   523 *-* /*                                                             */
   524 *-* /*  g.  add "warn/nowarn" option, where "NOWARN" is the default*/
   525 *-* /*      add "generic/nogeneric" option  "generic" s the default*/
   526 *-* /*                                                             */
   527 *-* /*  h.  add generic code for rules                             */
   528 *-* /*                                                             */
   529 *-* /*  */
   530 *-* /* set up error routines; and branch to "startup" */
   532 *-* signal on syntax /* set trap for syntax errors */
   533 *-* signal startUp      /* "branch" over the syntax handling routine */
   535 *-* /* -------                 */
   536 *-* syntax:
   537 *-* /* -------                 */
   538 *-* /* syntax:  error handling */
   539 *-* /*   rc    is set to the syntax error number;                        */
   540 *-* /*         ... equivelent to IRX00nnL as rc = 00, 01 to 99           */
   541 *-* /*   sigl  is set to the line number in error                        */
   542 *-* say 'IRX00'right('00'rc,2)'I Error running exec' ,                                 execName 'line' sigl':' errortext(rc)
   544 *-* syntaxLow = max(sigl-7,1)            /* -7 before (or pgm start) */
   545 *-* syntaxHigh= min(sigl+7,sourceline()) /* +7 after  (or pgm end)   */
   546 *-* do syntaxII = syntaxLow to syntaxHigh/* -7 lines back to +7 lines*/
   547 *-*  if syntaxII <> sigl
   548 *-*   then
       *-*   say 'line   ' right(syntaxii,length(syntaxHigh))':' ,                             sourceline(syntaxII)
   550 *-*  else
       *-*   say 'line==>' right(syntaxii,length(syntaxHigh))':' ,                             sourceline(syntaxII)
   552 *-* end
   554 *-* /* close (most) open files */
   555 *-* /* ----------------------- */
   556 *-* do i = 1 by 1 for openDDs
   557 *-*  ddname = openDDs.i
   558 *-*  address 'TSO' "EXECIO" bufferRecs.ddname ,                                  "DISKW" ddname '(FINIS STEM BUFFERX.'ddname
'.'
   560 *-*  if rc <> 0
   561 *-*   then
       *-*   say 'error closing/writting to ddname='ddname ,                                                 ||';rc='rc
   563 *-* end
   565 *-* say 'exiting exec with rc=12'
   566 *-* exit 12
   568 *-* /* --------                                                    */
   569 *-* startUp:
       *-* /* start of pgm... skipped error routine "syntax:" */
   570 *-* /* --------                                                    */
   572 *-* arg theargs
   573 *-* say 'called with args: "'strip(theArgs)'"'
   574 *-* pendingRc = 0
   575 *-* if wordpos('WARN',theargs) * wordpos('NOWARN',theargs) > 0
   576 *-*  then
       *-*  do
   577 *-*   say 'syntax illegal, cannot have both "WARN" and "NOWARN"'
   578 *-*   pendingrc = 8
   579 *-*  end
   580 *-* if wordpos('GENERIC',theargs) * wordpos('NOGENERIC',theargs) > 0
   581 *-*  then
       *-*  do
   582 *-*   say 'syntax illegal, cannot have both "GENERIC" and "NOGENERIC"'
   583 *-*   pendingrc = 8
   584 *-*  end
   585 *-* if wordpos('SQL',theargs) * wordpos('NOSQL',theargs) > 0
   586 *-*  then
       *-*  do
   587 *-*   say 'syntax illegal, cannot have both "SQL" and "NOSQL"'
   588 *-*   pendingrc = 8
   589 *-*  end
   590 *-* if wordpos('SLIMADM',theargs) * wordpos('NOSLIMADM',theargs) > 0
   591 *-*  then
       *-*  do
   592 *-*   say 'syntax illegal, cannot have both "SlimAdm" and "NoSlimAdm"'
   593 *-*   pendingrc = 8
   594 *-*  end
   596 *-*  /* change-06/06/2023 add PE/noPE option */
   597 *-* if wordpos('PE',theargs) * wordpos('NOPE',theargs) > 0
   598 *-*  then
       *-*  do
   599 *-*   say 'syntax illegal, cannot have both "PE" and "noPE" options'
   600 *-*   pendingrc = 8
   601 *-*  end
   603 *-*  /* change-08/15/2023 add RESET/noRESET option */
   604 *-* if wordpos('RESET',theargs) * wordpos('NORESET',theargs) > 0
   605 *-*  then
       *-*  do
   606 *-*   say 'syntax illegal, cannot have both "RESET" and "noRESET" options'
   607 *-*   pendingrc = 8
   608 *-*  end
   610 *-* if pendingrc = 8
   611 *-*  then
       *-*  do
   612 *-*   say 'due to parm error, exiting now with rc=8'
   613 *-*   exit 8
   614 *-*  end
   616 *-* optionsSpecified = 0
   617 *-* if wordpos('WARN',theargs) > 0
   618 *-*  then
       *-*  do
   619 *-*   say 'RDEF''s and RALT''s will have the "WARNING" option'
   620 *-*   optionWarn = 'WARNING'
   621 *-*   /* remove (default) option */
   622 *-*   x = wordpos('WARN',theargs)
   623 *-*   if x = 1
   624 *-*    then
       *-*    theArgs = subword(theArgs,2)
   625 *-*   else
       *-*    theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   626 *-*   optionsSpecified = 1
   627 *-*  end
   628 *-* else
       *-*  do
   629 *-*   optionWarn = '' /*default, no warning option */
   630 *-*   say 'NOWARN (default) in effect'
   631 *-*   if wordpos('NOWARN',theArgs) = 'NOWARN'
   632 *-*    then
       *-*    do
   633 *-*     /* remove (default) option */
   634 *-*     x = wordpos('NOWARN',theargs)
   635 *-*     if x = 1
   636 *-*      then
       *-*      theArgs = subword(theArgs,2)
   637 *-*     else
       *-*      theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   638 *-*     optionsSpecified = 1
   639 *-*    end
   640 *-*  end
   642 *-* genericOption = 'GENERIC' /* by default, we turn on generic option*/
   643 *-* if wordpos('NOGENERIC',theargs) > 0
   644 *-*  then
       *-*  do
   645 *-*   genericOption = ''
   646 *-*   say 'NOGENERIC is in effect, only explicit rules will be created'
   647 *-*   /* remove (default) option */
   648 *-*   x = wordpos('NOGENERIC',theargs)
   649 *-*   if x = 1
   650 *-*    then
       *-*    theArgs = subword(theArgs,2)
   651 *-*   else
       *-*    theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   652 *-*   optionsSpecified = 1
   653 *-*  end
   654 *-* else
       *-*  if wordpos('NOGENERICNOAUDIT',theargs) > 0
   655 *-*   then
       *-*   do
   656 *-*    genericOption = 'GENERICNOAUDIT'
   657 *-*    say 'GENERICNOAUDIT is in effect, generic RDEF(s) for tables' ,            'may be created, but AUDIT on tables is ig
nored'
   659 *-*    /* remove (default) option */
   660 *-*    x = wordpos('GENERICNOAUDIT',theargs)
   661 *-*    if x = 1
   662 *-*     then
       *-*     theArgs = subword(theArgs,2)
   663 *-*    else
       *-*     theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   664 *-*    optionsSpecified = 1
   665 *-*   end
   666 *-*  else
       *-*   do
   667 *-*    say 'GENERIC option in effect; to help simply rules'
   668 *-*    if wordpos('GENERIC',theArgs) > 0
   669 *-*     then
       *-*     do
   670 *-*      /* remove (default) option from args */
   671 *-*      x = wordpos('GENERIC',theargs)
   672 *-*      if x = 1
   673 *-*       then
       *-*       theArgs = subword(theArgs,2)
   674 *-*      else
       *-*       theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   675 *-*      optionsSpecified = 1
   676 *-*     end
   677 *-*   end
   679 *-* slimAdm = 1 /* by default turn on SLIMADM */
   680 *-* if wordpos('NOSLIMADM',theargs) > 0
   681 *-*  then
       *-*  do
   682 *-*   slimAdm = 0
   683 *-*   say 'NoSlimAdm is in effect, will generate all permits for SYSADM'
   684 *-*   /* remove (default) option */
   685 *-*   x = wordpos('NOSLIMADM',theargs)
   686 *-*   if x = 1
   687 *-*    then
       *-*    theArgs = subword(theArgs,2)
   688 *-*   else
       *-*    theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   689 *-*   optionsSpecified = 1
   690 *-*  end
   691 *-* else
       *-*  do
   692 *-*   say 'SlimAdm option in effect; to help simply rules'
   693 *-*   if wordpos('SLIMADM',theArgs) > 0
   694 *-*    then
       *-*    do
   695 *-*     /* remove (default) option from args */
   696 *-*     x = wordpos('SLIMADM',theargs)
   697 *-*     if x = 1
   698 *-*      then
       *-*      theArgs = subword(theArgs,2)
   699 *-*     else
       *-*      theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   700 *-*     optionsSpecified = 1
   701 *-*    end
   702 *-*  end
   704 *-* SqlOption = 'NOSQL'       /* by default, we turn off SQL option */
   705 *-* if wordpos('NOSQL',theargs) > 0
   706 *-*  then
       *-*  do
   707 *-*   SqlOption = 'NOSQL'
   708 *-*   /* remove (default) option */
   709 *-*   x = wordpos('NOSQL',theargs)
   710 *-*   if x = 1
   711 *-*    then
       *-*    theArgs = subword(theArgs,2)
   712 *-*   else
       *-*    theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   713 *-*   optionsSpecified = 1
   714 *-*  end
   715 *-* if wordpos('SQL',theargs) > 0
   716 *-*  then
       *-*  do
   717 *-*   SqlOption = 'SQL'
   718 *-*   /* remove (default) option */
   719 *-*   x = wordpos('SQL',theargs)
   720 *-*   if x = 1
   721 *-*    then
       *-*    theArgs = subword(theArgs,2)
   722 *-*   else
       *-*    theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   723 *-*   optionsSpecified = 1
   724 *-*  end
   725 *-* if SqlOption = 'SQL'
   726 *-*  then
       *-*  say 'SQL option in effect; we will output SQL as comments'
   728 *-*  /* change-06/06/2023 add PE/noPE option */
   729 *-* peOption = 'NOPE'        /* by default, we turn off PE option */
   730 *-* if wordpos('NOPE',theargs) > 0
   731 *-*  then
       *-*  do
   732 *-*   peOption = 'NOPE'
   733 *-*   /* remove (default) option */
   734 *-*   x = wordpos('NOPE',theargs)
   735 *-*   if x = 1
   736 *-*    then
       *-*    theArgs = subword(theArgs,2)
   737 *-*   else
       *-*    theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   738 *-*   optionsSpecified = 1
   739 *-*  end
   740 *-* if wordpos('PE',theargs) > 0
   741 *-*  then
       *-*  do
   742 *-*   peOption = 'PE'
   743 *-*   /* remove (default) option */
   744 *-*   x = wordpos('PE',theargs)
   745 *-*   if x = 1
   746 *-*    then
       *-*    theArgs = subword(theArgs,2)
   747 *-*   else
       *-*    theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   748 *-*   optionsSpecified = 1
   749 *-*  end
   750 *-* if peOption = 'PE'
   751 *-*  then
       *-*  say 'PE option in effect; we will keep PERMITs and RDEFs seperate'
   752 *-* else
       *-*  say 'noPE option in effect; RDEF files will have RDEFS + permits'
   754 *-* /* change-08/15/2023 add RESET/noRESET option */
   755 *-* resetOption = 'NORESET'   /* by default, we turn off RESET option */
   756 *-* if wordpos('NORESET',theargs) > 0
   757 *-*  then
       *-*  do
   758 *-*   resetOption = 'NORESET'
   759 *-*   /* remove (default) option */
   760 *-*   x = wordpos('NORESET',theargs)
   761 *-*   if x = 1
   762 *-*    then
       *-*    theArgs = subword(theArgs,2)
   763 *-*   else
       *-*    theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   764 *-*   optionsSpecified = 1
   765 *-*  end
   766 *-* if wordpos('RESET',theargs) > 0
   767 *-*  then
       *-*  do
   768 *-*   resetOption = 'RESET'
   769 *-*   /* remove (default) option */
   770 *-*   x = wordpos('RESET',theargs)
   771 *-*   if x = 1
   772 *-*    then
       *-*    theArgs = subword(theArgs,2)
   773 *-*   else
       *-*    theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   774 *-*   optionsSpecified = 1
   775 *-*  end
   776 *-* if resetOption = 'RESET'
   777 *-*  then
       *-*  say 'RESET option in effect; we will remove existing permits first'
   778 *-* else
       *-*  say 'noRESET option in effect; we will keep existing permits'
   780 *-* if optionsSpecified = 1
   781 *-*  then
       *-*  do
   782 *-*   say 'args after removing options are'
   783 *-*   say '  "'strip(theArgs)'"'
   784 *-*   say ' '
   785 *-*  end
   787 *-*  /* Arg owner ssid classmnt model charopt . */
   788 *-* parse var TheArgs owner ssid classmnt model charopt .
   790 *-* /* use defaults for some values */
   791 *-* /* ---------------------------- */
   792 *-* if classmnt = ''
       *-*  then
       *-*  classmnt = 'DSN'
   793 *-* if model = ''
       *-*  then
       *-*  model    = '2'
   794 *-* if classmnt = 'DSN' & model = 2
       *-*  then
       *-*  charopt = ''
   796 *-*  /* verification */
   797 *-* if owner = '' | length(owner) > 8 | ssid = '' | length(ssid) > 4
   798 *-*  then
       *-*  do
   799 *-*   say 'parameter error, the owner and ssid are required parms'
   800 *-*   say '  and owner must be a 1=8 character userid or group name'
   801 *-*   say 'Owner specified as "'owner'"'
   802 *-*   say 'ssid  specified as "'ssid'"'
   803 *-*   exit 8
   804 *-*  end
   805 *-* else
       *-*  do
   806 *-*   say 'Owner specified as "'owner'"'
   807 *-*   say 'ssid  specified as "'ssid'"'
   808 *-*  end
   810 *-* if classmnt <> '' & length(classmnt) > 4
   811 *-*  then
       *-*  do
   812 *-*   say ' '
   813 *-*   say 'classmnt specified as "'classmnt'" but cannot be > 4 chars'
   814 *-*   say 'classmnt you specify should match that specified in'
   815 *-*   say '   the racf exit code in DSNXRXAC.'
   816 *-*   say 'Note:  Default classmnt in DSNXRXAC is "DSN"'
   817 *-*   exit 8
   818 *-*  end
   819 *-* else
       *-*  do
   820 *-*   say ' '
   821 *-*   say 'classmnt specified as "'classmnt'"'
   822 *-*   say 'classmnt you specify should match that specified in'
   823 *-*   say '   the racf exit code in DSNXRXAC.'
   824 *-*   say 'Note:  Default classmnt in DSNXRXAC is "DSN"'
   825 *-*  end
   827 *-* if model = '' | model = '1' | model = '2'
   828 *-*  then
       *-*  do
   829 *-*   say ' '
   830 *-*   say 'Model specified as "'model'"'
   831 *-*   say 'Model value you specifiy should match that specified in'
   832 *-*   say '   the racf exit code in DSNXRXAC.'
   833 *-*   say 'Note:  Default DSNXRXAC model is 2'
   834 *-*  end
   835 *-* else
       *-*  do
   836 *-*   say ' '
   837 *-*   say 'parameter error, model specified as "'model'" but only 1 or 2',        'is a valid value'
   839 *-*   say 'Model value you specifiy should match that specified in'
   840 *-*   say '   the racf exit code in DSNXRXAC.'
   841 *-*   say 'Note:  Default DSNXRXAC model is 2'
   842 *-*   exit 8
   843 *-*  end
   845 *-* if classmnt = 'DSN' & model = 2
   846 *-*  then
       *-*  do
   847 *-*   charopt = '' /*charopt not used by racf exit in this case */
   848 *-*   say ' '
   849 *-*   say "as classmnt='DSN' and model=2, charopt is set to null"
   850 *-*   say 'and ignored, just like what happens in racf exit'
   851 *-*   say 'when using those settings.'
   852 *-*  end
   853 *-* else
       *-*  if length(charopt) = 1     ,                                             & pos(charopt,'0123456789$@#') > 0
   855 *-*   then
       *-*   do
   856 *-*    say ' '
   857 *-*    say 'charopt option specified as "'charopt'"'
   858 *-*    say 'Note:  must match the value you will specify in DSNXRXAC'
   859 *-*    say ' '
   860 *-*   end
   861 *-*  else
       *-*   do
   862 *-*    say ' '
   863 *-*    say 'charopt option specified as "'charopt'"'
   864 *-*    say 'but it must be one character long and be 0-9,#,$ or @ only'
   865 *-*    say 'and it must match the value you will specify in DSNXRXAC'
   866 *-*    exit 8
   867 *-*   end
   869 *-* /* Set addressability to DB2 Rexx function */
   870 *-* ADDRESS TSO "SUBCOM DSNREXX"
   871 *-* If RC = 1
       *-*  Then
       *-*  S_RC = RXSUBCOM('ADD','DSNREXX','DSNREXX')
   872 *-* Else
       *-*  Do
   873 *-*   Say 'Can not access DB2 Rexx Function.  Ending...'
   874 *-*   Exit
   875 *-*  End
   878 *-* /* Get RACF information, so that we know (a lot), about the */
   879 *-* /*    1) real users, that are currently active              */
   880 *-* /*    2) real users, but that are revoked.                  */
   881 *-* /*    3) users/groups that no longer exist.                 */
   882 *-* /*    4) groups (and their members)                         */
   883 *-* /* and write information out for our information.           */
   884 *-* /* -------------------------------------------------------- */
   885 *-* call processRACFdata
   887 *-* address 'TSO'
   888 *-* address dsnrexx "CONNECT "ssid
   890 *-* /* create exclude list */
   891 *-* /* ------------------- */
   892 *-* exclude. = 0 /* default, don't exclude anyone */
   893 *-* exclude  = 0 /* list of userid's to exclude */
   894 *-* excludeIndx. = 0 /* default, don't exclude anyone */
   895 *-* replace.     = ''/* default, replace group */
   896 *-* deleteId.    = 0 /* default, don't delete anyone */
   897 *-* /* DB2ENGNR is a sysadm with these userids ??? */
   898 *-* address 'TSO' 'EXECIO * DISKR EXCLIST (OPEN FINIS STEM EXCLIST.'
   899 *-* if rc <> 0
   900 *-*  then
       *-*  exclist.0 = 0
   902 *-*  /* create grantee case */
   903 *-*  /* ------------------- */
   904 *-* granteeCase = 'case'
   905 *-* commaParen = '('
   906 *-* RemoveUserList = ''
   907 *-* do exclist = 1 by 1 for exclist.0
   908 *-*  parse var exclist.exclist word1 .
   909 *-*  if word1 = ''
       *-*   then
       *-*   iterate
   910 *-*  if left(word1,1) = '*' | left(word1,2) = '/*'
       *-*   then
       *-*   iterate
   912 *-*   /* addexclude, will also add to the granteeCase variable */
   913 *-*  x = addExclude(strip(exclist.exclist))
   915 *-*  /* examples:                                                              x = addExclude('SFR609  *DELETE') /* exclude
list: delete SFR609 */     x = addExclude('KEA406  DWS000MT') /*exclude list: replace KEA406*/   */
   919 *-* end
   921 *-* if granteeCase = 'case'
   922 *-*  then
       *-*  granteeCase = 'strip(upper(a.grantee)) as grantee'
   923 *-* else
       *-*  do
   924 *-*   granteeCase = granteeCase 'else strip(upper(a.grantee))'
   925 *-*   granteeCase = granteeCase 'end as grantee'
   926 *-*  end
   928 *-* if RemoveUserList = ''
   929 *-*  then
       *-*  nop
   930 *-* else
       *-*  RemoveUserList = RemoveUserList ')' /* end with right paren */
   932 *-* say ' '
   933 *-* say '  We will use the "removeUserList" variable, if non-blank '
   934 *-* say '  to ignore db2 grants to those userids in our SQL.'
   935 *-* say 'removeUserList="'removeUserList'"'
   936 *-* say ' '
   938 *-* /* Set basic header */
   939 *-* hdr.0 = 6
   940 *-* hdr.1 = "/* DB2 to RACF conversion CLIST */"
   941 *-* hdr.2 = "/* input agruments              */"
   942 *-* hdr.3 = "/*     owner = '"owner"', ssid = '"ssid"'        */"
   943 *-* hdr.4 = "/*     classmnt = '"classmnt"', model='"model"'  */"
   944 *-* hdr.5 = "/*     charopt ='"charopt"'        */"
   945 *-* hdr.6 = "/* date="DATE() "time=" TIME() "*/"
   946 *-* hdr.7 = " "
   947 *-* do ii =1 by 1 for exclude
   948 *-*  hdr = ii + 7
   949 *-*  hdr.hdr = '  /* exclude userid: ' exclude.ii '*/'
   950 *-* end
   952 *-* openDDs = 0
   954 *-* /* resource definition output files */
   955 *-* /* -------------------------------- */
   956 *-* rdefClass =''
       *-* rdefDDname = 'RDEFMISC' /*default unknown rdefs */
   957 *-* rdefIndx. =rdefDDname /* default for unknown rdef class */
   958 *-* bufferRecs.rdefDDname = 0               /* lines in buffer */
   959 *-* openDDs = openDDs + 1
       *-* openDDs.openDDs = RdefDDname /* open DD names*/
   960 *-* Address TSO "EXECIO * DISKW" rdefDDname "(STEM hdr."
   962 *-* rdefClass ='DSNADM'
       *-* rdefDDname = 'RDEFADM'
   963 *-* RDEFIndx.rdefClass = rdefDDname
   964 *-* bufferRecs.rdefDDname = 0               /* lines in buffer */
   965 *-* openDDs = openDDs + 1
       *-* openDDs.openDDs = RdefDDname /* open DD names*/
   966 *-* Address TSO "EXECIO * DISKW" rdefDDname "(STEM HDR."
   968 *-* rdefClass ='MDSNCL'
       *-* rdefDDname = 'RDEFCL'
   969 *-* RDEFIndx.rdefClass = rdefDDname
   970 *-* bufferRecs.rdefDDname = 0               /* lines in buffer */
   971 *-* openDDs = openDDs + 1
       *-* openDDs.openDDs = RdefDDname /* open DD names*/
   972 *-* Address TSO "EXECIO * DISKW" rdefDDname "(STEM HDR."
   974 *-* rdefClass ='MDSNDB'
       *-* rdefDDname = 'RDEFDB'
   975 *-* RDEFIndx.rdefClass = rdefDDname
   976 *-* bufferRecs.rdefDDname = 0                   /* lines in buffer */
   977 *-* openDDs = openDDs + 1
       *-* openDDs.openDDs = RdefDDname /* open DD names*/
   978 *-* Address TSO "EXECIO * DISKW" rdefDDname "(STEM HDR."
   980 *-* rdefClass ='MDSNPK'
       *-* rdefDDname = 'RDEFPK'
   981 *-* RDEFIndx.rdefClass = rdefDDname
   982 *-* bufferRecs.rdefDDname = 0                   /* lines in buffer */
   983 *-* openDDs = openDDs + 1
       *-* openDDs.openDDs = RdefDDname /* open DD names*/
   984 *-* Address TSO "EXECIO * DISKW" rdefDDname "(STEM HDR."
   986 *-* rdefClass ='MDSNPN'
       *-* rdefDDname = 'RDEFPN'
   987 *-* RDEFIndx.rdefClass = rdefDDname
   988 *-* bufferRecs.rdefDDname = 0                   /* lines in buffer */
   989 *-* openDDs = openDDs + 1
       *-* openDDs.openDDs = RdefDDname /* open DD names*/
   990 *-* Address TSO "EXECIO * DISKW" rdefDDname "(STEM HDR."
   992 *-* rdefClass ='MDSNTB'
       *-* rdefDDname = 'RDEFTB'
   993 *-* RDEFIndx.rdefClass = rdefDDname
   994 *-* bufferRecs.rdefDDname = 0                   /* lines in buffer */
   995 *-* openDDs = openDDs + 1
       *-* openDDs.openDDs = RdefDDname /* open DD names*/
   996 *-* Address TSO "EXECIO * DISKW" rdefDDname "(STEM HDR."
   998 *-* rdefClass ='MDSNTS'
       *-* rdefDDname = 'RDEFTS'
   999 *-* RDEFIndx.rdefClass = rdefDDname
  1000 *-* bufferRecs.rdefDDname = 0                   /* lines in buffer */
  1001 *-* openDDs = openDDs + 1
       *-* openDDs.openDDs = RdefDDname /* open DD names*/
  1002 *-* Address TSO "EXECIO * DISKW" rdefDDname "(STEM HDR."
  1005 *-* /* resource permit     output files */
  1006 *-* /* -------------------------------- */
  1007 *-* pe$Class =''
       *-* pe$DDname = 'PE$MISC' /*default unknown permits */
  1008 *-* pe$Indx. =pe$DDname /* default for unknown pe$ class */
  1009 *-* bufferRecs.pe$DDname = 0                    /* lines in buffer */
  1010 *-* openDDs = openDDs + 1
       *-* openDDs.openDDs = pe$DDname /* open DD names*/
  1011 *-* Address TSO "EXECIO * DISKW" pe$DDname "(STEM hdr."
  1013 *-* pe$Class ='DSNADM'
       *-* pe$DDname = 'PE$ADM'
  1014 *-* pe$Indx.pe$Class = pe$DDname
  1015 *-* bufferRecs.pe$DDname = 0                    /* lines in buffer */
  1016 *-* openDDs = openDDs + 1
       *-* openDDs.openDDs = pe$DDname /* open DD names*/
  1017 *-* Address TSO "EXECIO * DISKW" pe$DDname "(STEM HDR."
  1019 *-* pe$Class ='MDSNCL'
       *-* pe$DDname = 'PE$CL'
  1020 *-* pe$Indx.pe$Class = pe$DDname
  1021 *-* bufferRecs.pe$DDname = 0                    /* lines in buffer */
  1022 *-* openDDs = openDDs + 1
       *-* openDDs.openDDs = pe$DDname /* open DD names*/
  1023 *-* Address TSO "EXECIO * DISKW" pe$DDname "(STEM HDR."
  1025 *-* pe$Class ='MDSNDB'
       *-* pe$DDname = 'PE$DB'
  1026 *-* pe$Indx.pe$Class = pe$DDname
  1027 *-* bufferRecs.pe$DDname = 0                    /* lines in buffer */
  1028 *-* openDDs = openDDs + 1
       *-* openDDs.openDDs = pe$DDname /* open DD names*/
  1029 *-* Address TSO "EXECIO * DISKW" pe$DDname "(STEM HDR."
  1031 *-* pe$Class ='MDSNPK'
       *-* pe$DDname = 'PE$PK'
  1032 *-* pe$Indx.pe$Class = pe$DDname
  1033 *-* bufferRecs.pe$DDname = 0                    /* lines in buffer */
  1034 *-* openDDs = openDDs + 1
       *-* openDDs.openDDs = pe$DDname /* open DD names*/
  1035 *-* Address TSO "EXECIO * DISKW" pe$DDname "(STEM HDR."
  1037 *-* pe$Class ='MDSNPN'
       *-* pe$DDname = 'PE$PN'
  1038 *-* pe$Indx.pe$Class = pe$DDname
  1039 *-* bufferRecs.pe$DDname = 0                    /* lines in buffer */
  1040 *-* openDDs = openDDs + 1
       *-* openDDs.openDDs = pe$DDname /* open DD names*/
  1041 *-* Address TSO "EXECIO * DISKW" pe$DDname "(STEM HDR."
  1043 *-* pe$Class ='MDSNTB'
       *-* pe$DDname = 'PE$TB'
  1044 *-* pe$Indx.pe$Class = pe$DDname
  1045 *-* bufferRecs.pe$DDname = 0                    /* lines in buffer */
  1046 *-* openDDs = openDDs + 1
       *-* openDDs.openDDs = pe$DDname /* open DD names*/
  1047 *-* Address TSO "EXECIO * DISKW" pe$DDname "(STEM HDR."
  1049 *-* pe$Class ='MDSNTS'
       *-* pe$DDname = 'PE$TS'
  1050 *-* pe$Indx.pe$Class = pe$DDname
  1051 *-* bufferRecs.pe$DDname = 0                    /* lines in buffer */
  1052 *-* openDDs = openDDs + 1
       *-* openDDs.openDDs = pe$DDname /* open DD names*/
  1053 *-* Address TSO "EXECIO * DISKW" pe$DDname "(STEM HDR."
  1055 *-* /* Set Optional header (relies on hdr. above) */
  1056 *-* hdr.1 = "/* Optional DB2 to RACF conversion CLIST */"
  1057 *-* Address TSO "EXECIO * DISKW OPTCLST (STEM hdr."
  1059 *-* uid      = 0 /* number of unique userids */
  1060 *-* uidIndx. = 0 /* index to userids         */
  1061 *-* classList= 0 /* number of unique classes; classlist.# = class */
  1062 *-* ClassIndx.=0 /* to keep classList unique */
  1063 *-* PermitsByClass. = 0 /* permitsByClass.class#.uid# = count */
  1065 *-* clistx   = 0 /*      buffer CLIST   output */
  1066 *-* optclstx = 0 /* also buffer OPTCLST output */
  1067 *-* If owner=""
       *-*  Then
       *-*  Do
  1068 *-*   Say "Owner must be specified"
  1069 *-*   Exit
  1070 *-*  End
  1071 *-* If ssid=""
       *-*  Then
       *-*  Do
  1072 *-*   Say "SSID must be specified"
  1073 *-*   Exit
  1074 *-*  End
  1076 *-*  /* ----------------                                       */
  1077 *-*  /* ----------------                                       */
  1078 *-*  End_of_startup:
  1079 *-*  /* ----------------                                       */
  1080 *-*  /* ----------------                                       */
  1081 *-*  /*                                                        */
  1082 *-*  /*            1. options parsed.                          */
  1083 *-*  /*            2. racf database input, if any, parsed.     */
  1084 *-*  /*            3. ddname EXCLIST input read and parsed.    */
  1085 *-*  /*            4. output files opened                      */
  1087 *-*  /* ----------------------- */
  1088 *-*  /* ----------------------- */
  1089 *-*  DB2_to_RACF_conversion:
  1090 *-*  /* ----------------------- */
  1091 *-*  /* ----------------------- */
  1092 *-*  /*                                                        */
  1093 *-*  /*   begin calling routines to read db2 auth tables       */
  1094 *-*  /*      and have them create necessary RDEFs, RALTs       */
  1095 *-*  /*      and/or permits.                                   */
  1096 *-*  /*                                                        */
  1098 *-*  /* set 'adminClass' to appropriate RACF class */
  1099 *-*  /* ------------------------------------------ */
  1100 *-* If classmnt=""
       *-*  Then
       *-*  classmnt="DSN"
  1101 *-* If model=""
       *-*  Then
       *-*  model=2
  1103 *-*  /* Set class based on 'Classification Model' */
  1104 *-*  /* If an invalid model, we default to II     */
  1105 *-* If model=1
       *-*  Then
       *-*  class=ssid"ADM"charopt
  1106 *-* Else
       *-*  class=classmnt"ADM"charopt
  1108 *-* adminClass = class
  1110 *-* /*---------------------------------------------------*/
  1111 *-* /* Start processing DB2 authorization tables         */
  1112 *-* /*---------------------------------------------------*/
  1113 *-* xsysadmIndx. = 0
  1114 *-* xsysadm      = 0
  1115 *-* /* adm privs:   class "DSNADM" */
  1116 *-* /* --------------------------- */
  1117 *-* class = adminClass
  1118 *-* call sys_attr "SYSADM","SYSADMAUTH"
  1119 *-* call sys_attr "SYSOPR","SYSOPRAUTH"
  1120 *-* call sys_attr "SYSCTRL","SYSCTRLAUTH"
  1121 *-* call sys_attr "SYSDBADM","SDBADMAUTH" /* rich Humphris:  add auth*/
  1122 *-* call sys_attr "DATAACCESS","DATAACCESSAUTH"/*r Humphris:  add auth*/
  1123 *-* call sys_attr "ACCESSCTRL","ACCESSCTRLAUTH"/*r Humphris:  add auth*/
  1125 *-* class = adminClass
  1126 *-* call db_attr "DBADM","DBADMAUTH"
  1128 *-* /* call db_option  ... call removed; racf fixed this problem */
  1129 *-* /* --------------      ------------                          */
  1131 *-* class = adminClass
  1132 *-* call db_attr "DBMAINT","DBMAINTAUTH"
  1133 *-* call db_attr "DBCTRL","DBCTRLAUTH"
  1134 *-* class = adminClass
  1135 *-* call packadm_attr "PACKADM"
  1137 *-* /* Schema   privileges;  rh:  add schema privs class "SC" */
  1138 *-* /* ------------------------------------------------------ */
  1139 *-* /* schema_attr changes "class" */
  1140 *-* call schema_attr "ALTERIN","ALTERINAUTH"    /* RH: add auth */
  1141 *-* call schema_attr "CREATEIN","CREATEINAUTH"  /* RH: add auth */
  1142 *-* call schema_attr "DROPIN","DROPINAUTH"      /* RH: add auth */
  1144 *-* /* Resource privileges class "SM" */
  1145 *-* /* ------------------------------ */
  1146 *-* /* RH: add auth */
  1147 *-* If model=1
       *-*  Then
       *-*  class="M"ssid"SM"charopt
  1148 *-* Else
       *-*  class="M"classmnt"SM"charopt
  1150 *-* /* sys_attr and bindagent use "SM" class (see above) */
  1151 *-* call sys_attr "ARCHIVE","ARCHIVEAUTH"
  1152 *-* call sys_attr "BINDADD","BINDADDAUTH"
  1153 *-* call bindagent
  1154 *-* call sys_attr "CREATEALIAS","CREATEALIASAUTH"
  1155 *-* call sys_attr "CREATEDBA","CREATEDBAAUTH"
  1156 *-* call sys_attr "CREATEDBC","CREATEDBCAUTH"
  1157 *-* call sys_attr "CREATESG","CREATESGAUTH"
  1158 *-* call sys_attr "DISPLAY","DISPLAYAUTH"
  1159 *-* call sys_attr "MONITOR1","MON1AUTH"
  1160 *-* call sys_attr "MONITOR2","MON2AUTH"
  1161 *-* call sys_attr "RECOVER","RECOVERAUTH"
  1162 *-* call sys_attr "STOPALL","STOPALLAUTH"
  1163 *-* call sys_attr "STOSPACE","STOSPACEAUTH"
  1164 *-* call sys_attr "SQLADM","SQLADMAUTH"           /* RH: add auth */
  1165 *-* call sys_attr "TRACE","TRACEAUTH"
  1166 *-* call sys_attr "CREATETMTAB","CREATETMTABAUTH"
  1167 *-* call sys_attr "CREATESECUREOBJECT","CREATESECUREAUTH"/* RH: add auth */
  1168 *-* call sys_attr "DEBUGSESSION","DEBUGSESSIONAUTH"/* RH: add auth */
  1169 *-* call sys_attr "EXPLAIN","EXPLAINAUTH"        /* RH: add auth */
  1170 *-* call sys_attr "BSDS","BSDSAUTH"              /* RH: add auth */
  1172 *-* /* collect data on Table privileges class "TB" */
  1173 *-* /* ------------------------------------------- */
  1175 *-* /* table privs set class for "TB" (see routines below) */
  1176 *-* call tab_priv "INIT","INIT"
  1177 *-* call tab_priv "ALTER","ALTERAUTH"
  1178 *-* call tab_priv "DELETE","DELETEAUTH"
  1179 *-* call tab_priv "INDEX","INDEXAUTH"
  1180 *-* call tab_priv "INSERT","INSERTAUTH"
  1181 *-* call tab_priv "SELECT","SELECTAUTH"
  1182 *-* call tab_priv "UPDATE","UPDATEAUTH"
  1183 *-* call tab_priv "REFERENCES","REFERENCESAUTH"
  1184 *-* call tab_priv "VIEW_INSERT","INSERTAUTH"
  1185 *-* call tab_priv "VIEW_UPDATE","UPDATEAUTH"
  1186 *-* call tab_priv "VIEW_DELETE","DELETEAUTH"
  1188 *-* call tab_col  "REFERENCES"                  /* column reference priv*/
  1190 *-* call tab_col  "UPDATECOLS"                  /* column update privs */
  1192 *-* call tab_priv "TRIGGER","TRIGGERAUTH"    /* add new table priv */
  1193 *-* call tab_priv "UNLOAD","UNLOADAUTH"      /* add new table priv */
  1196 *-* /* Database privileges class "DB" */
  1197 *-* /* ------------------------------ */
  1198 *-* /* database privs set class for "DB" (see routines below) */
  1199 *-* call def_priv "DB","CREATETAB","CREATETABAUTH","DB"
  1200 *-* call def_priv "DB","CREATETS","CREATETSAUTH","DB"
  1201 *-* call def_priv "DB","DISPLAYDB","DISPLAYDBAUTH","DB"
  1202 *-* call def_priv "DB","DROP","DROPAUTH","DB"
  1203 *-* call def_priv "DB","IMAGCOPY","IMAGCOPYAUTH","DB"
  1204 *-* call def_priv "DB","LOAD","LOADAUTH","DB"
  1205 *-* call def_priv "DB","REORG","REORGAUTH","DB"
  1206 *-* call def_priv "DB","RECOVERDB","RECOVERDBAUTH","DB"
  1207 *-* call def_priv "DB","REPAIR","REPAIRAUTH","DB"
  1208 *-* call def_priv "DB","STARTDB","STARTDBAUTH","DB"
  1209 *-* call def_priv "DB","STATS","STATSAUTH","DB"
  1210 *-* call def_priv "DB","STOPDB","STOPAUTH","DB"
  1212 *-* /* Plan privileges */
  1213 *-* /* plan privs set class for "PN" (see routines below) */
  1214 *-* call def_priv "PN","BIND","BINDAUTH","PLAN"
  1215 *-* call def_priv "PN","EXECUTE","EXECUTEAUTH","PLAN"
  1217 *-* /* Package privileges */
  1218 *-* /* package privs set class for "PK" (see routines below) */
  1219 *-* call pack_priv "BIND","BINDAUTH"
  1220 *-* say 'pack_priv "BIND","BINDAUTH" ended at' time()
  1221 *-* call pack_priv "EXECUTE","EXECUTEAUTH"
  1222 *-* say 'pack_priv "EXECUTE","EXECUTEAUTH" ended at' time()
  1223 *-* call pack_priv "COPY","COPYAUTH"
  1224 *-* say 'pack_priv "COPY","COPYAUTH" ended at' time()
  1226 *-* /* Collection privileges */
  1227 *-* /* collection privs set class for "CL" (see routines below) */
  1228 *-* call cltn_priv "CREATEIN"
  1230 *-* /* Use BUFFERPOOL/STOGROUP/TABLESPACE privileges */
  1231 *-* /* Use jar and distinct type          privileges */
  1233 *-* /* bp privs set class for "BP" (see routine below) */
  1234 *-* call BP_use_priv "USE","B","BP"   /* Buffer Pool   */
  1236 *-* /* storage group privs set class for "SG" (see routine below) */
  1237 *-* call use_priv "USE","S","SG"   /* storage group */
  1239 *-* /* TS privs set class for "TS" (see routine below) */
  1240 *-* call use_priv "USE","R","TS"   /* tablespace */
  1242 *-* /* JR privs set class for "JR" (see routine below) */
  1243 *-* call use_priv "USAGE","J","JR" /* jar */
  1245 *-* /* UT privs set class for "UT" (see routine below) */
  1246 *-* call use_priv "USAGE","D","UT" /* distinct type */
  1248 *-* /* global variables    class "GV" */
  1249 *-* /* ------------------------------ */
  1250 *-* /* RH: add auth */
  1251 *-* If model=1
       *-*  Then
       *-*  class="M"ssid"GV"charopt
  1252 *-* Else
       *-*  class="M"classmnt"GV"charopt
  1254 *-* /* GV privs set class for "GV" (see routine below) */
  1255 *-* call gv_attr "READ","READAUTH"    /* global variable/sysvariableauth*/
  1256 *-* call gv_attr "WRITE","WRITEAUTH"  /* global variable/sysvariableauth*/
  1258 *-* /* syssequenceauth     class "GV" */
  1259 *-* /* ------------------------------ */
  1260 *-* /* RH: add auth */
  1261 *-* If model=1
       *-*  Then
       *-*  class="M"ssid"SQ"charopt
  1262 *-* Else
       *-*  class="M"classmnt"SQ"charopt
  1264 *-* /* SQ privs set class for "SQ" (see routine below) */
  1265 *-* call seq_attr "ALTER","ALTERAUTH" /* seq priv/syssequenceauth*/
  1266 *-* call seq_attr "USAGE","USEAUTH"   /* seq priv/syssequenceauth*/
  1268 *-* /* sysroutineauth     class "SP" */
  1269 *-* /* sysroutineauth     class "UF" */
  1270 *-* /* ------------------------------ */
  1271 *-* /* RH: add auth */
  1272 *-* If model=1
       *-*  Then
       *-*  class="M"ssid"SP"charopt
  1273 *-* Else
       *-*  class="M"classmnt"SP"charopt
  1275 *-* /* SP privs set class for "SP" (see routine below) */
  1276 *-* call routine_attr "EXECUTE","EXECUTEAUTH","P" /*stored procedure */
  1278 *-* If model=1
       *-*  Then
       *-*  class="M"ssid"UF"charopt
  1279 *-* Else
       *-*  class="M"classmnt"UF"charopt
  1281 *-* /* UF privs set class for "UF" (see routine below) */
  1282 *-* call routine_attr "EXECUTE","EXECUTEAUTH","F" /*user defined function*/
  1284 *-* /* close open files */
  1285 *-* /* ---------------- */
  1286 *-* do i = 1 by 1 for openDDs
  1287 *-*  ddname = openDDs.i
  1288 *-*  address 'TSO' "EXECIO" bufferRecs.ddname ,                                               "DISKW" ddname '(FINIS STEM BU
FFERX.'ddname'.'
  1290 *-*  if rc <> 0
  1291 *-*   then
       *-*   do
  1292 *-*    say 'error closing/writting to ddname='ddname'; rc='rc
  1293 *-*    say 'will exit with rc=8'
  1294 *-*    pendingRc = 8
  1295 *-*   end
  1296 *-* end
  1298 *-* /* userid's found were */
  1299 *-* say 'userid''s we created racf cmds for were:'
  1300 *-* optclstx = optclstx + 1
  1301 *-* optclstx.optclstx = '   '
  1302 *-* optclstx = optclstx + 1
  1303 *-* optclstx.optclstx = ' /* userid''s we created racf cmds for were: */'
  1304 *-* optclstx = optclstx + 1
  1305 *-* optclstx.optclstx = '    /* userid''s in RACF database were:       */'
  1306 *-* do ii = 1 by 1 for uid
  1307 *-*  xxx = uid.ii
  1308 *-*  if useridIndx.xxx = 0 /* if useridIndx is zero... */
  1309 *-*   then
       *-*   iterate          /* ...must be a group, iterate */
  1310 *-*  if excludeIndx.xxx > 0 /* if excluded, */
  1311 *-*   then
       *-*   iterate           /* ...iterate      */
  1313 *-*  uidx  = useridIndx.xxx
  1314 *-*  if revoked.uidx <> 'No' /* if revoked */
  1315 *-*   then
       *-*   iterate            /* ...iterate    */
  1316 *-*  if revoked.uidx =  '?'  /* unknown?       */
  1317 *-*   then
       *-*   iterate           /* ...iterate     */
  1318 *-*  comm = userGroupInfo(xxx) /* Normal userid, give info */
  1319 *-*  optclstx = optclstx + 1
  1320 *-*  optclstx.optclstx = '   /* 'left(uid.ii,8) left(comm,70) '*/'
  1321 *-* end
  1322 *-* do ii = 1 by 1 for uid
  1323 *-*  xxx = uid.ii
  1324 *-*  if useridIndx.xxx = 0 /* if useridIndx is zero... */
  1325 *-*   then
       *-*   iterate          /* must be a group, iterate */
  1326 *-*  if excludeIndx.xxx > 0 /* if excluded, */
  1327 *-*   then
       *-*   iterate           /* ...iterate      */
  1329 *-*  uidx  = useridIndx.xxx
  1330 *-*  if revoked.uidx =  'No' /* if not revoked */
  1331 *-*   then
       *-*   iterate            /* ...iterate     */
  1332 *-*  if revoked.uidx =  '?'  /* unknown?       */
  1333 *-*   then
       *-*   iterate            /* ...iterate     */
  1334 *-*  comm = userGroupInfo(xxx) /* Revoked userid, give info */
  1335 *-*  optclstx = optclstx + 1
  1336 *-*  optclstx.optclstx = '   /* 'left(uid.ii,8) left(comm,70) '*/'
  1337 *-* end
  1338 *-* optclstx = optclstx + 1
  1339 *-* optclstx.optclstx = '    /* userid''s in RACF database but excluded: */'
  1340 *-* do ii = 1 by 1 for uid
  1341 *-*  xxx = uid.ii
  1342 *-*  if useridIndx.xxx = 0 /* if useridIndx is zero... */
  1343 *-*   then
       *-*   iterate          /* must be a group, iterate */
  1344 *-*  if excludeIndx.xxx = 0 /* if not excluded, */
  1345 *-*   then
       *-*   iterate           /* ...iterate       */
  1347 *-*  uidx  = useridIndx.xxx
  1348 *-*  if revoked.uidx <> 'No' /* if revoked */
  1349 *-*   then
       *-*   iterate            /* ...iterate     */
  1350 *-*  if revoked.uidx =  '?'  /* unknown?       */
  1351 *-*   then
       *-*   iterate            /* ...iterate     */
  1352 *-*  comm = userGroupInfo(xxx) /* excluded, not revoked, give info */
  1353 *-*  optclstx = optclstx + 1
  1354 *-*  optclstx.optclstx = '   /* 'left(uid.ii,8) left(comm,70) '*/'
  1355 *-* end
  1356 *-* do ii = 1 by 1 for uid
  1357 *-*  xxx = uid.ii
  1358 *-*  if useridIndx.xxx = 0 /* if useridIndx is zero... */
  1359 *-*   then
       *-*   iterate          /* must be a group, iterate */
  1360 *-*  if excludeIndx.xxx = 0 /* if not excluded, */
  1361 *-*   then
       *-*   iterate           /* ...iterate       */
  1363 *-*  uidx  = useridIndx.xxx
  1364 *-*  if revoked.uidx=  'No' /* if NOT revoked */
  1365 *-*   then
       *-*   iterate           /* ...iterate     */
  1366 *-*  if revoked.uidx=  '?'  /* unknown?       */
  1367 *-*   then
       *-*   iterate           /* ...iterate     */
  1368 *-*  comm = userGroupInfo(xxx) /* excluded, Revoked userid, give info */
  1369 *-*  optclstx = optclstx + 1
  1370 *-*  optclstx.optclstx = '   /* 'left(uid.ii,8) left(comm,70) '*/'
  1371 *-* end
  1372 *-* do ii = 1 by 1 for uid
  1373 *-*  xxx = uid.ii
  1374 *-*  if useridIndx.xxx = 0 /* if useridIndx is zero... */
  1375 *-*   then
       *-*   iterate          /* must be a group, iterate */
  1376 *-*  if excludeIndx.xxx = 0 /* if not excluded, */
  1377 *-*   then
       *-*   iterate           /* ...iterate       */
  1379 *-*  uidx  = useridIndx.xxx
  1380 *-*  if revoked.uidx<> '?'  /* unknown?       */
  1381 *-*   then
       *-*   iterate           /* ...iterate     */
  1382 *-*  comm = userGroupInfo(xxx) /* excluded, Revoked userid, give info */
  1383 *-*  optclstx = optclstx + 1
  1384 *-*  optclstx.optclstx = '   /* 'left(uid.ii,8) left(comm,70) '*/'
  1385 *-* end
  1386 *-* optclstx = optclstx + 1
  1387 *-* optclstx.optclstx = ' '
  1388 *-* optclstx = optclstx + 1
  1389 *-* optclstx.optclstx = '    /* unknown userids */'
  1390 *-* do ii = 1 by 1 for uid
  1391 *-*  xxx = uid.ii
  1392 *-*  if useridIndx.xxx = 0 /* if useridIndx is zero... */
  1393 *-*   then
       *-*   iterate          /* must be a group, iterate */
  1394 *-*  if excludeIndx.xxx = 1 /* if excluded, */
  1395 *-*   then
       *-*   iterate           /* ...iterate   */
  1397 *-*  uidx  = useridIndx.xxx
  1398 *-*  if revoked.uidx<> '?'
  1399 *-*   then
       *-*   iterate
  1400 *-*  comm = userGroupInfo(xxx)
  1401 *-*  optclstx = optclstx + 1
  1402 *-*  optclstx.optclstx = '   /* 'left(uid.ii,8) left(comm,70) '*/'
  1403 *-* end
  1404 *-* optclstx = optclstx + 1
  1405 *-* optclstx.optclstx = ' '
  1406 *-* optclstx = optclstx + 1
  1407 *-* optclstx.optclstx = '    /* groups used */'
  1408 *-* do ii = 1 by 1 for uid
  1409 *-*  xxx = uid.ii
  1410 *-*  if useridIndx.xxx <> 0 /* if useridIndx is nonzero... */
  1411 *-*   then
       *-*   iterate           /* must be a userid, iterate */
  1413 *-*  comm = userGroupInfo(xxx) /* get group info, and output*/
  1414 *-*  optclstx = optclstx + 1
  1415 *-*  optclstx.optclstx = '   /* 'left(xxx,8) left(comm,70) '*/'
  1417 *-*  /* set up to look at group membership */
  1418 *-*  gix = groupIndx.xxx  /* get the index to group info */
  1419 *-*  members = groupMembers.gix
  1420 *-*  gstatus = groupMembersStatus.gix
  1421 *-*  if members <> ''
  1422 *-*   then
       *-*   do
  1423 *-*    optclstx = optclstx + 1
  1424 *-*    optclstx.optclstx = '     /* ---members of group are--- */'
  1425 *-*   end
  1426 *-*  do while members <> ''
  1427 *-*   /* output membership details */
  1428 *-*   parse var members member members /* strip off a member*/
  1429 *-*   parse var gstatus stat   gstatus /* and a status */
  1430 *-*   comm = userGroupInfo(member)
  1431 *-*   optclstx = optclstx + 1
  1432 *-*   if stat = 'No' | stat = '?'
  1433 *-*    then
       *-*    optclstx.optclstx = '     /* 'left(member,8)'; 'comm '*/'
  1434 *-*   else
       *-*    optclstx.optclstx = '     /* 'left(member,8) ,                                          'GroupRevokeStatus=' || stat'
; 'comm' */'
  1436 *-*  end
  1437 *-* end
  1438 *-* optclstx = optclstx + 1
  1439 *-* optclstx.optclstx = ' '
  1440 *-* optclstx = optclstx + 1
  1441 *-* optclstx.optclstx = '    /* permits by class/userid */'
  1443 *-* maxUidLength = 0
  1444 *-* do uidNum = 1 by 1 for uid
  1445 *-*  if length(uid.uidNum) > maxUidLength
  1446 *-*   then
       *-*   maxUidLength = length(uid.uidNum)
  1447 *-* end
  1449 *-* do classnum = 1 by 1 for classList
  1450 *-*  optclstx = optclstx + 1
  1451 *-*  optclstx.optclstx = ' '
  1452 *-*  optclstx = optclstx + 1
  1453 *-*  optclstx.optclstx = '      /* permits by class='classlist.classnum ,                        ' */'
  1455 *-*  do uidnum = 1 by 1 for uid
  1456 *-*   if permitsByClass.classnum.uidnum = 0
       *-*    then
       *-*    iterate
  1457 *-*   comm = userGroupInfo(uid.uidnum)
  1458 *-*   optclstx = optclstx + 1
  1459 *-*   optclstx.optclstx = format(permitsByClass.classnum.uidnum,8,0) ,                            classlist.classnum '/' ,
                                              left(uid.uidnum,maxUidLength) ,                                         left(comm,80)
  1463 *-*   if optclstx > 100
  1464 *-*    then
       *-*    do
  1465 *-*     Address TSO "EXECIO" optClstx "DISKW OPTCLST (STEM OPTCLSTX."
  1466 *-*     if rc <> 0
  1467 *-*      then
       *-*      do
  1468 *-*       say 'error writing/closing ddname=OPTCLST; rc='rc
  1469 *-*       say 'will exit with rc=8'
  1470 *-*       pendingRc = 8
  1471 *-*      end
  1472 *-*     optclstx = 0
  1473 *-*    end
  1474 *-*  end
  1475 *-* end
  1477 *-* /* add information about table permits that were ignored */
  1478 *-* /* ----------------------------------------------------- */
  1479 *-* optClstx = optclstx + 1
  1480 *-* optCLstx.optClstx = ' '
  1482 *-* optClstx = optclstx + 1
  1483 *-* optCLstx.optClstx = ' users whose table permit access was ignored' ,                        'because either:'
  1485 *-* optClstx = optclstx + 1
  1486 *-* optCLstx.optClstx = ' -------------------------------------------' ,                     || '----------------'
  1489 *-* optClstx = optclstx + 1
  1490 *-* optCLstx.optClstx = '    1) the grantee wasn''t a owner of a package'
  1492 *-* optClstx = optclstx + 1
  1493 *-* optCLstx.optClstx = ' or 2) the grantee wasn''t a RACF current(valid)',                     'userid'
  1496 *-* optClstx = optclstx + 1
  1497 *-* optCLstx.optClstx = ' or 3) the grantee wasn''t a RACF groupid'
  1498 *-* optClstx = optclstx + 1
  1499 *-* optCLstx.optClstx = ' -------------------------------------------' ,                     || '----------------'
  1501 *-* if ignoredTableGranteeList = ''
  1502 *-*  then
       *-*  do
  1503 *-*   optClstX = optClstx + 1
  1504 *-*   optClstx.optclstx = '***none found***'
  1505 *-*  end
  1506 *-* else
       *-*  do
  1507 *-*   do while ignoredTableGranteeList <> ''
  1508 *-*    parse var ignoredTableGranteeList nextG ignoredTableGranteeList
  1509 *-*    optClstX = optclstx + 1
  1510 *-*    optClstx.optClstx = nextg 'ignored;' ignoredTableGrantee.nextg ,                        'table permits not needed (in
sert, update, etc)'
  1513 *-*    if optclstx > 100
  1514 *-*     then
       *-*     do
  1515 *-*      Address TSO "EXECIO" optClstx "DISKW OPTCLST (STEM OPTCLSTX."
  1516 *-*      if rc <> 0
  1517 *-*       then
       *-*       do
  1518 *-*        say 'error writing/closing ddname=OPTCLST; rc='rc
  1519 *-*        say 'will exit with rc=8'
  1520 *-*        pendingRc = 8
  1521 *-*       end
  1522 *-*      optclstx = 0
  1523 *-*     end
  1524 *-*   end
  1525 *-*  end
  1528 *-* /* add information about missing package owner userid/groups */
  1529 *-* /* --------------------------------------------------------- */
  1530 *-* optClstx = optclstx + 1
  1531 *-* optCLstx.optClstx = ' '
  1533 *-* optClstx = optclstx + 1
  1534 *-* optCLstx.optClstx = ' package owner''s who are missing a racf'     ,                        'userid and/or group; but ha
ve table permits'
  1536 *-* optClstx = optclstx + 1
  1537 *-* optCLstx.optClstx = ' ---------------------------------------' ,                         || '---------------------------
----------------'
  1540 *-* if packageTableGranteeList = ''
  1541 *-*  then
       *-*  do
  1542 *-*   optClstX = optClstx + 1
  1543 *-*   optClstx.optclstx = '***none found***'
  1544 *-*  end
  1545 *-* else
       *-*  do
  1546 *-*   do while packageTableGranteeList <> ''
  1547 *-*    parse var packageTableGranteeList nextG packageTableGranteeList
  1548 *-*    optClstX = optclstx + 1
  1549 *-*    optClstx.optClstx = nextg 'which needs racf userid/group id'
  1551 *-*    if optclstx > 100
  1552 *-*     then
       *-*     do
  1553 *-*      Address TSO "EXECIO" optClstx "DISKW OPTCLST (STEM OPTCLSTX."
  1554 *-*      if rc <> 0
  1555 *-*       then
       *-*       do
  1556 *-*        say 'error writing/closing ddname=OPTCLST; rc='rc
  1557 *-*        say 'will exit with rc=8'
  1558 *-*        pendingRc = 8
  1559 *-*       end
  1560 *-*      optclstx = 0
  1561 *-*     end
  1562 *-*   end
  1563 *-*  end
  1565 *-* say ' '
  1566 *-* Address TSO "EXECIO" optClstx "DISKW OPTCLST (FINIS STEM OPTCLSTX."
  1567 *-* if rc <> 0
  1568 *-*  then
       *-*  do
  1569 *-*   say 'error writing/closing ddname=OPTCLST; rc='rc
  1570 *-*   say 'will exit with rc=8'
  1571 *-*   pendingRc = 8
  1572 *-*  end
  1574 *-* address dsnrexx "DISCONNECT"
  1575 *-* /* Exit program here */
  1576 *-* /* ----------------- */
  1577 *-* Exit pendingRc
  1579 *-* /* subroutines follow */
  1580 *-* /* ------------------ */
  1581 *-* schema_attr:
  1582 *-* Arg auth,col
  1583 *-* If model=1
       *-*  Then
       *-*  class="M"ssid'SC'||charopt
  1584 *-* Else
       *-*  class="M"classmnt||'SC'||charopt
  1586 *-* extra = ''      /* default */
  1587 *-* dbowner = owner /* default */
  1589 *-* Rdef$Permit = 'RDEF' /* all output to rdef datasets */
  1590 *-* /* --------------------------- */
  1591 *-* useClass = class
  1593 *-* /* create "backstop" so that everything else is rejected */
  1594 *-* /* ----------------------------------------------------- */
  1595 *-* cmd='/* create backstop RDEF (in schema_attr: routine) */'
  1596 *-* x = clistCard(cmd)
  1598 *-* If model=1
       *-*  Then
       *-*  prof='*.'auth
  1599 *-* Else
       *-*  prof=ssid'.*.'auth
  1601 *-* extra = "DATA('"auth "for ssid("ssid") backstop schema(*)')"
  1602 *-* prof = left(prof,max(24,length(prof)))
  1603 *-* cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                            extra /*rph*/
  1606 *-* x = clistCard(cmd)
  1608 *-* /* Find all objects, and make commands to create profiles */
  1609 *-* /* for 'auth'. Then remove executor from access list.     */
  1610 *-* x=sql('NEW statement') /* start new sql statement */
  1611 *-* /* ----------------------- */
  1612 *-* x=sql("SELECT DISTINCT strip(a.SCHEMANAME) as name, 'READ'   as type")
  1613 *-* x=sql("FROM SYSIBM.SYSSCHEMAAUTH as a"                               )
  1614 *-* x=sql("WHERE a."col "<> ' '"                                         )
  1615 *-* if SlimAdm
  1616 *-*  then
       *-*  do
  1617 *-*   x=sql("  AND a.grantee not in"                                       )
  1618 *-*   x=sql("     ("                                                       )
  1619 *-*   x=sql("       select distinct b.grantee from sysibm.sysuserauth as b")
  1620 *-*   x=sql("       where b.sysadmAuth <> ' '"                             )
  1621 *-*   x=sql("      )"                                                      )
  1622 *-*  end
  1623 *-* x=sql("  AND EXISTS"                                                 )
  1624 *-* x=sql("     ("                                                       )
  1625 *-* x=sql("       select 1 from sysibm.sysschemaauth as c"               )
  1626 *-* x=sql("       where c."col "<> ' '"                                  )
  1627 *-* x=sql("         and c.schemaName = a.schemaName"                     )
  1628 *-* x=sql("         and c.grantee in ('PUBLIC','PUBLIC*')"               )
  1629 *-* x=sql("      )"                                                      )
  1630 *-* if RemoveUserList <> ''
  1631 *-*  then ,
  1632 *-*  x=sql("  AND a.grantee not in" RemoveUserList                        )
  1634 *-* x=sql("UNION" ,                                                      )
  1635 *-* x=sql("SELECT DISTINCT strip(a.SCHEMANAME) as name, 'NONE'   as type")
  1636 *-* x=sql("FROM SYSIBM.SYSSCHEMAAUTH as a"                               )
  1637 *-* x=sql("WHERE a."col "<> ' '"                                         )
  1638 *-* if SlimAdm
  1639 *-*  then
       *-*  do
  1640 *-*   x=sql("  AND a.grantee not in"                                       )
  1641 *-*   x=sql("     ("                                                       )
  1642 *-*   x=sql("       select distinct b.grantee from sysibm.sysuserauth as b")
  1643 *-*   x=sql("       where b.sysadmAuth <> ' '"                             )
  1644 *-*   x=sql("      )"                                                      )
  1645 *-*  end
  1646 *-* x=sql("  AND NOT EXISTS"                                             )
  1647 *-* x=sql("     ("                                                       )
  1648 *-* x=sql("       select 1 from sysibm.sysschemaauth as c"               )
  1649 *-* x=sql("       where c."col "<> ' '"                                  )
  1650 *-* x=sql("         and c.schemaName = a.schemaName"                     )
  1651 *-* x=sql("         and c.grantee in ('PUBLIC','PUBLIC*')"               )
  1652 *-* x=sql("      )"                                                      )
  1653 *-* if RemoveUserList <> ''
  1654 *-*  then ,
  1655 *-*  x=sql("  AND a.grantee not in" RemoveUserList                        )
  1657 *-* x=sql("order by name"                                                )
  1659 *-* call ZSQL
  1661 *-* rowsReturned = 0
  1662 *-* allPublic = 0  /* default is, of course, not all public */
  1663 *-* Do Until SQLCODE \= 0
  1664 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :name, :type"
  1665 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  1666 *-*    rowsReturned = rowsReturned + 1
  1667 *-*    parse upper var name name .
  1668 *-*    parse upper var type type .
  1669 *-*    If model=1
       *-*     Then
       *-*     prof=name'.'auth
  1670 *-*    Else
       *-*     prof=ssid'.'name'.'auth
  1672 *-*    if name = '*' & type = 'READ'
  1673 *-*     then
       *-*     allPublic = 1 /* yes, define everything as read */
  1675 *-*    if allPublic
  1676 *-*     then
       *-*     type = 'READ' /* override all schema's to public */
  1678 *-*    extra = "DATA('"auth "for ssid("ssid") schema("name")')"
  1679 *-*    if type = 'READ'
  1680 *-*     then
       *-*     extra = "DATA('everyone has" ,                                                     auth "for ssid("ssid") schema("na
me")')"
  1682 *-*    prof = left(prof,max(24,length(prof)))
  1684 *-*    /* normally, we have to create RDEF's but we already   */
  1685 *-*    /*   created backstop profile.  So if name = '*' we'll */
  1686 *-*    /*   have to modify if (RALT) instead of define it.    */
  1688 *-*    if name = '*' /* generic profile already created? modify it*/
  1689 *-*     then
       *-*     cmdx = 'RALT' /* modify 'backstop' */
  1690 *-*    else
       *-*     cmdx = 'RDEF' /* define profile    */
  1692 *-*    cmd=cmdx class prof" UACC("type") AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                               extra /*rph*/
  1695 *-*    x = clistCard(cmd)
  1697 *-*    cmd="PERMIT "prof" CLASS("class") RESET"
  1698 *-*    if resetOption = 'RESET'
       *-*     then
       *-*     x = clistCard(cmd)
  1699 *-*   End
  1700 *-* End /* do until */
  1701 *-* call showRowCount /* show rowsReturned */
  1702 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  1703 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  1704 *-* address dsnrexx "EXECSQL CLOSE C1"
  1705 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  1707 *-* Rdef$Permit = 'PERMIT'/*all output to PE   datasets */
  1708 *-* /* --------------------------- */
  1710 *-* /* Find all objects, and make commands to create profiles */
  1711 *-* /* for 'auth'. Then remove executor from access list.     */
  1712 *-* x=sql('NEW statement') /* start new sql statement */
  1713 *-* /* ----------------------- */
  1714 *-* x=sql("SELECT DISTINCT name"                                         )
  1715 *-* x=sql("               ,grantee"                                      )
  1716 *-* x=sql("FROM ("                                                       )
  1718 *-* x=sql("   SELECT DISTINCT strip(a.SCHEMANAME) as name"               )
  1719 *-* x=sql("                  ,strip(a.grantee)    as grantee"            )
  1720 *-* x=sql("   FROM SYSIBM.SYSSCHEMAAUTH as a"                            )
  1721 *-* x=sql("   WHERE a."col "<> ' '"                                      )
  1722 *-* if SlimAdm
  1723 *-*  then
       *-*  do
  1724 *-*   x=sql("     AND a.grantee not in"                                    )
  1725 *-*   x=sql("        ("                                                    )
  1726 *-*   x=sql("          select distinct b.grantee"                          )
  1727 *-*   x=sql("          from sysibm.sysuserauth as b"                       )
  1728 *-*   x=sql("          where b.sysadmAuth <> ' '"                          )
  1729 *-*   x=sql("         )"                                                   )
  1730 *-*  end
  1731 *-* x=sql("     AND NOT EXISTS"                                          )
  1732 *-* x=sql("        ("                                                    )
  1733 *-* x=sql("          select 1 from sysibm.sysschemaauth as c"            )
  1734 *-* x=sql("          where c."col "<> ' '"                               )
  1735 *-* x=sql("            and (   c.schemaName = a.schemaName"              )
  1736 *-* x=sql("                 or c.schemaName = '*'"                       )
  1737 *-* x=sql("                 )"                                           )
  1738 *-* x=sql("            and c.grantee in ('PUBLIC','PUBLIC*')"            )
  1739 *-* x=sql("         )"                                                   )
  1740 *-* if RemoveUserList <> ''
  1741 *-*  then ,
  1742 *-*  x=sql("     AND a.grantee not in" RemoveUserList                     )
  1743 *-* x=sql("UNION"                                                        )
  1744 *-* x=sql("   SELECT DISTINCT strip(a.SCHEMANAME) as name"               )
  1745 *-* x=sql("                  ,strip(b.grantee)    as grantee"            )
  1746 *-* x=sql("   FROM SYSIBM.SYSSCHEMAAUTH as a"                            )
  1747 *-* x=sql("       ,SYSIBM.SYSSCHEMAAUTH as b"                            )
  1748 *-* x=sql("   WHERE a."col "<> ' '"                                      )
  1749 *-* x=sql("     and b."col "<> ' '"                                      )
  1750 *-* x=sql("     and b.schemaName = '*'"                                  )
  1751 *-* if SlimAdm
  1752 *-*  then
       *-*  do
  1753 *-*   x=sql("     AND b.grantee not in"                                    )
  1754 *-*   x=sql("        ("                                                    )
  1755 *-*   x=sql("          select distinct b2.grantee"                         )
  1756 *-*   x=sql("          from sysibm.sysuserauth as b2"                      )
  1757 *-*   x=sql("          where b2.sysadmAuth <> ' '"                         )
  1758 *-*   x=sql("         )"                                                   )
  1759 *-*  end
  1760 *-* x=sql("     AND NOT EXISTS"                                          )
  1761 *-* x=sql("        ("                                                    )
  1762 *-* x=sql("          select 1 from sysibm.sysschemaauth as c"            )
  1763 *-* x=sql("          where c."col "<> ' '"                               )
  1764 *-* x=sql("            and (   c.schemaName = a.schemaName"              )
  1765 *-* x=sql("                 or c.schemaName = '*'"                       )
  1766 *-* x=sql("                 )"                                           )
  1767 *-* x=sql("            and c.grantee in ('PUBLIC','PUBLIC*')"            )
  1768 *-* x=sql("         )"                                                   )
  1769 *-* if RemoveUserList <> ''
  1770 *-*  then ,
  1771 *-*  x=sql("     AND b.grantee not in" RemoveUserList                     )
  1772 *-* x=sql("   )"                                                         )
  1774 *-* x=sql("order by name, grantee"                                       )
  1776 *-* call ZSQL
  1778 *-* rowsReturned = 0
  1779 *-* Do Until SQLCODE \= 0
  1780 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :name, :grantee"
  1781 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  1782 *-*    rowsReturned = rowsReturned + 1
  1783 *-*    parse upper var name name .
  1784 *-*    parse upper var type type .
  1785 *-*    If model=1
       *-*     Then
       *-*     prof=name'.'auth
  1786 *-*    Else
       *-*     prof=ssid'.'name'.'auth
  1788 *-*    prof = left(prof,max(24,length(prof)))
  1789 *-*    cmd="PERMIT" prof "CLASS("class") ACC(READ) ID("grantee")"
  1790 *-*    x = clistCard(cmd)
  1792 *-*   End
  1793 *-* End /* do until */
  1794 *-* call showRowCount /* show rowsReturned */
  1795 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  1796 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  1797 *-* address dsnrexx "EXECSQL CLOSE C1"
  1798 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  1800 *-* return
  1802 *-* def_priv:
  1803 *-* /* database privs */
  1804 *-* /*                                                        */
  1805 *-* /*    call def_priv "DB","CREATETAB","CREATETABAUTH","DB" */
  1806 *-* /*    call def_priv "DB","CREATETS","CREATETSAUTH","DB"   */
  1807 *-* /*    call def_priv "DB","DISPLAYDB","DISPLAYDBAUTH","DB" */
  1808 *-* /*    call def_priv "DB","DROP","DROPAUTH","DB"           */
  1809 *-* /*    call def_priv "DB","IMAGCOPY","IMAGCOPYAUTH","DB"   */
  1810 *-* /*    call def_priv "DB","LOAD","LOADAUTH","DB"           */
  1811 *-* /*    call def_priv "DB","REORG","REORGAUTH","DB"         */
  1812 *-* /*    call def_priv "DB","RECOVERDB","RECOVERDBAUTH","DB" */
  1813 *-* /*    call def_priv "DB","REPAIR","REPAIRAUTH","DB"       */
  1814 *-* /*    call def_priv "DB","STARTDB","STARTDBAUTH","DB"     */
  1815 *-* /*    call def_priv "DB","STATS","STATSAUTH","DB"         */
  1816 *-* /*    call def_priv "DB","STOPDB","STOPAUTH","DB"         */
  1818 *-* /* Plan privileges */
  1819 *-* /*                                                        */
  1820 *-* /*    call def_priv "PN","BIND","BINDAUTH","PLAN"         */
  1821 *-* /*    call def_priv "PN","EXECUTE","EXECUTEAUTH","PLAN"   */
  1822 *-* /*****************************************************************/
  1823 *-* /* Get DB2 Default privileges (plans, db, etc.)                  */
  1824 *-* /*****************************************************************/
  1825 *-* Arg type,auth,col,tab
  1826 *-* If model=1
       *-*  Then
       *-*  class="M"ssid||type||charopt
  1827 *-* Else
       *-*  class="M"classmnt||type||charopt
  1829 *-* extra = ''      /* default */
  1830 *-* dbowner = owner /* default */
  1832 *-* Rdef$Permit = 'RDEF' /* all output to rdef datasets */
  1833 *-* /* --------------------------- */
  1834 *-* useClass = class
  1836 *-* /* create "backstop" so that everything else is rejected */
  1837 *-* /* ----------------------------------------------------- */
  1838 *-* x = clistCard(' ')
  1839 *-* cmd='/* create backstop RDEF (in def_priv: routine) */'
  1840 *-* x = clistCard(cmd)
  1842 *-* If model=1
       *-*  Then
       *-*  prof='*.'auth
  1843 *-* Else
       *-*  prof=ssid'.*.'auth
  1845 *-* if tab  = 'DB'
  1846 *-*  then
       *-*  extra = "DATA('Backstop "auth "for ssid("ssid") database(*)')"
  1847 *-* else
       *-*  if tab  = 'PLAN'
  1848 *-*   then
       *-*   extra = "DATA('Backstop "auth "for ssid("ssid") plan(*)'"
  1850 *-* prof = left(prof,max(24,length(prof)))
  1851 *-* cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                            extra /*rph*/
  1854 *-* x = clistCard(cmd)
  1856 *-* /* Find all objects, and make commands to create profiles */
  1857 *-* /* for 'auth'. Then remove executor from access list.     */
  1858 *-* /* if selecting from SYSIBM.SYSDBAUTH, exclude implicit db's*/
  1859 *-* x=sql('NEW statement') /* start new sql statement */
  1860 *-* /* ----------------------- */
  1861 *-* x=sql("SELECT DISTINCT strip(a.NAME) as name"      )
  1862 *-* x=sql("   FROM SYSIBM.SYS"tab"AUTH as a"           )
  1864 *-* if tab = 'DB'
  1865 *-*  then
       *-*  do
  1866 *-*   x=sql("       ,SYSIBM.SYSDATABASE as b"            )
  1867 *-*   x=sql("   WHERE a.name = b.name"                   )
  1868 *-*   x=sql("     and b.implicit = 'N'"                  )
  1869 *-*  end
  1871 *-* x=sql("   order by name"                           )
  1873 *-* call ZSQL
  1875 *-* rowsReturned = 0
  1876 *-* Do Until SQLCODE \= 0
  1877 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :name"
  1878 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  1879 *-*    rowsReturned = rowsReturned + 1
  1880 *-*    parse upper var name name .
  1881 *-*    If model=1
       *-*     Then
       *-*     prof=name'.'auth
  1882 *-*    Else
       *-*     prof=ssid'.'name'.'auth
  1884 *-*    if tab  = 'DB'
  1885 *-*     then
       *-*     extra = "DATA('"auth "for ssid("ssid") database(" ,                                    ||name"')" /* rph */
  1887 *-*    else
       *-*     if tab  = 'PLAN'
  1888 *-*      then
       *-*      extra = "DATA('"auth "for ssid("ssid") plan(" ,                                        ||name"')" /* rph */
  1891 *-*    prof = left(prof,max(24,length(prof)))
  1892 *-*    cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                               extra /*rph*/
  1895 *-*    x = clistCard(cmd)
  1897 *-*    cmd="PERMIT "prof" CLASS("class") RESET"
  1898 *-*    if resetOption = 'RESET'
       *-*     then
       *-*     x = clistCard(cmd)
  1899 *-*   End
  1900 *-* End /* do until */
  1901 *-* call showRowCount /* show rowsReturned */
  1902 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  1903 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  1904 *-* address dsnrexx "EXECSQL CLOSE C1"
  1905 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  1907 *-*  /* If any of those were PUBLIC, change UACC to READ */
  1908 *-*  /* if selecting from SYSIBM.SYSDBAUTH, exclude implicit db's*/
  1909 *-* x=sql('NEW statement') /* start new sql statement */
  1910 *-* /* ----------------------- */
  1911 *-* x=sql("SELECT DISTINCT strip(a.NAME) as name"        )
  1912 *-* x=sql("   FROM SYSIBM.SYS"tab"AUTH as a"             )
  1914 *-* if tab = 'DB'
  1915 *-*  then ,
  1916 *-*  x=sql("       ,SYSIBM.SYSDATABASE AS b"              )
  1918 *-* x=sql("WHERE a.GRANTEE IN ('PUBLIC','PUBLIC*')"      )
  1919 *-* x=sql("  AND a."col"=' '"                           )
  1921 *-* if tab = 'DB'
  1922 *-*  then
       *-*  do
  1923 *-*   x=sql("  and a.name = b.name"                        )
  1924 *-*   x=sql("  and b.implicit = 'N'"                       )
  1925 *-*  end
  1927 *-* x=sql("order by name"                                )
  1929 *-* call ZSQL
  1931 *-* rowsReturned = 0
  1932 *-* Do Until SQLCODE \= 0
  1933 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :name"
  1934 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  1935 *-*    rowsReturned = rowsReturned + 1
  1936 *-*    parse upper var name name .
  1937 *-*    if tab  = 'DB'
  1938 *-*     then
       *-*     extra = "DATA('Everyone has" auth "for ssid("ssid")",                                 "database("name"')" /* rph */
  1940 *-*    else
       *-*     if tab  = 'PLAN'
  1941 *-*      then
       *-*      extra = "DATA('Everyone has" auth "for ssid("ssid")" ,                                "plan("name"')" /* rph */
  1943 *-*    If model=1
       *-*     Then
       *-*     prof=name'.'auth
  1944 *-*    Else
       *-*     prof=ssid'.'name'.'auth
  1945 *-*    prof = left(prof,max(35,length(prof)))
  1946 *-*    cmd="RALT "class prof" UACC(READ)" extra
  1947 *-*    x = clistCard(cmd)
  1948 *-*   End
  1949 *-* End /* do until */
  1950 *-* call showRowCount /* show rowsReturned */
  1951 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  1952 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  1953 *-* address dsnrexx "EXECSQL CLOSE C1"
  1954 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  1956 *-* Rdef$Permit = 'PERMIT' /* all output to permit datasets */
  1957 *-* /* --------------------------- */
  1959 *-* /* Get all ids (except PUBLIC) for access list */
  1960 *-* x=sql('NEW statement') /* start new sql statement */
  1961 *-* /* ----------------------- */
  1962 *-* x=sql("SELECT DISTINCT strip(a.NAME) as name," granteeCase           )
  1963 *-* x=sql("FROM SYSIBM.SYS"tab"AUTH as a"                                )
  1965 *-* if tab = 'DB'
  1966 *-*  then ,
  1967 *-*  x=sql("       ,SYSIBM.SYSDATABASE AS b"              )
  1969 *-* x=sql("WHERE a.GRANTEE NOT IN ('PUBLIC','PUBLIC*')"                  )
  1970 *-* x=sql("  AND a."col"<>' '"                                           )
  1971 *-* if SlimAdm
  1972 *-*  then
       *-*  do
  1973 *-*   x=sql("  AND a.grantee not in ("                                     )
  1974 *-*   x=sql("       select distinct b.grantee from sysibm.sysuserauth as b")
  1975 *-*   x=sql("       where b.sysadmAuth <> ' '" ,                           )
  1976 *-*   x=sql("                       )"                                     )
  1977 *-*  end
  1979 *-* if RemoveUserList <> ''
  1980 *-*  then ,
  1981 *-*  x=sql("  AND a.grantee not in" RemoveUserList                        )
  1983 *-* if tab = 'DB'
  1984 *-*  then
       *-*  do
  1985 *-*   x=sql("  and a.name = b.name"                        )
  1986 *-*   x=sql("  and b.implicit = 'N'"                       )
  1987 *-*  end
  1989 *-* x=sql("ORDER BY NAME, GRANTEE"                                       )
  1991 *-* call ZSQL
  1993 *-* rowsReturned = 0
  1994 *-* Do Until SQLCODE \= 0
  1995 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :name, :grantee"
  1996 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  1997 *-*    rowsReturned = rowsReturned + 1
  1998 *-*    parse upper var name name .
  1999 *-*    parse upper var grantee grantee .
  2000 *-*    If model=1
       *-*     Then
       *-*     prof=name'.'auth
  2001 *-*    Else
       *-*     prof=ssid'.'name'.'auth
  2002 *-*    prof = left(prof,max(35,length(prof)))
  2003 *-*    access = 'ACC(READ)'
  2004 *-*    cmd="PERMIT "prof" CLASS("class")" access "ID("grantee")"
  2005 *-*    x = clistCard(cmd)
  2006 *-*   End
  2007 *-* End /* do until */
  2008 *-* call showRowCount /* show rowsReturned */
  2009 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  2010 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  2011 *-* address dsnrexx "EXECSQL CLOSE C1"
  2012 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  2014 *-* Return    /* def_priv */
  2016 *-* tab_priv:
  2017 *-* /*****************************************************************/
  2018 *-* /* Get DB2 Tables privileges                                     */
  2019 *-* /*****************************************************************/
  2020 *-* /* this routine is (still) necessary for the SQL and data collection*/
  2021 *-* /* ... but it will no longer generate the RACF commands.            */
  2022 *-* /* ... RACF commands will be generated by tab_privRH                */
  2023 *-* Arg auth,col
  2026 *-* If model=1
       *-*  Then
       *-*  class="M"ssid"TB"charopt
  2027 *-* Else
       *-*  class="M"classmnt"TB"charopt
  2029 *-* Rdef$Permit = 'RDEF' /* all output to rdef datasets */
  2030 *-* /* --------------------------- */
  2031 *-* useClass = class
  2033 *-* /* comment as to why we are re-issuing the same sql */
  2034 *-* /* ------------------------------------------------ */
  2035 *-* Rdef$Permit = 'RDEF' /* all output to rdef datasets */
  2036 *-* /* --------------------------- */
  2037 *-* x = clistCard(' ')
  2038 *-* cmd='/* --------------------------------------------------- */'
  2039 *-* x = clistCard(cmd)
  2040 *-* cmd='/* Entering routine tab_priv: for auth='auth 'col='col '*/'
  2041 *-* x = clistCard(cmd)
  2042 *-* cmd='/* Entering routine tab_priv: for auth='auth 'col='col '*/'
  2043 *-* x = clistCard(cmd)
  2044 *-* cmd='/* --------------------------------------------------- */'
  2045 *-* x = clistCard(cmd)
  2047 *-* Rdef$Permit = 'PERMIT' /* all output to pe$ datasets */
  2048 *-* /* -------------------------- */
  2049 *-* x = clistCard(' ')
  2050 *-* cmd='/* --------------------------------------------------- */'
  2051 *-* x = clistCard(cmd)
  2052 *-* cmd='/* Entering routine tab_priv: for auth='auth 'col='col '*/'
  2053 *-* x = clistCard(cmd)
  2054 *-* cmd='/* Entering routine tab_priv: for auth='auth 'col='col '*/'
  2055 *-* x = clistCard(cmd)
  2056 *-* cmd='/* --------------------------------------------------- */'
  2057 *-* x = clistCard(cmd)
  2059 *-* Rdef$Permit = 'RDEF' /* all output to rdef datasets */
  2060 *-* /* --------------------------- */
  2062 *-* if auth = 'INIT' /*initialization */
  2063 *-*  then
       *-*  do
  2064 *-*   /* part of init... collect info on ignored table grantees */
  2065 *-*   ignoredTableGrantee. = 0 /* by default, not in our list */
  2066 *-*   ignoredTableGranteeList = '' /* be default list of ignored */
  2067 *-*   /* grantee's                  */
  2068 *-*   packageTableGrantee. = 0 /* by default, not in our list */
  2069 *-*   packageTableGranteeList = '' /* be default list of missing */
  2070 *-*   /* racf userid/groups         */
  2072 *-*   /* unknown package.owner will = 0 */
  2073 *-*   /*   known package.owner will = 1 */
  2074 *-*   /* after 'init' finishes          */
  2075 *-*   x = clistCard(' ')
  2076 *-*   cmd='/* For tab_priv (init), we want to know package owners*/'
  2077 *-*   x = clistCard(cmd)
  2078 *-*   cmd='/*    used in future tab_priv calls.                  */'
  2079 *-*   x = clistCard(cmd)
  2080 *-*   x = clistCard(' ')
  2082 *-*   x=sql('NEW statement') /* start new sql statement */
  2083 *-*   /* ----------------------- */
  2084 *-*   x=sql("select distinct strip(upper(owner)) as owner"      )
  2085 *-*   x=sql("   from sysibm.syspackage"                         )
  2086 *-*   x=sql("   order by owner"                                 )
  2088 *-*   call ZSQL
  2090 *-*   packageOwner. = 0
  2091 *-*   rowsReturned = 0
  2092 *-*   Do Until SQLCODE \= 0
  2093 *-*    address dsnrexx "EXECSQL FETCH C1 INTO :packageOwner"
  2094 *-*    If SQLCODE = 0
  2095 *-*     then
       *-*     do
  2096 *-*      rowsReturned = rowsReturned + 1
  2097 *-*      parse upper var packageOwner packageOwner .
  2098 *-*      packageOwner.packageOwner = 1
  2099 *-*     end
  2100 *-*   End /* do until */
  2101 *-*   call showRowCount /* show rowsReturned */
  2102 *-*   If SQLCODE=0 | SQLCODE=100
       *-*    Then
       *-*    nop
  2103 *-*   Else
       *-*    call prtsqlca 'FETCH C1'
  2104 *-*   address dsnrexx "EXECSQL CLOSE C1"
  2105 *-*   If SQLCODE \= 0
       *-*    Then
       *-*    call prtsqlca 'CLOSE C1'
  2106 *-*    /* finished initiaiization - part 1 */
  2108 *-*    /* part 2 - capture information about any updateable views */
  2109 *-*    /*    if view is updateable, associate view name w/table name*/
  2110 *-*   x = clistCard(' ')
  2111 *-*   cmd='/* For tab_priv (init), get info on updatable views */'
  2112 *-*   x = clistCard(cmd)
  2113 *-*   cmd='/*    used in future tab_priv calls                 */'
  2114 *-*   x = clistCard(cmd)
  2115 *-*   x = clistCard(' ')
  2117 *-*   x=sql('NEW statement') /* start new sql statement */
  2118 *-*   /* ----------------------- */
  2119 *-*   x=sql('select distinct'                         )
  2120 *-*   x=sql('    tb.creator  as viewCreator'          )
  2121 *-*   x=sql('   ,tb.name     as viewName'             )
  2122 *-*   x=sql('   ,dp.bcreator as tableCreator'         )
  2123 *-*   x=sql('   ,dp.bname    as tableName'            )
  2124 *-*   x=sql('from sysibm.systables  as tb'            )
  2125 *-*   x=sql('    ,sysibm.sysviewdep as dp'            )
  2126 *-*   x=sql("where tb.type = 'V'"                     )
  2127 *-*   x=sql("  and dp.btype= 'T'"                     )
  2128 *-*   x=sql("  and tb.creator = dp.dcreator"          )
  2129 *-*   x=sql("  and tb.name    = dp.dname"             )
  2130 *-*   x=sql("order by tb.creator"                     )
  2131 *-*   x=sql("        ,tb.name"                        )
  2132 *-*   x=sql("        ,dp.bcreator"                    )
  2133 *-*   x=sql("        ,dp.bname"                       )
  2135 *-*   call ZSQL
  2137 *-*   view2table. = '' /* default it's not a view, set to null    */
  2138 *-*   /* for single table views...               */
  2139 *-*   /*        view2table.viewCreator.ViewName  */
  2140 *-*   /*             will be set to:             */
  2141 *-*   /*                tableCreator'.'tablename */
  2142 *-*   /* for multi-table views...                */
  2143 *-*   /*        view2table.viewCreator.ViewName  */
  2144 *-*   /*             will be set to:             */
  2145 *-*   /*                <null string>            */
  2146 *-*   SingleTableInView.   = 0 /* by default = 0, not a view at all*/
  2147 *-*   /* set to 1, if a single table view*/
  2148 *-*   /* set to 2, if a  multi-table view*/
  2149 *-*   lastCount = 0
  2150 *-*   previousViewCreator  = ''
  2151 *-*   previousViewName     = ''
  2152 *-*   rowsReturned = 0
  2153 *-*   Do Until SQLCODE \= 0
  2154 *-*    address dsnrexx ,                                                       "EXECSQL FETCH C1 INTO :viewCreator,  :ViewNa
me"  ,                                         ", :tableCreator, :TableName"
  2157 *-*    If SQLCODE = 0
  2158 *-*     then
       *-*     do
  2159 *-*      rowsReturned = rowsReturned + 1
  2160 *-*      parse upper var viewCreator viewCreator .
  2161 *-*      parse upper var viewName    viewName    .
  2162 *-*      parse upper var tableCreator tableCreator .
  2163 *-*      parse upper var tableName    tableName    .
  2164 *-*      if previousViewCreator = viewCreator ,                                   & previousViewName    = viewName
  2166 *-*       then
       *-*       do
  2167 *-*        /* singleTableInView.viewCreator.ViewName should be */
  2168 *-*        /*    = 0 (not a view at all, default)              */
  2169 *-*        /*    = 1 (a single table view)                     */
  2170 *-*        /*    = 2 (a multi-table  view)                     */
  2171 *-*        SingleTableInView.viewCreator.viewName =2 /*mult. table */
  2173 *-*        /* reset, view2Table stem to null */
  2174 *-*        view2Table.viewCreator.viewName = ''
  2175 *-*        iterate
  2176 *-*       end
  2178 *-*       /* singleTableInView.viewCreator.ViewName should be */
  2179 *-*       /*    = 0 (not a view at all, default)              */
  2180 *-*       /*    = 1 (a single table view)                     */
  2181 *-*       /*    = 2 (a multi-table  view)                     */
  2183 *-*       /* now assume, it's a single table view */
  2184 *-*      SingleTableInView.viewCreator.viewName =1/*single table view*/
  2186 *-*      /* remember previous view */
  2187 *-*      previousViewCreator  = viewCreator
  2188 *-*      previousViewName     = viewName
  2190 *-*      /* for single table views, remember table creator + name*/
  2191 *-*      view2Table.viewCreator.viewName = ,                                                   tableCreator || '.' || tableN
ame
  2193 *-*      trace 'n'
  2194 *-*      iterate
  2195 *-*     end
  2196 *-*   End /* do until */
  2198 *-*   /*xxx*/ say 'singleTableInView.DISETS.VEAC0E="' ,                       /*xxx*/    ||singleTableInView.DISETS.VEAC0E'"
'
  2200 *-*   /*xxx*/ say 'view2Table.DISETS.VEAC0E="' ,                              /*xxx*/    ||view2Table.DISETS.VEAC0E'"'
  2203 *-*   call showRowCount /* show rowsReturned */
  2204 *-*   If SQLCODE=0 | SQLCODE=100
       *-*    Then
       *-*    nop
  2205 *-*   Else
       *-*    call prtsqlca 'FETCH C1'
  2206 *-*   address dsnrexx "EXECSQL CLOSE C1"
  2207 *-*   If SQLCODE \= 0
       *-*    Then
       *-*    call prtsqlca 'CLOSE C1'
  2210 *-*    /* finished initiaiization */
  2211 *-*   x = clistCard(' ')
  2212 *-*   cmd='/* For tab_priv auth='auth 'processing is complete */'
  2213 *-*   x = clistCard(cmd)
  2214 *-*   x = clistCard(' ')
  2216 *-*   return
  2217 *-*  end
  2219 *-*  /* create "backstop" so that everything else is rejected */
  2220 *-*  /* ----------------------------------------------------- */
  2221 *-* x = clistCard(' ')
  2222 *-* cmd='/* create backstop RDEF (in tab_priv: for auth='auth') */'
  2223 *-* x = clistCard(cmd)
  2224 *-* x = clistCard(' ')
  2226 *-* if auth = 'VIEW_INSERT' | auth = 'VIEW_UPDATE' | auth = 'VIEW_DELETE'
  2227 *-*  then
       *-*  do /* we need backstop created for views as well */
  2228 *-*   If model=1
       *-*    Then
       *-*    prof='*.*.*.*'
  2229 *-*   Else
       *-*    prof=ssid'.*.*.*.*'
  2230 *-*   tcreator = strip(tcreator)
  2231 *-*   ssidTable = prof
  2232 *-*   prof=prof'.'substr(auth,6) /* strip off 'VIEW_' from auth */
  2233 *-*   prof= left(prof,max(41,length(prof)))
  2234 *-*   data='Backstop for' substr(auth,6) ,                                                       'on view(s) *.*.*.*.'substr
(auth,6)
  2237 *-*   cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                                "DATA('"data"')"
  2240 *-*   x = clistCard(' ')
  2242 *-*   x = clistCard(cmd)
  2243 *-*  end
  2244 *-* else
       *-*  do /* we need backstop for this auth */
  2245 *-*   If model=1
       *-*    Then
       *-*    prof='*.*'
  2246 *-*   Else
       *-*    prof=ssid'.*.*'
  2247 *-*   tcreator = strip(tcreator)
  2248 *-*   ssidTable = prof
  2249 *-*   prof=prof'.'auth
  2250 *-*   prof= left(prof,max(41,length(prof)))
  2251 *-*   data='Backstop for' auth 'on table(s) *.*.'auth
  2253 *-*   cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                                "DATA('"data"')"
  2256 *-*   x = clistCard(' ')
  2258 *-*   x = clistCard(cmd)
  2259 *-*  end
  2261 *-* FewTables4Creator. = 1 /* assume everything is explcit */
  2262 *-* if (genericOption = 'GENERIC' | genericOption = 'GENERICNOAUDIT') ,      & auth <> 'VIEW_INSERT' , /* must be explicit;
generic ignored */       & auth <> 'VIEW_UPDATE' , /* must be explicit; generic ignored */       & auth <> 'VIEW_DELETE'   /* must
be explicit; generic ignored */
  2266 *-*  then
       *-*  do /* identify some tables we believe could have generic rules*/
  2267 *-*   x = clistCard(' ')
  2268 *-*   cmd='/* collect info 4 GENERIC/GENERICNOAUDIT for auth='auth') */'
  2269 *-*   x = clistCard(cmd)
  2270 *-*   x = clistCard(' ')
  2272 *-*   x=sql('NEW statement') /* start new sql statement */
  2273 *-*   /* ----------------------- */
  2274 *-*   x=sql('   Select tcreator, grantee, count(*)'            )
  2275 *-*   x=sql('   from (select distinct'                         )
  2276 *-*   x=sql('             a.tcreator'                          )
  2277 *-*   x=sql('            ,a.ttname'                            )
  2278 *-*   x=sql("            ,'PUBLIC' as grantee"                 )
  2279 *-*   x=sql('         from sysibm.systabauth as a'             )
  2280 *-*   x=sql("         where a.granteetype=' '"                 )
  2281 *-*   x=sql("           and a."col "<> ' '"                    )
  2283 *-*   if auth = 'UPDATE'
  2284 *-*    then ,
  2285 *-*    x=sql("           and a.updateCols = ' '"                )
  2287 *-*   if auth = 'REFERENCES'
  2288 *-*    then ,
  2289 *-*    x=sql("           and a.refCols = ' '"                   )
  2291 *-*   x=sql("           and exists"                            )
  2292 *-*   x=sql("             ("                                   )
  2293 *-*   x=sql("              select 1"                           )
  2294 *-*   x=sql("              from sysibm.systabauth as b"        )
  2295 *-*   x=sql("              where b.granteeType = ''"           )
  2296 *-*   x=sql("                and b."col "<> ' '"               )
  2298 *-*   if auth = 'UPDATE'
  2299 *-*    then ,
  2300 *-*    x=sql("                and b.updateCols = ' '"           )
  2302 *-*   if auth = 'REFERENCES'
  2303 *-*    then ,
  2304 *-*    x=sql("                and b.refCols = ' '"              )
  2306 *-*   x=sql("                and a.tcreator = b.tcreator"      )
  2307 *-*   x=sql("                and a.ttname   = b.ttname"        )
  2308 *-*   x=sql("                and (   b.grantee = 'PUBLIC' "    )
  2309 *-*   x=sql("                     or b.grantee = 'PUBLIC*'"    )
  2310 *-*   x=sql("                    )"                            )
  2311 *-*   x=sql("             )"                                   )
  2312 *-*   x=sql("        )"                                        )
  2313 *-*   x=sql('   group by tcreator, grantee'                    )
  2314 *-*   x=sql('union'                                            )
  2315 *-*   x=sql('   Select tcreator, grantee, count(*)'            )
  2316 *-*   x=sql('   from (select distinct'                         )
  2317 *-*   x=sql('             a.tcreator'                          )
  2318 *-*   x=sql('            ,a.ttname'                            )
  2319 *-*   x=sql("            ,'ATOTAL' as grantee"                 )
  2320 *-*   x=sql('         from sysibm.systabauth as a'             )
  2321 *-*   x=sql("         where a.granteetype=' '"                 )
  2322 *-*   x=sql("           and a."col "<> ' '"                    )
  2323 *-*   x=sql("        )"                                        )
  2324 *-*   x=sql('   group by tcreator, grantee'                    )
  2325 *-*   x=sql('order by tcreator, grantee'                       )
  2327 *-*   call ZSQL
  2329 *-*   lastCreator = ''
  2330 *-*   lastCount = 0
  2331 *-*   rowsReturned = 0
  2332 *-*   Do Until SQLCODE \= 0
  2333 *-*    address dsnrexx ,                                                       "EXECSQL FETCH C1 INTO :tcreator, :grantee, :
countx"
  2335 *-*    If SQLCODE = 0
  2336 *-*     then
       *-*     do
  2337 *-*      rowsReturned = rowsReturned + 1
  2338 *-*      parse upper var tcreator tcreator .
  2339 *-*      parse upper var grantee  grantee  .
  2340 *-*      if tcreator = lastCreator
  2341 *-*       then
       *-*       do /* we have total count + public tables */
  2342 *-*        if lastCount = countx , /* all public tables? */                         & countx >= 5
  2344 *-*         then
       *-*         do /* create a generic creator.*.priv uacc(Read)*/
  2345 *-*          /* create generic one */
  2346 *-*          /* ensure we don't create any more for creator*/
  2347 *-*          fewTables4Creator.Tcreator = -1 /* indicate skip */
  2349 *-*          If model=1
       *-*           Then
       *-*           prof=Strip(tcreator)'.*'
  2350 *-*          Else
       *-*           prof=ssid'.'Strip(tcreator)'.*'
  2351 *-*          tcreator = strip(tcreator)
  2352 *-*          ssidTable = prof
  2353 *-*          prof=prof'.'auth
  2354 *-*          prof= left(prof,max(41,length(prof)))
  2355 *-*          data='Everyone has' auth 'on table(s)' tcreator'.*'
  2357 *-*          x = clistCard(' ')
  2358 *-*          cmd="RDEF "class prof" UACC(READ) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                                       "DATA('"data"')"
  2362 *-*          x = clistCard(cmd)
  2364 *-*          cmd="PERMIT "prof" CLASS("class") RESET"
  2365 *-*          if resetOption = 'RESET'
       *-*           then
       *-*           x = clistCard(cmd)
  2366 *-*          trace 'n'
  2367 *-*          iterate
  2368 *-*         end
  2369 *-*        if lastCount < 5
  2370 *-*         then
       *-*         fewTables4Creator.Lastcreator = 1
  2371 *-*        else
       *-*         fewTables4Creator.Lastcreator = lastCount
  2373 *-*        lastGrantee = grantee /* set to "PUBLIC" */
  2375 *-*        trace 'n'
  2376 *-*        iterate
  2377 *-*       end
  2378 *-*      else
       *-*       if lastGrantee = 'ATOTAL' /* no public tables then */
  2379 *-*        then
       *-*        do
  2380 *-*         if lastCount < 5
  2381 *-*          then
       *-*          fewTables4Creator.Lastcreator = 1
  2382 *-*         else
       *-*          fewTables4Creator.Lastcreator = lastCount
  2383 *-*        end
  2384 *-*        /* by implication (different creators) grantee is "ATOTAL"*/
  2385 *-*        /* ...the current row is for "ATOTAL", save info.         */
  2386 *-*      lastCreator = tcreator
  2387 *-*      lastCount   = countx
  2388 *-*      lastGrantee = grantee
  2389 *-*      trace 'n'
  2390 *-*      iterate /* we have "ATOTAL" count, look for "PUBLIC" */
  2391 *-*     end
  2392 *-*   End /* do until */
  2393 *-*   call showRowCount /* show rowsReturned */
  2394 *-*   If SQLCODE=0 | SQLCODE=100
       *-*    Then
       *-*    nop
  2395 *-*   Else
       *-*    call prtsqlca 'FETCH C1'
  2396 *-*   address dsnrexx "EXECSQL CLOSE C1"
  2397 *-*   If SQLCODE \= 0
       *-*    Then
       *-*    call prtsqlca 'CLOSE C1'
  2399 *-*    /* handle last pending row, if any*/
  2400 *-*   if lastGrantee = 'ATOTAL' /* no public tables then */
  2401 *-*    then
       *-*    do
  2402 *-*     if lastCount < 5
  2403 *-*      then
       *-*      fewTables4Creator.Lastcreator = 1
  2404 *-*     else
       *-*      fewTables4Creator.Lastcreator = lastCount
  2405 *-*    end
  2406 *-*   trace 'n'
  2408 *-*   /* finished identifying potential generic processing */
  2409 *-*  end
  2411 *-*  /*sql="SELECT DISTINCT TCREATOR, TTNAME FROM SYSIBM.SYSTABAUTH", */
  2412 *-*  /*  "WHERE GRANTEETYPE=' '"                                    , */
  2413 *-*  /*  "ORDER BY TCREATOR, TTNAME"                                  */
  2415 *-*  /* Find out if table is being audited, in addition to normal info*/
  2416 *-*  /*     and tables that are public for 'col' (updateauth, etc)    */
  2417 *-*  /*     for PUBLIC access:  generate RACF code now.               */
  2418 *-*  /*     -----------------                                         */
  2419 *-*  /* Note:  for tables with PUBLIC access ignore GENERIC and/or    */
  2420 *-*  /*     GENERICNOAUDIT, and generate specific RDEF for public     */
  2421 *-*  /*     access.                                                   */
  2422 *-*  /* --------------------------------------------------------------*/
  2423 *-* x = clistCard(' ')
  2424 *-* cmd='/* Generate RDEF 4 tables with PUBLIC access 4 auth='auth' ) */'
  2425 *-* x = clistCard(cmd)
  2426 *-* cmd='/*    note:  additional grants for tables with public ) */'
  2427 *-* x = clistCard(cmd)
  2428 *-* cmd='/*          access will not be generated.               */'
  2429 *-* x = clistCard(cmd)
  2430 *-* x = clistCard(' ')
  2432 *-* x=sql('NEW statement') /* start new sql statement */
  2433 *-* /* ----------------------- */
  2434 *-* x=sql("SELECT DISTINCT A.TCREATOR, A.TTNAME, B.AUDITING, B.DBNAME" )
  2435 *-* x=sql("FROM SYSIBM.SYSTABAUTH AS A"                                )
  2436 *-* x=sql("    ,SYSIBM.SYSTABLES  AS B"                                )
  2437 *-* x=sql("WHERE A.GRANTEETYPE=' '"                                    )
  2438 *-* x=sql("  AND A.TCREATOR = B.CREATOR"                               )
  2439 *-* x=sql("  AND A.TTNAME   = B.NAME"                                  )
  2440 *-* x=sql("  AND A."col" <> ' '"                                       )
  2442 *-* if   auth='VIEW_INSERT' | auth='VIEW_UPDATE' | auth='VIEW_DELETE'
  2443 *-*  then ,
  2444 *-*  x=sql("  and b.type     = 'V'"                  )
  2447 *-* if auth = 'UPDATE'
  2448 *-*  then ,
  2449 *-*  x=sql("  AND A.UPDATECOLS = ' '"                                   )
  2451 *-* if auth = 'REFERENCES'
  2452 *-*  then ,
  2453 *-*  x=sql("  and A.refCols = ' '"                                      )
  2455 *-* x=sql("  AND exists ("                                             )
  2456 *-* x=sql("        select 1 from sysibm.systabauth as c"               )
  2457 *-* x=sql("           where c.tcreator = a.tcreator"                   )
  2458 *-* x=sql("             and c.ttname   = a.ttname"                     )
  2459 *-* x=sql("             and c."col" <> ' '"                            )
  2461 *-* if auth = 'UPDATE'
  2462 *-*  then ,
  2463 *-*  x=sql("             and c.UPDATECOLS = ' '"                        )
  2465 *-* if auth = 'REFERENCES'
  2466 *-*  then ,
  2467 *-*  x=sql("             and c.refCols = ' '"                           )
  2469 *-* x=sql("             and (   grantee = 'PUBLIC'"                    )
  2470 *-* x=sql("                  or grantee = 'PUBLIC*')"                  )
  2471 *-* x=sql("             )"                                             )
  2472 *-* x=sql("ORDER BY TCREATOR, TTNAME"                                  )
  2474 *-* call ZSQL
  2476 *-* rowsReturned = 0
  2477 *-* Do Until SQLCODE \= 0
  2478 *-*  address dsnrexx ,                                                       "EXECSQL FETCH C1 INTO :tcreator, :ttname, :aud
iting, :dbname"
  2480 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  2481 *-*    rowsReturned = rowsReturned + 1
  2482 *-*    parse upper var tcreator tcreator .
  2483 *-*    parse upper var ttname   ttname   .
  2484 *-*    parse upper var dbname   dbname   .
  2486 *-*    if FewTables4Creator.tcreator =-1 /* skip; creator.* is     */
  2487 *-*     then
       *-*     iterate                      /*       ...already generic*/
  2489 *-*    if auth = 'VIEW_INSERT' ,                                                | auth = 'VIEW_UPDATE' ,
                            | auth = 'VIEW_DELETE'
  2492 *-*     then
       *-*     do /* get profile for an updatable view */
  2493 *-*      if singleTableInView.tcreator.ttname <> 1
  2494 *-*       then
       *-*       iterate /* not a single table view */
  2495 *-*      if view2table.tcreator.ttname = ''
  2496 *-*       then
       *-*       iterate /* seems impossible, but skip this then */
  2498 *-*       /* updatable view (and view from a single table) */
  2499 *-*       /* get table creator.name (table) for view */
  2500 *-*      tableCreatorDotName = view2table.tcreator.ttname
  2502 *-*      If model=1
       *-*       Then
       *-*       prof=tableCreatorDotName'.'tcreator'.'ttname
  2503 *-*      Else
       *-*       prof=ssid'.'tableCreatorDotName'.'tcreator'.'ttname
  2504 *-*      dbname = strip(dbname)
  2505 *-*      if left(tcreator,3) = 'DSN'
  2506 *-*       then
       *-*       dbowner = 'DB2ENGNR'
  2507 *-*      tcreator = strip(tcreator)
  2509 *-*      ssidTable = prof
  2510 *-*      prof=prof'.'substr(auth,6)
  2511 *-*      prof= left(prof,max(41,length(prof)))
  2512 *-*      /* generate rdef's for 'PUBLIC' access                  */
  2513 *-*      /* -----------------------------------                  */
  2515 *-*      if auditing <> ' '
  2516 *-*       then
       *-*       data='DB2 auditing view everyone has' substr(auth,6) ,                       'on single-table view' tcreator'.'ttn
ame
  2518 *-*      else
       *-*       data='Everyone has' substr(auth,6) 'on single-table' ,                       'view' tcreator"."strip(ttname)
  2520 *-*     end
  2521 *-*    else
       *-*     if singleTableInView.tcreator.ttname = 1 ,                               & (  auth = 'INSERT'                    ,
                                | auth = 'UPDATE'                    ,                                  | auth = 'DELETE'
          ,                                 )
  2526 *-*      then
       *-*      iterate /* let view_insert,view_update,View_delete handle*/
  2527 *-*     else
       *-*      if singleTableInView.tcreator.ttname = 2 ,                               & (  auth = 'INSERT'                    ,
                                 | auth = 'UPDATE'                    ,                                  | auth = 'DELETE'
           ,                                 )
  2532 *-*       then
       *-*       do /* generate rdef for multi-table view using i/u/d */
  2533 *-*        If model=1
       *-*         Then
       *-*         prof=Strip(tcreator)'.'Strip(ttname)
  2534 *-*        Else
       *-*         prof=ssid'.'Strip(tcreator)'.'Strip(ttname)
  2535 *-*        dbname = strip(dbname)
  2536 *-*        if left(tcreator,3) = 'DSN'
  2537 *-*         then
       *-*         dbowner = 'DB2ENGNR'
  2538 *-*        tcreator = strip(tcreator)
  2540 *-*        ssidTable = prof
  2541 *-*        prof=prof'.'auth
  2542 *-*        prof= left(prof,max(41,length(prof)))
  2543 *-*        /* generate rdef's for 'PUBLIC' access                  */
  2544 *-*        /* -----------------------------------                  */
  2546 *-*        if auditing <> ' '
  2547 *-*         then
       *-*         data='DB2 auditing on multi-table view' ,                                         strip(prof) 'everyone has' aut
h
  2549 *-*        else
       *-*         data='Everyone has' auth 'on multi-table view' ,                             tcreator"."strip(ttname)
  2551 *-*       end
  2552 *-*      else
       *-*       if singleTableInView.tcreator.ttname > 0
  2553 *-*        then
       *-*        do /* get profile for view(s) */
  2554 *-*         If model=1
       *-*          Then
       *-*          prof=Strip(tcreator)'.'Strip(ttname)
  2555 *-*         Else
       *-*          prof=ssid'.'Strip(tcreator)'.'Strip(ttname)
  2556 *-*         dbname = strip(dbname)
  2557 *-*         if left(tcreator,3) = 'DSN'
  2558 *-*          then
       *-*          dbowner = 'DB2ENGNR'
  2559 *-*         tcreator = strip(tcreator)
  2561 *-*         ssidTable = prof
  2562 *-*         prof=prof'.'auth
  2563 *-*         prof= left(prof,max(41,length(prof)))
  2564 *-*         /* generate rdef's for 'PUBLIC' access                  */
  2565 *-*         /* -----------------------------------                  */
  2567 *-*         if auditing <> ' '
  2568 *-*          then
       *-*          data='DB2 auditing view' strip(prof) 'everyone has' auth
  2569 *-*         else
       *-*          data='Everyone has' auth 'on view' ,                                         tcreator"."strip(ttname)
  2571 *-*        end
  2572 *-*       else
       *-*        do /* get profile for tables */
  2573 *-*         If model=1
       *-*          Then
       *-*          prof=Strip(tcreator)'.'Strip(ttname)
  2574 *-*         Else
       *-*          prof=ssid'.'Strip(tcreator)'.'Strip(ttname)
  2575 *-*         dbname = strip(dbname)
  2576 *-*         if left(tcreator,3) = 'DSN'
  2577 *-*          then
       *-*          dbowner = 'DB2ENGNR'
  2578 *-*         tcreator = strip(tcreator)
  2580 *-*         ssidTable = prof
  2581 *-*         prof=prof'.'auth
  2582 *-*         prof= left(prof,max(41,length(prof)))
  2583 *-*         /* generate rdef's for 'PUBLIC' access                  */
  2584 *-*         /* -----------------------------------                  */
  2586 *-*         if auditing <> ' '
  2587 *-*          then
       *-*          data='DB2 auditing on' strip(prof) 'everyone has' auth
  2588 *-*         else
       *-*          data='Everyone has' auth 'on table' ,                                        tcreator"."strip(ttname)
  2590 *-*        end
  2592 *-*    x = clistCard(' ')
  2593 *-*    cmd="RDEF "class prof" UACC(READ) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                                 "DATA('"data"')"
  2597 *-*    x = clistCard(cmd)
  2599 *-*    cmd="PERMIT "prof" CLASS("class") RESET"
  2600 *-*    if resetOption = 'RESET'
       *-*     then
       *-*     x = clistCard(cmd)
  2601 *-*   End
  2602 *-* End /* do until */
  2603 *-* call showRowCount /* show rowsReturned */
  2604 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  2605 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  2606 *-* address dsnrexx "EXECSQL CLOSE C1"
  2607 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  2609 *-*  /* ------------------------------------------- */
  2610 *-*  /* table info for generic processing           */
  2611 *-*  /* but initialize requardless of genericOption */
  2612 *-*  /* ------------------------------------------- */
  2613 *-* rphTable = 0
  2614 *-* rphtable. = ''            /* .# = creator.tablename */
  2615 *-* rphTableIndx. = 0         /* .creator.tablename = # */
  2616 *-* rphTableCreator = 0
  2617 *-* rphTableCreator. = ''     /* .#       = creator */
  2618 *-* rphTableCreatorIndx. = 0  /* .creator = list of table numbers*/
  2619 *-* rphTablePriv. = ''   /* .tableindx = list of userids */
  2620 *-* rphTableWGrant. = '' /* .tableindx = list of userids */
  2621 *-* /* note: we no longer set this to anything */
  2622 *-* /*       ...so although used in code later */
  2623 *-* /*          this is always null            */
  2624 *-* rphTableAuditing. = ' '
  2625 *-* rphTableSchemaGranteeCount. = 0 /* # of times grantee used */
  2626 *-* rphTableSchemaGranteeList.  ='' /* list of grantees        */
  2627 *-* /* end table info */
  2629 *-* /* --------------------------------------------------------------*/
  2630 *-* /* Find out if table is being audited, in addition to normal info*/
  2631 *-* /*     for non "public" tables.                                  */
  2632 *-* /*         ------------                                          */
  2633 *-* /* --------------------------------------------------------------*/
  2634 *-* x = clistCard(' ')
  2635 *-* cmd='/* Get information about non-Public tables 4 auth='auth' ) */'
  2636 *-* x = clistCard(cmd)
  2637 *-* cmd='/*    note:  audit info will be ignored if option       */'
  2638 *-* x = clistCard(cmd)
  2639 *-* cmd='/*          GENERICNOAUDIT is in effect.                */'
  2640 *-* x = clistCard(cmd)
  2641 *-* cmd='/*    note:  RDEF''s may be generated for non-generic    */'
  2642 *-* x = clistCard(cmd)
  2643 *-* cmd='/*          option, or for updatable views, and some for*/'
  2644 *-* x = clistCard(cmd)
  2645 *-* cmd='/*          table creators (with too few tables) etc.   */'
  2646 *-* x = clistCard(cmd)
  2647 *-* cmd='/*    otherwise, RDEFs and PERMITs are delayed until     */'
  2648 *-* x = clistCard(cmd)
  2649 *-* cmd='/*    the routine collapse_tab_privRH: generates them.   */'
  2650 *-* x = clistCard(cmd)
  2651 *-* x = clistCard(cmd)
  2652 *-* cmd='/*    Note:  genericOption in effect is' genericOption '*/'
  2653 *-* x = clistCard(' ')
  2655 *-* x=sql('NEW statement') /* start new sql statement */
  2656 *-* /* ----------------------- */
  2657 *-* x=sql("SELECT DISTINCT A.TCREATOR, A.TTNAME, B.AUDITING"        )
  2658 *-* x=sql("FROM SYSIBM.SYSTABAUTH AS A"                             )
  2659 *-* x=sql("    ,SYSIBM.SYSTABLES  AS B"                             )
  2660 *-* x=sql("WHERE A.GRANTEETYPE=' '"                                 )
  2661 *-* x=sql("  AND A.TCREATOR = B.CREATOR"                            )
  2662 *-* x=sql("  AND A.TTNAME   = B.NAME"                               )
  2663 *-* x=sql("  AND A."col" <> ' '"                                    )
  2665 *-* if      auth='VIEW_INSERT' | auth='VIEW_UPDATE' | auth='VIEW_DELETE'
  2666 *-*  then ,
  2667 *-*  x=sql("  and b.type     = 'V'"                  )
  2670 *-* if auth = 'UPDATE'
  2671 *-*  then ,
  2672 *-*  x=sql("  AND A.UPDATECOLS = ' '"                               )
  2674 *-* if auth = 'REFERENCES'
  2675 *-*  then ,
  2676 *-*  x=sql("  and A.refCols = ' '"                                  )
  2678 *-* x=sql("  AND not exists ("                                     )
  2679 *-* x=sql("            select 1 from sysibm.systabauth as c"       )
  2680 *-* x=sql("               where c.tcreator = a.tcreator"           )
  2681 *-* x=sql("                 and c.ttname   = a.ttname"             )
  2682 *-* x=sql("                 and c."col" <> ' '"                    )
  2684 *-* if auth = 'UPDATE'
  2685 *-*  then ,
  2686 *-*  x=sql("             and c.UPDATECOLS = ' '"                    )
  2688 *-* if auth = 'REFERENCES'
  2689 *-*  then ,
  2690 *-*  x=sql("             and c.refCols = ' '"                       )
  2692 *-* x=sql("                 and (   c.grantee = 'PUBLIC'"          )
  2693 *-* x=sql("                      or c.grantee = 'PUBLIC*')"        )
  2694 *-* x=sql("                 )"                                     )
  2695 *-* x=sql("ORDER BY TCREATOR, TTNAME"                              )
  2697 *-* call ZSQL
  2699 *-* rowsReturned = 0
  2700 *-* Do Until SQLCODE \= 0
  2701 *-*  address dsnrexx ,                                                       "EXECSQL FETCH C1 INTO :tcreator, :ttname, :aud
iting"
  2703 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  2704 *-*    rowsReturned = rowsReturned + 1
  2706 *-*    if genericOption = 'GENERICNOAUDIT'
  2707 *-*     then
       *-*     auditing = ' ' /* ignore auditing w/GENERICNOAUDIT */
  2709 *-*    parse upper var tcreator tcreator .
  2710 *-*    parse upper var ttname   ttname   .
  2711 *-*    if auth = 'VIEW_INSERT' ,                                                | auth = 'VIEW_UPDATE' ,
                            | auth = 'VIEW_DELETE'
  2714 *-*     then
       *-*     do /* special profile needed */
  2715 *-*      if singleTableInView.tcreator.ttname <> 1
  2716 *-*       then
       *-*       iterate /* ignore multi-table views */
  2718 *-*      if view2table.tcreator.ttname = ''
  2719 *-*       then
       *-*       iterate /* unbelievable, but true */
  2721 *-*      If model=1
       *-*       Then
       *-*       prof=view2table.tcreator.ttname ,                                            || '.'tcreator'.'ttname
  2723 *-*      Else
       *-*       prof=ssid'.'view2table.tcreator.ttname     ,                                            || '.'tcreator'.'ttname
  2725 *-*      dbname = strip(dbname)
  2726 *-*      tcreator = strip(tcreator)
  2727 *-*      ssidTable = prof
  2728 *-*      prof=prof'.'substr(auth,6)
  2729 *-*      prof= left(prof,max(41,length(prof)))
  2731 *-*      if auditing <> ' '
  2732 *-*       then
       *-*       data='DB2 auditing single-table view' tcreator'.'ttname
  2733 *-*      else
       *-*       data=substr(auth,6) 'privs on single-table view' ,                                                            tcre
ator'.'ttname
  2735 *-*     end
  2736 *-*    else
       *-*     if (  auth = 'INSERT' ,                                                     | auth = 'UPDATE' ,
                                | auth = 'DELETE' ,                                                    )                  ,
                                          & singleTableInView.tcreator.ttname = 1
  2741 *-*      then
       *-*      iterate /* view_Insert/view_update/view_delete does this */
  2742 *-*     else
       *-*      if singleTableInView.tcreator.ttname = 1
  2743 *-*       then
       *-*       do /* view profile */
  2744 *-*        If model=1
       *-*         Then
       *-*         prof=Strip(tcreator)'.'Strip(ttname)
  2745 *-*        Else
       *-*         prof=ssid'.'Strip(tcreator)'.'Strip(ttname)
  2746 *-*        dbname = strip(dbname)
  2747 *-*        tcreator = strip(tcreator)
  2748 *-*        ssidTable = prof
  2749 *-*        prof=prof'.'auth
  2750 *-*        prof= left(prof,max(41,length(prof)))
  2752 *-*        if auditing <> ' '
  2753 *-*         then
       *-*         data='DB2 auditing single-table view' tcreator'.'ttname
  2754 *-*        else
       *-*         data=auth 'privs on single-table view' tcreator'.'ttname
  2755 *-*       end
  2756 *-*      else
       *-*       if singleTableInView.tcreator.ttname = 2
  2757 *-*        then
       *-*        do /* view profile */
  2758 *-*         If model=1
       *-*          Then
       *-*          prof=Strip(tcreator)'.'Strip(ttname)
  2759 *-*         Else
       *-*          prof=ssid'.'Strip(tcreator)'.'Strip(ttname)
  2760 *-*         dbname = strip(dbname)
  2761 *-*         tcreator = strip(tcreator)
  2762 *-*         ssidTable = prof
  2763 *-*         prof=prof'.'auth
  2764 *-*         prof= left(prof,max(41,length(prof)))
  2766 *-*         if auditing <> ' '
  2767 *-*          then
       *-*          data='DB2 auditing multi-table view' tcreator'.'ttname
  2768 *-*         else
       *-*          data=auth 'privs on multi-table view' tcreator'.'ttname
  2769 *-*        end
  2770 *-*       else
       *-*        do /* table profile */
  2771 *-*         If model=1
       *-*          Then
       *-*          prof=Strip(tcreator)'.'Strip(ttname)
  2772 *-*         Else
       *-*          prof=ssid'.'Strip(tcreator)'.'Strip(ttname)
  2773 *-*         dbname = strip(dbname)
  2774 *-*         tcreator = strip(tcreator)
  2775 *-*         ssidTable = prof
  2776 *-*         prof=prof'.'auth
  2777 *-*         prof= left(prof,max(41,length(prof)))
  2779 *-*         if auditing <> ' '
  2780 *-*          then
       *-*          data='DB2 auditing table' tcreator'.'ttname
  2781 *-*         else
       *-*          data=auth 'privs on table' tcreator'.'ttname
  2782 *-*        end
  2784 *-*    if FewTables4Creator.tcreator = -1 /* skip all for creator */
  2785 *-*     then
       *-*     iterate
  2787 *-*    if FewTables4Creator.tcreator = 1 /* no generic or no reason */
  2788 *-*     then
       *-*     do                           /* or updateable view      */
  2789 *-*      /* either genericOption <> 'GENERIC' or too few tables */
  2790 *-*      /* in any case, generate explicit rule now.            */
  2792 *-*      cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                                 "DATA('"data"')"
  2795 *-*      x = clistCard(cmd)
  2797 *-*      cmd="PERMIT "prof" CLASS("class") RESET"
  2798 *-*      if resetOption = 'RESET'
       *-*       then
       *-*       x = clistCard(cmd)
  2799 *-*      iterate
  2800 *-*     end
  2802 *-*     /* potential to generate generic rules */
  2803 *-*     /* So, update table and don't generate any rules yet*/
  2804 *-*     /* table info */
  2805 *-*    if rphTableIndx.ssidTable = 0
  2806 *-*     then
       *-*     do
  2807 *-*      /* add entry to rphTable (and indx) for table */
  2808 *-*      rphTable = rphTable + 1
  2809 *-*      rphTable.rphTable = ssidTable
  2810 *-*      rphTableAuditing.rphTable = auditing
  2811 *-*      rphTableIndx.ssidTable = rphTable
  2812 *-*     end
  2813 *-*    tableNumber = rphTableIndx.ssidTable
  2815 *-*    /* creator info */
  2816 *-*    if rphTableCreatorIndx.tcreator = 0
  2817 *-*     then
       *-*     do
  2818 *-*      rphTableCreator = rphTableCreator + 1
  2819 *-*      rphTableCreator.rphTableCreator = tcreator
  2820 *-*      rphTableCreatorIndx.tcreator = rphTableCreator
  2821 *-*     end
  2822 *-*    CreatorNumber = rphTableCreatorIndx.tcreator
  2824 *-*    /* add to priv's we will use later */
  2825 *-*    /* ------------------------------- */
  2826 *-*    if wordpos(tableNumber,rphTableCreator.creatorNumber) = 0
  2827 *-*     then
       *-*     rphTableCreator.creatorNumber = ,                                          rphTableCreator.creatorNumber tableNumber
 /*add 2 list*/
  2830 *-*   End
  2831 *-* End /* do until */
  2832 *-* call showRowCount /* show rowsReturned */
  2833 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  2834 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  2835 *-* address dsnrexx "EXECSQL CLOSE C1"
  2836 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  2838 *-* rdef$PERMIT = 'PERMIT'
  2840 *-* /* Get all ids (except PUBLIC) for access list */
  2841 *-* /* rph - let's just view G or Y as 'Y'.                    */
  2842 *-* x = clistCard(' ')
  2843 *-* cmd='/* Get grant info for non-Public tables 4 auth='auth' ) */'
  2844 *-* x = clistCard(cmd)
  2845 *-* cmd='/*    note:  audit info will be ignored if option       */'
  2846 *-* x = clistCard(cmd)
  2847 *-* cmd='/*          GENERICNOAUDIT is in effect.                */'
  2848 *-* x = clistCard(cmd)
  2849 *-* cmd='/*    note:  PERMIT generated for non-generic option,    */'
  2850 *-* x = clistCard(cmd)
  2851 *-* cmd='/*          or for updatable views, and some for table  */'
  2852 *-* x = clistCard(cmd)
  2853 *-* cmd='/*          creators (with too few tables) etc.         */'
  2854 *-* x = clistCard(cmd)
  2855 *-* cmd='/*    otherwise, RDEFs and PERMITs are delayed until     */'
  2856 *-* x = clistCard(cmd)
  2857 *-* cmd='/*    the routine collapse_tab_privRH: generates them.   */'
  2858 *-* x = clistCard(cmd)
  2859 *-* x = clistCard(' ')
  2861 *-* /* change-06/06/2023                                          */
  2862 *-* /* 1) added a union statement ... to ensure creator of view   */
  2863 *-* /*   and/or table always appears at least once in the result  */
  2864 *-* /*   set.                                                     */
  2865 *-* /*    a)  Note:  this ensure at least one row appears for     */
  2866 *-* /*       tcreator and tname.  Thus, if when grants are        */
  2867 *-* /*       collapsed, we are ensured a table/view with no grants*/
  2868 *-* /*       will get it's own RDEF and will NOT fall into the    */
  2869 *-* /*       "default RDEF "ssid.creator.*.UPDATE" for example.   */
  2870 *-* /*                                                            */
  2871 *-* /*    b)  Note:  Although RDEF is created for table, no       */
  2872 *-* /*       permits will be issued for the table/view creator as */
  2873 *-* /*       RACF always grants access for the table/view creator.*/
  2874 *-* /*       The excess grant will be eliminated from the result  */
  2875 *-* /*       set by doing a rexx "iterate" and ignoring that      */
  2876 *-* /*       grant/permit.                                        */
  2877 *-* /*                                                            */
  2878 *-* /*    c)  There was a missing predicate, which allowed excess */
  2879 *-* /*       grantee's in result set.  That has been eliminated.  */
  2880 *-* /*       See line below with comment "missing predicate".     */
  2881 *-* /*       Of course, looking in the RDEFTB dataset you will    */
  2882 *-* /*       see both the rexx lines below AND the resulting      */
  2883 *-* /*       sql that was actually "resolved" and executed.       */
  2884 *-* /*                                                            */
  2885 *-* /*    d)  Rexx code will ensure all single-table view RDEFs   */
  2886 *-* /*       are explicitly created for "VIEW_INSERT",            */
  2887 *-* /*       "VIEW_UPDATE" and "VIEW_DELETE" calls.  The primary  */
  2888 *-* /*       reason being that it is doubtful that it would reduce*/
  2889 *-* /*       any RDEFs anyway.  And therefore any additional      */
  2890 *-* /*       complications are simply avoided.                    */
  2891 *-* /*        However, single-table views ignored by INSERT,      */
  2892 *-* /*       UPDATE and DELETE calls; and will be handled by      */
  2893 *-* /*       VIEW_INSERT, VIEW_UPDATE and VIEW_DELETE instead.    */
  2894 *-* /*        Other calls like ALTER, SELECT, etc, treat any      */
  2895 *-* /*       single-table views like any other table access;      */
  2896 *-* /*       and they can participate in generic profiles, as     */
  2897 *-* /*       their RACF RDEFs are the same for those types of     */
  2898 *-* /*       access.                                              */
  2899 *-* /*                                                            */
  2900 *-* /*     e) Multi-table views are treated like regular tables   */
  2901 *-* /*       for all calls to tab_priv (except VIEW_INSERT,       */
  2902 *-* /*       VIEW_UPDATE and VIEW_DELETE).  This means they can   */
  2903 *-* /*       also participate in generic profiles.                */
  2904 *-* /*                                                            */
  2905 *-* /*     f) But RDEFs generated for views (multi-table views)   */
  2906 *-* /*       or single-table views will have comments identifing  */
  2907 *-* /*       them as such.  And RDEFs for tables will identify it */
  2908 *-* /*       as a table.                                          */
  2909 *-* /*                                                            */
  2910 *-* x=sql('NEW statement') /* start new sql statement */
  2911 *-* /* ----------------------- */
  2912 *-* x=sql("SELECT DISTINCT TCREATOR, TTNAME, GRANTEE"                   )
  2913 *-* x=sql("from ("                                                      )
  2914 *-* x=sql(" SELECT DISTINCT a.TCREATOR, a.TTNAME," granteeCase           )
  2915 *-* x=sql(" FROM SYSIBM.SYSTABAUTH as a"                                 )
  2916 *-* x=sql("     ,SYSIBM.SYSTABLES  as b"                                 )
  2917 *-* x=sql(" WHERE a.GRANTEE NOT IN ('PUBLIC','PUBLIC*') AND a."col"<>' '")
  2918 *-* x=sql("   AND a.GRANTEETYPE=' '"                                     )
  2919 *-* x=sql("   AND A."col" <> ' '"   /* missing predicate */              )
  2921 *-* x=sql("   AND a.TCREATOR = b.creator"                                )
  2922 *-* x=sql("   AND a.TTNAME   = b.name"                                   )
  2924 *-* if      auth='VIEW_INSERT' | auth='VIEW_UPDATE' | auth='VIEW_DELETE'
  2925 *-*  then ,
  2926 *-*  x=sql("   and b.type     = 'V'"                  )
  2928 *-* if auth = 'UPDATE'
  2929 *-*  then ,
  2930 *-*  x=sql("   AND A.UPDATECOLS = ' '"                                    )
  2932 *-* if auth = 'REFERENCES'
  2933 *-*  then ,
  2934 *-*  x=sql("   and A.refCols = ' '"                                       )
  2936 *-* if RemoveUserList <> ''
  2937 *-*  then ,
  2938 *-*  x=sql("   AND a.grantee not in" RemoveUserList                       )
  2940 *-* x=sql("   AND not exists ("                                          )
  2941 *-* x=sql("             select 1 from sysibm.systabauth as c"            )
  2942 *-* x=sql("                where c.tcreator = a.tcreator"                )
  2943 *-* x=sql("                  and c.ttname   = a.ttname"                  )
  2944 *-* x=sql("                  and c."col" <> ' '"                         )
  2946 *-* if auth = 'UPDATE'
  2947 *-*  then ,
  2948 *-*  x=sql("                  and c.UPDATECOLS = ' '"                     )
  2950 *-* if auth = 'REFERENCES'
  2951 *-*  then ,
  2952 *-*  x=sql("                  and c.refCols = ' '"                        )
  2954 *-* x=sql("                  and (   c.grantee = 'PUBLIC'"               )
  2955 *-* x=sql("                       or c.grantee = 'PUBLIC*')"             )
  2956 *-* x=sql("                  )"                                          )
  2957 *-* x=sql("UNION"                                                        )
  2958 *-* x=sql(" SELECT DISTINCT e.CREATOR as tcreator"                       )
  2959 *-* x=sql("                ,e.name    as ttname"                         )
  2960 *-* x=sql("                ,e.CREATOR as grantee"                        )
  2961 *-* x=sql(" from SYSIBM.SYSTABLES  as e"                                 )
  2963 *-* if      auth='VIEW_INSERT' | auth='VIEW_UPDATE' | auth='VIEW_DELETE'
  2964 *-*  then ,
  2965 *-*  x=sql(" where e.type     = 'V'"                  )
  2967 *-* x=sql(")"                                                            )
  2968 *-* x=sql("ORDER BY 1, 2, 3"                                             )
  2970 *-* call ZSQL
  2972 *-* rowsReturned = 0
  2973 *-* Do Until SQLCODE \= 0
  2974 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :tcreator, :ttname, :grantee"
  2975 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  2976 *-*    rowsReturned = rowsReturned + 1
  2977 *-*    parse upper var tcreator tcreator .
  2978 *-*    parse upper var ttname   ttname   .
  2979 *-*    parse upper var grantee  grantee  .
  2981 *-*    if grantee = '*DELETE'
       *-*     then
       *-*     iterate
  2982 *-*     /* grantee is upper case and strip'ed, as per "granteecase" */
  2983 *-*    if grantee = tcreator
  2984 *-*     then
       *-*     nop /* always allow; but won't do actual permit */
  2985 *-*    else
       *-*     if packageOwner.grantee = 0 , /*not a package owner */                   & useridIndx.grantee   = 0 , /*and not a ra
cf userid/group*/            & groupIndx.grantee    = 0   /*and not a racf userid/group*/
  2988 *-*      then
       *-*      do      /* ignore garbage authid */
  2989 *-*       if ignoredTableGrantee.grantee = 0 /* need to add to list */
  2990 *-*        then
       *-*        do      /* add to our list                          */
  2991 *-*         ignoredTableGrantee.grantee = 1 /* want to ignore quickly*/
  2992 *-*         ignoredTableGranteeList = ignoredTableGranteeList ,                                               grantee  /* ad
d to list */
  2994 *-*        end
  2995 *-*       else
       *-*        ignoredTableGrantee.grantee=ignoredTableGrantee.grantee+1
  2996 *-*       iterate   /* now iterate */
  2997 *-*      end
  2999 *-*      /* do package permit, but missing racf userid/group  */
  3000 *-*    if packageOwner.grantee = 1 , /* a package owner     */                  & useridIndx.grantee   = 0 , /* and not a ra
cf userid/group */          & groupIndx.grantee    = 0 , /* and not a racf userid/group */          & grantee <> tbcreator       /*
 package owner not tbcreator */
  3004 *-*     then
       *-*     do      /* package owner will need a racfid */
  3005 *-*      if packageTableGrantee.grantee = 0 /* need to add to list */
  3006 *-*       then
       *-*       do      /* add to our list                          */
  3007 *-*        packageTableGrantee.grantee = 1 /* want to ignore quickly*/
  3008 *-*        packageTableGranteeList = packageTableGranteeList ,                                               grantee  /* add
 to list */
  3010 *-*       end
  3011 *-*      else
       *-*       packageTableGrantee.grantee=packageTableGrantee.grantee+1
  3012 *-*     end
  3014 *-*    if auth = 'VIEW_INSERT' ,                                                | auth = 'VIEW_UPDATE' ,
                            | auth = 'VIEW_DELETE'
  3017 *-*     then
       *-*     do /* updatable view */
  3018 *-*      /* get table for view */
  3019 *-*      if view2table.tcreator.ttname = ''
  3020 *-*       then
       *-*       iterate /* seems impossible, but */
  3022 *-*      parse var view2table theTBcreator '.' .
  3024 *-*      If model=1
       *-*       Then
       *-*       prof=view2table.tcreator.ttname ,                                             || '.'tcreator'.'ttname
  3026 *-*      Else
       *-*       prof=ssid'.'view2table.tcreator.ttname     ,                                             || '.'tcreator'.'ttname
  3028 *-*      tcreator = strip(tcreator)
  3029 *-*      ssidTable = prof
  3030 *-*      prof=prof'.'substr(auth,6)
  3031 *-*      prof = left(prof,max(45,length(prof)))
  3032 *-*     end
  3033 *-*    else
       *-*     do /* table or non-updatable view */
  3034 *-*      If model=1
       *-*       Then
       *-*       prof=Strip(tcreator)'.'Strip(ttname)
  3035 *-*      Else
       *-*       prof=ssid'.'Strip(tcreator)'.'Strip(ttname)
  3036 *-*      tcreator = strip(tcreator)
  3037 *-*      ssidTable = prof
  3038 *-*      prof=prof'.'auth
  3039 *-*      prof = left(prof,max(45,length(prof)))
  3040 *-*     end
  3042 *-*    if FewTables4Creator.tcreator = 1 /* no generic or no reason */
  3043 *-*     then
       *-*     do                           /* ...or updateable view   */
  3045 *-*      if tcreator = grantee
  3046 *-*       then
       *-*       iterate /* don't need a permit */
  3048 *-*       /* generate permit now */
  3049 *-*      cmd="PERMIT "prof" CLASS("class") ACC(READ) ID("grantee")"
  3050 *-*      x = clistCard(cmd)
  3051 *-*      trace 'n'
  3052 *-*      iterate
  3053 *-*     end
  3055 *-*     /* generic option in effect and we may be able to collapse rules*/
  3056 *-*     /* collect info now; generate any permits/rdefs later           */
  3057 *-*     /* note:  only normal tables or non-updatable view access */
  3058 *-*     /*        will be processed here.                         */
  3059 *-*     /* update priv */
  3060 *-*    tableNumber = rphTableIndx.ssidTable
  3062 *-*    /* skip special code for 'G', handle 'Y' and/or 'G' the same */
  3063 *-*    rphTablePriv.tableNumber.auth = rphTablePriv.tableNumber.auth ,                                               grantee
  3066 *-*    /* count times a grantee was used for table schema */
  3067 *-*    if rphTableSchemaGranteeCount.tcreator.grantee = 0
  3068 *-*     then
       *-*     do
  3069 *-*      rphTableSchemaGranteeCount.tcreator.grantee = 1
  3070 *-*      rphTableSchemaGranteeList.tcreator = ,                                                   rphTableSchemaGranteeList.
tcreator grantee
  3072 *-*     end
  3073 *-*    else
       *-*     rphTableSchemaGranteeCount.tcreator.grantee = ,                                   rphTableSchemaGranteeCount.tcreato
r.grantee + 1
  3075 *-*    trace 'n'
  3076 *-*    iterate /* now skip code for 'G' or 'Y' */
  3077 *-*   End
  3078 *-* End /* do until */
  3079 *-* call showRowCount /* show rowsReturned */
  3080 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  3081 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  3082 *-* address dsnrexx "EXECSQL CLOSE C1"
  3083 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  3085 *-*  /* with Grants */
  3086 *-*  /* eliminate 2nd select.. we did everything in prev select */
  3088 *-*  /* now generate racf code */
  3089 *-* if (genericOption = 'GENERIC' | genericOption = 'GENERICNOAUDIT') ,      & auth <> 'VIEW_INSERT' , /* must be explicit;
generic ignored */       & auth <> 'VIEW_UPDATE' , /* must be explicit; generic ignored */       & auth <> 'VIEW_DELETE'   /* must
be explicit; generic ignored */
  3093 *-*  then
       *-*  call collapse_tab_privRH     /* generate racf permits */
  3094 *-* else
       *-*  nop                          /* explicit permits done */
  3096 *-* rdef$PERMIT = 'RDEF' /* all output to RDEF datasets */
  3097 *-* useClass    = class
  3099 *-* x = clistCard(' ')
  3100 *-* cmd = '   /* tab_priv: processing complete for auth='auth '*/'
  3101 *-* x = clistCard(cmd)
  3102 *-* x = clistCard(' ')
  3104 *-* rdef$PERMIT = 'PERMIT' /* all output to PE$ datasets */
  3106 *-* x = clistCard(' ')
  3107 *-* cmd = '   /* tab_priv: processing complete for auth='auth '*/'
  3108 *-* x = clistCard(cmd)
  3109 *-* x = clistCard(' ')
  3112 *-* rdef$PERMIT = 'RDEF' /* all output to RDEF datasets */
  3114 *-* return    /* tab_priv */
  3116 *-* collapse_tab_privRH:
       *-* /*     called by tab_priv (above) */
  3117 *-* /*****************************************************************/
  3118 *-* /* Get DB2 Tables privileges (collapse info)                     */
  3119 *-* /*****************************************************************/
  3120 *-* rdef$PERMIT = 'RDEF' /* all output to RDEF datasets */
  3121 *-* useClass    = class
  3123 *-* x = clistCard(' ')
  3124 *-* cmd = '   /* Generic processing begins for remaining tables/views */'
  3125 *-* x = clistCard(cmd)
  3126 *-* cmd = '   /* Generic processing begins for remaining tables/views */'
  3127 *-* x = clistCard(cmd)
  3128 *-* cmd = '   /* "collapse_tab_privRH" will generate rdef/permits */'
  3129 *-* x = clistCard(cmd)
  3130 *-* cmd = '   /*    from collected info for table priv='auth '*/'
  3131 *-* x = clistCard(cmd)
  3132 *-* cmd = '   /*    for tables/views using GENERIC or GENERICNOAUDIT */'
  3133 *-* x = clistCard(cmd)
  3134 *-* x = clistCard(' ')
  3136 *-* rdef$PERMIT = 'PERMIT' /* all output to PE$ datasets */
  3138 *-* x = clistCard(' ')
  3139 *-* cmd = '   /* Generic processing begins for remaining tables/views */'
  3140 *-* x = clistCard(cmd)
  3141 *-* cmd = '   /* Generic processing begins for remaining tables/views */'
  3142 *-* x = clistCard(cmd)
  3143 *-* cmd = '   /* "collapse_tab_privRH" will generate rdef/permits */'
  3144 *-* x = clistCard(cmd)
  3145 *-* cmd = '   /*    from collected info for table priv='auth '*/'
  3146 *-* x = clistCard(cmd)
  3147 *-* cmd = '   /*    for tables/views using GENERIC or GENERICNOAUDIT */'
  3148 *-* x = clistCard(cmd)
  3149 *-* x = clistCard(' ')
  3151 *-* rdef$PERMIT = 'RDEF' /* all output to RDEF datasets */
  3153 *-* optClstX = optclstx + 1
  3154 *-* optClstx.optClstx = ' '
  3156 *-* optClstX = optclstx + 1
  3157 *-* optClstx.optClstx = 'Table schema information for auth='auth
  3159 *-* optClstX = optclstx + 1
  3160 *-* optClstx.optClstx = '-------------------------------------------'
  3162 *-* do creator = 1 by 1 for rphTableCreator
  3163 *-*  /* go thru tables for this creator, and try to see what's in */
  3164 *-*  /* common.                                                   */
  3165 *-*  longPriv = 0
  3166 *-*  longPriv.= ''
  3167 *-*  longPrivIndx. = 0
  3168 *-*  maxlong = 0
  3169 *-*  maxlongindx = 0
  3170 *-*  /* get table list */
  3171 *-*  parse var rphTableCreator.creator tbcreator tables
  3172 *-*  totalTables = 0
  3173 *-*  savetables  = tables
  3174 *-*  maxLong = 0
  3176 *-*  if optclstx.optclstx <> '' /* only add one blank line */
  3177 *-*   then
       *-*   do
  3178 *-*    /* add a blank line */
  3179 *-*    optClstX = optclstx + 1
  3180 *-*    optClstx.optClstx = ' ' /* start schema info w/blank line */
  3181 *-*   end
  3182 *-*  do while tables <> ''
  3183 *-*   parse var tables tableNumber tables
  3184 *-*   /* use table info to get stats on priv's */
  3185 *-*   priv = strip(rphTablePriv.tableNumber.auth)
  3186 *-*   wgrant= '/' strip(rphTableWGrant.tableNumber.auth)
  3187 *-*   allprivs = strip(priv wgrant)
  3189 *-*   if allprivs = '/'
       *-*    then
       *-*    iterate /* ignore "nothing" */
  3191 *-*   allprivs = priv wgrant
  3192 *-*   trace 'n'
  3193 *-*   totalTables = totalTables + 1  /* tables w/privs   */
  3195 *-*   optClstX = optclstx + 1
  3196 *-*   optClstx.optClstx = 'auth='auth 'TableSchema=' ,                                           ||tbcreator'.'rphTable.tabl
eNumber
  3199 *-*   if length(allPrivs) <= 220
  3200 *-*    then
       *-*    hashKey = allPrivs /* hashkey = value */
  3201 *-*   else
       *-*    do
  3202 *-*     /* we need to use a shorter hash stem instead */
  3203 *-*     tooLong = allPrivs
  3204 *-*     parse var toolong 1 hashkey 201 toolong
  3205 *-*     do while length(tooLong) > 0
  3206 *-*      parse var tooLong 1 nextkey 201 tooLong
  3207 *-*      hashkey = bitxor(hashkey,nextkey)
  3208 *-*     end
  3209 *-*     /* now have a potentially (non-unique) hashkey */
  3210 *-*    end
  3211 *-*   if longPrivIndx.hashkey = 0
  3212 *-*    then
       *-*    do
  3213 *-*     /* create a new node */
  3214 *-*     longPriv = longPriv + 1
  3215 *-*     longPriv.longpriv = allprivs
  3216 *-*     longPrivCount.longpriv = 1
  3217 *-*     LongPrivNextHash.longPriv = 0
  3218 *-*     longPrivIndx.hashkey = longpriv
  3219 *-*     if maxlong = 0
  3220 *-*      then
       *-*      do
  3221 *-*       maxlong = 1
  3222 *-*       maxlongindx = tableNumber
  3223 *-*      end
  3224 *-*    end
  3225 *-*   else
       *-*    do
  3226 *-*     /* potentially two hashkeys for different allPrivs */
  3227 *-*     privIndx = longPrivIndx.hashkey
  3228 *-*     nextIndx = privIndx
  3229 *-*     do while nextIndx <> 0 & longPriv.nextIndx <> allPrivs
  3230 *-*      privIndx = nextIndx
  3231 *-*      nextIndx = longPrivNextHash.privIndx
  3232 *-*     end
  3233 *-*     /* either at end of chain, or found matching value */
  3234 *-*     if nextIndx = 0
  3235 *-*      then
       *-*      do
  3236 *-*       /* at end of chain (with no match); create new node */
  3237 *-*       longPriv = longPriv + 1
  3238 *-*       longPrivNextHash.privIndx = longPriv /* add new node */
  3239 *-*       /* ..to end of  */
  3240 *-*       /* ..chain.     */
  3241 *-*       /* create new node */
  3242 *-*       longPriv.longpriv = allprivs
  3243 *-*       longPrivCount.longpriv = 1
  3244 *-*       LongPrivNextHash.longPriv = 0
  3245 *-*       /* don't set "longPrivIndx.hashkey" its set to 1st one*/
  3246 *-*       if maxlong = 0
  3247 *-*        then
       *-*        do
  3248 *-*         maxlong = 1
  3249 *-*         maxlongindx = tableNumber
  3250 *-*        end
  3251 *-*      end
  3252 *-*     else
       *-*      do /* found matching node.  update count */
  3253 *-*       /* nextIndx points to matching node */
  3254 *-*       longPrivCount.nextIndx = longPrivCount.nextIndx + 1
  3255 *-*       if longPrivCount.nextIndx > maxLong
  3256 *-*        then
       *-*        do
  3257 *-*         maxlong = longPrivCount.nextIndx
  3258 *-*         maxlongindx = tableNumber
  3259 *-*        end
  3260 *-*      end
  3261 *-*    end
  3263 *-*  End
  3265 *-*  if totalTables = 0
  3266 *-*   then
       *-*   iterate
  3268 *-*   /* output some stats */
  3269 *-*  tempList = rphTableSchemaGranteeList.tbcreator
  3270 *-*  if templist <> ''
  3271 *-*   then
       *-*   do
  3272 *-*    optClstX = optclstx + 1
  3273 *-*    optClstx.optClstx = '  Grantees for schema(s) above are:'
  3274 *-*   end
  3275 *-*  do nw = 1 by 1 for words(rphTableSchemaGranteeList.tbcreator)
  3276 *-*   gw = word(rphTableSchemaGranteeList.tbcreator,nw)
  3277 *-*   if gw = tbcreator
  3278 *-*    then
       *-*    iterate
  3279 *-*   optClstX = optclstx + 1
  3280 *-*   optClstx.optClstx = '   Grantee' gw 'had/has' ,                             rphTableSchemaGranteeCount.tbcreator.gw 't
able permits'
  3284 *-*   if optclstx > 100
  3285 *-*    then
       *-*    do
  3286 *-*     Address TSO "EXECIO" optClstx "DISKW OPTCLST (STEM OPTCLSTX."
  3287 *-*     if rc <> 0
  3288 *-*      then
       *-*      do
  3289 *-*       say 'error writing/closing ddname=OPTCLST; rc='rc
  3290 *-*       say 'will exit with rc=8'
  3291 *-*       pendingRc = 8
  3292 *-*      end
  3293 *-*     optclstx = 0
  3294 *-*    end
  3295 *-*  end
  3297 *-*  trace 'n'
  3298 *-*  /* collected priv summary                   */
  3299 *-*  /* ...now try to figure out whats in common */
  3301 *-*  /* now generate the default (and then the specifics) */
  3302 *-*  tableNumber = maxLongIndx
  3303 *-*  priv = strip(rphTablePriv.tableNumber.auth)
  3304 *-*  wgrant= '/' strip(rphTableWGrant.tableNumber.auth)
  3305 *-*  allprivs = strip(priv wgrant)
  3306 *-*  savepriv = allprivs
  3308 *-*  if totalTables < 4                ,                                      | (totalTables = 4 & maxlong < 3),
                          | (totalTables = 5 & maxlong < 3),                                      | (totalTables = 6 & maxlong < 3)
,                                      | (totalTables = 7 & maxlong < 3),                                      | (totalTables = 8 &
 maxlong < 4),                                      | (totalTables = 9 & maxlong < 4),                                      | (tota
lTables =10 & maxlong < 4),                                      | (totalTables >10 & maxlong*100/totalTables < 30) ,
      | (totalTables >50 & maxlong*100/totalTables < 20)
  3318 *-*   then
       *-*   savepriv = '' /* only specific rules */
  3319 *-*  if savepriv <> ''
  3320 *-*   then
       *-*   do /* generate a generic rule */
  3322 *-*    Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
  3323 *-*    /* --------------------------- */
  3325 *-*    cmd = '   /*      generic for privs='savepriv '*/'
  3326 *-*    x = clistCard(cmd)
  3328 *-*    tbcreator = strip(tbcreator)
  3329 *-*    If model=1
       *-*     Then
       *-*     prof=tbcreator'.*.'auth
  3330 *-*    Else
       *-*     prof=ssid'.'tbcreator'.*.'auth
  3331 *-*    prof= left(prof,max(41,length(prof)))
  3332 *-*    dbname = strip(dbname)
  3333 *-*    if word(allprivs,1) = 'PUBLIC'
  3334 *-*     then
       *-*     do
  3335 *-*      cmd="RDEF "class prof" UACC(READ) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                                 "DATA('Everyone has" auth 'on table(s)' tbcreator".*')"
  3338 *-*      x = clistCard(cmd)
  3340 *-*      cmd="PERMIT "prof" CLASS("class") RESET"
  3341 *-*      if resetOption = 'RESET'
       *-*       then
       *-*       x = clistCard(cmd)
  3342 *-*     end
  3343 *-*    else
       *-*     do
  3344 *-*      cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                                 "DATA('Users with" auth 'on table(s)' tbcreator".*')"
  3347 *-*      x = clistCard(cmd)
  3349 *-*      cmd="PERMIT "prof" CLASS("class") RESET"
  3350 *-*      if resetOption = 'RESET'
       *-*       then
       *-*       x = clistCard(cmd)
  3351 *-*     end
  3353 *-*    useClass = class
  3354 *-*    Rdef$Permit = 'PERMIT' /* all output to permit datasets */
  3355 *-*    /* --------------------------- */
  3356 *-*    per = format(maxlong / totalTables * 100,3,1)'%'
  3357 *-*    cmd = '   /*    creator='tbcreator'.*.'auth maxlong 'of' ,                                   totaltables per '*/'
  3359 *-*    x = clistcard(' ')
  3360 *-*    x = clistCard(cmd)
  3362 *-*    Rdef$Permit = 'RDEF'   /* all output to permit datasets */
  3363 *-*    /* --------------------------- */
  3364 *-*    per = format(maxlong / totalTables * 100,3,1)'%'
  3365 *-*    cmd = '   /*    creator='tbcreator'.*.'auth maxlong 'of' ,                                   totaltables per '*/'
  3367 *-*    x = clistcard(' ')
  3368 *-*    x = clistCard(cmd)
  3370 *-*    Rdef$Permit = 'PERMIT' /* all output to permit datasets */
  3371 *-*    /* add in default priv's */
  3372 *-*    if word(allprivs,1) = 'PUBLIC'
  3373 *-*     then
       *-*     parse var allprivs . allprivs
  3374 *-*    wgrant = 0
  3375 *-*    do while allprivs <> ''
  3376 *-*     parse var allprivs nextpriv allprivs
  3377 *-*     if nextpriv = '/'
  3378 *-*      then
       *-*      do
  3379 *-*       wgrant = 1
  3380 *-*       iterate
  3381 *-*      end
  3382 *-*     grantee  = nextpriv
  3383 *-*     if grantee = tbcreator /* grantee = creator ?           */
  3384 *-*      then
       *-*      iterate           /* yes, skip unneccessary permit */
  3385 *-*     if wgrant = 0
  3386 *-*      then
       *-*      cmd="PERMIT "prof" CLASS("class") ACC(READ)",                        "ID("Translate(Strip(grantee))")"
  3388 *-*     else
       *-*      cmd="PERMIT "prof" CLASS("class") ACC(ALTER)",                       "ID("Translate(Strip(grantee))")"
  3390 *-*     x = clistCard(cmd)
  3391 *-*    end
  3392 *-*    /* finished generating the default table priv */
  3393 *-*   end
  3395 *-*   /* now generate the specific ones          */
  3396 *-*  tables = saveTables
  3397 *-*  do while tables <> ''
  3398 *-*   Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
  3399 *-*   /* --------------------------- */
  3401 *-*   parse var tables tableNumber tables
  3402 *-*   /* use table info to get stats on priv's */
  3403 *-*   priv = strip(rphTablePriv.tableNumber.auth)
  3404 *-*   wgrant= '/' strip(rphTableWGrant.tableNumber.auth)
  3405 *-*   allprivs = strip(priv wgrant)
  3406 *-*   if allprivs = '/' & rphTableAuditing.tableNumber = ' '
  3407 *-*    then
       *-*    iterate /* ignore "nothing" */
  3408 *-*   if allprivs = savepriv ,              /* generic table?   */             & rphTableAuditing.tableNumber = ' ' /* and N
OT audited? */
  3410 *-*    then
       *-*    iterate /* ...yes, let generic rule handle this table*/
  3412 *-*    /* this table either: */
  3413 *-*    /*    1) has different users w/privs than default    */
  3414 *-*    /* or 2) this is a db2 audited table, and we should  */
  3415 *-*    /*      not let it fall to the valid, but non-explict*/
  3416 *-*    /*      generic rdef.  Spell it out.                 */
  3418 *-*   prof=rphTable.tableNumber ||'.'auth
  3420 *-*   parse var prof . '.' . '.' tbname /* get table name */
  3421 *-*   if tbname = ''
  3422 *-*    then
       *-*    parse var prof . '.' tbname
  3424 *-*   prof= left(prof,max(41,length(prof)))
  3426 *-*   if rphTableAuditing.tableNumber = ' ' ,                                  & singleTableInView.tcreator.tbname = 0
  3428 *-*    then , /* non-audit table */
  3429 *-*    cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                               "DATA('"auth "privs for table" strip(prof)"')"
  3432 *-*   else
       *-*    if singleTableInView.tcreator.tbname = 0
  3433 *-*     then , /* audited table */
  3434 *-*     cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                                "DATA('DB2 auditing table. " auth 'auth on table' ,                           strip(prof)"')"
  3438 *-*    else
       *-*     if rphTableAuditing.tableNumber = ' ' ,                             & singleTableInView.tcreator.tbname = 2
  3440 *-*      then
       *-*      do
  3441 *-*       cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                                  "DATA('Users with" auth 'on multi-table view' ,                               strip(prof)"')"
  3445 *-*       x = clistCard(cmd)
  3447 *-*       cmd="PERMIT "prof" CLASS("class") RESET"
  3448 *-*       if resetOption = 'RESET'
       *-*        then
       *-*        x = clistCard(cmd)
  3449 *-*      end
  3450 *-*     else
       *-*      if singleTableInView.tcreator.tbname = 2
  3451 *-*       then
       *-*       do
  3452 *-*        cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                                   "DATA('DB2 audit on," auth 'on multi-table view' ,                            strip(prof)"')"
  3456 *-*        x = clistCard(cmd)
  3458 *-*        cmd="PERMIT "prof" CLASS("class") RESET"
  3459 *-*        if resetOption = 'RESET'
       *-*         then
       *-*         x = clistCard(cmd)
  3460 *-*       end
  3461 *-*      else
       *-*       if rphTableAuditing.tableNumber = ' '  ,
  3462 *-*        then
       *-*        do
  3463 *-*         cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                                    "DATA('Users with" auth 'on single-table view' ,                              strip(prof)"')"
  3467 *-*         x = clistCard(cmd)
  3469 *-*         cmd="PERMIT "prof" CLASS("class") RESET"
  3470 *-*         if resetOption = 'RESET'
       *-*          then
       *-*          x = clistCard(cmd)
  3471 *-*        end
  3472 *-*       else
       *-*        do
  3473 *-*         cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                                    "DATA('DB2 audit on," auth 'on single-table view' ,                           strip(prof)"')"
  3477 *-*         x = clistCard(cmd)
  3479 *-*         cmd="PERMIT "prof" CLASS("class") RESET"
  3480 *-*         if resetOption = 'RESET'
       *-*          then
       *-*          x = clistCard(cmd)
  3481 *-*        end
  3483 *-*   x = clistCard(cmd)
  3485 *-*   cmd="PERMIT "prof" CLASS("class") RESET"
  3486 *-*   if resetOption = 'RESET'
       *-*    then
       *-*    x = clistCard(cmd)
  3488 *-*   Rdef$Permit = 'PERMIT' /* all output to permit datasets */
  3489 *-*   /* --------------------------- */
  3491 *-*   /* audited tables get their own permits */
  3492 *-*   wgrant = 0
  3493 *-*   do while allprivs <> ''
  3494 *-*    parse var allprivs nextpriv allprivs
  3495 *-*    if nextpriv = '/'
  3496 *-*     then
       *-*     do
  3497 *-*      wgrant = 1
  3498 *-*      iterate
  3499 *-*     end
  3500 *-*    grantee  = nextpriv
  3502 *-*    if tbcreator = grantee
  3503 *-*     then
       *-*     iterate /* skip permit, if creator = grantee */
  3505 *-*    if wgrant = 0
  3506 *-*     then
       *-*     cmd="PERMIT "prof" CLASS("class") ACC(READ)",                        "ID("Translate(Strip(grantee))")"
  3508 *-*    else
       *-*     cmd="PERMIT "prof" CLASS("class") ACC(ALTER)",                       "ID("Translate(Strip(grantee))")"
  3510 *-*    x = clistCard(cmd)
  3511 *-*   end
  3512 *-*   /* finished generating spec table privs */
  3514 *-*  end
  3515 *-* End /* do while */
  3516 *-* trace 'n'
  3517 *-* Return    /* collapse_tab_privRH */
  3519 *-* tab_col:
       *-* /* note:  tab_upd  removed so that tab_col can handle  */
  3520 *-* /*                 both 'updatecol' and 'references'   */
  3521 *-* /*                 in addition.  table based authority */
  3522 *-* /*                 was removed.  Column based only.    */
  3524 *-* /* note:  tab_col  handles 'updatecol' and 'references'*/
  3525 *-* /*                 for column bases authority only.    */
  3527 *-* /* note:  these are very specific type authorities and */
  3528 *-* /*                 not good candidates for creating a  */
  3529 *-* /*                 general rule for.                   */
  3530 *-* parse upper arg auth . /* auth=UPDATE or AUTH=REFERENCES */
  3533 *-* If model=1
       *-*  Then
       *-*  class="M"ssid"TB"charopt
  3534 *-* Else
       *-*  class="M"classmnt"TB"charopt
  3536 *-* Rdef$Permit = 'RDEF' /* all output to rdef datasets */
  3537 *-* /* --------------------------- */
  3538 *-* useClass = class
  3540 *-* if auth = 'REFERENCES'
  3541 *-*  then
       *-*  do
  3542 *-*   privcols = 'REFCOLS'
  3543 *-*   privauth = 'REFERENCESAUTH'
  3544 *-*   privilegeValue = 'R'
  3545 *-*  end
  3546 *-* else
       *-*  if auth = 'UPDATECOLS'
  3547 *-*   then
       *-*   do
  3548 *-*    privcols = 'UPDATECOLS'
  3549 *-*    privauth = 'UPDATEAUTH'
  3550 *-*    privilegeValue = ' '
  3551 *-*   end
  3553 *-*   /* comment as to why we are re-issuing the same sql */
  3554 *-*   /* ------------------------------------------------ */
  3555 *-* Rdef$Permit = 'RDEF' /* all output to rdef datasets */
  3556 *-* /* --------------------------- */
  3558 *-* x = clistCard(' ')
  3559 *-* cmd='/* --------------------------------------------------- */'
  3560 *-* x = clistCard(cmd)
  3561 *-* cmd='/* Entering routine tab_col: for auth='auth      '     */'
  3562 *-* x = clistCard(cmd)
  3563 *-* cmd='/* Entering routine tab_col: for auth='auth      '     */'
  3564 *-* x = clistCard(cmd)
  3565 *-* cmd='/* --------------------------------------------------- */'
  3566 *-* x = clistCard(cmd)
  3568 *-* Rdef$Permit = 'PERMIT' /* all output to rdef datasets */
  3569 *-* /* --------------------------- */
  3571 *-* x = clistCard(' ')
  3572 *-* cmd='/* --------------------------------------------------- */'
  3573 *-* x = clistCard(cmd)
  3574 *-* cmd='/* Entering routine tab_col: for auth='auth      '     */'
  3575 *-* x = clistCard(cmd)
  3576 *-* cmd='/* Entering routine tab_col: for auth='auth      '     */'
  3577 *-* x = clistCard(cmd)
  3578 *-* cmd='/* --------------------------------------------------- */'
  3579 *-* x = clistCard(cmd)
  3581 *-* Rdef$Permit = 'RDEF' /* all output to rdef datasets */
  3582 *-* /* --------------------------- */
  3584 *-* /* create "backstop" so that everything else is rejected */
  3585 *-* /* ----------------------------------------------------- */
  3586 *-* x = clistCard(' ')
  3587 *-* cmd='/* create backstop RDEF (in tab_col: routine) */'
  3588 *-* x = clistCard(cmd)
  3590 *-* If model=1
       *-*  Then
       *-*  prof='*.*'
  3591 *-* Else
       *-*  prof=ssid'.*.*'
  3592 *-* prof=prof'.*.'auth
  3593 *-* prof= left(prof,max(41,length(prof)))
  3595 *-* cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                      "OWNER("owner")" ,
                           "DATA('DB2-"ssid "backstop rdef table/column priv" privauth"')"
  3598 *-* x = clistCard(cmd)
  3599 *-* x = clistCard(' ')
  3601 *-* /************************************************/
  3602 *-* /* Now for Column-only                          */
  3603 *-* /************************************************/
  3605 *-* /* Find all objects, and make commands to create profiles */
  3606 *-* /* for column based authority */
  3607 *-* x = clistCard(' ')
  3608 *-* cmd='/* Find all objects for column based authority */'
  3609 *-* x = clistCard(cmd)
  3611 *-* x=sql('NEW statement') /* start new sql statement */
  3612 *-* /* ----------------------- */
  3613 *-* x=sql("SELECT DISTINCT T.TCREATOR, T.TTNAME, C.COLNAME")
  3614 *-* x=sql("FROM SYSIBM.SYSTABAUTH T     ")
  3615 *-* x=sql("    ,SYSIBM.SYSCOLAUTH C     ")
  3616 *-* x=sql("WHERE T.GRANTEETYPE=' '      ") /* authid (no roles or pgms*/
  3617 *-* x=sql("  AND C.GRANTEETYPE=' '      ") /* authid (no roles or pgms*/
  3618 *-* x=sql("  AND T.DATEGRANTED=C.DATEGRANTED")
  3619 *-* x=sql("  AND T.TIMEGRANTED=C.TIMEGRANTED")
  3620 *-* x=sql("  AND T.TTNAME     =C.TNAME  ")
  3621 *-* x=sql("  AND T.TCREATOR   =C.CREATOR")
  3622 *-* x=sql("  AND T."privcols" ='*'      ") /* handle update/references*/
  3623 *-* x=sql("  AND T."privauth"<>' '      ")  /* handle update/references*/
  3624 *-* x=sql("  AND T.GRANTEE   <>T.TCREATOR") /* and a reason for grant  */
  3625 *-* x=sql("  AND C.GRANTEE   <>C.CREATOR")  /* and a reason for grant  */
  3626 *-* x=sql("  AND C.PRIVILEGE  ='"privilegeValue"'")/* ...              */
  3628 *-* call ZSQL
  3630 *-* rowsReturned = 0
  3631 *-* Do Until SQLCODE \= 0
  3632 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :tcreator, :ttname, :colname"
  3633 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  3634 *-*    rowsReturned = rowsReturned + 1
  3635 *-*    parse upper var tcreator tcreator .
  3636 *-*    parse upper var ttname   ttname   .
  3637 *-*    parse upper var colname  colname  .
  3639 *-*    If model=1
       *-*     Then
       *-*     prof=Strip(tcreator)'.'Strip(ttname)
  3640 *-*    Else
       *-*     prof=ssid'.'Strip(tcreator)'.'Strip(ttname)
  3641 *-*    prof=prof'.'Strip(colname)'.'auth
  3642 *-*    prof= left(prof,max(41,length(prof)))
  3644 *-*    cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                      "OWNER("owner")" ,
                              "DATA('DB2-"ssid "rdef table/column priv" privauth"')"
  3647 *-*    x = clistCard(cmd)
  3649 *-*    cmd="PERMIT "prof" CLASS("class") RESET"
  3650 *-*    if resetOption = 'RESET'
       *-*     then
       *-*     x = clistCard(cmd)
  3651 *-*   End
  3652 *-* End /* do until */
  3653 *-* call showRowCount /* show rowsReturned */
  3654 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  3655 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  3656 *-* address dsnrexx "EXECSQL CLOSE C1"
  3657 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  3659 *-*  /* If any of those were PUBLIC, change UACC to READ */
  3660 *-* x = clistCard(' ')
  3661 *-* cmd='/* Find if any of those were granted to PUBLIC */'
  3662 *-* x = clistCard(cmd)
  3664 *-* x=sql('NEW statement') /* start new sql statement */
  3665 *-* /* ----------------------- */
  3666 *-* x=sql("SELECT DISTINCT T.TCREATOR, T.TTNAME, C.COLNAME")
  3667 *-* x=sql("FROM SYSIBM.SYSTABAUTH T    ")
  3668 *-* x=sql("    ,SYSIBM.SYSCOLAUTH C    ")
  3669 *-* x=sql("WHERE T.GRANTEETYPE=' '     ") /* authid (no roles or pgms*/
  3670 *-* x=sql("  AND C.GRANTEETYPE=' '     ") /* authid (no roles or pgms*/
  3671 *-* x=sql("  AND T.DATEGRANTED=C.DATEGRANTED")
  3672 *-* x=sql("  AND T.TIMEGRANTED=C.TIMEGRANTED")
  3673 *-* x=sql("  AND T.TTNAME     =C.TNAME ")
  3674 *-* x=sql("  AND T.TCREATOR   =C.CREATOR")
  3675 *-* x=sql("  AND T.GRANTEE IN ('PUBLIC','PUBLIC*')")
  3676 *-* x=sql("  AND T."privcols" ='*'      ") /* handle update/references*/
  3677 *-* x=sql("  AND T."privauth"<>' '      ")  /* handle update/references*/
  3678 *-* x=sql("  AND C.PRIVILEGE  ='"privilegeValue"'")/* ...              */
  3680 *-* call ZSQL
  3682 *-* rowsReturned = 0
  3683 *-* Do Until SQLCODE \= 0
  3684 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :tcreator, :ttname, :colname"
  3685 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  3686 *-*    rowsReturned = rowsReturned + 1
  3687 *-*    parse upper var tcreator tcreator .
  3688 *-*    parse upper var ttname   ttname   .
  3689 *-*    parse upper var colname  colname  .
  3691 *-*    If model=1
       *-*     Then
       *-*     prof=Strip(tcreator)'.'Strip(ttname)
  3692 *-*    Else
       *-*     prof=ssid'.'Strip(tcreator)'.'Strip(ttname)
  3693 *-*    prof=prof'.'Strip(colname)'.UPDATE'
  3694 *-*    ssidTableCol = prof
  3695 *-*    prof= left(prof,max(55,length(prof)))
  3696 *-*    cmd="RALT "class prof" UACC(READ)" ,                                       "DATA('Everyone has DB2-"ssid "rdef table/
column priv')"
  3698 *-*    x = clistCard(cmd)
  3699 *-*   End
  3700 *-* End /* do until */
  3701 *-* call showRowCount /* show rowsReturned */
  3702 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  3703 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  3704 *-* address dsnrexx "EXECSQL CLOSE C1"
  3705 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  3707 *-*  /* Get all ids (except PUBLIC) for access list */
  3708 *-*  /*    #1 original sql code was wrong, but we're modifying it */
  3709 *-*  /*  anyway.                                                  */
  3710 *-*  /*      1)  predicate for T.UPDATEAUTH was wrong             */
  3711 *-*  /*       but we've changed that predicate test to be more    */
  3712 *-*  /*       generic and return more rows anyway.                */
  3713 *-*  /*      2)  C.PRIVILEGE should be blank                      */
  3714 *-*  /*    #2 now return T.UPDATEAUTH as well (as authx)          */
  3715 *-*  /*    #3 add order by to return UPDATEAUTH="G" before "Y"    */
  3716 *-*  /*      and handle both via fetches/code                     */
  3717 *-*  /*    #4 rewrite rexx code for sql statement... just to make */
  3718 *-*  /*  it readable.                                             */
  3719 *-*  /*    #5 changed so either UPDATEAUTH or REFERENCESAUTH is   */
  3720 *-*  /*  used.  as we've make this rountine handle both.          */
  3721 *-*  /*    note: neither IBM nor we handle "ROLES" */
  3722 *-*  /*    note: plans/packages don't need/have racf permits */
  3724 *-* Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
  3725 *-* /* --------------------------- */
  3727 *-* x = clistCard(' ')
  3728 *-* cmd='/* Get all ids (except PUBLIC) for access list */'
  3729 *-* x = clistCard(cmd)
  3731 *-* x=sql('NEW statement') /* start new sql statement */
  3732 *-* /* ----------------------- */
  3733 *-* x=sql("SELECT DISTINCT T.TCREATOR, T.TTNAME, C.COLNAME" )
  3734 *-* x=sql("         ,strip(upper(t.grantee)) as ugrantee"   )
  3735 *-* x=sql("FROM SYSIBM.SYSTABAUTH T, "                      )
  3736 *-* x=sql("     SYSIBM.SYSCOLAUTH C  "                      )
  3737 *-* x=sql("WHERE T.TTNAME      = C.TNAME   "                )
  3738 *-* x=sql("  AND T.TCREATOR   <> T.GRANTEE "                )
  3739 *-* x=sql("  AND T.TCREATOR    = C.CREATOR "                )
  3740 *-* x=sql("  AND C.CREATOR    <> C.GRANTEE "                )
  3741 *-* x=sql("  AND T.GRANTEETYPE = ' '       "                )
  3742 *-* x=sql("  AND T.GRANTEETYPE = ' '  " )/* authid (no roles or pgms*/
  3743 *-* x=sql("  AND C.GRANTEETYPE = ' '  " )/* authid (no roles or pgms*/
  3744 *-* x=sql("  and T.DATEGRANTED = C.DATEGRANTED"             )
  3745 *-* x=sql("  And T.TIMEGRANTED = C.TIMEGRANTED"             )
  3746 *-* x=sql("  AND T.GRANTEE NOT IN ('PUBLIC','PUBLIC*')"     )
  3747 *-* x=sql("  AND T."privcols" ='*'      ") /* handle update/references*/
  3748 *-* x=sql("  AND T."privauth"<>' '      ")  /* handle update/references*/
  3749 *-* x=sql("  AND C.PRIVILEGE  ='"privilegeValue"'")  /* ...            */
  3751 *-* if removeUserList <> ''
  3752 *-*  then
       *-*  do
  3753 *-*   x=sql("  AND T.GRANTEE not in" RemoveUserList           )
  3754 *-*   x=sql("  AND C.GRANTEE not in" RemoveUserList           )
  3755 *-*  end
  3757 *-* x=sql("ORDER BY T.TCREATOR, T.TTNAME, C.COLNAME, ugrantee")
  3759 *-* call ZSQL
  3761 *-* rowsReturned = 0
  3762 *-* Do Until SQLCODE \= 0
  3763 *-*  address dsnrexx ,                                                       "EXECSQL FETCH C1 INTO :tcreator, :ttname, :col
name, :grantee,"
  3765 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  3766 *-*    rowsReturned = rowsReturned + 1
  3767 *-*    parse upper var tcreator tcreator .
  3768 *-*    parse upper var ttname   ttname   .
  3769 *-*    parse upper var colname  colname  .
  3771 *-*    If model=1
       *-*     Then
       *-*     prof=Strip(tcreator)'.'Strip(ttname)
  3772 *-*    Else
       *-*     prof=ssid'.'Strip(tcreator)'.'Strip(ttname)
  3773 *-*    prof=prof'.'Strip(colname)'.'auth
  3774 *-*    prof= left(prof,max(55,length(prof)))
  3775 *-*    parse upper var grantee grantee . /* strip and upper case */
  3777 *-*    access = 'ACC(READ)' /* all access read, not grant */
  3778 *-*    cmd="PERMIT "prof" CLASS("class")" access "ID("grantee")"
  3779 *-*    x = clistCard(cmd)
  3780 *-*   End
  3781 *-* End /* do until */
  3782 *-* call showRowCount /* show rowsReturned */
  3783 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  3784 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  3785 *-* address dsnrexx "EXECSQL CLOSE C1"
  3786 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  3788 *-*  /* With Grants */
  3789 *-*  /* delete sql, already handled both ...AUTH=Y or AUTH=G */
  3790 *-*  /* end "with grant */
  3793 *-* Rdef$Permit = 'RDEF' /* all output to rdef datasets */
  3794 *-* /* --------------------------- */
  3795 *-* x = clistCard(' ')
  3796 *-* cmd = '   /* tab_col: processing complete for auth='auth '*/'
  3797 *-* x = clistCard(cmd)
  3798 *-* x = clistCard(' ')
  3800 *-* rdef$PERMIT = 'PERMIT'
  3801 *-* x = clistCard(' ')
  3802 *-* cmd = '   /* tab_col: processing complete for auth='auth '*/'
  3803 *-* x = clistCard(cmd)
  3804 *-* x = clistCard(' ')
  3806 *-* Return    /* tab_upd */
  3809 *-* use_priv:
  3810 *-* /*****************************************************************/
  3811 *-* /* Get DB2 USE privileges (stogroup, tablespace, jar, dist.type) */
  3812 *-* /*****************************************************************/
  3813 *-* Arg auth,obtype,type
  3814 *-* If model=1
       *-*  Then
       *-*  class="M"ssid||type||charopt
  3815 *-* Else
       *-*  class="M"classmnt||type||charopt
  3817 *-* Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
  3818 *-* /* --------------------------- */
  3819 *-* useClass = class
  3821 *-* /* create "backstop" so that everything else is rejected */
  3822 *-* /* ----------------------------------------------------- */
  3823 *-* x = clistCard(' ')
  3824 *-* cmd='/* create backstop RDEF (in use_priv: routine) */'
  3825 *-* x = clistCard(cmd)
  3827 *-* if      obtype = 'S'
  3828 *-*  then
       *-*  extra = "DATA('backstop for DB2-"ssid "stogroup')"
  3829 *-* else
       *-*  if obtype = 'R'
  3830 *-*   then
       *-*   extra = "DATA('backstop for DB2-"ssid "tablespace')"
  3831 *-*  else
       *-*   if obtype = 'J'
  3832 *-*    then
       *-*    extra = "DATA('backstop for DB2-"ssid "jar')"
  3833 *-*   else
       *-*    if obtype = 'D'
  3834 *-*     then
       *-*     extra = "DATA('backstop for DB2-"ssid "distinct type')"
  3835 *-*    else
       *-*     extra = ''
  3837 *-* if obtype = 'R'
  3838 *-*  then
       *-*  prof = '*.*.'auth
  3839 *-* else
       *-*  prof = '*.'auth
  3841 *-* If model=1
       *-*  Then
       *-*  prof=prof
  3842 *-* Else
       *-*  prof=ssid'.'prof
  3843 *-* prof= left(prof,max(20,length(prof)))
  3845 *-* cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                            extra /* rph */
  3848 *-* x = clistCard(cmd)
  3849 *-* x = clistCard(' ')
  3851 *-* /* for comments below */
  3852 *-* /* ------------------ */
  3853 *-* if      obtype = 'S'
  3854 *-*  then
       *-*  extra = "DATA('DB2-"ssid "use priv for stogroup')"
  3855 *-* else
       *-*  if obtype = 'R'
  3856 *-*   then
       *-*   extra = "DATA('DB2-"ssid "use priv for tablespace')"
  3857 *-*  else
       *-*   if obtype = 'J'
  3858 *-*    then
       *-*    extra = "DATA('DB2-"ssid "use priv for jar')"
  3859 *-*   else
       *-*    if obtype = 'D'
  3860 *-*     then
       *-*     extra = "DATA('DB2-"ssid "use priv for distinct type')"
  3861 *-*    else
       *-*     extra = ''
  3863 *-* /* Find all objects, and make commands to create profiles */
  3864 *-* /* for 'auth'. Then remove executor from access list.     */
  3865 *-* x=sql('NEW statement') /* start new sql statement */
  3866 *-* /* ----------------------- */
  3867 *-* x=sql("SELECT DISTINCT NAME"                        )
  3869 *-* if obtype = 'R'
  3870 *-*  then ,
  3871 *-*  x=sql("               ,QUALIFIER"                   )
  3873 *-* x=sql("FROM SYSIBM.SYSRESAUTH"                      )
  3874 *-* x=sql("WHERE OBTYPE='"obtype"'"                     )
  3876 *-* call ZSQL
  3878 *-* rowsReturned = 0
  3879 *-* Do Until SQLCODE \= 0
  3880 *-*  if obtype = 'R'
  3881 *-*   then
       *-*   address dsnrexx "EXECSQL FETCH C1 INTO :name, :qualifier"
  3882 *-*  else
       *-*   address dsnrexx "EXECSQL FETCH C1 INTO :name"
  3883 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  3884 *-*    rowsReturned = rowsReturned + 1
  3885 *-*    parse upper var name name .
  3886 *-*    parse upper var qualifier qualifier . /* potentially dbname*/
  3888 *-*    if obtype = 'R'
       *-*     then
       *-*     name = qualifier'.'name
  3890 *-*    If model=1
       *-*     Then
       *-*     prof=Strip(name)'.'auth
  3891 *-*    Else
       *-*     prof=ssid'.'Strip(name)'.'auth
  3892 *-*    prof= left(prof,max(20,length(prof)))
  3893 *-*    cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                               extra /* rph */
  3896 *-*    x = clistCard(cmd)
  3898 *-*    cmd="PERMIT "prof" CLASS("class") RESET"
  3899 *-*    if resetOption = 'RESET'
       *-*     then
       *-*     x = clistCard(cmd)
  3900 *-*   End
  3901 *-* End /* do until */
  3903 *-* call showRowCount /* show rowsReturned */
  3904 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  3905 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  3906 *-* address dsnrexx "EXECSQL CLOSE C1"
  3907 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  3909 *-*  /* If any of those were PUBLIC, change UACC to READ */
  3910 *-* x=sql('NEW statement') /* start new sql statement */
  3911 *-* /* ----------------------- */
  3912 *-* x=sql("SELECT DISTINCT NAME"                   )
  3914 *-* if obtype = 'R'
  3915 *-*  then ,
  3916 *-*  x=sql("               ,QUALIFIER"              )
  3918 *-* x=sql("FROM SYSIBM.SYSRESAUTH"                 )
  3919 *-* x=sql("WHERE OBTYPE='"obtype"'"                )
  3920 *-* x=sql("  AND USEAUTH=' '"                     )
  3921 *-* x=sql("  AND GRANTEE IN ('PUBLIC','PUBLIC*')"  )
  3923 *-* call ZSQL
  3925 *-* rowsReturned = 0
  3926 *-* Do Until SQLCODE \= 0
  3927 *-*  if obtype = 'R'
  3928 *-*   then
       *-*   address dsnrexx "EXECSQL FETCH C1 INTO :name, :qualifier"
  3929 *-*  else
       *-*   address dsnrexx "EXECSQL FETCH C1 INTO :name"
  3930 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  3931 *-*    rowsReturned = rowsReturned + 1
  3932 *-*    parse upper var name name .
  3933 *-*    parse upper var qualifier qualifier . /* potentially dbname*/
  3935 *-*    if obtype = 'R'
       *-*     then
       *-*     name = qualifier'.'name
  3938 *-*    If model=1
       *-*     Then
       *-*     prof=Strip(name)'.'auth
  3939 *-*    Else
       *-*     prof=ssid'.'Strip(name)'.'auth
  3940 *-*    prof= left(prof,max(35,length(prof)))
  3941 *-*    cmd="RALT "class prof" UACC(READ)" ,                                       "DATA('Everyone has" auth "priv on" name"'
)"
  3943 *-*    x = clistCard(cmd)
  3944 *-*   End
  3945 *-* End /* do until */
  3946 *-* call showRowCount /* show rowsReturned */
  3947 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  3948 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  3949 *-* address dsnrexx "EXECSQL CLOSE C1"
  3950 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  3952 *-* Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
  3953 *-* /* --------------------------- */
  3955 *-* /* Get all ids (except PUBLIC) for access list */
  3956 *-* x=sql('NEW statement') /* start new sql statement */
  3957 *-* /* ----------------------- */
  3958 *-* x=sql("SELECT DISTINCT NAME"                              )
  3959 *-* x=sql("               ,strip(upper(grantee)) as ugrantee" )
  3961 *-* if obtype = 'R'
  3962 *-*  then ,
  3963 *-*  x=sql("               ,QUALIFIER"                         )
  3965 *-* x=sql("FROM SYSIBM.SYSRESAUTH"                            )
  3966 *-* x=sql("WHERE OBTYPE='"obtype"'"                           )
  3967 *-* x=sql("  AND USEAUTH<>' '"                                )
  3968 *-* x=sql("  AND GRANTEE NOT IN ('PUBLIC','PUBLIC*')"         )
  3969 *-* if SlimAdm
  3970 *-*  then
       *-*  do
  3971 *-*   x=sql("  AND GRANTEE NOT IN (select distinct grantee"     )
  3972 *-*   x=sql("                      from sysibm.sysuserauth"     )
  3973 *-*   x=sql("                      where sysadmauth <> ' '"     )
  3974 *-*   x=sql("                     )"                            )
  3975 *-*  end
  3977 *-* if removeUserList <> ''
  3978 *-*  then ,
  3979 *-*  x=sql("  AND GRANTEE not in" RemoveUserList               )
  3981 *-* x=sql("ORDER BY name, ugrantee"                           )
  3983 *-* call ZSQL
  3985 *-* rowsReturned = 0
  3986 *-* Do Until SQLCODE \= 0
  3987 *-*  if obtype = 'R'
  3988 *-*   then
       *-*   address dsnrexx "EXECSQL FETCH C1 INTO :name, :grantee" ,                                                   ", :qualif
ier"
  3990 *-*  else
       *-*   address dsnrexx "EXECSQL FETCH C1 INTO :name, :grantee"
  3991 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  3992 *-*    rowsReturned = rowsReturned + 1
  3993 *-*    parse upper var name name .
  3994 *-*    parse upper var grantee grantee .
  3995 *-*    parse upper var qualifier qualifier . /* potentially dbname*/
  3997 *-*    if obtype = 'R'
       *-*     then
       *-*     name = qualifier'.'name
  3999 *-*    datacomment = ,                                                            "DATA('(READ); migrated" date('U')"')"
  4002 *-*    If model=1
       *-*     Then
       *-*     prof=Strip(name)'.'auth
  4003 *-*    Else
       *-*     prof=ssid'.'Strip(name)'.'auth
  4004 *-*    prof= left(prof,max(35,length(prof)))
  4005 *-*    cmd="PERMIT "prof" CLASS("class") ACC(READ)",                             "ID("Strip(grantee)")" ,
                             datacomment
  4008 *-*    x = clistCard(cmd)
  4009 *-*   End
  4010 *-* End /* do until */
  4011 *-* call showRowCount /* show rowsReturned */
  4012 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  4013 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  4014 *-* address dsnrexx "EXECSQL CLOSE C1"
  4015 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  4016 *-* Return    /* use_priv */
  4019 *-* BP_use_priv:
  4020 *-* /*****************************************************************/
  4021 *-* /* Get DB2 USE privileges (bufferpool, stogroup, tablespace)     */
  4022 *-* /*****************************************************************/
  4023 *-* Arg auth,obtype,type
  4024 *-* If model=1
       *-*  Then
       *-*  class="M"ssid||type||charopt
  4025 *-* Else
       *-*  class="M"classmnt||type||charopt
  4027 *-* Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
  4028 *-* /* --------------------------- */
  4029 *-* useClass = class
  4031 *-* /* create "backstop" so that everything else is rejected */
  4032 *-* /* ----------------------------------------------------- */
  4033 *-* x = clistCard(' ')
  4034 *-* cmd='/* create backstop RDEF (in bp_use_priv: routine) */'
  4035 *-* x = clistCard(cmd)
  4037 *-* extra = "DATA('backstop for DB2-"ssid "bufferpool')"
  4039 *-* If model=1
       *-*  Then
       *-*  prof='ALL.'auth
  4040 *-* Else
       *-*  prof=ssid'.ALL.'auth
  4041 *-* prof= left(prof,max(20,length(prof)))
  4043 *-* cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                            extra /* rph */
  4046 *-* x = clistCard(cmd)
  4047 *-* x = clistCard(' ')
  4050 *-* /* Find all objects (and whether PUBLIC or specific rules)*/
  4051 *-* /* Them create rdef's                                     */
  4052 *-* x=sql('NEW statement') /* start new sql statement */
  4053 *-* /* ----------------------- */
  4054 *-* x=sql("SELECT DISTINCT NAME, SPEC"                  )
  4055 *-* x=sql("from ("                                      )
  4056 *-* x=sql("     select distinct"                        )
  4057 *-* x=sql("        case when strip(a.name) = 'ALL' then '*'")
  4058 *-* x=sql("             else strip(a.name)"               )
  4059 *-* x=sql("             end             as name"        )
  4060 *-* x=sql("            ,'PUBLIC'        as spec"        )
  4061 *-* x=sql("        from sysibm.sysresauth a"            )
  4062 *-* x=sql("        where a.obtype='B' "                 )
  4063 *-* x=sql("          and a.useAuth <> ' '"              )
  4064 *-* x=sql("          and a.grantee in ('PUBLIC','PUBLIC*')")
  4065 *-* x=sql("    union"                                   )
  4066 *-* x=sql("     select distinct"                        )
  4067 *-* x=sql("        case when strip(b.name) = 'ALL' then '*'")
  4068 *-* x=sql("             else strip(b.name)"               )
  4069 *-* x=sql("             end             as name"        )
  4070 *-* x=sql("            ,'SPEC'          as spec"        )
  4071 *-* x=sql("        from sysibm.sysresauth b"            )
  4072 *-* x=sql("        where b.obtype='B' "                 )
  4073 *-* x=sql("          and b.useAuth <> ' '"              )
  4074 *-* x=sql("          and b.grantee"                     )
  4075 *-* x=sql("                not in ('PUBLIC','PUBLIC*')" )
  4076 *-* x=sql("          and not exists ("                  )
  4077 *-* x=sql("            select 1"                        )
  4078 *-* x=sql("            from sysibm.sysresauth c"        )
  4079 *-* x=sql("            where c.obtype='B' "             )
  4080 *-* x=sql("              and c.useAuth <> ' '"          )
  4081 *-* x=sql("              and c.grantee"                 )
  4082 *-* x=sql("                    in ('PUBLIC','PUBLIC*')" )
  4083 *-* x=sql("              and c.name = b.name"           )
  4084 *-* x=sql("                         )"                  )
  4085 *-* x=sql("     )"                                      )
  4086 *-* x=sql("order by name, spec"                         )
  4088 *-* call ZSQL
  4090 *-* rowsReturned = 0
  4091 *-* skiprest = 0
  4092 *-* Do Until SQLCODE \= 0
  4093 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :name, :spec"
  4094 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  4095 *-*    rowsReturned = rowsReturned + 1
  4096 *-*    parse upper var name name .
  4098 *-*    if name = '*'
  4099 *-*     then
       *-*     name = 'ALL' /* we wanted this to be 1st in sort order*/
  4101 *-*    if name = 'ALL' & spec = 'PUBLIC'
  4102 *-*     then
       *-*     do /* special case; have to override backstop */
  4103 *-*      If model=1
       *-*       Then
       *-*       prof=Strip(name)'.'auth
  4104 *-*      Else
       *-*       prof=ssid'.'Strip(name)'.'auth
  4105 *-*      prof= left(prof,max(35,length(prof)))
  4106 *-*      cmd="RALT "class prof" UACC(READ)" ,                                       "DATA('Everyone has" auth "priv on ALL b
ufferpools')"
  4108 *-*      x = clistCard(cmd)
  4109 *-*      skiprest = 1 /* ignore other rows*/
  4110 *-*      iterate
  4111 *-*     end
  4113 *-*    if skiprest = 1
  4114 *-*     then
       *-*     iterate /* if everyone has access, skip the rest */
  4116 *-*    If model=1
       *-*     Then
       *-*     prof=Strip(name)'.'auth
  4117 *-*    Else
       *-*     prof=ssid'.'Strip(name)'.'auth
  4118 *-*    prof= left(prof,max(20,length(prof)))
  4120 *-*    if spec = 'PUBLIC'
  4121 *-*     then
       *-*     do
  4122 *-*      cmd="RDEF "class prof" UACC(READ) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                                 "DATA('DB2-"ssid "Everyone has" auth "priv on" name"')"
  4125 *-*     end
  4126 *-*    else
       *-*     do
  4127 *-*      /* for comments below */
  4128 *-*      /* ------------------ */
  4129 *-*      cmd = 'RDEF'
  4130 *-*      if name = 'ALL'
  4131 *-*       then
       *-*       cmd = 'RALT'
  4132 *-*      cmd=cmd class prof" UACC(NONE) AUDIT(ALL(READ))",                           "OWNER("owner")" ,
                                 "DATA('DB2-"ssid "use priv for bufferpool" name"')"
  4135 *-*     end
  4137 *-*    x = clistCard(cmd)
  4139 *-*    cmd="PERMIT "prof" CLASS("class") RESET"
  4140 *-*    if resetOption = 'RESET'
       *-*     then
       *-*     x = clistCard(cmd)
  4141 *-*   End
  4142 *-* End /* do until */
  4144 *-* call showRowCount /* show rowsReturned */
  4145 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  4146 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  4147 *-* address dsnrexx "EXECSQL CLOSE C1"
  4148 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  4150 *-* if skiprest = 1 /* everyone has bufferpool use? */
  4151 *-*  then
       *-*  return     /* yes, nothing else to do */
  4153 *-* Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
  4154 *-* /* --------------------------- */
  4155 *-* /* Get all ids (except PUBLIC) for access list */
  4156 *-* x=sql('NEW statement') /* start new sql statement */
  4157 *-* /* ----------------------- */
  4158 *-* x=sql("SELECT DISTINCT NAME, UGRANTEE"                       )
  4159 *-* x=sql("from ("                                               )
  4160 *-* x=sql("   SELECT DISTINCT a.NAME                  as name"   )
  4161 *-* x=sql("                  ,strip(upper(a.grantee)) as ugrantee")
  4162 *-* x=sql("   FROM SYSIBM.SYSRESAUTH a"                          )
  4163 *-* x=sql("   WHERE a.OBTYPE='"obtype"'"                         )
  4164 *-* x=sql("     AND a.USEAUTH<>' '"                              )
  4165 *-* x=sql("     AND not exists ("                                )
  4166 *-* x=sql("            select 1"                                 )
  4167 *-* x=sql("            from sysibm.sysresauth b"                 )
  4168 *-* x=sql("            where a.obtype = b.obtype"                )
  4169 *-* x=sql("              and a.obtype = '"obtype"'"              )
  4170 *-* x=sql("              and a.name   = b.name"                  )
  4171 *-* x=sql("              and a.useauth <> ' '"                   )
  4172 *-* x=sql("              and b.useauth <> ' '"                   )
  4173 *-* x=sql("              and b.grantee in ('PUBLIC','PUBLIC*')"  )
  4174 *-* x=sql("                    )"                                )
  4175 *-* if SlimAdm
  4176 *-*  then
       *-*  do
  4177 *-*   x=sql("     AND a.GRANTEE NOT IN (select distinct grantee"   )
  4178 *-*   x=sql("                           from sysibm.sysuserauth"   )
  4179 *-*   x=sql("                           where sysadmauth <> ' '"   )
  4180 *-*   x=sql("                          )"                          )
  4181 *-*  end
  4183 *-* if removeUserList <> ''
  4184 *-*  then ,
  4185 *-*  x=sql("     AND GRANTEE not in" RemoveUserList               )
  4187 *-* x=sql("  UNION"                                              )
  4189 *-* x=sql("   SELECT DISTINCT a.NAME                  as name"   )
  4190 *-* x=sql("                  ,strip(upper(b.grantee)) as ugrantee")
  4191 *-* x=sql("   FROM SYSIBM.SYSRESAUTH A"                          )
  4192 *-* x=sql("       ,SYSIBM.SYSRESAUTH B"                          )
  4193 *-* x=sql("   WHERE A.OBTYPE='"obtype"'"                         )
  4194 *-* x=sql("     AND a.USEAUTH<>' '"                              )
  4195 *-* x=sql("     AND not exists ("                                )
  4196 *-* x=sql("            select 1"                                 )
  4197 *-* x=sql("            from sysibm.sysresauth c"                 )
  4198 *-* x=sql("            where a.obtype = c.obtype"                )
  4199 *-* x=sql("              and a.obtype = '"obtype"'"              )
  4200 *-* x=sql("              and a.name   = c.name"                  )
  4201 *-* x=sql("              and a.useauth <> ' '"                   )
  4202 *-* x=sql("              and c.useauth <> ' '"                   )
  4203 *-* x=sql("              and c.grantee in ('PUBLIC','PUBLIC*')"  )
  4204 *-* x=sql("                    )"                                )
  4205 *-* x=sql("     and b.OBTYPE='"obtype"'"                         )
  4206 *-* x=sql("     AND b.USEAUTH<>' '"                              )
  4207 *-* x=sql("     AND a.name   <> 'ALL'"                           )
  4208 *-* x=sql("     AND b.name    = 'ALL'"                           )
  4209 *-* if SlimAdm
  4210 *-*  then
       *-*  do
  4211 *-*   x=sql("     AND b.GRANTEE NOT IN (select distinct grantee"   )
  4212 *-*   x=sql("                           from sysibm.sysuserauth"   )
  4213 *-*   x=sql("                           where sysadmauth <> ' '"   )
  4214 *-*   x=sql("                          )"                          )
  4215 *-*  end
  4217 *-* if removeUserList <> ''
  4218 *-*  then ,
  4219 *-*  x=sql("     AND b.GRANTEE not in" RemoveUserList             )
  4221 *-* x=sql("     )"                                               )
  4222 *-* x=sql("ORDER BY name, ugrantee"                              )
  4224 *-* call ZSQL
  4226 *-* rowsReturned = 0
  4227 *-* Do Until SQLCODE \= 0
  4228 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :name, :grantee"
  4229 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  4230 *-*    rowsReturned = rowsReturned + 1
  4231 *-*    parse upper var name name .
  4232 *-*    parse upper var grantee grantee .
  4234 *-*    datacomment = ,                                                            "DATA('(READ); migrated" date('U')"')"
  4237 *-*    If model=1
       *-*     Then
       *-*     prof=Strip(name)'.'auth
  4238 *-*    Else
       *-*     prof=ssid'.'Strip(name)'.'auth
  4239 *-*    prof= left(prof,max(35,length(prof)))
  4240 *-*    cmd="PERMIT "prof" CLASS("class") ACC(READ)",                             "ID("Strip(grantee)")" ,
                             datacomment
  4243 *-*    x = clistCard(cmd)
  4244 *-*   End
  4245 *-* End /* do until */
  4246 *-* call showRowCount /* show rowsReturned */
  4247 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  4248 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  4249 *-* address dsnrexx "EXECSQL CLOSE C1"
  4250 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  4251 *-* return
  4252 *-* Return    /* use_priv */
  4254 *-* pack_priv:
  4255 *-* /*****************************************************************/
  4256 *-* /* Get DB2 Package privileges                                    */
  4257 *-* /*    This gets tricky, because SYSPACKAUTH has COLLID and       */
  4258 *-* /* can have * for NAME (Package ID).  We must define all the     */
  4259 *-* /* permits with * first, then PERMIT FROM(xx.*) as well as the   */
  4260 *-* /* normal permits.                                               */
  4261 *-* /*                                                               */
  4262 *-* /*    We also ignore any row where GRANTEETYPE='P' (for access)  */
  4263 *-* /*                                                               */
  4264 *-* /*    Note, PERMIT FROM(xx.*) can cause a lot of warnings because*/
  4265 *-* /* of, in effect, duplicate 'permits' for grantee's already in   */
  4266 *-* /* a specific profile.  Therefore, select has been changed so    */
  4267 *-* /* that for a specific profile, we only add the missing permits  */
  4268 *-* /* expliticly instead.                                           */
  4269 *-* /*****************************************************************/
  4270 *-* Arg auth,col
  4271 *-* If model=1
       *-*  Then
       *-*  class="M"ssid"PK"charopt
  4272 *-* Else
       *-*  class="M"classmnt"PK"charopt
  4275 *-* handledCollid.  = 0 /* 0 = explicit; 1 = collid.* to public */
  4277 *-* IgnoreCollid = ''
  4278 *-* CollidComma  = ' '
  4280 *-* Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
  4281 *-* /* --------------------------- */
  4283 *-* useClass    = class    /* direct comments to this class */
  4284 *-* /* ----------------------------- */
  4286 *-* /* create "backstop" so that everything else is rejected */
  4287 *-* /* ----------------------------------------------------- */
  4288 *-* x = clistCard(' ')
  4289 *-* cmd='/* create backstop RDEF (in pack_priv: routine) */'
  4290 *-* x = clistCard(cmd)
  4292 *-* If model=1
       *-*  Then
       *-*  prof='*.*'
  4293 *-* Else
       *-*  prof=ssid'.*.*'
  4294 *-* prof=prof'.'auth
  4295 *-* prof= left(prof,max(41,length(prof)))
  4296 *-* data='Backstop for' auth 'on collid/pkg *.*'
  4298 *-* x = clistCard(' ')
  4299 *-* cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                              "DATA('"data"')"
  4302 *-* x = clistCard(cmd)
  4303 *-* x = clistCard(' ')
  4305 *-* /* identify some pkges we believe could have generic rules*/
  4306 *-* /* look at packages + packauth to return the following    */
  4307 *-* /* for each collid, if appropriate.                       */
  4308 *-* /*                                                        */
  4309 *-* /* "all*pkgs" will only appear for collid.* to public     */
  4310 *-* /*           (sometime appears)                           */
  4311 *-* /*                                                        */
  4312 *-* /* "allspec"  will only appear if at least one pkg was    */
  4313 *-* /*           granted to public (sometimes appears)        */
  4314 *-* /*                                                        */
  4315 *-* /* "pkgTotal" will give us a count of distinct packages   */
  4316 *-* /*           for a given collid (always appears)          */
  4317 *-* /*                                                        */
  4318 *-* /* -----------------------------------------------------  */
  4319 *-* /* collid, "all*pkgs", 1: for grant collid.* to PUBLIC    */
  4320 *-* /*                                                        */
  4321 *-* /* collid, "allspec", count(*) of distinct packages       */
  4322 *-* /*                        for grant collid.pkg to PUBLIC  */
  4323 *-* /*                                                        */
  4324 *-* /* collid, "pkgTotal", count(*) for all distinct packages */
  4325 *-* /*                                                        */
  4326 *-* /* -----------------------------------------------------  */
  4327 *-* x = clistCard("/* PackPriv.  GenericOption SQL */")
  4328 *-* x=sql('NEW statement') /* start new sql statement */
  4329 *-* /* ----------------------- */
  4330 *-* x=sql(" Select collid, 'PKGTOTAL' as nameX, count(*)"   )
  4331 *-* x=sql('    from (select distinct'                       )
  4332 *-* x=sql('               collid'                           )
  4333 *-* x=sql('              ,name'                             )
  4334 *-* x=sql('          from sysibm.syspackage'                )
  4335 *-* x=sql('         )'                                      )
  4336 *-* x=sql('    group by collid'                             )
  4337 *-* x=sql('union'                                           )
  4338 *-* x=sql(" Select collid, 'ALL*PKGS' as nameX, count(*)"   )
  4339 *-* x=sql("    from ("                                      )
  4340 *-* x=sql("          select distinct a.collid"              )
  4341 *-* x=sql("          from sysibm.syspackauth as a"          )
  4342 *-* x=sql("          where a.granteeType = ' '"             )
  4343 *-* x=sql("            and a.name        = '*'"             )
  4344 *-* x=sql("            and a."col "<>' '"                   )
  4345 *-* x=sql("            and exists"                          )
  4346 *-* x=sql("               ("                                )
  4347 *-* x=sql("                select 1"                        )
  4348 *-* x=sql("                from sysibm.syspackauth as b"    )
  4349 *-* x=sql("                where b.granteeType = ''"        )
  4350 *-* x=sql("                  and b.name   = '*'"            )
  4351 *-* x=sql("                  and b.collid = a.collid"       )
  4352 *-* x=sql("                  and b."col "<> ' '"            )
  4353 *-* x=sql("                  and (   b.grantee = 'PUBLIC' " )
  4354 *-* x=sql("                       or b.grantee = 'PUBLIC*'" )
  4355 *-* x=sql("                      )"                         )
  4356 *-* x=sql("               )"                                )
  4357 *-* x=sql("         )"                                      )
  4358 *-* x=sql('    group by collid'                             )
  4359 *-* x=sql('union'                                           )
  4360 *-* x=sql(" Select collid, 'ALLSPEC ' as namex, count(*)"   )
  4361 *-* x=sql(' from (select distinct'                          )
  4362 *-* x=sql('           k.collid'                             )
  4363 *-* x=sql('          ,k.name'                               )
  4364 *-* x=sql("        from sysibm.syspackage as k"             )
  4365 *-* x=sql("       where exists"                             )
  4366 *-* x=sql("           ("                                    )
  4367 *-* x=sql("           select 1"                             )
  4368 *-* x=sql("           from sysibm.syspackauth as d"         )
  4369 *-* x=sql("           where d.granteeType = ''"             )
  4370 *-* x=sql("             and d."col "<> ' '"                 )
  4371 *-* x=sql("             and d.collid = k.collid"            )
  4372 *-* x=sql("             and d.name = k.name"                )
  4373 *-* x=sql("             and (   d.grantee = 'PUBLIC' "      )
  4374 *-* x=sql("                  or d.grantee = 'PUBLIC*'"      )
  4375 *-* x=sql("                 )"                              )
  4376 *-* x=sql("           )"                                    )
  4377 *-* x=sql("      )"                                         )
  4378 *-* x=sql(' group by collid'                                )
  4379 *-* x=sql('order by collid, nameX'                          )
  4381 *-* call ZSQL
  4383 *-* lastCollid = ''
  4384 *-* lastAllpkgCount = 0
  4385 *-* lastAllspecCount= 0
  4386 *-* lastPkgCount    = 0
  4387 *-* rowsReturned = 0
  4388 *-* Do Until SQLCODE \= 0
  4389 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :collid, :nameX, :countx"
  4390 *-*  If SQLCODE = 0
  4391 *-*   then
       *-*   do
  4392 *-*    rowsReturned = rowsReturned + 1
  4393 *-*    parse upper var collId collId .
  4394 *-*    parse upper var namex  namex  .
  4395 *-*    if handledCollid.collid = 1
  4396 *-*     then
       *-*     iterate /* ALL*PKGS = one generic collid.* public*/
  4398 *-*    if namex = 'ALL*PKGS'
  4399 *-*     then
       *-*     do
  4400 *-*      /* generate generic RDEF */
  4402 *-*      /* change-07/25/2023 fixed to use "collid" instead */
  4403 *-*      /*                   of lastCollid                 */
  4404 *-*      handledCollid.collid = 1 /* indicate we handled it */
  4405 *-*      ignoreCollid = ignoreCollid collidComma"'"Collid"'"
  4407 *-*      collidComma  = ',' /*seperate with comma's going forward*/
  4409 *-*      If model=1
       *-*       Then
       *-*       prof=Collid'.*'
  4410 *-*      Else
       *-*       prof=ssid'.'Collid'.*'
  4411 *-*      prof=prof'.'auth
  4412 *-*      prof= left(prof,max(41,length(prof)))
  4413 *-*      data='Everyone has' auth 'on collid' Collid'.*'
  4415 *-*      x = clistCard(' ')
  4416 *-*      cmd="RDEF "class prof" UACC(READ) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                                   "DATA('"data"')"
  4420 *-*      x = clistCard(cmd)
  4422 *-*      cmd="PERMIT "prof" CLASS("class") RESET"
  4423 *-*      if resetOption = 'RESET'
       *-*       then
       *-*       x = clistCard(cmd)
  4424 *-*      iterate
  4425 *-*     end
  4426 *-*    if collid <> lastCollid
  4427 *-*     then
       *-*     do
  4428 *-*      /* just re=init for next time */
  4429 *-*      /* could be that we had PUBLIC grants */
  4430 *-*      /* ... but for a collection with no   */
  4431 *-*      /*    packages.  So we will ignore it */
  4432 *-*      lastCollid = collid /* update last Collid */
  4433 *-*      if nameX = 'ALLSPEC'
  4434 *-*       then
       *-*       lastAllSpecCount = countx
  4435 *-*      iterate
  4436 *-*     end
  4438 *-*     /* same collid w/two rows, if we got here.               */
  4439 *-*     /*                                                       */
  4440 *-*     /* As any row with "ALL*PKGS" prevented us from getting  */
  4441 *-*     /* here, this must be "PKGTOTAL" after we saw an         */
  4442 *-*     /* "ALLSPEC" row.                                        */
  4443 *-*     /*                                                       */
  4444 *-*     /* Note:  not only was "ALL*PKGS" handled above, if any. */
  4445 *-*     /*    but that would also ensure handleCollid.collid=1   */
  4446 *-*     /*    and all subsequent rows for that collid were       */
  4447 *-*     /*    ignored (via an iterate) before we ever got here.  */
  4448 *-*     /*                                                       */
  4449 *-*     /*                                                       */
  4450 *-*    lastPkgCount = countx
  4452 *-*    /* this was last row for this collid (namex = PKGTOTAL) */
  4453 *-*    if lastAllSpecCount = lastPkgCount ,                                           & lastPkgCount   > 3
  4455 *-*     then
       *-*     do /* create a generic creator.*.priv uacc(Read)*/
  4456 *-*      /* all packages have PUBLIC access for this collid */
  4458 *-*      handledCollid.lastCollid= 1 /* indicate we handled it */
  4459 *-*      ignoreCollid = ignoreCollid collidComma"'"lastCollid"'"
  4461 *-*      collidComma  = ',' /*seperate with comma's going forward*/
  4463 *-*      If model=1
       *-*       Then
       *-*       prof=lastCollid'.*'
  4464 *-*      Else
       *-*       prof=ssid'.'lastCollid'.*'
  4465 *-*      prof=prof'.'auth
  4466 *-*      prof= left(prof,max(41,length(prof)))
  4467 *-*      data='Everyone has' auth 'on collid' lastCollid'.*'
  4469 *-*      x = clistCard(' ')
  4470 *-*      cmd="RDEF "class prof" UACC(READ) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                                   "DATA('"data"')"
  4474 *-*      x = clistCard(cmd)
  4476 *-*      cmd="PERMIT "prof" CLASS("class") RESET"
  4477 *-*      if resetOption = 'RESET'
       *-*       then
       *-*       x = clistCard(cmd)
  4478 *-*     end
  4479 *-*     /* as thiw row was "PKGTOTAL" ...       */
  4480 *-*    iterate /* next row will be start of new collid */
  4481 *-*   end
  4482 *-* End /* do until */
  4483 *-* call showRowCount /* show rowsReturned */
  4484 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  4485 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  4486 *-* address dsnrexx "EXECSQL CLOSE C1"
  4487 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  4489 *-* trace 'n'
  4491 *-* if ignoreCollid <> ''
  4492 *-*  then
       *-*  ignoreCollid = '('ignoreCollid')'
  4494 *-*  /* Find ALL packages with explicit names (to public) that  */
  4495 *-*  /* we need to create rdef's for.                           */
  4496 *-*  /* Note:  ignoreCollid will exclude all collid.* RDEF's    */
  4497 *-*  /*    we created above.                                    */
  4498 *-* x = clistCard("/* PackPriv.  SQL (all) explicit public */")
  4499 *-* x=sql('NEW statement') /* start new sql statement */
  4500 *-* /* ----------------------- */
  4501 *-* x=sql("SELECT DISTINCT COLLID, NAME"                 )
  4502 *-* x=sql("  FROM SYSIBM.SYSPACKAUTH"                    )
  4503 *-* x=sql("  WHERE" col "<> ' '"                         )
  4504 *-* x=sql("    and granteetype = ' '"                    )
  4505 *-* x=sql("    and grantee in ('PUBLIC','PUBLIC*')"      )
  4507 *-* if ignoreCollid <> ''
  4508 *-*  then ,
  4509 *-*  x=sql('    and COLLID NOT IN' ignoreCollid )/* eliminate these */
  4511 *-* x=sql("ORDER by COLLID, NAME"                        )
  4513 *-* call ZSQL
  4515 *-* rowsReturned = 0
  4516 *-* Do Until SQLCODE \= 0
  4517 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :collid, :name"
  4518 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  4519 *-*    rowsReturned = rowsReturned + 1
  4520 *-*    parse upper var collId collId .
  4521 *-*    parse upper var name   name   .
  4523 *-*    If model=1
       *-*     Then
       *-*     prof=Strip(collid)'.'Strip(name)'.'auth
  4524 *-*    Else
       *-*     prof=ssid'.'Strip(collid)'.'Strip(name)'.'auth
  4525 *-*    prof= left(prof,max(35,length(prof)))
  4526 *-*    cmd="RDEF "class prof" UACC(READ) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                              "DATA('Everyone has" ssid auth "for pkg" strip(collid)'.' ,                 || strip(name)"')"
  4530 *-*    x = clistCard(cmd)
  4532 *-*    cmd="PERMIT "prof" CLASS("class") RESET"
  4533 *-*    if resetOption = 'RESET'
       *-*     then
       *-*     x = clistCard(cmd)
  4534 *-*   End
  4535 *-* End /* do until */
  4536 *-* call showRowCount /* show rowsReturned */
  4537 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  4538 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  4539 *-* address dsnrexx "EXECSQL CLOSE C1"
  4540 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  4542 *-*  /* change-07/25/2023 reduce number of rdefs by making   */
  4543 *-*  /*                   sure we actually need an explicit  */
  4544 *-*  /*                   one.                               */
  4545 *-*  /* Find ALL (explicit) packages that have at least one     */
  4546 *-*  /* unique grant/permit that isn't in generic collid.*      */
  4547 *-* x = clistCard("/* PackPriv.  SQL 3 (all) explicit non-public */")
  4548 *-* x=sql('NEW statement') /* start new sql statement */
  4549 *-* /* ----------------------- */
  4550 *-* x=sql("SELECT DISTINCT a.COLLID, a.NAME"    )
  4551 *-* x=sql("    FROM SYSIBM.SYSPACKAUTH as a"    )
  4552 *-* x=sql("    WHERE a."col "<> ' '"            )
  4553 *-* x=sql("      and a.granteetype = ' '"       )
  4555 *-* if ignoreCollid <> ''
  4556 *-*  then ,
  4557 *-*  x=sql('    and a.COLLID NOT IN' ignoreCollid)/* eliminate these */
  4559 *-* if removeUserList <> ''
  4560 *-*  then ,
  4561 *-*  x=sql("    and a.GRANTEE not in" RemoveUserList   )
  4563 *-* x=sql("    and not exists /* ignore rdef for public */"   )
  4564 *-* x=sql("       ("                                          )
  4565 *-* x=sql("        select 1"                                  )
  4566 *-* x=sql("        from sysibm.sysPackAuth as b"              )
  4567 *-* x=sql("        where b."col "<> ' '"                      )
  4568 *-* x=sql("          and b.granteeType = ' '"                 )
  4569 *-* x=sql("          and b.collid = a.collid"                 )
  4570 *-* x=sql("          and b.name   = a.name"                   )
  4571 *-* x=sql("          and b.grantee in ('PUBLIC','PUBLIC*')"   )
  4572 *-* x=sql("       )"                                          )
  4574 *-* x=sql("    and exists /* must have grant not in pkg.* */" )
  4575 *-* x=sql("       ("                                          )
  4576 *-* x=sql("        select 1"                                  )
  4577 *-* x=sql("        from sysibm.sysPackAuth as c"              )
  4578 *-* x=sql("        where c."col "<> ' '"                      )
  4579 *-* x=sql("          and c.granteeType = ' '"                 )
  4580 *-* x=sql("          and c.collid = a.collid"                 )
  4581 *-* x=sql("          and c.name   = a.name"                   )
  4582 *-* x=sql("          and c.grantee not in ("                  )
  4583 *-* x=sql("            select d.grantee"                      )
  4584 *-* x=sql("            from sysibm.sysPackAuth as d"          )
  4585 *-* x=sql("            where d."col "<> ' '"                  )
  4586 *-* x=sql("              and d.granteeType = ' '"             )
  4587 *-* x=sql("              and d.collid = c.collid"             )
  4588 *-* x=sql("              and d.name   = '*'"                  )
  4589 *-* x=sql("              and d.name  <> c.name"               )
  4591 *-* if removeUserList <> ''
  4592 *-*  then ,
  4593 *-*  x=sql("              and d.GRANTEE not in" RemoveUserList )
  4594 *-* x=sql("                               )"                  )
  4595 *-* x=sql("       )"                                          )
  4596 *-* x=sql("ORDER by COLLID, NAME"                             )
  4597 *-* call ZSQL
  4599 *-* rowsReturned = 0
  4600 *-* Do Until SQLCODE \= 0
  4601 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :collid, :name"
  4602 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  4603 *-*    rowsReturned = rowsReturned + 1
  4604 *-*    parse upper var collid collid .
  4605 *-*    parse upper var name   name   .
  4607 *-*    If model=1
       *-*     Then
       *-*     prof=collid'.'name'.'auth
  4608 *-*    Else
       *-*     prof=ssid'.'collid'.'name'.'auth
  4609 *-*    prof= left(prof,max(35,length(prof)))
  4610 *-*    cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                              "DATA('DB2-"ssid auth "for pkg ssid.collection.pkgname')"
  4613 *-*    x = clistCard(cmd)
  4615 *-*    cmd="PERMIT "prof" CLASS("class") RESET"
  4616 *-*    if resetOption = 'RESET'
       *-*     then
       *-*     x = clistCard(cmd)
  4617 *-*   End
  4618 *-* End /* do until */
  4619 *-* call showRowCount /* show rowsReturned */
  4620 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  4621 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  4622 *-* address dsnrexx "EXECSQL CLOSE C1"
  4623 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  4626 *-* Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
  4627 *-* /* --------------------------- */
  4629 *-* /* change-07/25/2023 --- new sql statement to just collect */
  4630 *-* /*                       any grants for all collid.        */
  4631 *-* /*                       We will use them later            */
  4633 *-* x = clistCard("/* PackPriv.  SQL 4.1 get collid.* permits */")
  4634 *-* x=sql("New Statement")
  4635 *-* x=sql("SELECT DISTINCT a.collid, a.name, a.grantee" )
  4636 *-* x=sql("    FROM SYSIBM.SYSPACKAUTH as a"    )
  4637 *-* x=sql("    WHERE a."col "<> ' '"            )
  4638 *-* x=sql("      and a.name   = '*'"            )
  4639 *-* x=sql("      and a.granteetype = ' '"       )
  4641 *-* if ignoreCollid <> ''
  4642 *-*  then ,
  4643 *-*  x=sql('    and a.COLLID NOT IN' ignoreCollid)/* eliminate these */
  4645 *-* if removeUserList <> ''
  4646 *-*  then ,
  4647 *-*  x=sql("    and a.GRANTEE not in" RemoveUserList   )
  4649 *-* x=sql("    and not exists /* ignore rdef for public */"   )
  4650 *-* x=sql("       ("                                          )
  4651 *-* x=sql("        select 1"                                  )
  4652 *-* x=sql("        from sysibm.sysPackAuth as b"              )
  4653 *-* x=sql("        where b."col "<> ' '"                      )
  4654 *-* x=sql("          and b.granteeType = ' '"                 )
  4655 *-* x=sql("          and b.collid = a.collid"                 )
  4656 *-* x=sql("          and b.name   = a.name"                   )
  4657 *-* x=sql("          and b.grantee in ('PUBLIC','PUBLIC*')"   )
  4658 *-* x=sql("       )"                                          )
  4660 *-* x=sql("ORDER by COLLID, NAME, GRANTEE"                    )
  4662 *-* call ZSQL
  4664 *-* grantInGeneric.= 0
  4665 *-* rowsReturned = 0
  4666 *-* Do Until SQLCODE \= 0
  4667 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :collid, :name, :grantee"
  4668 *-*  If SQLCODE = 0
  4669 *-*   then
       *-*   do
  4670 *-*    rowsReturned = rowsReturned + 1
  4671 *-*    parse upper var collid  collid  .
  4672 *-*    parse upper var grantee grantee .
  4673 *-*    grantInGeneric.collid.0 = grantInGeneric.collid.0 + 1
  4674 *-*    grantInGeneric = grantInGeneric.collid.0
  4675 *-*    grantInGeneric.collid.grantInGeneric = grantee
  4676 *-*   end
  4677 *-* end
  4678 *-* call showRowCount /* show rowsReturned */
  4679 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  4680 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  4681 *-* address dsnrexx "EXECSQL CLOSE C1"
  4682 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  4685 *-* x = clistCard("/* PackPriv.  SQL 4.2 (all) permit '*' non-public */")
  4687 *-* /* change-07/25/2023 --- modifed sql statement to collect  */
  4688 *-* /*                       any grants for a specific package */
  4689 *-* /*                       in a collid (that aren't in       */
  4690 *-* /*                       collid.*)                         */
  4691 *-* /*                                                         */
  4692 *-* /*                       If none are found, we won't need  */
  4693 *-* /*                       need to generate any permits.  If */
  4694 *-* /*                       some are found, also add the      */
  4695 *-* /*                       generic permits to this explicit  */
  4696 *-* /*                       profile.                          */
  4698 *-* /* Get all ids (except PUBLIC) for access list to '*' packs */
  4699 *-* x=sql('NEW statement') /* start new sql statement */
  4700 *-* /* ----------------------- */
  4701 *-* x=sql("SELECT DISTINCT a.COLLID, a.NAME, a.grantee"       )
  4702 *-* x=sql("    FROM SYSIBM.SYSPACKAUTH as a"    )
  4703 *-* x=sql("    WHERE a."col "<> ' '"            )
  4704 *-* x=sql("      and a.granteetype = ' '"       )
  4706 *-* if ignoreCollid <> ''
  4707 *-*  then ,
  4708 *-*  x=sql('    and a.COLLID NOT IN' ignoreCollid)/* eliminate these */
  4710 *-* if removeUserList <> ''
  4711 *-*  then ,
  4712 *-*  x=sql("    and a.GRANTEE not in" RemoveUserList   )
  4714 *-* x=sql("    and not exists /* ignore rdef for public */"   )
  4715 *-* x=sql("       ("                                          )
  4716 *-* x=sql("        select 1"                                  )
  4717 *-* x=sql("        from sysibm.sysPackAuth as b"              )
  4718 *-* x=sql("        where b."col "<> ' '"                      )
  4719 *-* x=sql("          and b.granteeType = ' '"                 )
  4720 *-* x=sql("          and b.collid = a.collid"                 )
  4721 *-* x=sql("          and b.name   = a.name"                   )
  4722 *-* x=sql("          and b.grantee in ('PUBLIC','PUBLIC*')"   )
  4723 *-* x=sql("       )"                                          )
  4725 *-* x=sql("    and a.grantee in   /* grant not in pkg.* */"   )
  4726 *-* x=sql("       ("                                          )
  4727 *-* x=sql("        select c.grantee"                          )
  4728 *-* x=sql("        from sysibm.sysPackAuth as c"              )
  4729 *-* x=sql("        where c."col "<> ' '"                      )
  4730 *-* x=sql("          and c.granteeType = ' '"                 )
  4731 *-* x=sql("          and c.collid = a.collid"                 )
  4732 *-* x=sql("          and c.name   = a.name"                   )
  4733 *-* x=sql("          and c.grantee not in ("                  )
  4734 *-* x=sql("            select d.grantee"                      )
  4735 *-* x=sql("            from sysibm.sysPackAuth as d"          )
  4736 *-* x=sql("            where d."col "<> ' '"                  )
  4737 *-* x=sql("              and d.granteeType = ' '"             )
  4738 *-* x=sql("              and d.collid = c.collid"             )
  4739 *-* x=sql("              and d.name   = '*'"                  )
  4740 *-* x=sql("              and d.name  <> c.name"               )
  4742 *-* if removeUserList <> ''
  4743 *-*  then ,
  4744 *-*  x=sql("              and d.GRANTEE not in" RemoveUserList )
  4745 *-* x=sql("                               )"                  )
  4746 *-* x=sql("       )"                                          )
  4747 *-* x=sql("ORDER by COLLID, NAME, GRANTEE"                    )
  4749 *-* call ZSQL
  4751 *-* rowsReturned = 0
  4752 *-* lastCollid = ''
  4753 *-* lastname   = ''
  4754 *-* Do Until SQLCODE \= 0
  4755 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :collid, :name, :grantee"
  4756 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  4757 *-*    rowsReturned = rowsReturned + 1
  4758 *-*    parse upper var collid collid .
  4759 *-*    parse upper var name name .
  4760 *-*    parse upper var grantee grantee .
  4761 *-*    if lastCollid <> collid
  4762 *-*     then
       *-*     do /* set up for switch */
  4763 *-*      lastCollid = collid /* we switched collids */
  4764 *-*      lastName = ''       /* ...implies, we switched names too */
  4765 *-*     end
  4767 *-*    if lastName <> name
  4768 *-*     then
       *-*     do
  4769 *-*      /* add grants from collid.* to this (explict) collid.name */
  4770 *-*      If model=1
       *-*       Then
       *-*       prof=collid'.'name'.'auth
  4771 *-*      Else
       *-*       prof=ssid'.'collid'.'name'.'auth
  4772 *-*      prof= left(prof,max(55,length(prof)))
  4773 *-*      if grantInGeneric.collid.0 > 0 & name <> '*'
  4774 *-*       then
       *-*       do i4 = 1 by 1 for grantInGeneric.collid.0
  4775 *-*        cmd="PERMIT "prof" CLASS("class") ACC(READ)" ,                                            "ID("grantInGeneric.col
lid.i4")"
  4777 *-*        x = clistCard(cmd)
  4778 *-*       end
  4779 *-*      lastName = name /* but only add them once per name */
  4780 *-*     end
  4781 *-*    If model=1
       *-*     Then
       *-*     prof=collid'.'name'.'auth
  4782 *-*    Else
       *-*     prof=ssid'.'collid'.'name'.'auth
  4783 *-*    prof= left(prof,max(55,length(prof)))
  4784 *-*    cmd="PERMIT "prof" CLASS("class") ACC(READ) ID("grantee")"
  4785 *-*    x = clistCard(cmd)
  4786 *-*   End
  4787 *-* End /* do until */
  4788 *-* call showRowCount /* show rowsReturned */
  4789 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  4790 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  4791 *-* address dsnrexx "EXECSQL CLOSE C1"
  4792 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  4794 *-*  /* change-07/25/2023 "sql 5" which caused problems removed */
  4795 *-*  /*                       also permit missing acc(read) was */
  4796 *-*  /*                       in the sql 5 code.                */
  4797 *-*  /*                   "sql 4.1 and 4.2 replaced that.       */
  4799 *-* Return     /* pack_priv */
  4801 *-* cltn_priv:
  4802 *-* /*****************************************************************/
  4803 *-* /* Get DB2 Collection privileges                                 */
  4804 *-* /*    This gets tricky, because SYSRESAUTH with OBTYPE='C'       */
  4805 *-* /* can have * for NAME (Collection ID).  We must define all      */
  4806 *-* /* the permits with * first, then PERMIT FROM(xx.*) as well as  */
  4807 *-* /* the normal permits.                                           */
  4808 *-* /*                                                               */
  4809 *-* /*    Note, PERMIT FROM(xx.*) can cause a lot of warnings because*/
  4810 *-* /* of, in effect, duplicate 'permits' for grantee's already in   */
  4811 *-* /* a specific profile.  Therefore, select has been changed so    */
  4812 *-* /* that for a specific profile, we only add the missing permits  */
  4813 *-* /* expliticly instead.                                           */
  4814 *-* /*****************************************************************/
  4815 *-* Arg auth
  4816 *-* /* Note: auth is always CREATEIN for Collections */
  4817 *-* If model=1
       *-*  Then
       *-*  class="M"ssid"CL"charopt
  4818 *-* Else
       *-*  class="M"classmnt"CL"charopt
  4820 *-* Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
  4821 *-* /* --------------------------- */
  4822 *-* useClass = class
  4824 *-* /* create "backstop" so that everything else is rejected */
  4825 *-* /* ----------------------------------------------------- */
  4826 *-* x = clistCard(' ')
  4827 *-* cmd='/* create backstop RDEF (in cltn_priv: routine) */'
  4828 *-* x = clistCard(cmd)
  4830 *-* If model=1
       *-*  Then
       *-*  prof="*."auth
  4831 *-* Else
       *-*  prof=ssid".*."auth
  4832 *-* prof= left(prof,max(25,length(prof)))
  4833 *-* cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                      "OWNER("owner")" ,
                           "DATA('Backstop DB2-"ssid auth "priv for collection')"
  4836 *-* x = clistCard(cmd)
  4837 *-* x = clistCard(' ')
  4839 *-* /* Find all objects, and make commands to create profiles */
  4840 *-* /* for 'auth'. Then remove executor from access list.     */
  4841 *-* x=sql('NEW statement') /* start new sql statement */
  4842 *-* /* ----------------------- */
  4843 *-* x=sql("SELECT DISTINCT NAME, SPEC"                  )
  4844 *-* x=sql("from ("                                      )
  4845 *-* x=sql("     select distinct a.name as name"         )
  4846 *-* x=sql("                  ,'PUBLIC' as spec"         )
  4847 *-* x=sql("        from sysibm.sysresauth a"            )
  4848 *-* x=sql("        where a.obtype='C' "                 )
  4849 *-* x=sql("          and a.QUALIFIER='        '"        )
  4850 *-* x=sql("          and a.grantee in ('PUBLIC','PUBLIC*')")
  4851 *-* x=sql("    union"                                   )
  4852 *-* x=sql("     select distinct b.name as name"         )
  4853 *-* x=sql("                  ,'SPEC'   as spec"         )
  4854 *-* x=sql("        from sysibm.sysresauth b"            )
  4855 *-* x=sql("        where b.obtype='C' "                 )
  4856 *-* x=sql("          and b.QUALIFIER='        '"        )
  4857 *-* x=sql("          and b.grantee"                     )
  4858 *-* x=sql("                not in ('PUBLIC','PUBLIC*')" )
  4859 *-* x=sql("          and not exists ("                  )
  4860 *-* x=sql("            select 1"                        )
  4861 *-* x=sql("            from sysibm.sysresauth c"        )
  4862 *-* x=sql("            where c.obtype='C' "             )
  4863 *-* x=sql("              and b.QUALIFIER='        '"    )
  4864 *-* x=sql("              and c.grantee"                 )
  4865 *-* x=sql("                    in ('PUBLIC','PUBLIC*')" )
  4866 *-* x=sql("              and c.name = b.name"           )
  4867 *-* x=sql("                         )"                  )
  4868 *-* x=sql("     )"                                      )
  4869 *-* x=sql("order by name, spec"                         )
  4871 *-* call ZSQL
  4873 *-* /* now create collections */
  4874 *-* rowsReturned = 0
  4875 *-* skiprest = 0
  4876 *-* Do Until SQLCODE \= 0
  4877 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :name, :spec"
  4878 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  4879 *-*    rowsReturned = rowsReturned + 1
  4880 *-*    parse upper var name name .
  4882 *-*    if name = '*' & spec = 'PUBLIC'
  4883 *-*     then
       *-*     do /* special case; have to override backstop */
  4884 *-*      If model=1
       *-*       Then
       *-*       prof=Strip(name)"."auth
  4885 *-*      Else
       *-*       prof=ssid"."Strip(name)"."auth
  4886 *-*      prof= left(prof,max(25,length(prof)))
  4887 *-*      cmd="RALT "class prof" UACC(READ) AUDIT(ALL(READ))",                      "OWNER("owner")" ,
                                "DATA('DB2-"ssid "Everyone has CREATE 4 all collections')"
  4890 *-*      x = clistCard(cmd)
  4892 *-*      cmd="PERMIT "prof" CLASS("class") RESET"
  4893 *-*      if resetOption = 'RESET'
       *-*       then
       *-*       x = clistCard(cmd)
  4894 *-*      skiprest = 1
  4895 *-*      iterate
  4896 *-*     end
  4898 *-*    if skiprest = 1
  4899 *-*     then
       *-*     iterate
  4901 *-*    cmd = 'RDEF'
  4902 *-*    if name = '*'
       *-*     then
       *-*     cmd = 'RALT'
  4904 *-*    If model=1
       *-*     Then
       *-*     prof=Strip(name)"."auth
  4905 *-*    Else
       *-*     prof=ssid"."Strip(name)"."auth
  4906 *-*    prof= left(prof,max(25,length(prof)))
  4908 *-*    if spec = 'PUBLIC'
  4909 *-*     then
       *-*     do
  4910 *-*      cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                      "OWNER("owner")" ,
                                "DATA('DB2-"ssid "Everyone has create priv')" /* rph */
  4913 *-*      x = clistCard(cmd)
  4914 *-*     end
  4915 *-*    else
       *-*     do
  4916 *-*      cmd = 'RDEF'
  4917 *-*      if name = '*'
       *-*       then
       *-*       cmd = 'RALT'
  4918 *-*      cmd=cmd class prof" UACC(NONE) AUDIT(ALL(READ))",                         "OWNER("owner")" ,
                                "DATA('DB2-"ssid auth "priv for collection')" /* rph */
  4921 *-*      x = clistCard(cmd)
  4922 *-*     end
  4924 *-*    cmd="PERMIT "prof" CLASS("class") RESET"
  4925 *-*    if resetOption = 'RESET'
       *-*     then
       *-*     x = clistCard(cmd)
  4926 *-*   End
  4927 *-* End /* do until */
  4928 *-* call showRowCount /* show rowsReturned */
  4929 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  4930 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  4931 *-* address dsnrexx "EXECSQL CLOSE C1"
  4932 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  4934 *-* if skiprest = 1 /*everyone has create collection priv? */
  4935 *-*  then
       *-*  return     /*yes, nothing else to do              */
  4937 *-* Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
  4938 *-* /* --------------------------- */
  4940 *-* /* Get all ids (except PUBLIC) for access list create       */
  4941 *-* /* add ids granted to create *                              */
  4942 *-* /* ...other than sysadmins                                  */
  4943 *-* x=sql('NEW statement') /* start new sql statement */
  4944 *-* /* ----------------------- */
  4945 *-* x=sql("SELECT DISTINCT NAME, UGRANTEE"                       )
  4946 *-* x=sql("from ("                                               )
  4947 *-* x=sql("   SELECT DISTINCT a.NAME                  as name"   )
  4948 *-* x=sql("                  ,strip(upper(a.grantee)) as ugrantee")
  4949 *-* x=sql("   FROM SYSIBM.SYSRESAUTH a"                          )
  4950 *-* x=sql("   WHERE a.OBTYPE='C'"                                )
  4951 *-* x=sql("     AND a.QUALIFIER='        '"                      )
  4952 *-* x=sql("     AND a.USEAUTH<>' '"                              )
  4953 *-* x=sql("     AND not exists ("                                )
  4954 *-* x=sql("            select 1"                                 )
  4955 *-* x=sql("            from sysibm.sysresauth b"                 )
  4956 *-* x=sql("            where a.obtype = b.obtype"                )
  4957 *-* x=sql("              and a.obtype = 'C'"                     )
  4958 *-* x=sql("              and a.QUALIFIER='        '"             )
  4959 *-* x=sql("              and b.QUALIFIER='        '"             )
  4960 *-* x=sql("              and a.name   = b.name"                  )
  4961 *-* x=sql("              and a.useauth <> ' '"                   )
  4962 *-* x=sql("              and b.useauth <> ' '"                   )
  4963 *-* x=sql("              and b.grantee in ('PUBLIC','PUBLIC*')"  )
  4964 *-* x=sql("                    )"                                )
  4965 *-* if SlimAdm
  4966 *-*  then
       *-*  do
  4967 *-*   x=sql("     AND a.GRANTEE NOT IN (select distinct grantee"   )
  4968 *-*   x=sql("                           from sysibm.sysuserauth"   )
  4969 *-*   x=sql("                           where sysadmauth <> ' '"   )
  4970 *-*   x=sql("                          )"                          )
  4971 *-*  end
  4973 *-* if removeUserList <> ''
  4974 *-*  then ,
  4975 *-*  x=sql("     AND GRANTEE not in" RemoveUserList               )
  4977 *-* x=sql("  UNION"                                              )
  4979 *-* x=sql("   SELECT DISTINCT a.NAME                  as name"   )
  4980 *-* x=sql("                  ,strip(upper(b.grantee)) as ugrantee")
  4981 *-* x=sql("   FROM SYSIBM.SYSRESAUTH A"                          )
  4982 *-* x=sql("       ,SYSIBM.SYSRESAUTH B"                          )
  4983 *-* x=sql("   WHERE A.OBTYPE='C'"                                )
  4984 *-* x=sql("     AND a.QUALIFIER='        '"                      )
  4985 *-* x=sql("     AND b.QUALIFIER='        '"                      )
  4986 *-* x=sql("     AND a.USEAUTH<>' '"                              )
  4987 *-* x=sql("     AND not exists ("                                )
  4988 *-* x=sql("            select 1"                                 )
  4989 *-* x=sql("            from sysibm.sysresauth c"                 )
  4990 *-* x=sql("            where a.obtype = c.obtype"                )
  4991 *-* x=sql("              and a.obtype = 'C'"                     )
  4992 *-* x=sql("              and a.QUALIFIER='        '"             )
  4993 *-* x=sql("              and c.QUALIFIER='        '"             )
  4994 *-* x=sql("              and a.name   = c.name"                  )
  4995 *-* x=sql("              and a.useauth <> ' '"                   )
  4996 *-* x=sql("              and c.useauth <> ' '"                   )
  4997 *-* x=sql("              and c.grantee in ('PUBLIC','PUBLIC*')"  )
  4998 *-* x=sql("                    )"                                )
  4999 *-* x=sql("     and b.OBTYPE='C'"                                )
  5000 *-* x=sql("     AND b.USEAUTH<>' '"                              )
  5001 *-* x=sql("     AND a.name   <> '*'"                             )
  5002 *-* x=sql("     AND b.name    = '*'"                             )
  5003 *-* if SlimAdm
  5004 *-*  then
       *-*  do
  5005 *-*   x=sql("     AND b.GRANTEE NOT IN (select distinct grantee"   )
  5006 *-*   x=sql("                           from sysibm.sysuserauth"   )
  5007 *-*   x=sql("                           where sysadmauth <> ' '"   )
  5008 *-*   x=sql("                          )"                          )
  5009 *-*  end
  5011 *-* if removeUserList <> ''
  5012 *-*  then ,
  5013 *-*  x=sql("     AND b.GRANTEE not in" RemoveUserList             )
  5015 *-* x=sql("     )"                                               )
  5016 *-* x=sql("ORDER BY name, ugrantee"                              )
  5018 *-* call ZSQL
  5020 *-* rowsReturned = 0
  5021 *-* Do Until SQLCODE \= 0
  5022 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :name, :grantee"
  5023 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  5024 *-*    rowsReturned = rowsReturned + 1
  5025 *-*    parse upper var name name .
  5027 *-*    If model=1
       *-*     Then
       *-*     prof=Strip(name)"."auth
  5028 *-*    Else
       *-*     prof=ssid"."Strip(name)"."auth
  5029 *-*    prof= left(prof,max(35,length(prof)))
  5030 *-*    datacomment = "DATA('has" auth "priv')"
  5031 *-*    cmd="PERMIT "prof" CLASS("class") ACC(READ)",                             "ID("Strip(grantee)")" ,
                             datacomment
  5034 *-*    x = clistCard(cmd)
  5035 *-*   End
  5036 *-* End /* do until */
  5037 *-* call showRowCount /* show rowsReturned */
  5038 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  5039 *-* Else
       *-*  call prtsqlca 'FETCH C1'
  5040 *-* address dsnrexx "EXECSQL CLOSE C1"
  5041 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  5043 *-* Return    /* cltn_priv */
  5045 *-* sys_attr:
  5046 *-* /*****************************************************************/
  5047 *-* /* Get DB2 system administrative authorities                     */
  5048 *-* /*****************************************************************/
  5049 *-* Arg auth,col
  5050 *-* If model=1
       *-*  Then
       *-*  prof=auth
  5051 *-* Else
       *-*  prof=ssid"."auth
  5053 *-* Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
  5054 *-* /* --------------------------- */
  5055 *-* useClass = class
  5057 *-* /* First determine if it is given to PUBLIC */
  5058 *-* x=sql('NEW statement') /* start new sql statement */
  5059 *-* /* ----------------------- */
  5060 *-* x=sql("SELECT COUNT(*)"           )
  5061 *-* x=sql("FROM SYSIBM.SYSUSERAUTH"   )
  5062 *-* x=sql("WHERE GRANTEE='PUBLIC'"    )
  5063 *-* x=sql("  AND "col"=' '"          )
  5065 *-* call ZSQL
  5067 *-* rowsReturned = 0
  5068 *-* address dsnrexx "EXECSQL FETCH C1 INTO :totalCount"
  5069 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'FETCH C1 '
  5071 *-* rowsReturned = rowsReturned + 1
  5073 *-* call showRowCount /* show rowsReturned */
  5074 *-* address dsnrexx "EXECSQL CLOSE C1"
  5075 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1 '
  5078 *-*  /* If there are no rows, it is not public */
  5079 *-* If totalCount = 0
  5080 *-*  then
       *-*  do
  5081 *-*   /* Define base profile */
  5082 *-*   uac = 'NONE'
  5083 *-*   prof= left(prof,max(25,length(prof)))
  5084 *-*   cmd="RDEF "class prof" UACC("uac") OWNER("owner") AUDIT(ALL(READ))" ,          "DATA('DB2-"ssid "subsystem" auth"-priv
iledge')" /* rph */
  5086 *-*   x = clistCard(cmd)
  5087 *-*  end
  5088 *-* else
       *-*  do
  5089 *-*   /* Define base profile */
  5090 *-*   uac = 'READ'
  5091 *-*   prof= left(prof,max(25,length(prof)))
  5092 *-*   cmd="RDEF "class prof" UACC("uac") OWNER("owner") AUDIT(ALL(READ))" ,          "DATA('Everyone has" ssid auth"-priv on
 subsystem')"
  5094 *-*   x = clistCard(cmd)
  5095 *-*  end
  5098 *-* /* Remove executor from access list */
  5099 *-* cmd="PERMIT "prof" CLASS("class") RESET"
  5100 *-* if resetOption = 'RESET'
       *-*  then
       *-*  x = clistCard(cmd)
  5102 *-* Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
  5103 *-* /* --------------------------- */
  5105 *-* /* Get all ids (except PUBLIC) for access list */
  5106 *-* /* ...for grantee with both PRIV = G and Y ... only*/
  5107 *-* /* ...process one for G                            */
  5108 *-* x=sql('NEW statement') /* start new sql statement */
  5109 *-* /* ----------------------- */
  5110 *-* x=sql("SELECT DISTINCT" granteeCase             )
  5111 *-* x=sql("FROM SYSIBM.SYSUSERAUTH as a"            )
  5112 *-* x=sql("WHERE a."col"<>' '"                      )
  5113 *-* x=sql("  AND a.GRANTEE='PUBLIC'"               )
  5115 *-* if col <> 'SYSADMAUTH' & SlimAdm
  5116 *-*  then
       *-*  do
  5117 *-*   x=sql("  and a.GRANTEE not in ("                )
  5118 *-*   x=sql("     select distinct b.grantee"          )
  5119 *-*   x=sql("        from sysibm.sysuserauth as b"    )
  5120 *-*   x=sql("        where b.sysadmauth <> ' '"       )
  5121 *-*   x=sql("                       )"                )
  5122 *-*  end
  5124 *-* if removeUserList <> ''
  5125 *-*  then ,
  5126 *-*  x=sql("  AND a.GRANTEE not in" RemoveUserList   )
  5128 *-* x=sql("order by grantee"                        )
  5130 *-* call ZSQL
  5132 *-* rowsReturned = 0
  5133 *-* Do Until SQLCODE \= 0
  5134 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :grantee"
  5135 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  5136 *-*    rowsReturned = rowsReturned + 1
  5137 *-*    if grantee = '*DELETE'
       *-*     then
       *-*     iterate
  5138 *-*    if auth = 'SYSADM' /* priv must = 'G' */
  5139 *-*     then
       *-*     cmd="PERMIT "prof" CLASS("class") ACC(ALTER) ID("grantee")"
  5140 *-*    else , /* just use read */
  5141 *-*     cmd="PERMIT "prof" CLASS("class") ACC(READ)  ID("grantee")"
  5143 *-*    x = clistCard(cmd) /* actually generate priv */
  5145 *-*    if auth = 'SYSADM'
  5146 *-*     then
       *-*     do
  5147 *-*      xsysadm = xsysadm + 1
  5148 *-*      xsysadm.xsysadm = grantee     /* remember who has sysadm */
  5149 *-*      xsysadmIndx.grantee = xsysadm /* quick index as well     */
  5150 *-*     end
  5151 *-*   End
  5152 *-* End /* do until */
  5153 *-* call showRowCount /* show rowsReturned */
  5154 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  5155 *-* Else
       *-*  call prtsqlca 'FETCH C1 '
  5156 *-* address dsnrexx "EXECSQL CLOSE C1"
  5157 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1 '
  5159 *-* Return     /* sys_attr */
  5162 *-* gv_attr:
  5163 *-* /*****************************************************************/
  5164 *-* /* Get DB2 global variable authorities                           */
  5165 *-* /*****************************************************************/
  5166 *-* Arg auth,col
  5167 *-* If model=1
       *-*  Then
       *-*  prof=auth
  5168 *-* Else
       *-*  prof=ssid"."auth
  5170 *-* Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
  5171 *-* /* --------------------------- */
  5172 *-* useClass = Class
  5174 *-* /* create "backstop" so that everything else is rejected */
  5175 *-* /* ----------------------------------------------------- */
  5176 *-* x = clistCard(' ')
  5177 *-* cmd='/* create backstop RDEF (in gv_attr: routine) */'
  5178 *-* x = clistCard(cmd)
  5180 *-* data = 'backstop DB2-'ssid auth'-priv on *.*'
  5182 *-* if model=1
  5183 *-*  then
       *-*  prof =      '*.*.'auth
  5184 *-* else
       *-*  prof = ssid'.*.*.'auth
  5186 *-* prof= left(prof,max(45,length(prof)))
  5187 *-* cmd="RDEF "class prof "UACC(NONE) OWNER("owner")" ,                            "AUDIT(ALL(READ))" ,
                               "DATA('"data"')"
  5190 *-* x = clistCard(cmd)
  5192 *-* /* First determine if it is given to PUBLIC */
  5193 *-* x=sql('NEW statement') /* start new sql statement */
  5194 *-* /* ----------------------- */
  5195 *-* x=sql(" SELECT distinct a.schema, a.name, 'PUBLIC' as gtype" )
  5196 *-* x=sql("   FROM SYSIBM.SYSVARIABLEAUTH as a"                  )
  5197 *-* x=sql("   WHERE a.GRANTEE='PUBLIC'"                          )
  5198 *-* x=sql("     and a."col"=' '"                                )
  5199 *-* x=sql("     and a.granteeType = ' '"                         )
  5200 *-* x=sql("UNION"                                                )
  5201 *-* x=sql(" SELECT distinct b.schema, b.name, 'OTHER ' as gtype" )
  5202 *-* x=sql("   FROM SYSIBM.SYSVARIABLEAUTH as b"                  )
  5203 *-* x=sql("   WHERE b."col"=' '"                                )
  5204 *-* x=sql("     and b.granteeType = ' '"                         )
  5205 *-* x=sql("     and not exists"                                  )
  5206 *-* x=sql("        ("                                            )
  5207 *-* x=sql("          select 1"                                   )
  5208 *-* x=sql("          FROM SYSIBM.SYSVARIABLEAUTH as c"           )
  5209 *-* x=sql("          WHERE c."col"=' '"                         )
  5210 *-* x=sql("            and c.granteeType = ' '"                  )
  5211 *-* x=sql("            and c.GRANTEE='PUBLIC'"                   )
  5212 *-* x=sql("            and c.schema = b.schema"                  )
  5213 *-* x=sql("            and c.name   = b.name"                    )
  5214 *-* x=sql("        )"                                            )
  5215 *-* x=sql("ORDER BY schema, name, gtype"                         )
  5216 *-* call ZSQL
  5218 *-* rowsReturned = 0
  5219 *-* do UNTIL sqlcode <> 0
  5220 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :schema, :name, :gtype"
  5221 *-*  if sqlcode = 0
  5222 *-*   then
       *-*   do
  5223 *-*    rowsReturned = rowsReturned + 1
  5224 *-*    parse upper var schema schema .
  5225 *-*    parse upper var name   name   .
  5226 *-*    if model=1
  5227 *-*     then
       *-*     prof =        schema'.'name'.'auth
  5228 *-*    else
       *-*     prof = ssid'.'schema'.'name'.'auth
  5230 *-*    if gtype = 'PUBLIC'
  5231 *-*     then
       *-*     do
  5232 *-*      uac = 'UACC(READ)'
  5233 *-*      data = 'DB2-'ssid 'Everyone has' auth'-priv on' ,                          schema'.'name
  5235 *-*     end
  5236 *-*    else
       *-*     do
  5237 *-*      uac = 'UACC(NONE)'
  5238 *-*      data = 'DB2-'ssid auth'-priv on' ,                                         schema'.'name
  5240 *-*     end
  5241 *-*    /* Define base profile */
  5242 *-*    prof= left(prof,max(45,length(prof)))
  5243 *-*    cmd="RDEF "class prof uac "OWNER("owner")" ,                                   "AUDIT(ALL(READ))" ,
                                  "DATA('"data"')"
  5246 *-*    x = clistCard(cmd)
  5247 *-*    /* Remove executor from access list */
  5248 *-*    cmd="PERMIT "prof" CLASS("class") RESET"
  5249 *-*    if resetOption = 'RESET'
       *-*     then
       *-*     x = clistCard(cmd)
  5250 *-*   end
  5251 *-* end
  5252 *-* call showRowCount /* show rowsReturned */
  5253 *-* If SQLCODE = 0 | sqlcode = 100
  5254 *-*  then
       *-*  nop
  5255 *-* else
       *-*  call prtsqlca 'FETCH C1 '
  5256 *-* address dsnrexx "EXECSQL CLOSE C1"
  5257 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1 '
  5259 *-* Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
  5260 *-* /* --------------------------- */
  5262 *-* /* Get all ids (except PUBLIC) for access list */
  5263 *-* x=sql('NEW statement') /* start new sql statement */
  5264 *-* /* ----------------------- */
  5265 *-* x=sql("SELECT DISTINCT a.schema"                        )
  5266 *-* x=sql("               ,a.name"                          )
  5267 *-* x=sql("               ,"granteecase                     )
  5268 *-* x=sql("   FROM SYSIBM.SYSVARIABLEAUTH as a"             )
  5269 *-* x=sql("   WHERE a."col"=' '"                           )
  5270 *-* x=sql("     and a.granteeType = ' '"                    )
  5271 *-* x=sql("     and not exists"                             )
  5272 *-* x=sql("        ("                                       )
  5273 *-* x=sql("          select 1"                              )
  5274 *-* x=sql("          FROM SYSIBM.SYSVARIABLEAUTH as c"      )
  5275 *-* x=sql("          WHERE c."col"=' '"                    )
  5276 *-* x=sql("            and c.granteeType = ' '"             )
  5277 *-* x=sql("            and c.GRANTEE='PUBLIC'"              )
  5278 *-* x=sql("            and c.schema = a.schema"             )
  5279 *-* x=sql("            and c.name   = a.name"               )
  5280 *-* x=sql("        )"                                       )
  5282 *-* if col <> 'SYSADMAUTH' & SlimAdm
  5283 *-*  then
       *-*  do
  5284 *-*   x=sql("     and a.GRANTEE not in"                       )
  5285 *-*   x=sql("        ("                                       )
  5286 *-*   x=sql("        select distinct d.grantee"               )
  5287 *-*   x=sql("           from sysibm.sysUserAUTH as d"         )
  5288 *-*   x=sql("           where d.sysadmauth <> ' '"            )
  5289 *-*   x=sql("        )"                                       )
  5290 *-*  end
  5292 *-* if removeUserList <> ''
  5293 *-*  then ,
  5294 *-*  x=sql("     AND a.GRANTEE not in" RemoveUserList        )
  5296 *-* x=sql("ORDER BY schema, name, grantee"                  )
  5298 *-* call ZSQL
  5300 *-* rowsReturned = 0
  5301 *-* Do Until SQLCODE \= 0
  5302 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :schema, :name, :grantee"
  5303 *-*  If SQLCODE = 0
  5304 *-*   then
       *-*   do
  5305 *-*    rowsReturned = rowsReturned + 1
  5306 *-*    parse upper var schema schema .
  5307 *-*    parse upper var name   name   .
  5309 *-*    if model=1
  5310 *-*     then
       *-*     prof =        schema'.'name'.'auth
  5311 *-*    else
       *-*     prof = ssid'.'schema'.'name'.'auth
  5312 *-*    prof= left(prof,max(45,length(prof)))
  5313 *-*    cmd="PERMIT "prof" CLASS("class") ACC(READ) ID("grantee")"
  5315 *-*    x = clistCard(cmd) /* actually generate priv */
  5316 *-*   End
  5317 *-* End /* do until */
  5318 *-* call showRowCount /* show rowsReturned */
  5319 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  5320 *-* Else
       *-*  call prtsqlca 'FETCH C1 '
  5321 *-* address dsnrexx "EXECSQL CLOSE C1"
  5322 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1 '
  5324 *-* Return     /* gv_attr */
  5326 *-* seq_attr:
  5327 *-* /*****************************************************************/
  5328 *-* /* Get DB2 sequence authorities                                  */
  5329 *-* /*****************************************************************/
  5330 *-* Arg auth,col
  5331 *-* If model=1
       *-*  Then
       *-*  prof=auth
  5332 *-* Else
       *-*  prof=ssid"."auth
  5334 *-* Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
  5335 *-* /* --------------------------- */
  5336 *-* useClass = class
  5338 *-* /* create "backstop" so that everything else is rejected */
  5339 *-* /* ----------------------------------------------------- */
  5340 *-* x = clistCard(' ')
  5341 *-* cmd='/* create backstop RDEF (in seq_attr: routine) */'
  5342 *-* x = clistCard(cmd)
  5344 *-* if model=1
  5345 *-*  then
       *-*  prof =      '*.*.'auth
  5346 *-* else
       *-*  prof = ssid'.*.*.'auth
  5348 *-* data = 'Backstop DB2-'ssid auth'-priv on *.*'
  5349 *-* /* Define base profile */
  5350 *-* prof= left(prof,max(45,length(prof)))
  5351 *-* cmd="RDEF "class prof "UACC(NONE) OWNER("owner")" ,                            "AUDIT(ALL(READ))" ,
                               "DATA('"data"')"
  5354 *-* x = clistCard(cmd)
  5355 *-* x = clistCard(' ')
  5357 *-* /* First determine if it is given to PUBLIC */
  5358 *-* x=sql('NEW statement') /* start new sql statement */
  5359 *-* /* ----------------------- */
  5360 *-* x=sql("  SELECT distinct a.schema, a.name, 'PUBLIC' as gtype"   )
  5361 *-* x=sql("     FROM SYSIBM.SYSSEQUENCEAUTH as a"                   )
  5362 *-* x=sql("     WHERE a.GRANTEE='PUBLIC'"                           )
  5363 *-* x=sql("       and a."col"=' '"                                 )
  5364 *-* x=sql("       and a.granteeType = ' '"                          )
  5365 *-* x=sql("UNION"                                                   )
  5366 *-* x=sql("  SELECT distinct b.schema, b.name, 'OTHER ' as gtype"   )
  5367 *-* x=sql("     FROM SYSIBM.SYSSEQUENCEAUTH as b"                   )
  5368 *-* x=sql("     WHERE b."col"=' '"                                 )
  5369 *-* x=sql("       and b.granteeType = ' '"                          )
  5370 *-* x=sql("       and not exists"                                   )
  5371 *-* x=sql("          ("                                             )
  5372 *-* x=sql("            select 1"                                    )
  5373 *-* x=sql("            FROM SYSIBM.SYSSEQUENCEAUTH as c"            )
  5374 *-* x=sql("            WHERE c."col"=' '"                          )
  5375 *-* x=sql("              and c.granteeType = ' '"                   )
  5376 *-* x=sql("              and c.GRANTEE='PUBLIC'"                    )
  5377 *-* x=sql("              and c.schema = b.schema"                   )
  5378 *-* x=sql("              and c.name   = b.name"                     )
  5379 *-* x=sql("          )"                                             )
  5380 *-* x=sql("ORDER BY schema, name, gtype"                            )
  5382 *-* call ZSQL
  5384 *-* rowsReturned = 0
  5385 *-* do UNTIL sqlcode <> 0
  5386 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :schema, :name, :gtype"
  5387 *-*  if sqlcode = 0
  5388 *-*   then
       *-*   do
  5389 *-*    rowsReturned = rowsReturned + 1
  5390 *-*    parse upper var schema schema .
  5391 *-*    parse upper var name   name   .
  5392 *-*    if model=1
  5393 *-*     then
       *-*     prof =        schema'.'name'.'auth
  5394 *-*    else
       *-*     prof = ssid'.'schema'.'name'.'auth
  5396 *-*    if gtype = 'PUBLIC'
  5397 *-*     then
       *-*     do
  5398 *-*      uac = 'UACC(READ)'
  5399 *-*      data = 'DB2-'ssid 'Everyone has' auth'-priv on' ,                          schema'.'name
  5401 *-*     end
  5402 *-*    else
       *-*     do
  5403 *-*      uac = 'UACC(NONE)'
  5404 *-*      data = 'DB2-'ssid auth'-priv on' ,                                         schema'.'name
  5406 *-*     end
  5407 *-*    /* Define base profile */
  5408 *-*    prof= left(prof,max(45,length(prof)))
  5409 *-*    cmd="RDEF "class prof uac "OWNER("owner")" ,                                   "AUDIT(ALL(READ))" ,
                                  "DATA('"data"')"
  5412 *-*    x = clistCard(cmd)
  5413 *-*    /* Remove executor from access list */
  5414 *-*    cmd="PERMIT "prof" CLASS("class") RESET"
  5415 *-*    if resetOption = 'RESET'
       *-*     then
       *-*     x = clistCard(cmd)
  5416 *-*   end
  5417 *-* end
  5418 *-* call showRowCount /* show rowsReturned */
  5419 *-* If SQLCODE = 0 | sqlcode = 100
  5420 *-*  then
       *-*  nop
  5421 *-* else
       *-*  call prtsqlca 'FETCH C1 '
  5422 *-* address dsnrexx "EXECSQL CLOSE C1"
  5423 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1 '
  5426 *-* Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
  5427 *-* /* --------------------------- */
  5429 *-* /* Get all ids (except PUBLIC) for access list */
  5430 *-* x=sql('NEW statement') /* start new sql statement */
  5431 *-* /* ----------------------- */
  5432 *-* x=sql("SELECT DISTINCT a.schema"                       )
  5433 *-* x=sql("               ,a.name"                         )
  5434 *-* x=sql("               ,"granteecase                    )
  5435 *-* x=sql("   FROM SYSIBM.SYSSEQUENCEAUTH as a"            )
  5436 *-* x=sql("   WHERE a."col"=' '"                          )
  5437 *-* x=sql("     and a.granteeType = ' '"                   )
  5438 *-* x=sql("     and not exists"                            )
  5439 *-* x=sql("        ("                                      )
  5440 *-* x=sql("          select 1"                             )
  5441 *-* x=sql("          FROM SYSIBM.SYSSEQUENCEAUTH as c"     )
  5442 *-* x=sql("          WHERE c."col"=' '"                   )
  5443 *-* x=sql("            and c.granteeType = ' '"            )
  5444 *-* x=sql("            and c.GRANTEE='PUBLIC'"             )
  5445 *-* x=sql("            and c.schema = a.schema"            )
  5446 *-* x=sql("            and c.name   = a.name"              )
  5447 *-* x=sql("        )"                                      )
  5449 *-* if col <> 'SYSADMAUTH' & SlimAdm
  5450 *-*  then
       *-*  do
  5451 *-*   x=sql( "    and a.GRANTEE not in ("                    )
  5452 *-*   x=sql( "       select distinct d.grantee"              )
  5453 *-*   x=sql( "          from sysibm.sysUserAUTH as d"        )
  5454 *-*   x=sql( "          where d.sysadmauth <> ' '"           )
  5455 *-*   x=sql( "                         )"                    )
  5456 *-*  end
  5458 *-* if removeUserList <> ''
  5459 *-*  then ,
  5460 *-*  x=sql( "    AND a.GRANTEE not in" RemoveUserList       )
  5462 *-* x=sql( "  ORDER BY schema, name, grantee"              )
  5464 *-* call ZSQL
  5466 *-* rowsReturned = 0
  5467 *-* Do Until SQLCODE \= 0
  5468 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :schema, :name, :grantee"
  5469 *-*  If SQLCODE = 0
  5470 *-*   then
       *-*   do
  5471 *-*    rowsReturned = rowsReturned + 1
  5472 *-*    parse upper var schema schema .
  5473 *-*    parse upper var name   name   .
  5474 *-*    if model=1
  5475 *-*     then
       *-*     prof =        schema'.'name'.'auth
  5476 *-*    else
       *-*     prof = ssid'.'schema'.'name'.'auth
  5477 *-*    prof= left(prof,max(45,length(prof)))
  5478 *-*    cmd="PERMIT "prof" CLASS("class") ACC(READ) ID("grantee")"
  5480 *-*    x = clistCard(cmd) /* actually generate priv */
  5481 *-*   End
  5482 *-* End /* do until */
  5483 *-* call showRowCount /* show rowsReturned */
  5484 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  5485 *-* Else
       *-*  call prtsqlca 'FETCH C1 '
  5486 *-* address dsnrexx "EXECSQL CLOSE C1"
  5487 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1 '
  5489 *-* Return     /* seq_attr */
  5491 *-* routine_attr:
  5492 *-* /*****************************************************************/
  5493 *-* /* handle stored procedures and UDF (user defined functions)     */
  5494 *-* /*****************************************************************/
  5495 *-* Arg auth,col,SP$UDF
  5496 *-* If model=1
       *-*  Then
       *-*  prof=auth
  5497 *-* Else
       *-*  prof=ssid"."auth
  5499 *-* Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
  5500 *-* /* --------------------------- */
  5501 *-* useClass = class
  5503 *-* /* create "backstop" so that everything else is rejected */
  5504 *-* /* ----------------------------------------------------- */
  5505 *-* x = clistCard(' ')
  5506 *-* cmd='/* create backstop RDEF (in routine_attr: routine) */'
  5507 *-* x = clistCard(cmd)
  5509 *-* if model=1
  5510 *-*  then
       *-*  prof =      '*.*.'auth
  5511 *-* else
       *-*  prof = ssid'.*.*.'auth
  5513 *-* data = 'Backstop DB2-'ssid auth'-priv on *.*'
  5514 *-* /* Define base profile */
  5515 *-* prof= left(prof,max(45,length(prof)))
  5516 *-* cmd="RDEF "class prof "UACC(NONE) OWNER("owner")" ,                            "AUDIT(ALL(READ))" ,
                               "DATA('"data"')"
  5519 *-* x = clistCard(cmd)
  5520 *-* x = clistCard(' ')
  5522 *-* /* First determine if it is given to PUBLIC */
  5523 *-* x=sql('NEW statement') /* start new sql statement */
  5524 *-* /* ----------------------- */
  5525 *-* x=sql(" SELECT distinct a.schema, a.specificname, 'PUBLIC' as gtype")
  5526 *-* x=sql(" FROM SYSIBM.SYSROUTINEAUTH as a"                            )
  5527 *-* x=sql(" WHERE a.GRANTEE='PUBLIC'"                                   )
  5528 *-* x=sql("   and a."col"=' '"                                         )
  5529 *-* x=sql("   and a.granteeType = ' '"                                  )
  5530 *-* x=sql("   and a.routineType = '"sp$udf"'"                           )
  5531 *-* x=sql("UNION"                                                       )
  5532 *-* x=sql(" SELECT distinct b.schema, b.specificname, 'OTHER ' as gtype")
  5533 *-* x=sql(" FROM SYSIBM.SYSROUTINEAUTH as b"                            )
  5534 *-* x=sql(" WHERE b."col"=' '"                                         )
  5535 *-* x=sql("   and b.granteeType = ' '"                                  )
  5536 *-* x=sql("   and b.routineType = '"sp$udf"'"                           )
  5537 *-* x=sql("   and not exists"                                           )
  5538 *-* x=sql("      ("                                                     )
  5539 *-* x=sql("        select 1"                                            )
  5540 *-* x=sql("        FROM SYSIBM.SYSROUTINEAUTH as c"                     )
  5541 *-* x=sql("        WHERE c."col"=' '"                                  )
  5542 *-* x=sql("          and c.granteeType = ' '"                           )
  5543 *-* x=sql("          and c.routineType = '"sp$udf"'"                    )
  5544 *-* x=sql("          and c.GRANTEE='PUBLIC'"                            )
  5545 *-* x=sql("          and c.schema = b.schema"                           )
  5546 *-* x=sql("          and c.specificname = b.specificname"               )
  5547 *-* x=sql("      )"                                                     )
  5548 *-* x=sql("ORDER BY schema, specificname, gtype"                        )
  5550 *-* call ZSQL
  5552 *-* rowsReturned = 0
  5553 *-* do UNTIL sqlcode <> 0
  5554 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :schema, :name, :gtype"
  5555 *-*  if sqlcode = 0
  5556 *-*   then
       *-*   do
  5557 *-*    rowsReturned = rowsReturned + 1
  5558 *-*    parse upper var schema schema .
  5559 *-*    parse upper var name   name   .
  5560 *-*    if model=1
  5561 *-*     then
       *-*     prof =        schema'.'name'.'auth
  5562 *-*    else
       *-*     prof = ssid'.'schema'.'name'.'auth
  5564 *-*    if gtype = 'PUBLIC'
  5565 *-*     then
       *-*     do
  5566 *-*      uac = 'UACC(READ)'
  5567 *-*      data = 'DB2-'ssid 'Everyone has' auth'-priv on' ,                          schema'.'name
  5569 *-*     end
  5570 *-*    else
       *-*     do
  5571 *-*      uac = 'UACC(NONE)'
  5572 *-*      data = 'DB2-'ssid auth'-priv on' ,                                         schema'.'name
  5574 *-*     end
  5575 *-*    /* Define base profile */
  5576 *-*    prof= left(prof,max(45,length(prof)))
  5577 *-*    cmd="RDEF "class prof uac "OWNER("owner")" ,                                   "AUDIT(ALL(READ))" ,
                                  "DATA('"data"')"
  5580 *-*    x = clistCard(cmd)
  5581 *-*    /* Remove executor from access list */
  5582 *-*    cmd="PERMIT "prof" CLASS("class") RESET"
  5583 *-*    if resetOption = 'RESET'
       *-*     then
       *-*     x = clistCard(cmd)
  5584 *-*   end
  5585 *-* end
  5586 *-* call showRowCount /* show rowsReturned */
  5587 *-* If SQLCODE = 0 | sqlcode = 100
  5588 *-*  then
       *-*  nop
  5589 *-* else
       *-*  call prtsqlca 'FETCH C1 '
  5590 *-* address dsnrexx "EXECSQL CLOSE C1"
  5591 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1 '
  5593 *-* Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
  5594 *-* /* --------------------------- */
  5597 *-* /* Get all ids (except PUBLIC) for access list */
  5599 *-* /* Get all ids (except PUBLIC) for access list */
  5600 *-* x=sql('NEW statement') /* start new sql statement */
  5601 *-* /* ----------------------- */
  5602 *-* x=sql("SELECT DISTINCT a.schema"                           )
  5603 *-* x=sql("               ,a.specificname"                     )
  5604 *-* x=sql("               ,"granteecase                        )
  5605 *-* x=sql("   FROM SYSIBM.SYSROUTINEAUTH as a"                 )
  5606 *-* x=sql("   WHERE a."col"=' '"                              )
  5607 *-* x=sql("     and a.granteeType = ' '"                       )
  5608 *-* x=sql("     and a.routineType = '"sp$udf"'"                )
  5609 *-* x=sql("     and not exists"                                )
  5610 *-* x=sql("        ("                                          )
  5611 *-* x=sql("          select 1"                                 )
  5612 *-* x=sql("          FROM SYSIBM.SYSROUTINEAUTH as c"          )
  5613 *-* x=sql("          WHERE c."col"=' '"                       )
  5614 *-* x=sql("            and c.granteeType = ' '"                )
  5615 *-* x=sql("            and c.routineType = '"sp$udf"'"         )
  5616 *-* x=sql("            and c.GRANTEE='PUBLIC'"                 )
  5617 *-* x=sql("            and c.schema = a.schema"                )
  5618 *-* x=sql("            and c.specificname = a.specificname"    )
  5619 *-* x=sql("        )"                                          )
  5620 *-* if SlimAdm
  5621 *-*  then
       *-*  do
  5622 *-*   x=sql("     and a.GRANTEE not in ("                        )
  5623 *-*   x=sql("        select distinct d.grantee"                  )
  5624 *-*   x=sql("           from sysibm.sysUserAUTH as d"            )
  5625 *-*   x=sql("           where d.sysadmauth <> ' '"               )
  5626 *-*   x=sql("                          )"                        )
  5627 *-*  end
  5629 *-* if removeUserList <> ''
  5630 *-*  then ,
  5631 *-*  x=sql("     AND a.GRANTEE not in" RemoveUserList           )
  5633 *-* x=sql("ORDER BY schema, specificname, grantee"             )
  5635 *-* call ZSQL
  5637 *-* rowsReturned = 0
  5639 *-* Do Until SQLCODE \= 0
  5640 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :schema, :name, :grantee"
  5641 *-*  If SQLCODE = 0
  5642 *-*   then
       *-*   do
  5643 *-*    rowsReturned = rowsReturned + 1
  5644 *-*    parse upper var schema schema .
  5645 *-*    parse upper var name   name   .
  5647 *-*    if model=1
  5648 *-*     then
       *-*     prof =        schema'.'name'.'auth
  5649 *-*    else
       *-*     prof = ssid'.'schema'.'name'.'auth
  5651 *-*    prof= left(prof,max(45,length(prof)))
  5652 *-*    cmd="PERMIT "prof" CLASS("class") ACC(READ) ID("grantee")"
  5654 *-*    x = clistCard(cmd) /* actually generate priv */
  5655 *-*   End
  5656 *-* End /* do until */
  5657 *-* call showRowCount /* show rowsReturned */
  5658 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  5659 *-* Else
       *-*  call prtsqlca 'FETCH C1 '
  5661 *-* address dsnrexx "EXECSQL CLOSE C1"
  5662 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1 '
  5665 *-*  /* Get all ids in schema.* that need to be in a*/
  5666 *-*  /* specific profile.                           */
  5668 *-* if granteeCaseBB = 'GRANTEECASEBB' /* only need to set once */
  5669 *-*  then
       *-*  granteeCaseBB = changestr('a.',granteecase,'bb.')
  5671 *-* x=sql('NEW statement') /* start new sql statement */
  5672 *-* /* ----------------------- */
  5673 *-* x=sql("SELECT DISTINCT aa.schema"                           )
  5674 *-* x=sql("               ,aa.specificname"                     )
  5675 *-* x=sql("               ,"granteecaseBB                      )
  5676 *-* x=sql("   FROM ("                                          )
  5677 *-* x=sql("         SELECT DISTINCT a.schema"                  )
  5678 *-* x=sql("                        ,a.specificname"            )
  5679 *-* x=sql("            FROM SYSIBM.SYSROUTINEAUTH as a"                 )
  5680 *-* x=sql("            WHERE a."col"=' '"                              )
  5681 *-* x=sql("              and a.specificname <> '*'"                     )
  5682 *-* x=sql("              and a.granteeType = ' '"                       )
  5683 *-* x=sql("              and a.routineType = '"sp$udf"'"                )
  5684 *-* x=sql("              and not exists"                                )
  5685 *-* x=sql("                 ("                                          )
  5686 *-* x=sql("                   select 1"                                 )
  5687 *-* x=sql("                   FROM SYSIBM.SYSROUTINEAUTH as c"          )
  5688 *-* x=sql("                   WHERE c."col"=' '"                       )
  5689 *-* x=sql("                     and c.granteeType = ' '"                )
  5690 *-* x=sql("                     and c.routineType = '"sp$udf"'"         )
  5691 *-* x=sql("                     and c.GRANTEE='PUBLIC'"                 )
  5692 *-* x=sql("                     and c.schema = a.schema"                )
  5693 *-* x=sql("                     and c.specificname = a.specificname"    )
  5694 *-* x=sql("                 )"                                          )
  5695 *-* x=sql("        ) as aa"                                    )
  5696 *-* x=sql("        ,sysibm.sysroutineAuth as bb"               )
  5697 *-* x=sql("   where aa.schema = bb.schema"                     )
  5698 *-* x=sql("     and bb.specificName = '*'"                     )
  5699 *-* x=sql("     and bb."col"<>' '"                             )
  5700 *-* if SlimAdm
  5701 *-*  then
       *-*  do
  5702 *-*   x=sql("     and bb.GRANTEE not in ("                       )
  5703 *-*   x=sql("        select distinct d.grantee"                  )
  5704 *-*   x=sql("           from sysibm.sysUserAUTH as d"            )
  5705 *-*   x=sql("           where d.sysadmauth <> ' '"               )
  5706 *-*   x=sql("                           )"                       )
  5707 *-*  end
  5709 *-* if removeUserList <> ''
  5710 *-*  then ,
  5711 *-*  x=sql("     AND bb.GRANTEE not in" RemoveUserList          )
  5713 *-* x=sql("     AND bb.GRANTEE not in ("                       )
  5714 *-* x=sql("        select distinct dd.grantee"                 )
  5715 *-* x=sql("           from sysibm.sysroutineauth as cc"        )
  5716 *-* x=sql("               ,sysibm.sysroutineauth as dd"        )
  5717 *-* x=sql("           where cc.schema = aa.schema"             )
  5718 *-* x=sql("             and dd.schema = aa.schema"             )
  5719 *-* x=sql("             and cc.specificName = aa.SpecificName" )
  5720 *-* x=sql("             and dd.specificName = '*'"             )
  5721 *-* x=sql("             and cc."col "<> ' '"                   )
  5722 *-* x=sql("             and dd."col "<> ' '"                   )
  5723 *-* x=sql("             and cc.grantee = dd.grantee"           )
  5724 *-* x=sql("                           )"                       )
  5726 *-* x=sql("ORDER BY schema, specificname, grantee"             )
  5728 *-* call ZSQL
  5730 *-* Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
  5731 *-* /* --------------------------- */
  5733 *-* pastSchema = ''
  5734 *-* pastName   = ''
  5735 *-* rowsReturned = 0
  5736 *-* Do Until SQLCODE \= 0
  5737 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :schema, :name, :grantee"
  5738 *-*  If SQLCODE = 0
  5739 *-*   then
       *-*   do
  5740 *-*    rowsReturned = rowsReturned + 1
  5741 *-*    parse upper var schema schema .
  5742 *-*    parse upper var name   name   .
  5744 *-*    if model=1
  5745 *-*     then
       *-*     prof =        schema'.'name'.'auth
  5746 *-*    else
       *-*     prof = ssid'.'schema'.'name'.'auth
  5748 *-*    prof= left(prof,max(45,length(prof)))
  5749 *-*    cmd="PERMIT "prof" CLASS("class") ACC(READ) ID("grantee")"
  5751 *-*    x = clistCard(cmd) /* actually generate priv */
  5752 *-*   End
  5753 *-* End /* do until */
  5754 *-* call showRowCount /* show rowsReturned */
  5755 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  5756 *-* Else
       *-*  call prtsqlca 'FETCH C1 '
  5758 *-* address dsnrexx "EXECSQL CLOSE C1"
  5759 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1 '
  5761 *-* Return     /* routine_attr */
  5763 *-* bindagent:
  5764 *-* /*****************************************************************/
  5765 *-* /* Get DB2 system BINDAGENT authority                            */
  5766 *-* /*****************************************************************/
  5768 *-* Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
  5769 *-* /* --------------------------- */
  5770 *-* useClass = class
  5772 *-* cmd='/* create backstop RDEF (in bindagent: routine) */'
  5773 *-* x = clistCard(cmd)
  5775 *-* If model=1
       *-*  Then
       *-*  prof='*.BINDAGENT'
  5776 *-* Else
       *-*  prof=ssid'.*.BINDAGENT'
  5777 *-* prof= left(prof,max(25,length(prof)))
  5778 *-* cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                          "DATA('DB2-"ssid "backstop bindagent profile')"
  5781 *-* x = clistCard(cmd)
  5783 *-* /* Create (ssid.)grantor.BINDAGENT profile for each GRANTOR */
  5784 *-* /* And remove executor from access list */
  5785 *-* x=sql('NEW statement') /* start new sql statement */
  5786 *-* /* ----------------------- */
  5788 *-* x=sql("SELECT DISTINCT strip(upper(grantor)) as ugrantor"  )
  5789 *-* x=sql("FROM SYSIBM.SYSUSERAUTH"                            )
  5790 *-* x=sql("WHERE BINDAGENTAUTH=' '"                           )
  5792 *-* if removeUserList <> ''
  5793 *-*  then ,
  5794 *-*  x=sql("  AND GRANTEE not in" RemoveUserList                )
  5796 *-* x=sql("ORDER by ugrantor"                                  )
  5798 *-* call ZSQL
  5800 *-* rowsReturned = 0
  5801 *-* Do Until SQLCODE \= 0
  5802 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :grantor"
  5803 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  5804 *-*    rowsReturned = rowsReturned + 1
  5805 *-*    If model=1
       *-*     Then
       *-*     prof=Strip(grantor)'.BINDAGENT'
  5806 *-*    Else
       *-*     prof=ssid'.'Strip(grantor)'.BINDAGENT'
  5807 *-*    prof= left(prof,max(25,length(prof)))
  5808 *-*    cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                             "DATA('DB2-"ssid "bindagent profile for grantor" grantor"')"
  5811 *-*    x = clistCard(cmd)
  5813 *-*    cmd="PERMIT "prof" CLASS("class") RESET"
  5814 *-*    if resetOption = 'RESET'
       *-*     then
       *-*     x = clistCard(cmd)
  5815 *-*   End
  5816 *-* End /* do until */
  5817 *-* call showRowCount /* show rowsReturned */
  5818 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  5819 *-* Else
       *-*  call prtsqlca 'FETCH C1 '
  5820 *-* address dsnrexx "EXECSQL CLOSE C1"
  5821 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1 '
  5823 *-*  /* Change UACC if it is given to PUBLIC */
  5824 *-* x=sql('NEW statement') /* start new sql statement */
  5825 *-* /* ----------------------- */
  5826 *-* x=sql("SELECT DISTINCT strip(upper(GRANTOR)) as ugrantor"  )
  5827 *-* x=sql("FROM SYSIBM.SYSUSERAUTH"                            )
  5828 *-* x=sql("WHERE BINDAGENTAUTH=' '"                           )
  5829 *-* x=sql("  AND GRANTEE='PUBLIC'"                             )
  5830 *-* x=sql("ORDER by ugrantor"                                  )
  5832 *-* call ZSQL
  5834 *-* rowsReturned = 0
  5835 *-* Do Until SQLCODE \= 0
  5836 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :grantor"
  5837 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  5838 *-*    rowsReturned = rowsReturned + 1
  5839 *-*    If model=1
       *-*     Then
       *-*     prof=Strip(grantor)'.BINDAGENT'
  5840 *-*    Else
       *-*     prof=ssid'.'Strip(grantor)'.BINDAGENT'
  5841 *-*    prof= left(prof,max(35,length(prof)))
  5842 *-*    cmd="RALT " class prof" UACC(READ)" ,                                     "DATA('"ssid grantor "gave everyone bindage
nt priv')"
  5844 *-*    x = clistCard(cmd)
  5845 *-*   End
  5846 *-* End /* do until */
  5847 *-* call showRowCount /* show rowsReturned */
  5848 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  5849 *-* Else
       *-*  call prtsqlca 'FETCH C1 '
  5850 *-* address dsnrexx "EXECSQL CLOSE C1"
  5851 *-* If SQLCODE\=0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  5853 *-* Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
  5854 *-* /* --------------------------- */
  5856 *-* /* Get all ids (except PUBLIC) for access list */
  5857 *-* x=sql('NEW statement') /* start new sql statement */
  5858 *-* /* ----------------------- */
  5859 *-* X=SQL("SELECT DISTINCT strip(upper(a.grantor)) as ugrantor"  )
  5860 *-* X=SQL("               ,"granteeCase                          )
  5861 *-* X=SQL("FROM SYSIBM.SYSUSERAUTH as a"                         )
  5862 *-* X=SQL("WHERE a.BINDAGENTAUTH<>' '"                           )
  5863 *-* X=SQL("  AND A.GRANTEE='PUBLIC'"                            )
  5864 *-* if SlimAdm
  5865 *-*  then
       *-*  do
  5866 *-*   X=SQL("  AND a.GRANTEE NOT IN ("                             )
  5867 *-*   X=SQL("            SELECT DISTINCT B.GRANTEE"                )
  5868 *-*   X=SQL("            FROM SYSIBM.SYSUSERAUTH as b"             )
  5869 *-*   X=SQL("            WHERE B.SYSADMAUTH <> ' '"                )
  5870 *-*   X=SQL("                       )"                             )
  5871 *-*  end
  5872 *-* X=SQL("  and not exists ("                                   )
  5873 *-* X=SQL("            select 1"                                 )
  5874 *-* X=SQL("            from sysibm.sysuserauth as c"             )
  5875 *-* X=SQL("            WHERE a.grantor = c.grantor"              )
  5876 *-* X=SQL("              and c.grantee = 'PUBLIC'"               )
  5877 *-* X=SQL("                 )"                                   )
  5879 *-* if removeUserList <> ''
  5880 *-*  then ,
  5881 *-*  X=SQL("  AND a.GRANTEE not in" RemoveUserList                )
  5883 *-* X=SQL("order by ugrantor, grantee"                           )
  5885 *-* call ZSQL
  5887 *-* rowsReturned = 0
  5888 *-* Do Until SQLCODE \= 0
  5889 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :grantor, :grantee"
  5890 *-*  If SQLCODE=0
       *-*   Then
       *-*   Do
  5891 *-*    rowsReturned = rowsReturned + 1
  5892 *-*    if grantee = '*DELETE'
       *-*     then
       *-*     iterate
  5894 *-*    access = 'ACC(READ)'
  5896 *-*    If model=1
       *-*     Then
       *-*     prof=grantor'.BINDAGENT'
  5897 *-*    Else
       *-*     prof=ssid'.'grantor'.BINDAGENT'
  5898 *-*    prof= left(prof,max(35,length(prof)))
  5899 *-*    cmd="PERMIT "prof" CLASS("class")" access "ID("grantee")"
  5900 *-*    x = clistCard(cmd)
  5901 *-*   End
  5902 *-* End /* do until */
  5903 *-* call showRowCount /* show rowsReturned */
  5904 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  5905 *-* Else
       *-*  call prtsqlca 'FETCH C1 '
  5906 *-* address dsnrexx "EXECSQL CLOSE C1"
  5907 *-* If SQLCODE\=0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  5909 *-* Return     /* bindagent */
  5911 *-* db_attr:
  5912 *-* /*****************************************************************/
  5913 *-* /* Get DB2 database administrative authorities                   */
  5914 *-* /*****************************************************************/
  5915 *-* Arg auth,col
  5917 *-* Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
  5918 *-* /* --------------------------- */
  5919 *-* useClass = class
  5921 *-* /* Find all databases, and make commands to create profiles */
  5922 *-* /* for 'auth'. Then remove executor from access list.       */
  5923 *-* x=sql('NEW statement') /* start new sql statement */
  5924 *-* /* ----------------------- */
  5925 *-* x=sql("SELECT DISTINCT a.NAME FROM SYSIBM.SYSDBAUTH as a"     )
  5926 *-* x=sql("   WHERE a.NAME in"                                    )
  5927 *-* x=sql("        ("                                             )
  5928 *-* x=sql("         select distinct c.name"                       )
  5929 *-* x=sql("         from sysibm.sysdatabase as c"                 )
  5930 *-* x=sql("         where c.implicit <> 'Y'"                      )
  5931 *-* x=sql("        )"                                             )
  5933 *-* if removeUserList <> ''
  5934 *-*  then ,
  5935 *-*  x=sql("     AND a.GRANTEE not in" RemoveUserList              )
  5937 *-* call ZSQL
  5939 *-* rowsReturned = 0
  5940 *-* Do Until SQLCODE \= 0
  5941 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :name"
  5942 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  5943 *-*    rowsReturned = rowsReturned + 1
  5944 *-*    parse upper var name name .
  5945 *-*    If model=1
       *-*     Then
       *-*     prof=Strip(name)'.'auth
  5946 *-*    Else
       *-*     prof=ssid'.'Strip(name)'.'auth
  5947 *-*    prof= left(prof,max(25,length(prof)))
  5948 *-*    cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                        "OWNER("owner")" ,
                              "DATA('DB2-"ssid "database-"name auth"-priviledge')" /* rph */
  5951 *-*    x = clistCard(cmd)
  5953 *-*    cmd="PE "prof" CLASS("class") RESET"
  5954 *-*    if resetOption = 'RESET'
       *-*     then
       *-*     x = clistCard(cmd)
  5955 *-*   End
  5956 *-* End /* do until */
  5957 *-* call showRowCount /* show rowsReturned */
  5958 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  5959 *-* Else
       *-*  call prtsqlca 'FETCH C1 '
  5960 *-* address dsnrexx "EXECSQL CLOSE C1"
  5961 *-* If SQLCODE\=0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  5963 *-*  /* If any of those were PUBLIC, change UACC to READ */
  5964 *-* x=sql('NEW statement') /* start new sql statement */
  5965 *-* /* ----------------------- */
  5966 *-* x=sql("select distinct name"                             )
  5967 *-* x=sql("from ("                                           )
  5968 *-* x=sql("        SELECT DISTINCT a.NAME"                   )
  5969 *-* x=sql("        FROM SYSIBM.SYSDBAUTH as a"               )
  5970 *-* x=sql("        WHERE a.GRANTEE='PUBLIC'"                 )
  5971 *-* x=sql("          and a."col "<> ' '"                     )
  5972 *-* x=sql("          and a.NAME in"                          )
  5973 *-* x=sql("                ("                                )
  5974 *-* x=sql("                 select distinct c.name"          )
  5975 *-* x=sql("                 from sysibm.sysdatabase as c"    )
  5976 *-* x=sql("                 where c.implicit <> 'Y'"         )
  5977 *-* x=sql("                )"                                )
  5978 *-* x=sql("      UNION"                                      )
  5979 *-* x=sql("        SELECT 'DSNDB04' as name"                 )
  5980 *-* x=sql("        FROM SYSIBM.SYSDBAUTH as b"               )
  5981 *-* x=sql("        WHERE b.GRANTEE='PUBLIC'"                 )
  5982 *-* x=sql("          and b."col "<> ' '"                     )
  5983 *-* x=sql("          and b.NAME in"                          )
  5984 *-* x=sql("                ("                                )
  5985 *-* x=sql("                 select distinct e.name"          )
  5986 *-* x=sql("                 from sysibm.sysdatabase as e"    )
  5987 *-* x=sql("                 where e.implicit = 'Y'"          )
  5988 *-* x=sql("                )"                                )
  5989 *-* x=sql("      )"                                          )
  5990 *-* x=sql("order by name"                                    )
  5992 *-* call ZSQL
  5994 *-* rowsReturned = 0
  5995 *-* Do Until SQLCODE \= 0
  5996 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :name"
  5997 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  5998 *-*    rowsReturned = rowsReturned + 1
  5999 *-*    parse upper var name name .
  6000 *-*    If model=1
       *-*     Then
       *-*     prof=Strip(name)'.'auth
  6001 *-*    Else
       *-*     prof=ssid'.'Strip(name)'.'auth
  6002 *-*    prof= left(prof,max(35,length(prof)))
  6003 *-*    cmd="RALT "class prof" UACC(READ)" ,                                       "DATA('Everyone has" ssid ,
                                    "database-"name auth"-priviledge')" /* rph */
  6006 *-*    x = clistCard(cmd)
  6007 *-*   End
  6008 *-* End /* do until */
  6009 *-* call showRowCount /* show rowsReturned */
  6010 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  6011 *-* Else
       *-*  call prtsqlca 'FETCH C1 '
  6012 *-* address dsnrexx "EXECSQL CLOSE C1"
  6013 *-* If SQLCODE\=0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  6015 *-* Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
  6016 *-* /* --------------------------- */
  6018 *-* /* Get all ids (except PUBLIC) for access list */
  6019 *-* x=sql('NEW statement') /* start new sql statement */
  6020 *-* /* ----------------------- */
  6021 *-* x=sql("SELECT DISTINCT name, grantee"                        )
  6022 *-* x=sql("FROM ("                                               )
  6023 *-* x=sql("   SELECT DISTINCT a.NAME," granteeCase               )
  6024 *-* x=sql("   FROM SYSIBM.SYSDBAUTH as a"                        )
  6025 *-* x=sql("   WHERE a."col "<> ' '"                              )
  6026 *-* x=sql("     AND a.GRANTEE <> a.GRANTOR"                      )
  6027 *-* if SlimAdm
  6028 *-*  then
       *-*  do
  6029 *-*   x=sql("     and a.GRANTEE not in ("                          )
  6030 *-*   x=sql("        select distinct b.grantee"                    )
  6031 *-*   x=sql("           from sysibm.sysuserauth as b"              )
  6032 *-*   x=sql("           where b.sysadmauth <> ' '"                 )
  6033 *-*   x=sql("                        )"                            )
  6034 *-*  end
  6035 *-* x=sql("     and not exists ("                                )
  6036 *-* x=sql("        select 1"                                     )
  6037 *-* x=sql("           from sysibm.sysdbauth as c"                )
  6038 *-* x=sql("           where c.name  = a.name"                    )
  6039 *-* x=sql("             and c."col "<> ' '"                      )
  6040 *-* x=sql("             and c.grantee = 'PUBLIC'"                )
  6041 *-* x=sql("                    )"                                )
  6042 *-* x=sql("     and a.name in  ("                                )
  6043 *-* x=sql("        select distinct e.name"                       )
  6044 *-* x=sql("           from sysibm.sysdatabase as e"              )
  6045 *-* x=sql("           where e.name  = a.name"                    )
  6046 *-* x=sql("             and e.implicit <> 'Y'"                   )
  6047 *-* x=sql("                    )"                                )
  6049 *-* if col <> 'DBADMAUTH' & SlimAdm
  6050 *-*  then
       *-*  do
  6051 *-*   x=sql("     and a.GRANTEE not in ("                          )
  6052 *-*   x=sql("        select distinct d.grantee"                    )
  6053 *-*   x=sql("           from sysibm.sysdbauth as d"                )
  6054 *-*   x=sql("           where d.dbadmauth <> ' '"                  )
  6055 *-*   x=sql("             and d.name = a.name"                     )
  6056 *-*   x=sql("                        )"                            )
  6057 *-*  end
  6059 *-* if removeUserList <> ''
  6060 *-*  then ,
  6061 *-*  x=sql("     AND a.GRANTEE not in" RemoveUserList             )
  6063 *-* if granteeCaseF = 'GRANTEECASEF' /* only need to set once */
  6064 *-*  then
       *-*  granteeCaseF = changestr('a.',granteecase,'f.')
  6066 *-* x=sql("     )" ) /* end of "FROM ( ... )"  */
  6067 *-* x=sql("UNION"                                               )
  6068 *-* x=sql("SELECT DISTINCT 'DSNDB04' as name"                 )
  6069 *-* x=sql("            ," granteeCaseF                        )
  6070 *-* x=sql("FROM SYSIBM.SYSDBAUTH as f"                        )
  6071 *-* x=sql("WHERE f."col "<> ' '"                              )
  6072 *-* x=sql("  AND f.GRANTEE <> f.GRANTOR"                      )
  6073 *-* if SlimAdm
  6074 *-*  then
       *-*  do
  6075 *-*   x=sql("  and f.GRANTEE not in ("                          )
  6076 *-*   x=sql("     select distinct g.grantee"                    )
  6077 *-*   x=sql("        from sysibm.sysuserauth as g"              )
  6078 *-*   x=sql("        where g.sysadmauth <> ' '"                 )
  6079 *-*   x=sql("                     )"                            )
  6080 *-*  end
  6081 *-* x=sql("  and not exists ("                                )
  6082 *-* x=sql("     select 1"                                     )
  6083 *-* x=sql("        from sysibm.sysdbauth as h"                )
  6084 *-* x=sql("        where h.name  = f.name"                    )
  6085 *-* x=sql("          and h."col "<> ' '"                      )
  6086 *-* x=sql("          and h.grantee = 'PUBLIC'"                )
  6087 *-* x=sql("                 )"                                )
  6088 *-* x=sql("  and f.name in  ("                                )
  6089 *-* x=sql("     select distinct i.name"                       )
  6090 *-* x=sql("        from sysibm.sysdatabase as i"              )
  6091 *-* x=sql("        where i.name  = f.name"                    )
  6092 *-* x=sql("          and i.implicit = 'Y'"                    )
  6093 *-* x=sql("                 )"                                )
  6096 *-* if col <> 'DBADMAUTH' & slimadm
  6097 *-*  then
       *-*  do
  6098 *-*   x=sql("  and f.GRANTEE not in ("                             )
  6099 *-*   x=sql("     select distinct k.grantee"                       )
  6100 *-*   x=sql("        from sysibm.sysdbauth as k"                   )
  6101 *-*   x=sql("        where k.dbadmauth <> ' '"                     )
  6102 *-*   x=sql("        and k.name = f.name"                          )
  6103 *-*   x=sql("                       )"                             )
  6104 *-*  end
  6106 *-* if removeUserList <> ''
  6107 *-*  then ,
  6108 *-*  x=sql("  AND f.GRANTEE not in" RemoveUserList                )
  6110 *-* x=sql("Order by name, grantee"                               )
  6111 *-* call ZSQL
  6113 *-* rowsReturned = 0
  6114 *-* Do Until SQLCODE \= 0
  6115 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :name, :grantee"
  6116 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  6117 *-*    rowsReturned = rowsReturned + 1
  6118 *-*    parse upper var name name .
  6120 *-*    if grantee = '*DELETE'
       *-*     then
       *-*     iterate
  6122 *-*    access = 'ACC(READ)'
  6124 *-*    If model=1
       *-*     Then
       *-*     prof=Strip(name)'.'auth
  6125 *-*    Else
       *-*     prof=ssid'.'Strip(name)'.'auth
  6126 *-*    prof= left(prof,max(35,length(prof)))
  6127 *-*    cmd="PERMIT "prof" CLASS("class")" access "ID("grantee")"
  6128 *-*    x = clistCard(cmd)
  6129 *-*   End
  6130 *-* End /* do until */
  6131 *-* call showRowCount /* show rowsReturned */
  6132 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  6133 *-* Else
       *-*  call prtsqlca 'FETCH C1 '
  6134 *-* address dsnrexx "EXECSQL CLOSE C1"
  6135 *-* If SQLCODE\=0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  6137 *-* Return
  6139 *-* db_option:
  6140 *-* /*****************************************************************/
  6141 *-* /* For DBADM write optional commands for profile with no DBname  */
  6142 *-* /*****************************************************************/
  6143 *-* /* this fixed an issue that RACF now handles; ... delete code */
  6145 *-* Return
  6147 *-* packadm_attr:
  6148 *-* /*****************************************************************/
  6149 *-* /* Get DB2 PACKADM                                               */
  6150 *-* /*****************************************************************/
  6151 *-* Arg auth
  6153 *-* Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
  6154 *-* /* --------------------------- */
  6155 *-* useClass = class
  6157 *-* /* create "backstop" so that everything else is rejected */
  6158 *-* /* ----------------------------------------------------- */
  6159 *-* x = clistCard(' ')
  6160 *-* cmd='/* create backstop RDEF (in packadm_attr: routine) */'
  6161 *-* x = clistCard(cmd)
  6163 *-* If model=1
       *-*  Then
       *-*  prof="*."auth
  6164 *-* Else
       *-*  prof=ssid".*."auth
  6165 *-* prof= left(prof,max(25,length(prof)))
  6166 *-* cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",                      "OWNER("owner")" ,
                           "DATA('Backstop DB2-"ssid auth "priv for packadm')"
  6169 *-* x = clistCard(cmd)
  6170 *-* x = clistCard(' ')
  6172 *-* /* Find all collections, and make commands to create profiles */
  6173 *-* /* for 'auth'. Then remove executor from access list.         */
  6174 *-* x=sql('NEW statement') /* start new sql statement */
  6175 *-* /* ----------------------- */
  6176 *-* x=sql("SELECT DISTINCT NAME, SPEC"                  )
  6177 *-* x=sql("from ("                                      )
  6178 *-* x=sql("     select distinct a.name as name"         )
  6179 *-* x=sql("                  ,'PUBLIC' as spec"         )
  6180 *-* x=sql("        from sysibm.sysresauth a"            )
  6181 *-* x=sql("        where a.obtype='C' "                 )
  6182 *-* x=sql("          and a.QUALIFIER='PACKADM '"        )
  6183 *-* x=sql("          and a.grantee in ('PUBLIC','PUBLIC*')")
  6184 *-* x=sql("          and (   a.name in ("               )
  6185 *-* x=sql("                     select distinct collid" )
  6186 *-* x=sql("                     from sysibm.syspackage" )
  6187 *-* x=sql("                            )"               )
  6188 *-* x=sql("               or a.name like ('%ISETS%')"   )
  6189 *-* x=sql("               or a.name like ('IVR%')"      )
  6190 *-* x=sql("               or a.name = '*'"              )
  6191 *-* x=sql("              )"                             )
  6192 *-* x=sql("    union"                                   )
  6193 *-* x=sql("     select distinct b.name as name"         )
  6194 *-* x=sql("                  ,'SPEC'   as spec"         )
  6195 *-* x=sql("        from sysibm.sysresauth b"            )
  6196 *-* x=sql("        where b.obtype='C' "                 )
  6197 *-* x=sql("          and b.QUALIFIER='PACKADM '"        )
  6198 *-* x=sql("          and b.grantee"                     )
  6199 *-* x=sql("                not in ('PUBLIC','PUBLIC*')" )
  6200 *-* x=sql("          and (   b.name in ("               )
  6201 *-* x=sql("                     select distinct collid" )
  6202 *-* x=sql("                     from sysibm.syspackage" )
  6203 *-* x=sql("                            )"               )
  6204 *-* x=sql("               or b.name like ('%ISETS%')"   )
  6205 *-* x=sql("               or b.name like ('IVR%')"      )
  6206 *-* x=sql("               or b.name = '*'"              )
  6207 *-* x=sql("              )"                             )
  6208 *-* x=sql("          and not exists ("                  )
  6209 *-* x=sql("            select 1"                        )
  6210 *-* x=sql("            from sysibm.sysresauth c"        )
  6211 *-* x=sql("            where b.obtype='C' "             )
  6212 *-* x=sql("              and c.obtype='C' "             )
  6213 *-* x=sql("              and b.QUALIFIER='PACKADM '"    )
  6214 *-* x=sql("              and c.QUALIFIER='PACKADM '"    )
  6215 *-* x=sql("              and c.grantee"                 )
  6216 *-* x=sql("                    in ('PUBLIC','PUBLIC*')" )
  6217 *-* x=sql("              and c.name = b.name"           )
  6218 *-* x=sql("                         )"                  )
  6219 *-* x=sql("     )"                                      )
  6220 *-* x=sql("order by name, spec"                         )
  6222 *-* call ZSQL
  6224 *-* rowsReturned = 0
  6225 *-* skipRest = 0
  6226 *-* Do Until SQLCODE \= 0
  6227 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :name, :spec"
  6228 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  6229 *-*    rowsReturned = rowsReturned + 1
  6230 *-*    parse upper var name name .
  6232 *-*    if name = '*' & spec = 'PUBLIC'
  6233 *-*     then
       *-*     do /* special case; have to override backstop */
  6234 *-*      If model=1
       *-*       Then
       *-*       prof=Strip(name)"."auth
  6235 *-*      Else
       *-*       prof=ssid"."Strip(name)"."auth
  6236 *-*      prof= left(prof,max(35,length(prof)))
  6237 *-*      cmd="RALT "class prof" UACC(READ) AUDIT(ALL(READ))",                      "OWNER("owner")" ,
                                "DATA('DB2-"ssid "Everyone has PACKADM for collection-*')"
  6240 *-*      x = clistCard(cmd)
  6242 *-*      cmd="PERMIT "prof" CLASS("class") RESET"
  6243 *-*      if resetOption = 'RESET'
       *-*       then
       *-*       x = clistCard(cmd)
  6244 *-*      skiprest = 1
  6245 *-*      iterate
  6246 *-*     end
  6248 *-*    if skiprest = 1
  6249 *-*     then
       *-*     iterate
  6251 *-*    cmd = 'RDEF'
  6252 *-*    if name = '*'
       *-*     then
       *-*     cmd = 'RALT'
  6254 *-*    If model=1
       *-*     Then
       *-*     prof=Strip(name)'.'auth
  6255 *-*    Else
       *-*     prof=ssid'.'Strip(name)'.'auth
  6256 *-*    prof= left(prof,max(35,length(prof)))
  6258 *-*    if spec = 'PUBLIC'
  6259 *-*     then
       *-*     do
  6260 *-*      cmd=cmd class prof" UACC(READ) AUDIT(ALL(READ))" ,
 "OWNER("owner")" ,            "DATA('DB2-"ssid "Everyone has packadm for-"name"')" /*rph*/
  6263 *-*      x = clistCard(cmd)
  6264 *-*     end
  6265 *-*    else
       *-*     do
  6266 *-*      cmd=cmd class prof" UACC(NONE) AUDIT(ALL(READ))" ,
 "OWNER("owner")" ,            "DATA('DB2-"ssid "PACKADM for-"name"')" /*rph*/
  6269 *-*      x = clistCard(cmd)
  6270 *-*     end
  6272 *-*    cmd="PERMIT "prof" CLASS("class") RESET"
  6273 *-*    if resetOption = 'RESET'
       *-*     then
       *-*     x = clistCard(cmd)
  6274 *-*   End
  6275 *-* End /* do until */
  6276 *-* call showRowCount /* show rowsReturned */
  6277 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  6278 *-* Else
       *-*  call prtsqlca 'FETCH C1 '
  6279 *-* address dsnrexx "EXECSQL CLOSE C1"
  6280 *-* If SQLCODE\=0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  6282 *-* if skipRest = 1 /* if everyone has access */
  6283 *-*  then
       *-*  return     /* then, we're done.      */
  6285 *-* Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
  6286 *-* /* --------------------------- */
  6288 *-* /* Get all ids (except PUBLIC) for access list */
  6289 *-* x=sql('NEW statement') /* start new sql statement */
  6290 *-* /* ----------------------- */
  6291 *-* x=sql("SELECT DISTINCT NAME, UGRANTEE"                       )
  6292 *-* x=sql("from ("                                               )
  6293 *-* x=sql("   SELECT DISTINCT a.NAME                  as name"   )
  6294 *-* x=sql("                  ,strip(upper(a.grantee)) as ugrantee")
  6295 *-* x=sql("   FROM SYSIBM.SYSRESAUTH a"                          )
  6296 *-* x=sql("   WHERE a.OBTYPE='C'"                                )
  6297 *-* x=sql("     AND a.QUALIFIER='PACKADM '"                      )
  6298 *-* x=sql("     AND a.USEAUTH<>' '"                              )
  6299 *-* x=sql("     AND not exists ("                                )
  6300 *-* x=sql("            select 1"                                 )
  6301 *-* x=sql("            from sysibm.sysresauth b"                 )
  6302 *-* x=sql("            where a.obtype = b.obtype"                )
  6303 *-* x=sql("              and a.obtype = 'C'"                     )
  6304 *-* x=sql("              and a.QUALIFIER='PACKADM '"             )
  6305 *-* x=sql("              and b.QUALIFIER='PACKADM '"             )
  6306 *-* x=sql("              and a.name   = b.name"                  )
  6307 *-* x=sql("              and a.useauth <> ' '"                   )
  6308 *-* x=sql("              and b.useauth <> ' '"                   )
  6309 *-* x=sql("              and b.grantee in ('PUBLIC','PUBLIC*')"  )
  6310 *-* x=sql("                    )"                                )
  6311 *-* x=sql("     AND (   a.NAME IN ("                             )
  6312 *-* x=sql("                        SELECT DISTINCT COLLID"       )
  6313 *-* x=sql("                        FROM SYSIBM.SYSPACKAGE"       )
  6314 *-* x=sql("                       )"                             )
  6315 *-* x=sql("          OR a.NAME LIKE ('%SETS%')"                  )
  6316 *-* x=sql("          OR a.NAME LIKE ('IVR%')"                    )
  6317 *-* x=sql("          OR a.NAME = '*'"                            )
  6318 *-* x=sql("         )"                                           )
  6319 *-* if SlimAdm
  6320 *-*  then
       *-*  do
  6321 *-*   x=sql("     AND a.GRANTEE NOT IN (select distinct grantee"   )
  6322 *-*   x=sql("                           from sysibm.sysuserauth"   )
  6323 *-*   x=sql("                           where sysadmauth <> ' '"   )
  6324 *-*   x=sql("                          )"                          )
  6325 *-*  end
  6327 *-* if removeUserList <> ''
  6328 *-*  then ,
  6329 *-*  x=sql("     AND GRANTEE not in" RemoveUserList               )
  6331 *-* x=sql("  UNION"                                              )
  6333 *-* x=sql("   SELECT DISTINCT a.NAME                  as name"   )
  6334 *-* x=sql("                  ,strip(upper(b.grantee)) as ugrantee")
  6335 *-* x=sql("   FROM SYSIBM.SYSRESAUTH A"                          )
  6336 *-* x=sql("       ,SYSIBM.SYSRESAUTH B"                          )
  6337 *-* x=sql("   WHERE A.OBTYPE='C'"                                )
  6338 *-* x=sql("     AND a.QUALIFIER='PACKADM '"                      )
  6339 *-* x=sql("     AND b.QUALIFIER='PACKADM '"                      )
  6340 *-* x=sql("     AND a.USEAUTH<>' '"                              )
  6341 *-* x=sql("     AND not exists ("                                )
  6342 *-* x=sql("            select 1"                                 )
  6343 *-* x=sql("            from sysibm.sysresauth c"                 )
  6344 *-* x=sql("            where a.obtype = c.obtype"                )
  6345 *-* x=sql("              and a.obtype = 'C'"                     )
  6346 *-* x=sql("              and a.QUALIFIER='PACKADM '"             )
  6347 *-* x=sql("              and c.QUALIFIER='PACKADM '"             )
  6348 *-* x=sql("              and a.name   = c.name"                  )
  6349 *-* x=sql("              and a.useauth <> ' '"                   )
  6350 *-* x=sql("              and c.useauth <> ' '"                   )
  6351 *-* x=sql("              and c.grantee in ('PUBLIC','PUBLIC*')"  )
  6352 *-* x=sql("                    )"                                )
  6353 *-* x=sql("     and b.OBTYPE='C'"                                )
  6354 *-* x=sql("     AND b.USEAUTH<>' '"                              )
  6355 *-* x=sql("     AND a.name   <> '*'"                             )
  6356 *-* x=sql("     AND b.name    = '*'"                             )
  6357 *-* x=sql("     AND (   a.NAME IN ("                             )
  6358 *-* x=sql("                        SELECT DISTINCT COLLID"       )
  6359 *-* x=sql("                        FROM SYSIBM.SYSPACKAGE"       )
  6360 *-* x=sql("                       )"                             )
  6361 *-* x=sql("          OR a.NAME LIKE ('%SETS%')"                  )
  6362 *-* x=sql("          OR a.NAME LIKE ('IVR%')"                    )
  6363 *-* x=sql("         )"                                           )
  6364 *-* if SlimAdm
  6365 *-*  then
       *-*  do
  6366 *-*   x=sql("     AND b.GRANTEE NOT IN (select distinct grantee"   )
  6367 *-*   x=sql("                           from sysibm.sysuserauth"   )
  6368 *-*   x=sql("                           where sysadmauth <> ' '"   )
  6369 *-*   x=sql("                          )"                          )
  6370 *-*  end
  6372 *-* if removeUserList <> ''
  6373 *-*  then ,
  6374 *-*  x=sql("     AND b.GRANTEE not in" RemoveUserList             )
  6376 *-* x=sql("     )"                                               )
  6377 *-* x=sql("ORDER BY name, ugrantee"                              )
  6379 *-* call ZSQL
  6381 *-* rowsReturned = 0
  6382 *-* Do Until SQLCODE \= 0
  6383 *-*  address dsnrexx "EXECSQL FETCH C1 INTO :name, :grantee"
  6384 *-*  If SQLCODE = 0
       *-*   Then
       *-*   Do
  6385 *-*    rowsReturned = rowsReturned + 1
  6386 *-*    parse upper var name name .
  6388 *-*    if grantee = '*DELETE'
       *-*     then
       *-*     iterate
  6390 *-*    access = 'ACC(READ)'
  6392 *-*    If model=1
       *-*     Then
       *-*     prof=Strip(name)'.'auth
  6393 *-*    Else
       *-*     prof=ssid'.'Strip(name)'.'auth
  6394 *-*    prof= left(prof,max(55,length(prof)))
  6395 *-*    cmd="PERMIT "prof" CLASS("class")" access "ID("grantee")"
  6396 *-*    x = clistCard(cmd)
  6397 *-*   End
  6398 *-* End /* do until */
  6399 *-* call showRowCount /* show rowsReturned */
  6400 *-* If SQLCODE=0 | SQLCODE=100
       *-*  Then
       *-*  nop
  6401 *-* Else
       *-*  call prtsqlca 'FETCH C1 '
  6402 *-* address dsnrexx "EXECSQL CLOSE C1"
  6403 *-* If SQLCODE\=0
       *-*  Then
       *-*  call prtsqlca 'CLOSE C1'
  6405 *-* Return
  6407 *-* OneLineSQL:
  6408 *-* /* used only for one line of sql code zsql, where we declare */
  6409 *-* /* a cursor for use... before we prepare/open cursor for a   */
  6410 *-* /* sql statement.                                            */
  6411 *-* /*                                                           */
  6412 *-* /* We didn't want to use prtsqlca for error recovery before  */
  6413 *-* /* the sql statement was even prepared.  So this is called   */
  6414 *-* /* like this (from zsql):                                    */
  6415 *-* /*                                                           */
  6416 *-* /*        call OneLineSQL "EXECSQL DECLARE C1 CURSOR FOR S1" */
  6417 *-* /*                                                           */
  6418 *-* parse arg oneLineSQLcode
  6419 *-* address dsnrexx oneLineSqlCode /* execute it */
  6420 *-* if sqlcode = 0
  6421 *-*  then
       *-*  return
  6423 *-*  /* error recovery for simple sql */
  6424 *-* err_sw = "1"
  6425 *-* say ' '
  6426 *-* say ' '
  6427 *-* say ' '
  6428 *-* say '** --------------------'
  6429 *-* say '** start error analysis'
  6430 *-* say '** --------------------'
  6431 *-* say ' '
  6432 *-* Say '** Error SQL statement'
  6433 *-* Say '** failing SQL statement follows:'
  6434 *-* say oneLineSQLcode
  6435 *-* say '** end failing SQL statement'
  6436 *-* say ' '
  6437 *-* Say 'SQLCODE = 'SQLCODE
  6438 *-* Say 'SQLERRMC = 'SQLERRMC
  6439 *-* Say 'SQLERRP = 'SQLERRP
  6440 *-* Say 'SQLERRD = 'SQLERRD.1',',                                                       || SQLERRD.2',',
                                    || SQLERRD.3',',                                                        || SQLERRD.4',',
                                                 || SQLERRD.5',',                                                        || SQLERRD
.6
  6447 *-* Say 'SQLWARN = 'SQLWARN.1',',                                                       || SQLWARN.2',',
                                    || SQLWARN.3',',                                                        || SQLWARN.4',',
                                                 || SQLWARN.5',',                                                        || SQLWARN
.6',',                                                        || SQLWARN.7',',
   || SQLWARN.8',',                                                        || SQLWARN.9',',
                || SQLWARN.10
  6458 *-* Say 'SQLSTATE= 'SQLSTATE
  6460 *-* say 'called from line' sigl
  6461 *-* say ' '
  6462 *-* say 'code near call to OneLineSql'
  6463 *-* say ' '
  6464 *-* prbl = sigl
  6466 *-* syntaxLow = max(prbL-12,1)           /*-12 before (or pgm start */
  6467 *-* syntaxHigh= min(prbL+4,sourceline()) /* +4 after  (or pgm end   */
  6468 *-* do syntaxII = syntaxLow to syntaxHigh/* show subset of lines    */
  6469 *-*  if syntaxII <> prbL
  6470 *-*   then
       *-*   say 'line   ' right(syntaxii,length(syntaxHigh))':' ,                           sourceline(syntaxII)
  6472 *-*  else
       *-*   say 'line==>' right(syntaxii,length(syntaxHigh))':' ,                           sourceline(syntaxII)
  6474 *-* end
  6475 *-* say ' '
  6478 *-* /* close (most) open files */
  6479 *-* /* ----------------------- */
  6480 *-* do i = 1 by 1 for openDDs
  6481 *-*  ddname = openDDs.i
  6482 *-*  address 'TSO' "EXECIO" bufferRecs.ddname ,                                              "DISKW" ddname '(FINIS STEM BUF
FERX.'ddname'.'
  6484 *-*  if rc <> 0
  6485 *-*   then
       *-*   say 'error closing/writting to ddname='ddname ,                                                 ||';rc='rc
  6487 *-* end
  6488 *-* Exit 999
  6490 *-* ZSQL:
  6491 *-* zsqlSigl = sigl /* helps prtsqlca give us info */
  6492 *-* err_sw = "0"
  6494 *-* /* normally:   declare c1 cursor for s1"      */
  6495 *-* /* but may be: declare c2 cursor for s2", etc */
  6496 *-* call OneLineSQL "EXECSQL DECLARE C"sqlStmtValue ,                                               "CURSOR FOR S"sqlStmtVal
ue
  6498 *-* /*trace 'n'*/
  6500 *-* if sqlOption = 'SQL'
  6501 *-*  then
       *-*  do /* "display" sql statement in output */
  6502 *-*   if datatype(zsqlsigl,'W')
  6503 *-*    then
       *-*    do
  6504 *-*     cmd='/* **rexx code generating SQL statement began at' ,                    sqlstmt.sqlStmtValue.startSQLcaller ,
                                'ended at'                          ,                                   sqlstmt.sqlStmtValue.lastSQ
Lcaller  ,                                   ' */'
  6509 *-*     x=clistCard(cmd)
  6510 *-*     x=clistCard(' ')
  6511 *-*     cmd='/*   ** rexx code follows:  */'
  6512 *-*     x=clistCard(cmd)
  6513 *-*     iiiStart = sqlstmt.sqlStmtValue.startSQLcaller
  6514 *-*     iiiEnd   = sqlstmt.sqlStmtValue.lastSQLcaller
  6515 *-*     do iii = iiiStart by 1 to iiiEnd
  6516 *-*      cmd= '/*'   iii'-->'sourceline(iii) '*/'
  6517 *-*      x=clistCard(cmd)
  6518 *-*     end
  6519 *-*     cmd='/*   ** End of rexx code ** */'
  6520 *-*     x=clistCard(cmd)
  6521 *-*     x=clistCard(' ')
  6522 *-*     cmd='/* **resolved rexx SQL code; statement began at' ,                     sqlstmt.sqlStmtValue.startSQLcaller ,
                                'ended at'                          ,                                   sqlstmt.sqlStmtValue.lastSQ
Lcaller  ,                                   ' */'
  6527 *-*     x=clistCard(cmd)
  6528 *-*     x=clistCard(' ')
  6529 *-*     cmd='/*   ** resolved SQL code follows:  */'
  6530 *-*     x=clistCard(cmd)
  6531 *-*     iiiStart = sqlstmt.sqlStmtValue.startSQLcaller
  6532 *-*     iiiEnd   = sqlstmt.sqlStmtValue.lastSQLcaller
  6533 *-*     do iii = iiiStart by 1 to iiiEnd
  6534 *-*      /* ex:  SQLSTMT0.iii = 0 */
  6535 *-*      /*   or SQLSTMT1.iii = 0 */
  6536 *-*      /*   or etc.         = 0 */
  6537 *-*      /* --------------------- */
  6538 *-*      if value('sqlStmt'sqlStmtValue'SiglIndx.'iii) = 0
  6539 *-*       then
       *-*       iterate
  6540 *-*      mmm = value('sqlStmt'sqlStmtValue'SiglIndx.'iii)
  6541 *-*      rsql = sqlStmt.sqlStmtValue.mmm
  6542 *-*      do while length(rsql) > 72
  6543 *-*       rsql1 = left(rsql,72)
  6544 *-*       rsql  = substr(rsql,73)
  6545 *-*       cmd= '/*'   iii'-->'rsql1'<-- */'
  6546 *-*       x=clistCard(cmd)
  6547 *-*      end
  6548 *-*      cmd= '/*'   iii'-->'left(rsql,72)'<-- */'
  6549 *-*      x=clistCard(cmd)
  6550 *-*     end
  6551 *-*     cmd='/*   ** End of resolved SQL code ** */'
  6552 *-*     x=clistCard(cmd)
  6553 *-*     x=clistCard(' ')
  6555 *-*    end
  6556 *-*  end
  6557 *-*  /* generate "sql" statement from sqlstmt. */
  6558 *-* GenSql = ''
  6559 *-* do iii=1 by 1 for sqlstmt.sqlStmtValue.0
  6560 *-*  GenSql = genSql sqlstmt.sqlStmtValue.iii
  6561 *-* end
  6562 *-* x = value('GenSql'sqlStmtValue,genSql) /* set GENSQL1, etc */
  6563 *-* address dsnrexx "EXECSQL PREPARE S"sqlStmtValue /* s# */ ,                                         "INTO :outsqlca FROM
:gensql"
  6565 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'PREPARE S'sqlStmtValue
  6567 *-* address dsnrexx "EXECSQL OPEN C"sqlStmtValue
  6568 *-* If SQLCODE \= 0
       *-*  Then
       *-*  call prtsqlca 'OPEN C'sqlStmtValue
  6570 *-* zsqlSigl = ''   /* zsql no longer active */
  6571 *-* Return  /* zsql */
  6573 *-* prtsqlca:
  6574 *-* trace 'n'
  6575 *-* err_sw = "1"
  6576 *-* say ' '
  6577 *-* say ' '
  6578 *-* say ' '
  6579 *-* say '** --------------------'
  6580 *-* say '** start error analysis'
  6581 *-* say '** --------------------'
  6582 *-* say ' '
  6583 *-* Say '** Error SQL statement - ' arg(1)
  6585 *-* parse upper arg word1 word2 word3
  6586 *-* if word1 = 'PREPARE'
  6587 *-*  then
       *-*  parse upper arg . ' S'stmtCursorNum .
  6588 *-* else
       *-*  parse upper arg . ' C'stmtCursorNum .
  6590 *-* Say '** failing SQL statement follows:'
  6591 *-* say value('GenSql'stmtCursorNum) /* Gensql1 or GenSql2, etc */
  6592 *-* say '** end failing SQL statement'
  6593 *-* say ' '
  6594 *-* if datatype(zsqlsigl,'W')
  6595 *-*  then
       *-*  do
  6596 *-*   say '** rexx code generating failing statement began at' ,                  sqlstmt.stmtCursorNum.startSQLcaller ,
                              'ended at'                           ,                                  sqlstmt.stmtCursorNum.lastSQL
caller
  6600 *-*   say ' '
  6601 *-*   say '** rexx code follows:'
  6602 *-*   iiiStart = sqlstmt.stmtCursorNum.StartSQLcaller
  6603 *-*   iiiEnd   = sqlstmt.stmtCursorNum.lastSQLcaller
  6604 *-*   do iii = iiiStart by 1 to iiiEnd
  6605 *-*    say iii'-->'sourceline(iii)
  6606 *-*   end
  6607 *-*   say '** end of rexx code **'
  6608 *-*   say ' '
  6609 *-*   say '/* **resolved rexx SQL code; statement began at' ,                     sqlstmt.stmtCursorNum.startSQLcaller ,
                              'ended at'                           ,                                  sqlstmt.stmtCursorNum.lastSQL
caller  ,                                  ' */'
  6614 *-*   say ' '
  6615 *-*   say '/*   ** resolved SQL code follows:  */'
  6616 *-*   iiiStart = sqlstmt.stmtCursorNum.StartSQLcaller
  6617 *-*   iiiEnd   = sqlstmt.stmtCursorNum.lastSQLcaller
  6618 *-*   do iii = iiiStart by 1 to iiiEnd
  6619 *-*    if value('sqlStmt'stmtCursorNum'SiglIndx.'iii) = 0
  6620 *-*     then
       *-*     iterate
  6621 *-*    mmm = value('sqlStmt'stmtCursorNum'SiglIndx.'iii)
  6622 *-*    rsql = sqlStmt.stmtCursorNum.mmm
  6623 *-*    do while length(rsql) > 72
  6624 *-*     rsql1 = left(rsql,72)
  6625 *-*     rsql  = substr(rsql,73)
  6626 *-*     say  '/*'   iii'-->'rsql1'<-- */'
  6627 *-*    end
  6628 *-*    say  '/*'   iii'-->'left(rsql,72)'<-- */'
  6629 *-*   end
  6630 *-*   say '/*   ** End of resolved SQL code ** */'
  6631 *-*   say ' '
  6632 *-*  end
  6633 *-* Say 'SQLCODE = 'SQLCODE
  6634 *-* Say 'SQLERRMC = 'SQLERRMC
  6635 *-* Say 'SQLERRP = 'SQLERRP
  6636 *-* Say 'SQLERRD = 'SQLERRD.1',',                                                       || SQLERRD.2',',
                                    || SQLERRD.3',',                                                        || SQLERRD.4',',
                                                 || SQLERRD.5',',                                                        || SQLERRD
.6
  6643 *-* Say 'SQLWARN = 'SQLWARN.1',',                                                       || SQLWARN.2',',
                                    || SQLWARN.3',',                                                        || SQLWARN.4',',
                                                 || SQLWARN.5',',                                                        || SQLWARN
.6',',                                                        || SQLWARN.7',',
   || SQLWARN.8',',                                                        || SQLWARN.9',',
                || SQLWARN.10
  6654 *-* Say 'SQLSTATE= 'SQLSTATE
  6656 *-* if zsqlsigl = 'ZSQLSIGL' | zsqlsigl = ''
  6657 *-*  then
       *-*  prbL= sigl
  6658 *-* else
       *-*  do
  6659 *-*   prbL = zsqlSigl
  6660 *-*   say ' '
  6661 *-*   say 'problem detected in ZSQL: routine'
  6662 *-*  end
  6663 *-* say ' '
  6664 *-* say 'code near call to ZSQL: and/or call to PRTSQLCA at' prbL
  6665 *-* say ' '
  6667 *-* syntaxLow = max(prbL-12,1)           /*-12 before (or pgm start */
  6668 *-* syntaxHigh= min(prbL+4,sourceline()) /* +4 after  (or pgm end   */
  6669 *-* do syntaxII = syntaxLow to syntaxHigh/* show subset of lines    */
  6670 *-*  if syntaxII <> prbL
  6671 *-*   then
       *-*   say 'line   ' right(syntaxii,length(syntaxHigh))':' ,                           sourceline(syntaxII)
  6673 *-*  else
       *-*   say 'line==>' right(syntaxii,length(syntaxHigh))':' ,                           sourceline(syntaxII)
  6675 *-* end
  6676 *-* say ' '
  6677 *-* say '** scroll up to "** start error analysis" to see start of'
  6678 *-* say '** ... the diagnostic messages for this problem.        '
  6680 *-* /* close (most) open files */
  6681 *-* /* ----------------------- */
  6682 *-* do i = 1 by 1 for openDDs
  6683 *-*  ddname = openDDs.i
  6684 *-*  address 'TSO' "EXECIO" bufferRecs.ddname ,                                              "DISKW" ddname '(FINIS STEM BUF
FERX.'ddname'.'
  6686 *-*  if rc <> 0
  6687 *-*   then
       *-*   say 'error closing/writting to ddname='ddname ,                                                 ||';rc='rc
  6689 *-* end
  6690 *-* Exit 999
  6691 *-* Return
  6693 *-* clistcard:
  6694 *-* /* if called to write a blank line                         */
  6695 *-* /* then do                                                 */
  6696 *-* /*    if caller set useClass to a class (ex: MDSNPK)       */
  6697 *-* /*    then it will directed to that classes outut file.    */
  6698 *-* /*    if caller set rdef$permit to 'RDEF' or "PERMIT'      */
  6699 *-* /*    then it will direct line to RDEF or PE$ class file.  */
  6700 *-* /*    otherwise, it will use prior useClass + rdef$PERMIT  */
  6701 *-* /* end                                                     */
  6702 *-* /* else do                                                 */
  6703 *-* /*    for actual RDEF and PERMIT's it will update useClass */
  6704 *-* /*    and rdef$Permit variables automatically, to direct   */
  6705 *-* /*    output.                                              */
  6706 *-* /* end                                                     */
  6707 *-* parse arg clistcard
  6708 *-* ccData = ''
  6710 *-* if clistcard = ''
  6711 *-*  then
       *-*  nop
  6712 *-* else
       *-*  if left(word(clistcard,1),4) = 'RDEF' ,                                  | left(word(clistcard,1),4) = 'RALT'
  6714 *-*   then
       *-*   do
  6715 *-*    rdef$PERMIT = 'RDEF' /* override, just in case */
  6716 *-*    parse upper var clistcard . useClass .
  6717 *-*    clistCard = clistcard optionWarn
  6718 *-*   end
  6719 *-*  else
       *-*   if word(clistcard,words(clistCard)) = 'RESET'
  6720 *-*    then
       *-*    do
  6721 *-*     rdef$PERMIT = 'RDEF' /* override, just in case */
  6722 *-*     parse upper var clistcard . 'CLASS(' useClass ')' .
  6723 *-*    end
  6724 *-*   else
       *-*    if pos(' CLASS(',clistCard) > 0
  6725 *-*     then
       *-*     do
  6726 *-*      rdef$PERMIT = 'PERMIT' /* override, just in case */
  6727 *-*      parse upper var clistcard . 'CLASS(' useClass ')' .
  6728 *-*     end
  6729 *-*    else
       *-*     if rdef$permit = 'RDEF$PERMIT'
  6730 *-*      then
       *-*      rdef$permit = 'RDEF'
  6732 *-*      /* change-06/06/2023 add PE/noPE option */
  6733 *-*      /*                                      */
  6734 *-*      /* choose output dataset (to RDEF or PE dataset)                */
  6735 *-*      /* ---------------------------------------------                */
  6736 *-*      /* if rdef$permit = RDEF,  line should be written to rdef ddname*/
  6737 *-*      /* else (rdef$permit = permit)                                  */
  6738 *-*      /*    if peOption = PE,    line should be written to pe   ddname*/
  6739 *-*      /*    else                 line re-routed to write 2 rdef ddname*/
  6741 *-* if rdef$permit = 'RDEF'
  6742 *-*  then
       *-*  ddname = rdefIndx.useClass /* rdef output to rdef ddnames*/
  6743 *-* else
       *-*  do
  6744 *-*   if peOption = 'PE' /* PE or NOPE (noPE); change-06/06/2023 */
  6745 *-*    then
       *-*    ddname = pe$Indx.useClass  /*   PE option, pe output to pe  */
  6746 *-*   else
       *-*    ddname = rdefIndx.useClass /* noPE option, pe output to rdef*/
  6747 *-*  end
  6749 *-* if pos(' ID(',clistcard) > 0
  6750 *-*  then
       *-*  do /* keep track of unique userid's */
  6751 *-*   parse var clistcard frontHalf 'ID(' uidx ')' backhalf
  6752 *-*   uidx = strip(uidx)
  6754 *-*   if deleteId.uidx = 1
  6755 *-*    then
       *-*    return 0 /* we want this userid deleted */
  6757 *-*   if excludeIndx.uidx > 0
  6758 *-*    then
       *-*    do
  6759 *-*     /* userid is excluded; replace w/the replacement id/group */
  6760 *-*     replace = excludeIndx.uidx
  6761 *-*     uidx    = replace.replace
  6762 *-*     clistcard = frontHalf 'ID('uidx')' backhalf
  6763 *-*    end
  6765 *-*    /* while we are here, add to # of unique userid's we know about*/
  6766 *-*   if uidIndx.uidx = 0
  6767 *-*    then
       *-*    do /* this is an unknown userid, add to our list */
  6768 *-*     uid = uid + 1  /* we got another one */
  6769 *-*     uid.uid = uidx /* add to list of sequential userid's */
  6770 *-*     uidIndx.uidx = uid /* now add quick lookup for this userid */
  6771 *-*    end
  6772 *-*   if (  word(clistcard,1) = 'PERMIT' ,                                        | word(clistcard,1) = 'PE'     ,
                             )                               ,
  6775 *-*    then
       *-*    do/* lets count permits by useclass by uidx */
  6776 *-*     if classIndx.useclass = 0
  6777 *-*      then
       *-*      do /* add to classlist */
  6778 *-*       classList = classList + 1
  6779 *-*       classList.classList = useClass
  6780 *-*       classIndx.useClass  = classList
  6781 *-*      end
  6782 *-*     classIndx = classIndx.useClass
  6783 *-*     uidIndx   = uidIndx.uidx
  6784 *-*     PermitsByClass.classIndx.uidIndx = ,                                               PermitsByClass.Classindx.uidIndx
+ 1
  6786 *-*    end
  6787 *-*   if (  word(clistcard,1) = 'PERMIT' ,                                        | word(clistcard,1) = 'PE'     ,
                             )                               ,                                       & pos(' DATA(',clistcard) = 0
  6791 *-*    then
       *-*    do
  6792 *-*     ccData = userGroupInfo(uidx)
  6793 *-*     ccData = "DATA('"ccData"')"
  6794 *-*    end
  6795 *-*   else
       *-*    if (  word(clistcard,1) = 'PERMIT' ,                                        | word(clistcard,1) = 'PE'     ,
                              )                               ,                                  & pos(' DATA(',clistcard) > 0
  6799 *-*     then
       *-*     do
  6800 *-*      if groupIndx.uidx > 0
  6801 *-*       then
       *-*       do
  6802 *-*        /* replace with group info */
  6803 *-*        parse var clistcard clistcard ' DATA(' .
  6804 *-*        ccData = userGroupInfo(uidx)
  6805 *-*        ccData = "DATA('"ccData"')"
  6806 *-*       end
  6807 *-*      else
       *-*       if useridIndx.uidx > 0
  6808 *-*        then
       *-*        do
  6809 *-*         /* prefix with "user xyz;" */
  6810 *-*         parse var clistcard clistCard " DATA('" ccData "'" .
  6811 *-*         ccData = "DATA('user" uidx";" ccData"')"
  6812 *-*        end
  6813 *-*       else
       *-*        do
  6814 *-*         /* replace with unknown user info */
  6815 *-*         parse var clistcard clistCard ' DATA(' .
  6816 *-*         ccData = userGroupInfo(uidx)
  6817 *-*         ccData = "DATA('"ccData"')"
  6818 *-*        end
  6819 *-*     end
  6820 *-*  end
  6821 *-* else
       *-*  uidx = ''
  6823 *-* clistx = bufferRecs.ddname + 1
  6825 *-* if word(clistcard,1) = '/*' | clistcard = ''
  6826 *-*  then
       *-*  bufferX.ddname.clistx = clistcard
  6827 *-* else
       *-*  if word(clistcard,1) = 'RDEF' ,                                          | word(clistcard,1) = 'RALT'
  6829 *-*   then
       *-*   do
  6831 *-*    bufferX.ddname.clistx = ' ' /* insert blank line */
  6832 *-*    clistx = clistx + 1 /* now add RDEF card */
  6834 *-*    bufferX.ddname.clistx = ,                                                        left(word(clistcard,1),10) subword(c
listcard,2)
  6836 *-*    if pos(' DATA(',bufferX.ddname.clistx) > 0
  6837 *-*     then
       *-*     do
  6838 *-*      parse var bufferX.ddname.clistx bufferX.ddname.clistx ,                    ' DATA(' rest
  6840 *-*      bufferX.ddname.clistx = bufferX.ddname.clistx '-'
  6841 *-*      if length(bufferx.DDname.clistx) > 120
  6842 *-*       then
       *-*       do
  6843 *-*        if pos(' UACC(',bufferx.DDname.clistx) > 0
  6844 *-*         then
       *-*         do
  6845 *-*          parse var bufferx.DDname.clistx bufferx.DDname.clistx ,                    ' UACC(' uacc
  6847 *-*          bufferx.DDname.clistx = bufferx.DDname.clistx '-'
  6848 *-*          clistx = clistx + 1
  6849 *-*          bufferx.DDname.clistx = left('',11) 'UACC('uacc
  6850 *-*         end
  6851 *-*        else
       *-*         if pos(' CLASS(',bufferx.DDname.clistx) > 0
  6852 *-*          then
       *-*          do
  6853 *-*           parse var bufferx.DDname.clistx bufferx.DDname.clistx ,                    ' CLASS(' class
  6855 *-*           bufferx.DDname.clistx = bufferx.DDname.clistx '-'
  6856 *-*           clistx = clistx + 1
  6857 *-*           bufferx.DDname.clistx = left('',11) 'CLASS('class
  6858 *-*          end
  6859 *-*       end
  6860 *-*      clistx = clistx + 1
  6861 *-*      bufferX.ddname.clistx = left('',11) 'DATA('rest
  6862 *-*     end
  6863 *-*   end
  6864 *-*  else
       *-*   if ccData = ''
  6865 *-*    then
       *-*    do                /* add permit, etc */
  6867 *-*     bufferX.ddname.clistx = ' '
  6868 *-*     clistx = clistx + 1
  6870 *-*     bufferX.ddname.clistx = ,                                                        left('   'word(clistcard,1),length(
class)+11) ,                                 subword(clistcard,2)
  6873 *-*     if pos(' DATA(',bufferX.ddname.clistx) > 0
  6874 *-*      then
       *-*      do
  6875 *-*       parse var bufferX.ddname.clistx bufferX.ddname.clistx ,                    ' DATA(' rest
  6877 *-*       bufferX.ddname.clistx = bufferX.ddname.clistx
  6878 *-*       if length(bufferx.DDname.clistx) > 120
  6879 *-*        then
       *-*        do
  6880 *-*         if pos(' UACC(',bufferx.DDname.clistx) > 0
  6881 *-*          then
       *-*          do
  6882 *-*           parse var bufferx.DDname.clistx bufferx.DDname.clistx ,                    ' UACC(' uacc
  6884 *-*           bufferx.DDname.clistx = bufferx.DDname.clistx '-'
  6885 *-*           clistx = clistx + 1
  6886 *-*           bufferx.DDname.clistx = left('',11) 'UACC('uacc
  6887 *-*          end
  6888 *-*         else
       *-*          if pos(' CLASS(',bufferx.DDname.clistx) > 0
  6889 *-*           then
       *-*           do
  6890 *-*            parse var bufferx.DDname.clistx bufferx.DDname.clistx ,                    ' CLASS(' class
  6892 *-*            bufferx.DDname.clistx = bufferx.DDname.clistx '-'
  6893 *-*            clistx = clistx + 1
  6894 *-*            bufferx.DDname.clistx = left('',11) 'CLASS('class
  6895 *-*           end
  6896 *-*        end
  6897 *-*       clistx = clistx + 1
  6898 *-*       bufferX.ddname.clistx = left('',11) '/*' left(rest,90) '*/'
  6899 *-*      end
  6900 *-*    end
  6901 *-*   else
       *-*    do                /* add permit, etc */
  6903 *-*     bufferX.ddname.clistx = ' '
  6904 *-*     clistx = clistx + 1
  6906 *-*     bufferX.ddname.clistx = ,                                                        left('   'word(clistcard,1),length(
class)+11) ,                                 subword(clistcard,2)
  6909 *-*     if length(bufferx.DDname.clistx) > 120
  6910 *-*      then
       *-*      do
  6911 *-*       if pos(' UACC(',bufferx.DDname.clistx) > 0
  6912 *-*        then
       *-*        do
  6913 *-*         parse var bufferx.DDname.clistx bufferx.DDname.clistx ,                    ' UACC(' uacc
  6915 *-*         bufferx.DDname.clistx = bufferx.DDname.clistx '-'
  6916 *-*         clistx = clistx + 1
  6917 *-*         bufferx.DDname.clistx = left('',11) 'UACC('uacc
  6918 *-*        end
  6919 *-*       else
       *-*        if pos(' CLASS(',bufferx.DDname.clistx) > 0
  6920 *-*         then
       *-*         do
  6921 *-*          parse var bufferx.DDname.clistx bufferx.DDname.clistx ,                    ' CLASS(' class
  6923 *-*          bufferx.DDname.clistx = bufferx.DDname.clistx '-'
  6924 *-*          clistx = clistx + 1
  6925 *-*          bufferx.DDname.clistx = left('',11) 'CLASS('class
  6926 *-*         end
  6927 *-*      end
  6928 *-*     clistx = clistx + 1
  6929 *-*     bufferX.ddname.clistx = '        ' '/*' left(ccData,90) '*/'
  6930 *-*    end
  6932 *-* if clistx > 100
  6933 *-*  then
       *-*  do /* need to start writting out some of the buffer */
  6934 *-*   Address TSO "EXECIO" clistx ,                                                             "DISKW" ddname "(STEM bUFFER
X."ddname"."
  6936 *-*   if rc <> 0
  6937 *-*    then
       *-*    do
  6938 *-*     say 'error writting to ddname' ddname'; rc='rc
  6939 *-*     if pendingrc = 0
  6940 *-*      then
       *-*      do
  6941 *-*       say 'will exit with rc=8'
  6942 *-*       pendingrc = 8
  6943 *-*      end
  6944 *-*    end
  6945 *-*   clistx = 0 /* reset number of recs in buffer to zero */
  6946 *-*   bufferRecs.ddname = 0
  6947 *-*  end
  6948 *-* else
       *-*  bufferRecs.ddname = clistx
  6950 *-* return 0
  6952 *-* optClstCard:
  6953 *-* parse arg clistcard
  6954 *-* ccData = ''
  6955 *-* if pos(' ID(',clistcard) > 0
  6956 *-*  then
       *-*  do /* keep track of unique userid's */
  6957 *-*   parse var clistcard frontHalf 'ID(' uidx ')' backhalf
  6958 *-*   uidx = strip(uidx)
  6960 *-*   if deleteId.uidx = 1
  6961 *-*    then
       *-*    return 0 /* we want this userid deleted */
  6963 *-*   if excludeIndx.uidx > 0
  6964 *-*    then
       *-*    do
  6965 *-*     /* userid is excluded; replace w/the replacement id/group */
  6966 *-*     replace = excludeIndx.uidx
  6967 *-*     uidx    = replace.replace
  6968 *-*     clistcard = frontHalf 'ID('uidx')' backhalf
  6969 *-*    end
  6971 *-*    /* while we are here, add to # of unique userid's we know about */
  6972 *-*   if uidIndx.uidx = 0
  6973 *-*    then
       *-*    do /* this is an unknown userid, add to our list */
  6974 *-*     uid = uid + 1  /* we got another one */
  6975 *-*     uid.uid = uidx /* add to list of sequential userid's */
  6976 *-*     uidIndx.uidx = uid /* now add quick lookup for this userid */
  6977 *-*    end
  6978 *-*   if (  word(clistcard,1) = 'PERMIT' ,                                        | word(clistcard,1) = 'PE'     ,
                             )                               ,                                       & pos(' DATA(',clistcard) = 0
  6982 *-*    then
       *-*    do
  6983 *-*     ccData = userGroupInfo(uidx)
  6984 *-*     ccData = "DATA('"ccData"')"
  6985 *-*    end
  6986 *-*   else
       *-*    if (  word(clistcard,1) = 'PERMIT' ,                                        | word(clistcard,1) = 'PE'     ,
                              )                               ,                                  & pos(' DATA(',clistcard) > 0
  6990 *-*     then
       *-*     do
  6991 *-*      if groupIndx.uidx > 0
  6992 *-*       then
       *-*       do
  6993 *-*        /* replace with group info */
  6994 *-*        parse var clistcard clistcard ' DATA(' .
  6995 *-*        ccData = userGroupInfo(uidx)
  6996 *-*        ccData = "DATA('"ccData"')"
  6997 *-*       end
  6998 *-*      else
       *-*       if useridIndx.uidx > 0
  6999 *-*        then
       *-*        do
  7000 *-*         /* prefix with "user xyz;" */
  7001 *-*         parse var clistcard clistCard " DATA('" ccData "'" .
  7002 *-*         ccData = "DATA('user" uidx";" ccData"')"
  7003 *-*        end
  7004 *-*       else
       *-*        do
  7005 *-*         /* replace with unknown user info */
  7006 *-*         parse var clistcard clistCard ' DATA(' .
  7007 *-*         ccData = userGroupInfo(uidx)
  7008 *-*         ccData = "DATA('"ccData"')"
  7009 *-*        end
  7010 *-*     end
  7011 *-*  end
  7012 *-* else
       *-*  uidx = ''
  7013 *-* optClstx = optClstx + 1
  7014 *-* if left(word(clistcard,1),2) = '/*' | clistcard = ''
  7015 *-*  then
       *-*  optClstx.optClstx = clistcard
  7016 *-* else
       *-*  if word(clistcard,1) = 'RDEF'
  7017 *-*   then
       *-*   do
  7018 *-*    optClstx.optClstx = ' ' /* insert blank line */
  7019 *-*    optClstx = optClstx + 1 /* now add RDEF card */
  7020 *-*    optClstx.optClstx = left(word(clistcard,1),10) subword(clistcard,2)
  7021 *-*    parse var optClstX.optClstx optClstX.optClstx ,                            ' DATA(' rest
  7023 *-*    optClstX.optClstx = optClstX.optClstx '-'
  7024 *-*    optClstx = optClstx + 1 /* now add data card */
  7025 *-*    optClstX.optClstx = left('',11) 'DATA('rest
  7026 *-*   end
  7027 *-*  else
       *-*   do                    /* add permit card, etc*/
  7028 *-*    optClstx.optClstx = left('   'word(clistcard,1),length(class)+11) ,                           subword(clistcard,2) cc
Data
  7030 *-*    parse var optClstX.optClstx optClstX.optClstx ,                            ' DATA(' rest
  7032 *-*    if rest <> ''
  7033 *-*     then
       *-*     do
  7034 *-*      optClstX.optClstx = optClstX.optClstx '-'
  7035 *-*      optClstx = optClstx + 1 /* now add data card */
  7036 *-*      optClstX.optClstx = left('',11) 'DATA('rest
  7037 *-*     end
  7038 *-*   end
  7039 *-* return 0
  7041 *-* addExclude:
  7042 *-* /* if we are changing userids, that happens in a case statement */
  7043 *-* /* if we are rejecting userids (deletes) that goes in a "not in"*/
  7044 *-* /*    list                                                      */
  7045 *-* parse upper arg excludeId groupid .
  7046 *-* exclude = exclude + 1
  7047 *-* exclude.exclude = excludeId
  7048 *-* replace.exclude = groupid
  7049 *-* excludeIndx.excludeId = exclude
  7050 *-* if groupid = '*DELETE'
  7051 *-*  then
       *-*  do
  7052 *-*   /* *DELETE(s) go into a "NOT IN ('id1','id2','id3'... list */
  7053 *-*   deleteId.excludeId = 1
  7054 *-*   RemoveUserList = removeUserList commaParen||"'"excludeId"'"
  7055 *-*   commaParen = ',' /* switch from ( to , */
  7056 *-*  end
  7057 *-* else
       *-*  granteeCase = granteeCase , /* changes go into case stmt */                     "when upper(a.grantee) = '"excludeId"'
then '"groupid"'"
  7059 *-* return 0
  7062 *-* userGroupInfo:
  7063 *-* parse upper arg userORgroup .
  7064 *-* if useridIndx.userORgroup > 0
  7065 *-*  then
       *-*  do
  7066 *-*   /* we have user info */
  7067 *-*   uix = useridIndx.userORgroup
  7068 *-*   userRef.uix = 1
  7069 *-*   userORgroup = left(userORgroup,max(8,length(userorGroup)))
  7070 *-*   if revoked.uix = 'No'
  7071 *-*    then
       *-*    return 'User='userOrGroup'; d-grp='left(usersDgroup.uix,8) ,                  ||'; migDate='date('U') ,
                                 ||'; name='strip(usersName.uix)
  7074 *-*   return 'User='userOrGroup'; d-grp='left(usersDgroup.uix,8) ,                       ||'; revoke='revoked.uix'; name='st
rip(usersName.uix)
  7076 *-*  end
  7077 *-* else
       *-*  if groupIndx.userORgroup > 0
  7078 *-*   then
       *-*   do
  7079 *-*    /* we have group info */
  7080 *-*    gix = groupIndx.userORgroup
  7081 *-*    groupRef.gix = 1
  7082 *-*    userORgroup = left(userORgroup,max(8,length(userorGroup)))
  7083 *-*    return 'Group='userORgroup'; desc='groupdesc.gix
  7084 *-*   end
  7085 *-*  else
       *-*   do
  7086 *-*    /* we have no info */
  7087 *-*    /* now remember some information about the user */
  7088 *-*    userid = userid.0
  7089 *-*    userid = userid + 1
  7090 *-*    userid.0 = userid
  7091 *-*    useridIndx.UserORgroup = userid
  7092 *-*    userid.userid = UserORgroup
  7093 *-*    revoked.userid= '?'
  7094 *-*    usersName.userid = 'Not in Racf'
  7095 *-*    usersDGroup.userid = '?'
  7096 *-*    usersGroups.userid = 0  /* collect user groups with 0205's*/
  7098 *-*    uix = userid
  7099 *-*    userRef.uix = 1
  7100 *-*    userORgroup = left(userORgroup,max(8,length(userorGroup)))
  7101 *-*    return 'User='userOrGroup'; d-grp='left(usersDgroup.uix,8)';',                         'revoke='revoked.uix'; name='s
trip(usersName.uix)
  7103 *-*   end
  7105 *-* changestr:
  7106 *-* /* function to replace string (1st parm) */
  7107 *-* /*          in haystack string(2nd parm) */
  7108 *-* /*           w/string         (3rd parm) */
  7109 *-* cNeedleParm1   = arg(1) /* string (needle) to replace */
  7110 *-* cHaystackParm2 = arg(2) /* haystack to be updated.   */
  7111 *-* cReplacementParm3 = arg(3) /* replacement string*/
  7113 *-* cTempHaystack = cHaystackParm2 /* use as temp string */
  7114 *-* cReturnValue = '' /* uas as string to build up */
  7116 *-* if length(cNeedleParm1) = 0/* if parm1 is null                 */
  7117 *-*  then
       *-*  return cHaystackParm2 /* then return parm2, nothing to do */
  7119 *-* x = pos(cNeedleParm1,cTempHaystack) /* find needle in haystack*/
  7120 *-* do while x > 0
  7121 *-*  if x > 1
  7122 *-*   then
       *-*   do
  7123 *-*    cReturnValue = cReturnValue || left(cTempHaystack,x-1) ,                                            || cReplacementPa
rm3
  7125 *-*    cTempHaystack = substr(cTempHaystack,length(cNeedleParm1)+x)
  7126 *-*   end
  7127 *-*  else
       *-*   do /* x = 1 */
  7128 *-*    cReturnValue = cReturnValue || cReplacementParm3
  7129 *-*    cTempHaystack = substr(cTempHaystack,length(cNeedleParm1)+x)
  7130 *-*   end
  7131 *-*  x = pos(cNeedleParm1,cTempHaystack) /* find needle in remaining*/
  7132 *-*  /* haystack, if any        */
  7133 *-* end
  7134 *-* cReturnValue = cReturnValue || cTempHaystack
  7135 *-* return cReturnValue
  7137 *-* sql:
  7138 *-* /* function.  collects sql statement in readable form */
  7139 *-* /*    ...we'll set (and append) to stem SQLSTMT       */
  7140 *-* /*    which will be executed later                    */
  7141 *-* /* if called with argument "new statement" we will    */
  7142 *-* /*    set stem SQLSTMT.0 = 0                          */
  7143 *-* /*    set stem SQLSTMT.startSQLcaller = sigl          */
  7144 *-* /* otherwise                                          */
  7145 *-* /*    we will increament SQLSTMT.0 and set next line  */
  7146 *-* /*    SQLSTMT.# to the callers argument               */
  7147 *-* /*    set stem SQLSTMT.lastSQLcaller = sigl           */
  7148 *-* parse upper arg sql1 sql2 ';' option '=' value .
  7149 *-* if sql1 sql2 = 'NEW STATEMENT'
  7150 *-*  then
       *-*  do
  7151 *-*   if option = 'STMT/CURSOR'
  7152 *-*    then
       *-*    do
  7153 *-*     if value = ''
  7154 *-*      then
       *-*      do
  7155 *-*       parse upper arg passedArgs
  7156 *-*       say 'invalid function call to SQL from' sigl
  7157 *-*       say 'args ='passedArgs
  7158 *-*       say 'but missing # for STMT/CURSOR option'
  7159 *-*       exit 12
  7160 *-*      end
  7161 *-*     if datatype(value,'W') = 0 ,                                             | value < 1 | value > 100
  7163 *-*      then
       *-*      do
  7164 *-*       parse upper arg passedArgs
  7165 *-*       say 'invalid function call to SQL from' sigl
  7166 *-*       say 'args ='passedArgs
  7167 *-*       say 'but STMT/CURSOR value "'value'" is invalid'
  7168 *-*       exit 12
  7169 *-*      end
  7170 *-*     sqlStmtValue = value
  7171 *-*    end
  7172 *-*   else
       *-*    if option <> ''
  7173 *-*     then
       *-*     do
  7174 *-*      parse upper arg passedArgs
  7175 *-*      say 'invalid function call to SQL from' sigl
  7176 *-*      say 'args ='passedArgs
  7177 *-*      say 'but option "'option'" after ";" is invalid'
  7178 *-*      say 'expected option "; STMT/CURSOR=#'
  7179 *-*      exit 12
  7180 *-*     end
  7181 *-*    else
       *-*     do
  7182 *-*      sqlStmtValue = 1 /* default stmt/cursor to use */
  7183 *-*     end
  7185 *-*   SQLSTMT.sqlStmtValue.0 = 0
  7186 *-*   SQLSTMT.sqlStmtValue.StartSQLcaller = sigl /* New Statement line*/
  7187 *-*   x = value('sqlStmt'SqlStmtValue'SiglIndx.',0)
  7188 *-*   return 0
  7189 *-*  end
  7190 *-* sqlstmt = sqlstmt.SqlStmtValue.0 + 1
  7191 *-* parse arg sqlStmtLine
  7192 *-* sqlstmt.SqlStmtValue.0 = sqlstmt
  7193 *-* sqlstmt.SqlStmtValue.sqlstmt = sqlStmtLine /* save sql code*/
  7195 *-* /*Note:                                   */
  7196 *-* /* sigl = callers line # (in rexx code)   */
  7197 *-* /* sqlstmt = line # of sql code (1 to n)  */
  7198 *-* /*                                        */
  7199 *-* /*Set :                                   */
  7200 *-* /* sqlStmt||sqlStmtValue||SiglIndx.sigl   = sqlstmt     */
  7201 *-* /*                                                      */
  7202 *-* /*Usage:                                                */
  7203 *-* /* which lines of rexx code actually used in sql stmt.  */
  7204 *-* /*                                                      */
  7206 *-* /* set it here */
  7207 *-* x = value('sqlstmt'sqlStmtValue'SiglIndx.'sigl,sqlStmt)
  7208 *-* sqlstmt.SqlStmtValue.LastSQLCaller = sigl    /* last call to sql: */
  7209 *-* return 0
  7211 *-* /* Get RACF information, so that we know (a lot), about the */
  7212 *-* /*    1) real users, that are currently active              */
  7213 *-* /*    2) real users, but that are revoked.                  */
  7214 *-* /*    3) users/groups that no longer exist.                 */
  7215 *-* /*    4) groups (and their members)                         */
  7216 *-* /* and write information out for our information.           */
  7217 *-* /* -------------------------------------------------------- */
  7218 *-* processRACFdata:
  7219 *-* /* read in our RACF summary */
  7220 *-* address TSO 'EXECIO 100 DISKR RACFSMRY (STEM RACFSMRY.'
  7221 *-* if rc <> 0
  7222 *-*  then
       *-*  do
  7223 *-*   say 'RACFSMRY dd not available; rc='rc
  7224 *-*   say 'we will just exit now with rc=8'
  7225 *-*   address tso 'EXECIO 0 DISKR RACFSMRY (FINIS'
  7226 *-*   exit 8
  7227 *-*  end
  7228 *-* racfsmryRc = rc
  7230 *-* racfsmryRc = 0
  7231 *-* racfsmry = 0 /* logical ptr into the RACFSMRY. buffer */
  7232 *-* group = 0
  7233 *-* groupIndx. = 0
  7234 *-* groupName. = ''
  7235 *-* groupDesc. = ''
  7236 *-* groupRef.  = 0
  7237 *-* userid = 0
  7238 *-* useridIndx. = 0
  7239 *-* userId.   = ''
  7240 *-* userRef.  = 0
  7241 *-* dateS = date('s')
  7242 *-* parse var dateS 1 yyyy 5 mm 7 dd
  7243 *-* currentDate = yyyy'-'mm'-'dd
  7245 *-* /* invent special userid's PUBLIC and *PUBLIC */
  7246 *-* racfUserid = 'PUBLIC'
  7247 *-* revoke     = 'NO'
  7248 *-* usersName  = ''
  7249 *-* usersDefaultGroup = ''
  7250 *-* usersLastDate = ''
  7251 *-* usersLastTime = ''
  7252 *-* /* add "user" PUBLIC */
  7253 *-* userid = userid + 1
  7254 *-* useridIndx.racfUserid = userid
  7255 *-* userid.userid = racfUserid
  7256 *-* revoked.userid= revoke
  7257 *-* usersName.userid = usersName
  7258 *-* usersDGroup.userid = usersDefaultGroup
  7259 *-* usersGroups.userid = 0  /* collect user groups with 0205's*/
  7260 *-* usersLastDate.userid = usersLastDate
  7261 *-* usersLastTime.userid = usersLastTime
  7263 *-* do forever /* process all logical recs in RACFSMRY. buffers */
  7264 *-*  racfsmry = racfsmry + 1 /* get next logical record */
  7265 *-*  if racfsmry > racfsmry.0 /* need another buffer? */
  7266 *-*   then
       *-*   do /* yes, get another buffer */
  7267 *-*    if racfsmryRc <> 0
  7268 *-*     then
       *-*     leave /* either we working on last buffer, or bad rc */
  7269 *-*    address tso 'EXECIO 100 DISKR RACFSMRY (STEM RACFSMRY.'
  7270 *-*    racfsmryRc = rc
  7271 *-*    racfsmry = 0 /* reset logical buffer pointer */
  7272 *-*    iterate
  7273 *-*   end
  7274 *-*   /* we have a good racfsmry pointer into the buffer */
  7275 *-*  parse var racfsmry.racfsmry ,                                              1 racftype ,
                            5 .
  7278 *-*  if racftype = '0100' /* we need to look at a racf group */
  7279 *-*   then
       *-*   do
  7280 *-*    parse var racfsmry.racfsmry ,                                              . /* ignore first word, it's 0100 */ ,
                              groupName superGrpName createDate groupOwner groupUacc . ,              58 groupDesc 313 . 314 groupM
odel groupUniversal .
  7284 *-*    if groupIndx.groupname = 0 /* they are all unique, but check*/
  7285 *-*     then
       *-*     do /* unknown, add to rexx stems */
  7287 *-*      /* change single to double single quotes in GroupDesc */
  7288 *-*      groupDesc = strip(groupDesc)
  7289 *-*      if pos("'",GroupDesc) > 0
  7290 *-*       then
       *-*       do /* change single to double single quotes */
  7291 *-*        parse var GroupDesc GroupDesc "'" rest
  7292 *-*        do forever
  7293 *-*         GroupDesc = GroupDesc"''"
  7294 *-*         if left(rest,1) = "'"
  7295 *-*          then
       *-*          rest = substr(rest,2) /* double single quotes*/
  7296 *-*         if rest = ''
       *-*          then
       *-*          leave
  7297 *-*         if pos("'",rest) = 0
  7298 *-*          then
       *-*          do
  7299 *-*           groupdesc= GroupDesc || rest
  7300 *-*           leave
  7301 *-*          end
  7302 *-*         parse var rest leftside "'" rest
  7303 *-*         GroupDesc = GroupDesc || leftside
  7304 *-*         iterate
  7305 *-*        end
  7306 *-*       end
  7308 *-*       /* now remember some information about the group */
  7309 *-*      group = group + 1 /* it's a new group */
  7310 *-*      groupIndx.groupName = group /* update index, to find us */
  7311 *-*      groupName.group = groupName /* groupname.# = groupname  */
  7312 *-*      /* save details, in case we want to know later */
  7313 *-*      superGrpName.group = SuperGrpname
  7314 *-*      groupCreateDate.group = createDate
  7315 *-*      groupOwner.group      = groupOwner
  7316 *-*      groupUacc.group       = groupUacc
  7317 *-*      groupDesc.group       = strip(groupDesc)
  7318 *-*      groupModel.group      = strip(groupModel)
  7319 *-*      groupUniversal.group  = groupUniversal
  7320 *-*      groupMembers.group    = ''
  7321 *-*      groupMembersStatus.group = ''
  7322 *-*     end
  7323 *-*    else
       *-*     nop /* this will never happen, just documenting */
  7324 *-*   end
  7326 *-*  else
       *-*   if racftype = '0200' /* we are looking at a user record */
  7327 *-*    then
       *-*    do /* handle type 0200 "user basic data record (0200)   */
  7328 *-*     /* these are really big... here we will just ignore a lot */
  7329 *-*     /* of the 0200 record                                     */
  7330 *-*     parse var racfsmry.racfsmry ,                                              . /* ignore first word, it's 0200 */ ,
                               racfUserid ,                                                            userCreateDate ,
                                            UseridOwner    ,                                                        . /* let's igno
re stuff for a while */ ,                                50 revoke ,                                                             54
 . /* ignore some more */ ,                                           75 usersName ,
           96 UsersDefaultGroup ,                                                 105 UsersLastTime ,
                           UsersLastDate ,                                                     124 . /* ignore some more */ ,
                                    458 usersRevokeDate ,                                                   469 usersResumedate ,
                                                 480 .
  7347 *-*     /* according to RACF, revoke setting is meaningless */
  7348 *-*     /* ... and dates are what is important.             */
  7349 *-*     if      usersRevokeDate = ''
  7350 *-*      then
       *-*      revoke = 'No' /* no revoke date = no revoke */
  7353 *-*     else
       *-*      if usersResumeDate = '' /* no intention to resume */
  7354 *-*       then
       *-*       do /* either Revoke "pending" or Revoked "now"   */
  7355 *-*        if currentDate < usersRevokeDate
  7356 *-*         then
       *-*         revoke = 'Pending'
  7357 *-*        else
       *-*         revoke = 'Yes'
  7358 *-*       end
  7360 *-*      else
       *-*       do
  7361 *-*        /* dates are NOT null, figure it out */
  7363 *-*        /* we have two dates (revoke and resume) */
  7364 *-*        if currentDate >= usersResumedate
  7365 *-*         then
       *-*         ResumeNow = 1 /* resume time has come */
  7366 *-*        else
       *-*         ResumeNow = 0 /* ... not yet          */
  7368 *-*        if currentDate >= usersRevokeDate
  7369 *-*         then
       *-*         RevokeNow = 1 /* revoke time has come */
  7370 *-*        else
       *-*         revokeNow = 0 /* ...not yet           */
  7372 *-*        /* check resumedNow and RevokeNow and dates */
  7373 *-*        /* ---------------------------------------- */
  7374 *-*        if revokeNow = 0        /* revoke in future? */
  7375 *-*         then
       *-*         revoke = 'Pending' /* yes, revoke is pending */
  7377 *-*        else
       *-*         if revokeNow = 1 ,  /* revoke now            */                          & resumeNow = 0    /* but resume in fut
ure? */
  7379 *-*          then
       *-*          revoke = 'Yes'      /* ...yeah, we're revoked*/
  7381 *-*         else
       *-*          do /* revokeNow = 1 and resumeNow = 1*/
  7382 *-*           /* time to revoke or resume user, check dates */
  7383 *-*           if usersResumeDate > usersRevokeDate
  7384 *-*            then
       *-*            revoke = 'No' /* resumed... (revoke meaningless)*/
  7385 *-*           else
       *-*            revoke = 'Yes'/* revoked... (resume meaningless)*/
  7386 *-*          end
  7388 *-*       end
  7389 *-*     /* revoke has been set to "Yes", "No" or "Pending" */
  7391 *-*     /* change single quote to double single quotes in usersName */
  7392 *-*     if pos("'",usersName) > 0
  7393 *-*      then
       *-*      do /* change single to double single quotes */
  7394 *-*       parse var usersname usersName "'" rest
  7395 *-*       do forever
  7396 *-*        usersName = usersName"''"
  7397 *-*        if left(rest,1) = "'"
  7398 *-*         then
       *-*         rest = substr(rest,2) /* already double single ' */
  7399 *-*        if rest = ''
       *-*         then
       *-*         leave
  7400 *-*        if pos("'",rest) = 0
  7401 *-*         then
       *-*         do
  7402 *-*          username = usersname || rest
  7403 *-*          leave
  7404 *-*         end
  7405 *-*        parse var rest leftside "'" rest
  7406 *-*        usersName = usersName || leftside
  7407 *-*        iterate
  7408 *-*       end
  7409 *-*      end
  7411 *-*      /* now remember some information about the user */
  7412 *-*     userid = userid + 1
  7413 *-*     useridIndx.racfUserid = userid
  7414 *-*     userid.userid = racfUserid
  7415 *-*     revoked.userid= revoke
  7416 *-*     usersName.userid = usersName
  7417 *-*     usersDGroup.userid = usersDefaultGroup
  7418 *-*     usersGroups.userid = 0  /* collect user groups with 0205's*/
  7419 *-*     usersLastDate.userid = usersLastDate
  7420 *-*     usersLastTime.userid = usersLastTime
  7421 *-*    end
  7423 *-*   else
       *-*    if racftype = '0205' /* looking at user (group) connect */
  7424 *-*     then
       *-*     do
  7425 *-*      /* these are really big... here we will just ignore a lot */
  7426 *-*      /* of the 0200 record                                     */
  7427 *-*      parse var racfsmry.racfsmry ,                                              . /* ignore first word, it's 0200 */ ,
                                racfUserid ,                                                            racfGroup ,
                                             racfConnectedDate ,                                                     racfGroupOwner
 ,                                                        . ,                                                                     r
acfLastConnectDate ,                                                   . ,
            109 . ,                                                                 racfGroupRevokeDate ,
                         racfGroupResumeDate ,                                                   .
  7441 *-*      uidx = useridIndx.racfUserid
  7442 *-*      /* according to RACF, revoke setting is meaningless */
  7443 *-*      /* ... and dates are what is important.             */
  7444 *-*      if      racfGroupRevokeDate = ''
  7445 *-*       then
       *-*       revoke = 'No' /* no revoke date = no revoke */
  7448 *-*      else
       *-*       if racfGroupResumeDate = '' /* no intention to resume */
  7449 *-*        then
       *-*        do /* either Revoke "pending" or Revoked "now"   */
  7450 *-*         if currentDate < racfGroupRevokeDate
  7451 *-*          then
       *-*          revoke = 'Pending'
  7452 *-*         else
       *-*          revoke = 'Yes'
  7453 *-*        end
  7455 *-*       else
       *-*        do
  7456 *-*         /* dates are NOT null, figure it out */
  7458 *-*         /* we have two dates (revoke and resume) */
  7459 *-*         if currentDate >= racfGroupResumeDate
  7460 *-*          then
       *-*          ResumeNow = 1 /* resume time has come */
  7461 *-*         else
       *-*          ResumeNow = 0 /* ... not yet          */
  7463 *-*         if currentDate >= racfGroupRevokeDate
  7464 *-*          then
       *-*          RevokeNow = 1 /* revoke time has come */
  7465 *-*         else
       *-*          revokeNow = 0 /* ...not yet           */
  7467 *-*         /* check resumedNow and RevokeNow and dates */
  7468 *-*         /* ---------------------------------------- */
  7469 *-*         if revokeNow = 0        /* revoke in future? */
  7470 *-*          then
       *-*          revoke = 'Pending' /* yes, revoke is pending */
  7472 *-*         else
       *-*          if revokeNow = 1 ,  /* revoke now            */                          & resumeNow = 0    /* but resume in fu
ture? */
  7474 *-*           then
       *-*           revoke = 'Yes'      /* ...yeah, we're revoked*/
  7476 *-*          else
       *-*           do /* revokeNow = 1 and resumeNow = 1*/
  7477 *-*            /* time to revoke or resume user, check dates */
  7478 *-*            if racfGroupResumeDate > racfGroupRevokeDate
  7479 *-*             then
       *-*             revoke = 'No' /* resumed... (revoke meaningless)*/
  7480 *-*            else
       *-*             revoke = 'Yes'/* revoked... (resume meaningless)*/
  7481 *-*           end
  7483 *-*        end
  7484 *-*      /* revoke has been set to "Yes", "No" or "Pending" */
  7486 *-*      /* now add user to this group */
  7487 *-*      groupIndx = groupIndx.racfGroup /* find index to group */
  7488 *-*      if groupIndx <> 0
  7489 *-*       then
       *-*       do /* if group exists, add member info */
  7490 *-*        groupMembers.groupIndx = groupMembers.GroupIndx racfUserid
  7491 *-*        groupMembersStatus.groupIndx = ,                                                               groupMembersStatus
.groupIndx revoke
  7493 *-*       end
  7494 *-*     end
  7495 *-* end
  7497 *-* if racfsmryRc <> 2
  7498 *-*  then
       *-*  do
  7499 *-*   say 'EXECIO to read from RACFSMRY failed with rc='rc
  7500 *-*   say 'will exit rc=8'
  7501 *-*   address 'TSO' 'EXECIO 0 DISKR RACFSMRY (FINIS'
  7502 *-*   exit 8
  7503 *-*  end
  7504 *-* address 'TSO' 'EXECIO 0 DISKR RACFSMRY (FINIS'
  7505 *-* userid.0 = userid
  7506 *-* say ' '
  7507 *-* say 'ProcessRACFdata routine has found:'
  7508 *-* say '   # of RACF userids = 'userid
  7509 *-* say '   # of RACF groups  = 'group
  7510 *-* say '   These will be important as we look at db2 grants'
  7511 *-* say ' '
  7512 *-* if userid.0 = 0 & group = 0
  7513 *-*  then
       *-*  do
  7514 *-*   say 'With zero userid and/or group information, this output'
  7515 *-*   say 'will be missing valuable RACF permits, etc.'
  7516 *-*  end
  7517 *-* return
  7519 *-* ShowRowCount:
  7520 *-* if sqlOption <> 'SQL'
  7521 *-*  then
       *-*  return
  7523 *-* x = clistcard(' ')
  7525 *-* cmd = '    /* rowsReturned =' rowsReturned '*/'
  7526 *-* x = clistcard(cmd)
  7528 *-* cmd = '    /* --------------' RowsReturned '*/'
  7529 *-* x = clistcard(cmd)
  7531 *-* x = clistcard(' ')
  7532 *-* return
  7534 *-* ShowRowCount2:
  7535 *-* if sqlOption <> 'SQL'
  7536 *-*  then
       *-*  return
  7538 *-* x = clistcard(' ')
  7540 *-* cmd = '    /* rowsReturnedC2 =' rowsReturnedC2 '*/'
  7541 *-* x = clistcard(cmd)
  7543 *-* cmd = '    /* ----------------' rowsReturnedC2 '*/'
  7544 *-* x = clistcard(cmd)
  7546 *-* x = clistcard(' ')
  7547 *-* return
READY
END


 ------------ now xreference begins -----------------------
 ------------ now xreference begins -----------------------


    xref (1 of 2) section 1 is for variables (not stem.'s)
    xref (1 of 2) section 1 is for variables (not stem.'s)
    ----------------------------------------------------------

       variables/labels are in "upperCase" if variable was never
                       assigned a value.

                        they are in "lowercase", otherwise.

       variables/stems set via a command, like EXECIO for
                       example, where the stem is within quotes
                       will not be shown in the xref as either
                       an assignment or a reference.

       Note special variables like:  RC, SIGL, can be assigned
                       values explictly.  But rexx can set them
                       as well implicitly.  Implicit assignments
                       are not in the xref.
    ----------------------------------------------------------



Variable (set w/rexx)   access                         Assigned : 2003 3777 5894 6122 6390
Variable (used in/rexx) access                         Reference: 2004 3778 5899 6127 6395

Label (internal label)  ADDEXCLUDE                     Defined  : 7041
Label (int. label ref)  ADDEXCLUDE                     Reference: F(913)

Address Envir.Constant: ADDRESS 'DSNREXX' <cmd>        Reference: 888 1574 1664 1704 1780 1797 1877 1904 1933 1953 1995 2011 2093 2104 2154 2206
                        ...                                       2333 2396 2478 2606 2701 2835 2974 3082 3632 3656 3684 3704 3763 3785 3881 3882
                        ...                                       3906 3928 3929 3949 3988 3990 4014 4093 4147 4228 4249 4389 4486 4517 4539 4601
                        ...                                       4622 4667 4681 4755 4791 4877 4931 5022 5040 5068 5074 5134 5156 5220 5256 5302
                        ...                                       5321 5386 5422 5468 5486 5554 5590 5640 5661 5737 5758 5802 5820 5836 5850 5889
                        ...                                       5906 5941 5960 5996 6012 6115 6134 6227 6279 6383 6402 6419 6563 6567

Address Envir.Constant: ADDRESS 'TSO'                  Reference: 887

Address Envir.Constant: ADDRESS 'TSO' <cmd>            Reference: 558 870 898 960 966 972 978 984 990 996 1002 1011 1017 1023 1029 1035 1041 1047
                        ...                                       1053 1057 1288 1465 1515 1553 1566 3286 6482 6684 6934 7220 7225 7269 7501 7504

Variable (set w/rexx)   adminclass                     Assigned : 1108
Variable (used in/rexx) adminclass                     Reference: 1117 1125 1131 1134

Variable (set w/rexx)   allprivs                       Assigned : 3187 3191 3305 3373 3376 3405 3494
Variable (used in/rexx) allprivs                       Reference: 3189 3199 3200 3203 3215 3229 3242 3306 3333 3372 3373 3375 3376 3406 3408 3493
                        ...                                       3494

Variable (set w/rexx)   allpublic                      Assigned : 1662 1673
Variable (used in/rexx) allpublic                      Reference: 1675

Built-In+/External use  ARG                            Reference: F(6583) F(7109) F(7110) F(7111)

Variable (set w/rexx)   auditing                       Assigned : 2707
Variable (used in/rexx) auditing                       Reference: 2515 2546 2567 2586 2731 2752 2766 2779 2810

Variable (set w/rexx)   auth                           Assigned : 1582 1825 2023 3530 3813 4023 4270 4815 5049 5166 5330 5495 5915 6151
Variable (used in/rexx) auth                           Reference: 1598 1599 1601 1669 1670 1678 1680 1785 1786 1842 1843 1846 1848 1881 1882 1885
                        ...                                       1888 1938 1941 1943 1944 2000 2001 2040 2042 2052 2054 2062 2212 2222 2226 2232
                        ...                                       2234 2249 2251 2262 2268 2283 2287 2298 2302 2353 2355 2424 2442 2447 2451 2461
                        ...                                       2465 2489 2510 2516 2518 2521 2527 2541 2547 2549 2562 2568 2569 2581 2587 2588
                        ...                                       2635 2665 2670 2674 2684 2688 2711 2728 2733 2736 2749 2754 2763 2768 2776 2781
                        ...                                       2843 2924 2928 2932 2946 2950 2963 3014 3030 3038 3089 3100 3107 3130 3145 3157
                        ...                                       3196 3329 3330 3335 3344 3357 3365 3418 3429 3434 3441 3452 3463 3473 3540 3546
                        ...                                       3561 3563 3574 3576 3592 3641 3773 3796 3802 3838 3839 3890 3891 3938 3939 3941
                        ...                                       4002 4003 4039 4040 4103 4104 4106 4116 4117 4122 4237 4238 4294 4296 4411 4413
                        ...                                       4465 4467 4523 4524 4526 4607 4608 4610 4770 4771 4781 4782 4830 4831 4833 4884
                        ...                                       4885 4904 4905 4918 5027 5028 5030 5050 5051 5084 5092 5138 5145 5167 5168 5180
                        ...                                       5183 5184 5227 5228 5233 5238 5310 5311 5331 5332 5345 5346 5348 5393 5394 5399
                        ...                                       5404 5475 5476 5496 5497 5510 5511 5513 5561 5562 5567 5572 5648 5649 5745 5746
                        ...                                       5945 5946 5948 6000 6001 6003 6124 6125 6163 6164 6166 6234 6235 6254 6255 6392
                        ...                                       6393
Variable (in Stem Set)  auth                           Assigned : 3063
Variable (in Stem Ref)  auth                           Reference: 3063 3185 3186 3303 3304 3403 3404

Variable (set w/rexx)   backhalf                       Assigned : 6751 6957
Variable (used in/rexx) backhalf                       Reference: 6762 6968

Label (internal label)  BINDAGENT                      Defined  : 5763
Label (int. label ref)  BINDAGENT                      Reference: C(1153)

Built-In+/External use  BITXOR                         Reference: F(3207)

Label (internal label)  BP_USE_PRIV                    Defined  : 4019
Label (int. label ref)  BP_USE_PRIV                    Reference: C(1234)

Variable (set w/rexx)   ccdata                         Assigned : 6708 6792 6793 6804 6805 6810 6811 6816 6817 6954 6983 6984 6995 6996 7001 7002
                        ...                                       7007 7008
Variable (used in/rexx) ccdata                         Reference: 6793 6805 6811 6817 6864 6929 6984 6996 7002 7008 7028

Label (internal label)  CHANGESTR                      Defined  : 7105
Label (int. label ref)  CHANGESTR                      Reference: F(5669) F(6064)

Variable (set w/rexx)   charopt                        Assigned : 788 794 847
Variable (used in/rexx) charopt                        Reference: 853 857 863 944 1105 1106 1147 1148 1251 1252 1261 1262 1272 1273 1278 1279
                        ...                                       1583 1584 1826 1827 2026 2027 3533 3534 3814 3815 4024 4025 4271 4272 4817 4818

Variable (set w/rexx)   chaystackparm2                 Assigned : 7110
Variable (used in/rexx) chaystackparm2                 Reference: 7113 7117

Variable (set w/rexx)   class                          Assigned : 1105 1106 1117 1125 1131 1134 1147 1148 1251 1252 1261 1262 1272 1273 1278 1279
                        ...                                       1583 1584 1826 1827 2026 2027 3533 3534 3814 3815 4024 4025 4271 4272 4817 4818
                        ...                                       6853 6890 6921
Variable (used in/rexx) class                          Reference: 1108 1591 1603 1692 1697 1789 1834 1851 1892 1897 1946 2004 2031 2237 2253 2358
                        ...                                       2364 2593 2599 2792 2797 3049 3097 3121 3335 3340 3344 3349 3353 3386 3388 3429
                        ...                                       3434 3441 3447 3452 3458 3463 3469 3473 3479 3485 3506 3508 3538 3595 3644 3649
                        ...                                       3696 3778 3819 3845 3893 3898 3941 4005 4029 4043 4106 4122 4132 4139 4240 4283
                        ...                                       4299 4416 4422 4470 4476 4526 4532 4610 4615 4775 4784 4822 4833 4887 4892 4910
                        ...                                       4918 4924 5031 5055 5084 5092 5099 5139 5141 5172 5187 5243 5248 5313 5336 5351
                        ...                                       5409 5414 5478 5501 5516 5577 5582 5652 5749 5770 5778 5808 5813 5842 5899 5919
                        ...                                       5948 5953 6003 6127 6155 6166 6237 6242 6260 6266 6272 6395 6857 6870 6894 6906
                        ...                                       6925 7028

Variable (set w/rexx)   classindx                      Assigned : 6782
Variable (in Stem Set)  classindx                      Assigned : 6784
Variable (in Stem Ref)  classindx                      Reference: 6784

Variable (set w/rexx)   classlist                      Assigned : 1061 6778
Variable (used in/rexx) classlist                      Reference: 1449 6778 6780
Variable (in Stem Set)  classlist                      Assigned : 6779

Variable (set w/rexx)   classmnt                       Assigned : 788 792 1100
Variable (used in/rexx) classmnt                       Reference: 792 794 810 813 821 845 943 1100 1106 1148 1252 1262 1273 1279 1584 1827 2027
                        ...                                       3534 3815 4025 4272 4818

Variable (set w/rexx)   classnum                       Assigned : 1449
Variable (in Stem Ref)  classnum                       Reference: 1453 1456 1459

Variable (set w/rexx)   clistcard                      Assigned : 6707 6717 6762 6803 6810 6815 6953 6968 6994 7001 7006
Variable (used in/rexx) clistcard                      Reference: 6710 6712 6716 6717 6719 6722 6724 6727 6749 6751 6772 6787 6795 6803 6810 6815
                        ...                                       6825 6826 6827 6834 6870 6906 6955 6957 6978 6986 6994 7001 7006 7014 7015 7016
                        ...                                       7020 7028
Label (internal label)  CLISTCARD                      Defined  : 6693
Label (int. label ref)  CLISTCARD                      Reference: F(1596) F(1606) F(1695) F(1698) F(1790) F(1838) F(1840) F(1854) F(1895) F(1898)
                        ...                                       F(1947) F(2005) F(2037) F(2039) F(2041) F(2043) F(2045) F(2049) F(2051) F(2053)
                        ...                                       F(2055) F(2057) F(2075) F(2077) F(2079) F(2080) F(2110) F(2112) F(2114) F(2115)
                        ...                                       F(2211) F(2213) F(2214) F(2221) F(2223) F(2224) F(2240) F(2242) F(2256) F(2258)
                        ...                                       F(2267) F(2269) F(2270) F(2357) F(2362) F(2365) F(2423) F(2425) F(2427) F(2429)
                        ...                                       F(2430) F(2592) F(2597) F(2600) F(2634) F(2636) F(2638) F(2640) F(2642) F(2644)
                        ...                                       F(2646) F(2648) F(2650) F(2651) F(2653) F(2795) F(2798) F(2842) F(2844) F(2846)
                        ...                                       F(2848) F(2850) F(2852) F(2854) F(2856) F(2858) F(2859) F(3050) F(3099) F(3101)
                        ...                                       F(3102) F(3106) F(3108) F(3109) F(3123) F(3125) F(3127) F(3129) F(3131) F(3133)
                        ...                                       F(3134) F(3138) F(3140) F(3142) F(3144) F(3146) F(3148) F(3149) F(3326) F(3338)
                        ...                                       F(3341) F(3347) F(3350) F(3359) F(3360) F(3367) F(3368) F(3390) F(3445) F(3448)
                        ...                                       F(3456) F(3459) F(3467) F(3470) F(3477) F(3480) F(3483) F(3486) F(3510) F(3558)
                        ...                                       F(3560) F(3562) F(3564) F(3566) F(3571) F(3573) F(3575) F(3577) F(3579) F(3586)
                        ...                                       F(3588) F(3598) F(3599) F(3607) F(3609) F(3647) F(3650) F(3660) F(3662) F(3698)
                        ...                                       F(3727) F(3729) F(3779) F(3795) F(3797) F(3798) F(3801) F(3803) F(3804) F(3823)
                        ...                                       F(3825) F(3848) F(3849) F(3896) F(3899) F(3943) F(4008) F(4033) F(4035) F(4046)
                        ...                                       F(4047) F(4108) F(4137) F(4140) F(4243) F(4288) F(4290) F(4298) F(4302) F(4303)
                        ...                                       F(4327) F(4415) F(4420) F(4423) F(4469) F(4474) F(4477) F(4498) F(4530) F(4533)
                        ...                                       F(4547) F(4613) F(4616) F(4633) F(4685) F(4777) F(4785) F(4826) F(4828) F(4836)
                        ...                                       F(4837) F(4890) F(4893) F(4913) F(4921) F(4925) F(5034) F(5086) F(5094) F(5100)
                        ...                                       F(5143) F(5176) F(5178) F(5190) F(5246) F(5249) F(5315) F(5340) F(5342) F(5354)
                        ...                                       F(5355) F(5412) F(5415) F(5480) F(5505) F(5507) F(5519) F(5520) F(5580) F(5583)
                        ...                                       F(5654) F(5751) F(5773) F(5781) F(5811) F(5814) F(5844) F(5900) F(5951) F(5954)
                        ...                                       F(6006) F(6128) F(6159) F(6161) F(6169) F(6170) F(6240) F(6243) F(6263) F(6269)
                        ...                                       F(6273) F(6396) F(6509) F(6510) F(6512) F(6517) F(6520) F(6521) F(6527) F(6528)
                        ...                                       F(6530) F(6546) F(6549) F(6552) F(6553) F(7523) F(7526) F(7529) F(7531) F(7538)
                        ...                                       F(7541) F(7544) F(7546)

Variable (set w/rexx)   clistx                         Assigned : 1065 6823 6832 6848 6856 6860 6868 6885 6893 6897 6904 6916 6924 6928 6945
Variable (used in/rexx) clistx                         Reference: 6832 6848 6856 6860 6868 6885 6893 6897 6904 6916 6924 6928 6932 6934 6948
Variable (in Stem Set)  clistx                         Assigned : 6826 6831 6834 6840 6847 6849 6855 6857 6861 6867 6870 6877 6884 6886 6892 6894
                        ...                                       6898 6903 6906 6915 6917 6923 6925 6929
Variable (in Stem Ref)  clistx                         Reference: 6836 6838 6840 6841 6843 6845 6847 6851 6853 6855 6873 6875 6877 6878 6880 6882
                        ...                                       6884 6888 6890 6892 6909 6911 6913 6915 6919 6921 6923

Label (internal label)  CLTN_PRIV                      Defined  : 4801
Label (int. label ref)  CLTN_PRIV                      Reference: C(1228)

Variable (set w/rexx)   cmd                            Assigned : 1595 1603 1692 1697 1789 1839 1851 1892 1897 1946 2004 2038 2040 2042 2044 2050
                        ...                                       2052 2054 2056 2076 2078 2111 2113 2212 2222 2237 2253 2268 2358 2364 2424 2426
                        ...                                       2428 2593 2599 2635 2637 2639 2641 2643 2645 2647 2649 2652 2792 2797 2843 2845
                        ...                                       2847 2849 2851 2853 2855 2857 3049 3100 3107 3124 3126 3128 3130 3132 3139 3141
                        ...                                       3143 3145 3147 3325 3335 3340 3344 3349 3357 3365 3386 3388 3429 3434 3441 3447
                        ...                                       3452 3458 3463 3469 3473 3479 3485 3506 3508 3559 3561 3563 3565 3572 3574 3576
                        ...                                       3578 3587 3595 3608 3644 3649 3661 3696 3728 3778 3796 3802 3824 3845 3893 3898
                        ...                                       3941 4005 4034 4043 4106 4122 4129 4131 4132 4139 4240 4289 4299 4416 4422 4470
                        ...                                       4476 4526 4532 4610 4615 4775 4784 4827 4833 4887 4892 4901 4902 4910 4916 4917
                        ...                                       4918 4924 5031 5084 5092 5099 5139 5141 5177 5187 5243 5248 5313 5341 5351 5409
                        ...                                       5414 5478 5506 5516 5577 5582 5652 5749 5772 5778 5808 5813 5842 5899 5948 5953
                        ...                                       6003 6127 6160 6166 6237 6242 6251 6252 6260 6266 6272 6395 6504 6511 6516 6519
                        ...                                       6522 6529 6545 6548 6551 7525 7528 7540 7543
Variable (used in/rexx) cmd                            Reference: 1596 1606 1695 1698 1790 1840 1854 1895 1898 1947 2005 2039 2041 2043 2045 2051
                        ...                                       2053 2055 2057 2077 2079 2112 2114 2213 2223 2242 2258 2269 2362 2365 2425 2427
                        ...                                       2429 2597 2600 2636 2638 2640 2642 2644 2646 2648 2650 2651 2795 2798 2844 2846
                        ...                                       2848 2850 2852 2854 2856 2858 3050 3101 3108 3125 3127 3129 3131 3133 3140 3142
                        ...                                       3144 3146 3148 3326 3338 3341 3347 3350 3360 3368 3390 3445 3448 3456 3459 3467
                        ...                                       3470 3477 3480 3483 3486 3510 3560 3562 3564 3566 3573 3575 3577 3579 3588 3598
                        ...                                       3609 3647 3650 3662 3698 3729 3779 3797 3803 3825 3848 3896 3899 3943 4008 4035
                        ...                                       4046 4108 4132 4137 4140 4243 4290 4302 4420 4423 4474 4477 4530 4533 4613 4616
                        ...                                       4777 4785 4828 4836 4890 4893 4913 4918 4921 4925 5034 5086 5094 5100 5143 5178
                        ...                                       5190 5246 5249 5315 5342 5354 5412 5415 5480 5507 5519 5580 5583 5654 5751 5773
                        ...                                       5781 5811 5814 5844 5900 5951 5954 6006 6128 6161 6169 6240 6243 6260 6263 6266
                        ...                                       6269 6273 6396 6509 6512 6517 6520 6527 6530 6546 6549 6552 7526 7529 7541 7544

Variable (set w/rexx)   cmdx                           Assigned : 1689 1690
Variable (used in/rexx) cmdx                           Reference: 1692

Variable (set w/rexx)   cneedleparm1                   Assigned : 7109
Variable (used in/rexx) cneedleparm1                   Reference: 7116 7119 7125 7129 7131

Variable (set w/rexx)   col                            Assigned : 1582 1825 2023 4270 5049 5166 5330 5495 5915
Variable (used in/rexx) col                            Reference: 1614 1626 1637 1649 1721 1734 1748 1749 1763 1919 1970 2040 2042 2052 2054 2281
                        ...                                       2296 2322 2440 2459 2663 2682 2917 2919 2944 4344 4352 4370 4503 4552 4567 4578
                        ...                                       4585 4637 4653 4703 4718 4729 4736 5063 5112 5115 5198 5203 5209 5269 5275 5282
                        ...                                       5363 5368 5374 5436 5442 5449 5528 5534 5541 5606 5613 5680 5688 5699 5721 5722
                        ...                                       5971 5982 6025 6039 6049 6071 6085 6096

Label (internal label)  COLLAPSE_TAB_PRIVRH            Defined  : 3116
Label (int. label ref)  COLLAPSE_TAB_PRIVRH            Reference: C(3093)

Variable (set w/rexx)   collid                         Assigned : 4393 4520 4604 4671 4758
Variable (used in/rexx) collid                         Reference: 4393 4405 4409 4410 4413 4426 4432 4520 4523 4524 4526 4604 4607 4608 4671 4758
                        ...                                       4761 4763 4770 4771 4781 4782
Variable (in Stem Set)  collid                         Assigned : 4404 4673 4675
Variable (in Stem Ref)  collid                         Reference: 4395 4673 4674 4773 4774 4775

Variable (set w/rexx)   collidcomma                    Assigned : 4278 4407 4461
Variable (used in/rexx) collidcomma                    Reference: 4405 4459

Variable (set w/rexx)   colname                        Assigned : 3637 3689 3769
Variable (used in/rexx) colname                        Reference: 3637 3641 3689 3693 3769 3773

Variable (set w/rexx)   comm                           Assigned : 1318 1334 1352 1368 1382 1400 1413 1430 1457
Variable (used in/rexx) comm                           Reference: 1320 1336 1354 1370 1384 1402 1415 1433 1434 1459

Variable (set w/rexx)   commaparen                     Assigned : 905 7055
Variable (used in/rexx) commaparen                     Reference: 7054

Variable (NEVER SET)    COUNTX                         Not Assgn: EITHER used as upper case value OR set via cmd
Variable (used in/rexx) COUNTX                         Reference: 2342 2387 4434 4450

Variable (set w/rexx)   createdate                     Assigned : 7280
Variable (used in/rexx) createdate                     Reference: 7314

Variable (set w/rexx)   creator                        Assigned : 3162
Variable (in Stem Ref)  creator                        Reference: 3171

Variable (set w/rexx)   creatornumber                  Assigned : 2822
Variable (in Stem Set)  creatornumber                  Assigned : 2827
Variable (in Stem Ref)  creatornumber                  Reference: 2826 2827

Variable (set w/rexx)   creplacementparm3              Assigned : 7111
Variable (used in/rexx) creplacementparm3              Reference: 7123 7128

Variable (set w/rexx)   creturnvalue                   Assigned : 7114 7123 7128 7134
Variable (used in/rexx) creturnvalue                   Reference: 7123 7128 7134 7135

Variable (set w/rexx)   ctemphaystack                  Assigned : 7113 7125 7129
Variable (used in/rexx) ctemphaystack                  Reference: 7119 7123 7125 7129 7131 7134

Variable (set w/rexx)   currentdate                    Assigned : 7243
Variable (used in/rexx) currentdate                    Reference: 7355 7364 7368 7450 7459 7463

Variable (set w/rexx)   data                           Assigned : 2234 2251 2355 2516 2518 2547 2549 2568 2569 2587 2588 2732 2733 2753 2754 2767
                        ...                                       2768 2780 2781 4296 4413 4467 5180 5233 5238 5348 5399 5404 5513 5567 5572
Variable (used in/rexx) data                           Reference: 2237 2253 2358 2593 2792 4299 4416 4470 5187 5243 5351 5409 5516 5577

Variable (set w/rexx)   datacomment                    Assigned : 3999 4234 5030
Variable (used in/rexx) datacomment                    Reference: 4005 4240 5031

Built-In+/External use  DATATYPE                       Reference: F(6502) F(6594) F(7161)

Built-In+/External use  DATE                           Reference: F(945) F(3999) F(4234) F(7071) F(7241)

Variable (set w/rexx)   dates                          Assigned : 7241
Variable (used in/rexx) dates                          Reference: 7242

Label (internal label)  DB2_TO_RACF_CONVERSION         Defined  : 1089
Label (int. label ref)  DB2_TO_RACF_CONVERSION         Reference:

Variable (set w/rexx)   dbname                         Assigned : 2484 2504 2535 2556 2575 2725 2746 2760 2773 3332
Variable (used in/rexx) dbname                         Reference: 2484 2504 2535 2556 2575 2725 2746 2760 2773 3332

Variable (set w/rexx)   dbowner                        Assigned : 1587 1830 2506 2537 2558 2577
Variable (NEVER USED)   dbowner                        No Ref.  : If actually referenced, it must be via a cmd.

Label (internal label)  DB_ATTR                        Defined  : 5911
Label (int. label ref)  DB_ATTR                        Reference: C(1126) C(1132) C(1133)

Label (internal label)  DB_OPTION                      Defined  : 6139
Label (int. label ref)  DB_OPTION                      Reference:

Variable (set w/rexx)   dd                             Assigned : 7242
Variable (used in/rexx) dd                             Reference: 7243

Variable (set w/rexx)   ddname                         Assigned : 557 1287 6481 6683 6742 6745 6746
Variable (used in/rexx) ddname                         Reference: 558 561 1288 1292 6482 6485 6684 6687 6934 6938
Variable (in Stem Set)  ddname                         Assigned : 6826 6831 6834 6840 6847 6849 6855 6857 6861 6867 6870 6877 6884 6886 6892 6894
                        ...                                       6898 6903 6906 6915 6917 6923 6925 6929 6946 6948
Variable (in Stem Ref)  ddname                         Reference: 558 1288 6482 6684 6823 6836 6838 6840 6841 6843 6845 6847 6851 6853 6855 6873
                        ...                                       6875 6877 6878 6880 6882 6884 6888 6890 6892 6909 6911 6913 6915 6919 6921 6923

Label (internal label)  DEF_PRIV                       Defined  : 1802
Label (int. label ref)  DEF_PRIV                       Reference: C(1199) C(1200) C(1201) C(1202) C(1203) C(1204) C(1205) C(1206) C(1207) C(1208)
                        ...                                       C(1209) C(1210) C(1214) C(1215)

Variable (NEVER SET)    DISETS                         Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Ref)  DISETS                         Reference: 2198 2200

Label (internal label)  END_OF_STARTUP                 Defined  : 1078
Label (int. label ref)  END_OF_STARTUP                 Reference:

Built-In+/External use  ERRORTEXT                      Reference: F(542)

Variable (set w/rexx)   err_sw                         Assigned : 6424 6492 6575
Variable (NEVER USED)   err_sw                         No Ref.  : If actually referenced, it must be via a cmd.

Variable (set w/rexx)   exclist                        Assigned : 907
Variable (in Stem Ref)  exclist                        Reference: 908 913

Variable (set w/rexx)   exclude                        Assigned : 893 7046
Variable (used in/rexx) exclude                        Reference: 947 7046 7049
Variable (in Stem Set)  exclude                        Assigned : 7047 7048

Variable (set w/rexx)   excludeid                      Assigned : 7045
Variable (used in/rexx) excludeid                      Reference: 7047 7054 7057
Variable (in Stem Set)  excludeid                      Assigned : 7049 7053

Variable (NEVER SET)    EXECNAME                       Not Assgn: EITHER used as upper case value OR set via cmd
Variable (used in/rexx) EXECNAME                       Reference: 542

Variable (set w/rexx)   extra                          Assigned : 1586 1601 1678 1680 1829 1846 1848 1885 1888 1938 1941 3828 3830 3832 3834 3835
                        ...                                       3854 3856 3858 3860 3861 4037
Variable (used in/rexx) extra                          Reference: 1603 1692 1851 1892 1946 3845 3893 4043

Built-In+/External use  FORMAT                         Reference: F(1459) F(3356) F(3364)

Variable (set w/rexx)   fronthalf                      Assigned : 6751 6957
Variable (used in/rexx) fronthalf                      Reference: 6762 6968

Variable (set w/rexx)   genericoption                  Assigned : 642 645 656
Variable (used in/rexx) genericoption                  Reference: 2262 2652 2706 3089

Variable (set w/rexx)   gensql                         Assigned : 6558 6560
Variable (used in/rexx) gensql                         Reference: 6560 6562

Variable (set w/rexx)   gix                            Assigned : 1418 7080
Variable (in Stem Set)  gix                            Assigned : 7081
Variable (in Stem Ref)  gix                            Reference: 1419 1420 7083

Variable (set w/rexx)   grantee                        Assigned : 1999 2339 2979 3382 3500 3775 3994 4232 4672 4760
Variable (used in/rexx) grantee                        Reference: 1789 1999 2004 2339 2373 2388 2979 2981 2983 2992 3000 3008 3045 3049 3063 3070
                        ...                                       3383 3386 3388 3502 3506 3508 3775 3778 3994 4005 4232 4240 4672 4675 4760 4784
                        ...                                       5031 5137 5139 5141 5148 5313 5478 5652 5749 5892 5899 6120 6127 6388 6395
Variable (in Stem Set)  grantee                        Assigned : 2991 2995 3007 3011 3069 3073 5149
Variable (in Stem Ref)  grantee                        Reference: 2985 2989 2995 3000 3005 3011 3067 3073

Variable (set w/rexx)   granteecase                    Assigned : 904 922 924 925 7057
Variable (used in/rexx) granteecase                    Reference: 921 924 925 1962 2914 5110 5267 5434 5604 5669 5860 6023 6064 7057

Variable (set w/rexx)   granteecasebb                  Assigned : 5669
Variable (used in/rexx) granteecasebb                  Reference: 5668 5675

Variable (set w/rexx)   granteecasef                   Assigned : 6064
Variable (used in/rexx) granteecasef                   Reference: 6063 6069

Variable (set w/rexx)   grantingeneric                 Assigned : 4674
Variable (in Stem Set)  grantingeneric                 Assigned : 4675

Variable (NEVER SET)    GRANTOR                        Not Assgn: EITHER used as upper case value OR set via cmd
Variable (used in/rexx) GRANTOR                        Reference: 5805 5806 5808 5839 5840 5842 5896 5897

Variable (set w/rexx)   group                          Assigned : 7232 7309
Variable (used in/rexx) group                          Reference: 7309 7310 7509 7512
Variable (in Stem Set)  group                          Assigned : 7311 7313 7314 7315 7316 7317 7318 7319 7320 7321

Variable (set w/rexx)   groupdesc                      Assigned : 7280 7288 7291 7293 7299 7303
Variable (used in/rexx) groupdesc                      Reference: 7288 7289 7291 7293 7299 7303 7317

Variable (set w/rexx)   groupid                        Assigned : 7045
Variable (used in/rexx) groupid                        Reference: 7048 7050 7057

Variable (set w/rexx)   groupindx                      Assigned : 7487
Variable (used in/rexx) groupindx                      Reference: 7488
Variable (in Stem Set)  groupindx                      Assigned : 7490 7491
Variable (in Stem Ref)  groupindx                      Reference: 7490 7491

Variable (set w/rexx)   groupmodel                     Assigned : 7280
Variable (used in/rexx) groupmodel                     Reference: 7318

Variable (set w/rexx)   groupname                      Assigned : 7280
Variable (used in/rexx) groupname                      Reference: 7311
Variable (in Stem Set)  groupname                      Assigned : 7310
Variable (in Stem Ref)  groupname                      Reference: 7284

Variable (set w/rexx)   groupowner                     Assigned : 7280
Variable (used in/rexx) groupowner                     Reference: 7315

Variable (set w/rexx)   groupuacc                      Assigned : 7280
Variable (used in/rexx) groupuacc                      Reference: 7316

Variable (set w/rexx)   groupuniversal                 Assigned : 7280
Variable (used in/rexx) groupuniversal                 Reference: 7319

Variable (set w/rexx)   gstatus                        Assigned : 1420 1429
Variable (used in/rexx) gstatus                        Reference: 1429

Variable (NEVER SET)    GTYPE                          Not Assgn: EITHER used as upper case value OR set via cmd
Variable (used in/rexx) GTYPE                          Reference: 5230 5396 5564

Label (internal label)  GV_ATTR                        Defined  : 5162
Label (int. label ref)  GV_ATTR                        Reference: C(1255) C(1256)

Variable (set w/rexx)   gw                             Assigned : 3276
Variable (used in/rexx) gw                             Reference: 3277 3280
Variable (in Stem Ref)  gw                             Reference: 3280

Variable (set w/rexx)   hashkey                        Assigned : 3200 3204 3207
Variable (used in/rexx) hashkey                        Reference: 3207
Variable (in Stem Set)  hashkey                        Assigned : 3218
Variable (in Stem Ref)  hashkey                        Reference: 3211 3227

Variable (set w/rexx)   hdr                            Assigned : 948
Variable (in Stem Set)  hdr                            Assigned : 949

Variable (set w/rexx)   i                              Assigned : 556 1286 6480 6682
Variable (in Stem Ref)  i                              Reference: 557 1287 6481 6683

Variable (set w/rexx)   i4                             Assigned : 4774
Variable (in Stem Ref)  i4                             Reference: 4775

Variable (set w/rexx)   ignorecollid                   Assigned : 4277 4405 4459 4492
Variable (used in/rexx) ignorecollid                   Reference: 4405 4459 4491 4492 4507 4509 4555 4557 4641 4643 4706 4708

Variable (set w/rexx)   ignoredtablegranteelist        Assigned : 1508 2066 2992
Variable (used in/rexx) ignoredtablegranteelist        Reference: 1501 1507 1508 2992

Variable (set w/rexx)   ii                             Assigned : 947 1306 1322 1340 1356 1372 1390 1408
Variable (used in/rexx) ii                             Reference: 948
Variable (in Stem Ref)  ii                             Reference: 949 1307 1320 1323 1336 1341 1354 1357 1370 1373 1384 1391 1402 1409

Variable (set w/rexx)   iii                            Assigned : 6515 6533 6559 6604 6618
Variable (used in/rexx) iii                            Reference: 6516 6538 6540 6545 6548 6605 6619 6621 6626 6628
Variable (in Stem Ref)  iii                            Reference: 6560

Variable (set w/rexx)   iiiend                         Assigned : 6514 6532 6603 6617
Variable (used in/rexx) iiiend                         Reference: 6515 6533 6604 6618

Variable (set w/rexx)   iiistart                       Assigned : 6513 6531 6602 6616
Variable (used in/rexx) iiistart                       Reference: 6515 6533 6604 6618

Variable (set w/rexx)   lastallpkgcount                Assigned : 4384
Variable (NEVER USED)   lastallpkgcount                No Ref.  : If actually referenced, it must be via a cmd.

Variable (set w/rexx)   lastallspeccount               Assigned : 4385 4434
Variable (used in/rexx) lastallspeccount               Reference: 4453

Variable (set w/rexx)   lastcollid                     Assigned : 4383 4432 4752 4763
Variable (used in/rexx) lastcollid                     Reference: 4426 4459 4463 4464 4467 4761
Variable (in Stem Set)  lastcollid                     Assigned : 4458

Variable (set w/rexx)   lastcount                      Assigned : 2149 2330 2387
Variable (used in/rexx) lastcount                      Reference: 2342 2369 2371 2380 2382 2402 2404

Variable (set w/rexx)   lastcreator                    Assigned : 2329 2386
Variable (used in/rexx) lastcreator                    Reference: 2340
Variable (in Stem Set)  lastcreator                    Assigned : 2370 2371 2381 2382 2403 2404

Variable (set w/rexx)   lastgrantee                    Assigned : 2373 2388
Variable (used in/rexx) lastgrantee                    Reference: 2378 2400

Variable (set w/rexx)   lastname                       Assigned : 4753 4764 4779
Variable (used in/rexx) lastname                       Reference: 4767

Variable (set w/rexx)   lastpkgcount                   Assigned : 4386 4450
Variable (used in/rexx) lastpkgcount                   Reference: 4453

Variable (NEVER SET)    LASTSQLCALLER                  Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  LASTSQLCALLER                  Assigned : 7208
Variable (in Stem Ref)  LASTSQLCALLER                  Reference: 6504 6514 6522 6532 6596 6603 6609 6617

Built-In+/External use  LEFT                           Reference: F(910) F(1320) F(1336) F(1354) F(1370) F(1384) F(1402) F(1415) F(1433) F(1434)
                        ...                                       F(1459) F(1602) F(1682) F(1788) F(1850) F(1891) F(1945) F(2002) F(2233) F(2250)
                        ...                                       F(2354) F(2505) F(2511) F(2536) F(2542) F(2557) F(2563) F(2576) F(2582) F(2729)
                        ...                                       F(2750) F(2764) F(2777) F(3031) F(3039) F(3331) F(3424) F(3593) F(3642) F(3695)
                        ...                                       F(3774) F(3843) F(3892) F(3940) F(4004) F(4041) F(4105) F(4118) F(4239) F(4295)
                        ...                                       F(4412) F(4466) F(4525) F(4609) F(4772) F(4783) F(4832) F(4886) F(4906) F(5029)
                        ...                                       F(5083) F(5091) F(5186) F(5242) F(5312) F(5350) F(5408) F(5477) F(5515) F(5576)
                        ...                                       F(5651) F(5748) F(5777) F(5807) F(5841) F(5898) F(5947) F(6002) F(6126) F(6165)
                        ...                                       F(6236) F(6256) F(6394) F(6543) F(6548) F(6624) F(6628) F(6712) F(6834) F(6849)
                        ...                                       F(6857) F(6861) F(6870) F(6886) F(6894) F(6898) F(6906) F(6917) F(6925) F(6929)
                        ...                                       F(7014) F(7020) F(7025) F(7028) F(7036) F(7069) F(7071) F(7074) F(7082) F(7100)
                        ...                                       F(7101) F(7123) F(7294) F(7397)

Variable (set w/rexx)   leftside                       Assigned : 7302 7405
Variable (used in/rexx) leftside                       Reference: 7303 7406

Built-In+/External use  LENGTH                         Reference: F(548) F(550) F(797) F(810) F(853) F(1445) F(1446) F(1602) F(1682) F(1788)
                        ...                                       F(1850) F(1891) F(1945) F(2002) F(2233) F(2250) F(2354) F(2511) F(2542) F(2563)
                        ...                                       F(2582) F(2729) F(2750) F(2764) F(2777) F(3031) F(3039) F(3199) F(3205) F(3331)
                        ...                                       F(3424) F(3593) F(3642) F(3695) F(3774) F(3843) F(3892) F(3940) F(4004) F(4041)
                        ...                                       F(4105) F(4118) F(4239) F(4295) F(4412) F(4466) F(4525) F(4609) F(4772) F(4783)
                        ...                                       F(4832) F(4886) F(4906) F(5029) F(5083) F(5091) F(5186) F(5242) F(5312) F(5350)
                        ...                                       F(5408) F(5477) F(5515) F(5576) F(5651) F(5748) F(5777) F(5807) F(5841) F(5898)
                        ...                                       F(5947) F(6002) F(6126) F(6165) F(6236) F(6256) F(6394) F(6470) F(6472) F(6542)
                        ...                                       F(6623) F(6671) F(6673) F(6841) F(6870) F(6878) F(6906) F(6909) F(7028) F(7069)
                        ...                                       F(7082) F(7100) F(7116) F(7125) F(7129)

Variable (set w/rexx)   longpriv                       Assigned : 3165 3214 3237
Variable (used in/rexx) longpriv                       Reference: 3214 3218 3237 3238
Variable (in Stem Set)  longpriv                       Assigned : 3215 3216 3217 3242 3243 3244

Built-In+/External use  MAX                            Reference: F(544) F(1602) F(1682) F(1788) F(1850) F(1891) F(1945) F(2002) F(2233) F(2250)
                        ...                                       F(2354) F(2511) F(2542) F(2563) F(2582) F(2729) F(2750) F(2764) F(2777) F(3031)
                        ...                                       F(3039) F(3331) F(3424) F(3593) F(3642) F(3695) F(3774) F(3843) F(3892) F(3940)
                        ...                                       F(4004) F(4041) F(4105) F(4118) F(4239) F(4295) F(4412) F(4466) F(4525) F(4609)
                        ...                                       F(4772) F(4783) F(4832) F(4886) F(4906) F(5029) F(5083) F(5091) F(5186) F(5242)
                        ...                                       F(5312) F(5350) F(5408) F(5477) F(5515) F(5576) F(5651) F(5748) F(5777) F(5807)
                        ...                                       F(5841) F(5898) F(5947) F(6002) F(6126) F(6165) F(6236) F(6256) F(6394) F(6466)
                        ...                                       F(6667) F(7069) F(7082) F(7100)

Variable (set w/rexx)   maxlong                        Assigned : 3168 3174 3221 3248 3257
Variable (used in/rexx) maxlong                        Reference: 3219 3246 3255 3308 3356 3357 3364 3365

Variable (set w/rexx)   maxlongindx                    Assigned : 3169 3222 3249 3258
Variable (used in/rexx) maxlongindx                    Reference: 3302

Variable (set w/rexx)   maxuidlength                   Assigned : 1443 1446
Variable (used in/rexx) maxuidlength                   Reference: 1445 1459

Variable (set w/rexx)   member                         Assigned : 1428
Variable (used in/rexx) member                         Reference: 1430 1433 1434

Variable (set w/rexx)   members                        Assigned : 1419 1428
Variable (used in/rexx) members                        Reference: 1421 1426 1428

Built-In+/External use  MIN                            Reference: F(545) F(6467) F(6668)

Variable (set w/rexx)   mm                             Assigned : 7242
Variable (used in/rexx) mm                             Reference: 7243

Variable (set w/rexx)   mmm                            Assigned : 6540 6621
Variable (in Stem Ref)  mmm                            Reference: 6541 6622

Variable (set w/rexx)   model                          Assigned : 788 793 1101
Variable (used in/rexx) model                          Reference: 793 794 827 830 837 845 943 1101 1105 1147 1251 1261 1272 1278 1583 1598 1669
                        ...                                       1785 1826 1842 1881 1943 2000 2026 2228 2245 2349 2502 2533 2554 2573 2721 2744
                        ...                                       2758 2771 3024 3034 3329 3533 3590 3639 3691 3771 3814 3841 3890 3938 4002 4024
                        ...                                       4039 4103 4116 4237 4271 4292 4409 4463 4523 4607 4770 4781 4817 4830 4884 4904
                        ...                                       5027 5050 5167 5182 5226 5309 5331 5344 5392 5474 5496 5509 5560 5647 5744 5775
                        ...                                       5805 5839 5896 5945 6000 6124 6163 6234 6254 6392

Variable (set w/rexx)   name                           Assigned : 1667 1783 1880 1936 1998 3885 3888 3932 3935 3993 3997 4096 4099 4231 4521 4605
                        ...                                       4759 4880 5025 5225 5307 5391 5473 5559 5645 5742 5944 5999 6118 6230 6386
Variable (used in/rexx) name                           Reference: 1667 1669 1670 1672 1678 1680 1688 1783 1785 1786 1880 1881 1882 1885 1888 1936
                        ...                                       1938 1941 1943 1944 1998 2000 2001 3885 3888 3890 3891 3932 3935 3938 3939 3941
                        ...                                       3993 3997 4002 4003 4096 4098 4101 4103 4104 4116 4117 4122 4130 4132 4231 4237
                        ...                                       4238 4521 4523 4524 4526 4605 4607 4608 4759 4767 4770 4771 4773 4779 4781 4782
                        ...                                       4880 4882 4884 4885 4902 4904 4905 4917 5025 5027 5028 5225 5227 5228 5233 5238
                        ...                                       5307 5310 5311 5391 5393 5394 5399 5404 5473 5475 5476 5559 5561 5562 5567 5572
                        ...                                       5645 5648 5649 5742 5745 5746 5944 5945 5946 5948 5999 6000 6001 6003 6118 6124
                        ...                                       6125 6230 6232 6234 6235 6252 6254 6255 6260 6266 6386 6392 6393

Variable (set w/rexx)   namex                          Assigned : 4394
Variable (used in/rexx) namex                          Reference: 4394 4398 4433

Variable (set w/rexx)   nextg                          Assigned : 1508 1547
Variable (used in/rexx) nextg                          Reference: 1510 1549
Variable (in Stem Ref)  nextg                          Reference: 1510

Variable (set w/rexx)   nextindx                       Assigned : 3228 3231
Variable (used in/rexx) nextindx                       Reference: 3229 3230 3234
Variable (in Stem Set)  nextindx                       Assigned : 3254
Variable (in Stem Ref)  nextindx                       Reference: 3229 3254 3255 3257

Variable (set w/rexx)   nextkey                        Assigned : 3206
Variable (used in/rexx) nextkey                        Reference: 3207

Variable (set w/rexx)   nextpriv                       Assigned : 3376 3494
Variable (used in/rexx) nextpriv                       Reference: 3377 3382 3495 3500

Variable (set w/rexx)   nw                             Assigned : 3275
Variable (used in/rexx) nw                             Reference: 3276

Variable (set w/rexx)   obtype                         Assigned : 3813 4023
Variable (used in/rexx) obtype                         Reference: 3827 3829 3831 3833 3837 3853 3855 3857 3859 3869 3874 3880 3888 3914 3919 3927
                        ...                                       3935 3961 3966 3987 3997 4163 4169 4193 4199 4205

Label (internal label)  ONELINESQL                     Defined  : 6407
Label (int. label ref)  ONELINESQL                     Reference: C(6496)

Variable (set w/rexx)   onelinesqlcode                 Assigned : 6418
Variable (used in/rexx) onelinesqlcode                 Reference: 6419 6434

Variable (set w/rexx)   opendds                        Assigned : 952 959 965 971 977 983 989 995 1001 1010 1016 1022 1028 1034 1040 1046 1052
Variable (used in/rexx) opendds                        Reference: 556 959 965 971 977 983 989 995 1001 1010 1016 1022 1028 1034 1040 1046 1052
                        ...                                       1286 6480 6682
Variable (in Stem Set)  opendds                        Assigned : 959 965 971 977 983 989 995 1001 1010 1016 1022 1028 1034 1040 1046 1052

Label (internal label)  OPTCLSTCARD                    Defined  : 6952
Label (int. label ref)  OPTCLSTCARD                    Reference:

Variable (set w/rexx)   optclstx                       Assigned : 1066 1300 1302 1304 1319 1335 1338 1353 1369 1383 1386 1388 1401 1404 1406 1414
                        ...                                       1423 1431 1438 1440 1450 1452 1458 1472 1479 1482 1485 1489 1492 1496 1498 1503
                        ...                                       1509 1522 1530 1533 1536 1542 1548 1560 3153 3156 3159 3179 3195 3272 3279 3293
                        ...                                       7013 7019 7024 7035
Variable (used in/rexx) optclstx                       Reference: 1300 1302 1304 1319 1335 1338 1353 1369 1383 1386 1388 1401 1404 1406 1414 1423
                        ...                                       1431 1438 1440 1450 1452 1458 1463 1465 1479 1482 1485 1489 1492 1496 1498 1503
                        ...                                       1509 1513 1515 1530 1533 1536 1542 1548 1551 1553 1566 3153 3156 3159 3179 3195
                        ...                                       3272 3279 3284 3286 7013 7019 7024 7035
Variable (in Stem Set)  optclstx                       Assigned : 1301 1303 1305 1320 1336 1339 1354 1370 1384 1387 1389 1402 1405 1407 1415 1424
                        ...                                       1433 1434 1439 1441 1451 1453 1459 1480 1483 1486 1490 1493 1497 1499 1504 1510
                        ...                                       1531 1534 1537 1543 1549 3154 3157 3160 3180 3196 3273 3280 7015 7018 7020 7023
                        ...                                       7025 7028 7034 7036
Variable (in Stem Ref)  optclstx                       Reference: 3176 7021 7023 7030 7034

Variable (set w/rexx)   option                         Assigned : 7148
Variable (used in/rexx) option                         Reference: 7151 7172 7177

Variable (set w/rexx)   optionsspecified               Assigned : 616 626 638 652 664 675 689 700 713 723 738 748 764 774
Variable (used in/rexx) optionsspecified               Reference: 780

Variable (set w/rexx)   optionwarn                     Assigned : 620 629
Variable (used in/rexx) optionwarn                     Reference: 6717

Variable (set w/rexx)   owner                          Assigned : 788
Variable (used in/rexx) owner                          Reference: 797 801 806 942 1067 1587 1603 1692 1830 1851 1892 2237 2253 2358 2593 2792
                        ...                                       3335 3344 3429 3434 3441 3452 3463 3473 3595 3644 3845 3893 4043 4122 4132 4299
                        ...                                       4416 4470 4526 4610 4833 4887 4910 4918 5084 5092 5187 5243 5351 5409 5516 5577
                        ...                                       5778 5808 5948 6166 6237 6260 6266

Label (internal label)  PACKADM_ATTR                   Defined  : 6147
Label (int. label ref)  PACKADM_ATTR                   Reference: C(1135)

Variable (set w/rexx)   packageowner                   Assigned : 2097
Variable (used in/rexx) packageowner                   Reference: 2097
Variable (in Stem Set)  packageowner                   Assigned : 2098

Variable (set w/rexx)   packagetablegranteelist        Assigned : 1547 2069 3008
Variable (used in/rexx) packagetablegranteelist        Reference: 1540 1546 1547 3008

Label (internal label)  PACK_PRIV                      Defined  : 4254
Label (int. label ref)  PACK_PRIV                      Reference: C(1219) C(1221) C(1223)

Variable (set w/rexx)   passedargs                     Assigned : 7155 7164 7174
Variable (used in/rexx) passedargs                     Reference: 7157 7166 7176

Variable (set w/rexx)   pastname                       Assigned : 5734
Variable (NEVER USED)   pastname                       No Ref.  : If actually referenced, it must be via a cmd.

Variable (set w/rexx)   pastschema                     Assigned : 5733
Variable (NEVER USED)   pastschema                     No Ref.  : If actually referenced, it must be via a cmd.

Variable (set w/rexx)   pe$class                       Assigned : 1007 1013 1019 1025 1031 1037 1043 1049
Variable (in Stem Set)  pe$class                       Assigned : 1014 1020 1026 1032 1038 1044 1050

Variable (set w/rexx)   pe$ddname                      Assigned : 1007 1013 1019 1025 1031 1037 1043 1049
Variable (used in/rexx) pe$ddname                      Reference: 1008 1010 1011 1014 1016 1017 1020 1022 1023 1026 1028 1029 1032 1034 1035 1038
                        ...                                       1040 1041 1044 1046 1047 1050 1052 1053
Variable (in Stem Set)  pe$ddname                      Assigned : 1009 1015 1021 1027 1033 1039 1045 1051

Variable (set w/rexx)   pendingrc                      Assigned : 574 578 583 588 593 600 607 1294 1470 1520 1558 1571 3291 6942
Variable (used in/rexx) pendingrc                      Reference: 610 1577 6939

Variable (set w/rexx)   peoption                       Assigned : 729 732 742
Variable (used in/rexx) peoption                       Reference: 750 6744

Variable (set w/rexx)   per                            Assigned : 3356 3364
Variable (used in/rexx) per                            Reference: 3357 3365

Built-In+/External use  POS                            Reference: F(853) F(6724) F(6749) F(6787) F(6795) F(6836) F(6843) F(6851) F(6873) F(6880)
                        ...                                       F(6888) F(6911) F(6919) F(6955) F(6978) F(6986) F(7119) F(7131) F(7289) F(7297)
                        ...                                       F(7392) F(7400)

Variable (set w/rexx)   prbl                           Assigned : 6464 6657 6659
Variable (used in/rexx) prbl                           Reference: 6466 6467 6469 6664 6667 6668 6670

Variable (set w/rexx)   previousviewcreator            Assigned : 2150 2187
Variable (used in/rexx) previousviewcreator            Reference: 2164

Variable (set w/rexx)   previousviewname               Assigned : 2151 2188
Variable (used in/rexx) previousviewname               Reference: 2164

Variable (set w/rexx)   priv                           Assigned : 3185 3303 3403
Variable (used in/rexx) priv                           Reference: 3187 3191 3305 3405

Variable (set w/rexx)   privauth                       Assigned : 3543 3549
Variable (used in/rexx) privauth                       Reference: 3595 3623 3644 3677 3748

Variable (set w/rexx)   privcols                       Assigned : 3542 3548
Variable (used in/rexx) privcols                       Reference: 3622 3676 3747

Variable (set w/rexx)   privilegevalue                 Assigned : 3544 3550
Variable (used in/rexx) privilegevalue                 Reference: 3626 3678 3749

Variable (set w/rexx)   privindx                       Assigned : 3227 3230
Variable (used in/rexx) privindx                       Reference: 3228
Variable (in Stem Set)  privindx                       Assigned : 3238
Variable (in Stem Ref)  privindx                       Reference: 3231

Label (internal label)  PROCESSRACFDATA                Defined  : 7218
Label (int. label ref)  PROCESSRACFDATA                Reference: C(885)

Variable (set w/rexx)   prof                           Assigned : 1598 1599 1602 1669 1670 1682 1785 1786 1788 1842 1843 1850 1881 1882 1891 1943
                        ...                                       1944 1945 2000 2001 2002 2228 2229 2232 2233 2245 2246 2249 2250 2349 2350 2353
                        ...                                       2354 2502 2503 2510 2511 2533 2534 2541 2542 2554 2555 2562 2563 2573 2574 2581
                        ...                                       2582 2721 2723 2728 2729 2744 2745 2749 2750 2758 2759 2763 2764 2771 2772 2776
                        ...                                       2777 3024 3026 3030 3031 3034 3035 3038 3039 3329 3330 3331 3418 3424 3590 3591
                        ...                                       3592 3593 3639 3640 3641 3642 3691 3692 3693 3695 3771 3772 3773 3774 3838 3839
                        ...                                       3841 3842 3843 3890 3891 3892 3938 3939 3940 4002 4003 4004 4039 4040 4041 4103
                        ...                                       4104 4105 4116 4117 4118 4237 4238 4239 4292 4293 4294 4295 4409 4410 4411 4412
                        ...                                       4463 4464 4465 4466 4523 4524 4525 4607 4608 4609 4770 4771 4772 4781 4782 4783
                        ...                                       4830 4831 4832 4884 4885 4886 4904 4905 4906 5027 5028 5029 5050 5051 5083 5091
                        ...                                       5167 5168 5183 5184 5186 5227 5228 5242 5310 5311 5312 5331 5332 5345 5346 5350
                        ...                                       5393 5394 5408 5475 5476 5477 5496 5497 5510 5511 5515 5561 5562 5576 5648 5649
                        ...                                       5651 5745 5746 5748 5775 5776 5777 5805 5806 5807 5839 5840 5841 5896 5897 5898
                        ...                                       5945 5946 5947 6000 6001 6002 6124 6125 6126 6163 6164 6165 6234 6235 6236 6254
                        ...                                       6255 6256 6392 6393 6394
Variable (used in/rexx) prof                           Reference: 1602 1603 1682 1692 1697 1788 1789 1850 1851 1891 1892 1897 1945 1946 2002 2004
                        ...                                       2231 2232 2233 2237 2248 2249 2250 2253 2352 2353 2354 2358 2364 2509 2510 2511
                        ...                                       2540 2541 2542 2547 2561 2562 2563 2568 2580 2581 2582 2587 2593 2599 2727 2728
                        ...                                       2729 2748 2749 2750 2762 2763 2764 2775 2776 2777 2792 2797 3029 3030 3031 3037
                        ...                                       3038 3039 3049 3331 3335 3340 3344 3349 3386 3388 3420 3422 3424 3429 3434 3441
                        ...                                       3447 3452 3458 3463 3469 3473 3479 3485 3506 3508 3592 3593 3595 3641 3642 3644
                        ...                                       3649 3693 3694 3695 3696 3773 3774 3778 3841 3842 3843 3845 3892 3893 3898 3940
                        ...                                       3941 4004 4005 4041 4043 4105 4106 4118 4122 4132 4139 4239 4240 4294 4295 4299
                        ...                                       4411 4412 4416 4422 4465 4466 4470 4476 4525 4526 4532 4609 4610 4615 4772 4775
                        ...                                       4783 4784 4832 4833 4886 4887 4892 4906 4910 4918 4924 5029 5031 5083 5084 5091
                        ...                                       5092 5099 5139 5141 5186 5187 5242 5243 5248 5312 5313 5350 5351 5408 5409 5414
                        ...                                       5477 5478 5515 5516 5576 5577 5582 5651 5652 5748 5749 5777 5778 5807 5808 5813
                        ...                                       5841 5842 5898 5899 5947 5948 5953 6002 6003 6126 6127 6165 6166 6236 6237 6242
                        ...                                       6256 6260 6266 6272 6394 6395

Label (internal label)  PRTSQLCA                       Defined  : 6573
Label (int. label ref)  PRTSQLCA                       Reference: C(1703) C(1705) C(1796) C(1798) C(1903) C(1905) C(1952) C(1954) C(2010) C(2012)
                        ...                                       C(2103) C(2105) C(2205) C(2207) C(2395) C(2397) C(2605) C(2607) C(2834) C(2836)
                        ...                                       C(3081) C(3083) C(3655) C(3657) C(3703) C(3705) C(3784) C(3786) C(3905) C(3907)
                        ...                                       C(3948) C(3950) C(4013) C(4015) C(4146) C(4148) C(4248) C(4250) C(4485) C(4487)
                        ...                                       C(4538) C(4540) C(4621) C(4623) C(4680) C(4682) C(4790) C(4792) C(4930) C(4932)
                        ...                                       C(5039) C(5041) C(5069) C(5075) C(5155) C(5157) C(5255) C(5257) C(5320) C(5322)
                        ...                                       C(5421) C(5423) C(5485) C(5487) C(5589) C(5591) C(5659) C(5662) C(5756) C(5759)
                        ...                                       C(5819) C(5821) C(5849) C(5851) C(5905) C(5907) C(5959) C(5961) C(6011) C(6013)
                        ...                                       C(6133) C(6135) C(6278) C(6280) C(6401) C(6403) C(6565) C(6568)

Variable (set w/rexx)   qualifier                      Assigned : 3886 3933 3995
Variable (used in/rexx) qualifier                      Reference: 3886 3888 3933 3935 3995 3997

Variable (set w/rexx)   racfconnecteddate              Assigned : 7427
Variable (NEVER USED)   racfconnecteddate              No Ref.  : If actually referenced, it must be via a cmd.

Variable (set w/rexx)   racfgroup                      Assigned : 7427
Variable (in Stem Ref)  racfgroup                      Reference: 7487

Variable (set w/rexx)   racfgroupowner                 Assigned : 7427
Variable (NEVER USED)   racfgroupowner                 No Ref.  : If actually referenced, it must be via a cmd.

Variable (set w/rexx)   racfgroupresumedate            Assigned : 7427
Variable (used in/rexx) racfgroupresumedate            Reference: 7448 7459 7478

Variable (set w/rexx)   racfgrouprevokedate            Assigned : 7427
Variable (used in/rexx) racfgrouprevokedate            Reference: 7444 7450 7463 7478

Variable (set w/rexx)   racflastconnectdate            Assigned : 7427
Variable (NEVER USED)   racflastconnectdate            No Ref.  : If actually referenced, it must be via a cmd.

Variable (set w/rexx)   racfsmry                       Assigned : 7231 7264 7271
Variable (used in/rexx) racfsmry                       Reference: 7264 7265
Variable (in Stem Ref)  racfsmry                       Reference: 7275 7280 7330 7427

Variable (set w/rexx)   racfsmryrc                     Assigned : 7228 7230 7270
Variable (used in/rexx) racfsmryrc                     Reference: 7267 7497

Variable (set w/rexx)   racftype                       Assigned : 7275
Variable (used in/rexx) racftype                       Reference: 7278 7326 7423

Variable (set w/rexx)   racfuserid                     Assigned : 7246 7330 7427
Variable (used in/rexx) racfuserid                     Reference: 7255 7414 7490
Variable (in Stem Set)  racfuserid                     Assigned : 7254 7413
Variable (in Stem Ref)  racfuserid                     Reference: 7441

SpecialVar(set no-XREF) RC                              *Special: No xref; set w/ADDR env cmd and/or REXX itself
SpecialVar(used w/rexx) RC                             Reference: 542 560 561 871 899 1290 1292 1466 1468 1516 1518 1554 1556 1567 1569 3287 3289
                        ...                                       6484 6485 6686 6687 6936 6938 7221 7223 7228 7270 7499

Variable (set w/rexx)   rdef$permit                    Assigned : 1589 1707 1832 1956 2029 2035 2047 2059 2838 3096 3104 3112 3120 3136 3151 3322
                        ...                                       3354 3362 3370 3398 3488 3536 3555 3568 3581 3724 3793 3800 3817 3952 4027 4153
                        ...                                       4280 4626 4820 4937 5053 5102 5170 5259 5334 5426 5499 5593 5730 5768 5853 5917
                        ...                                       6015 6153 6285 6715 6721 6726 6730
Variable (used in/rexx) rdef$permit                    Reference: 6729 6741

Variable (set w/rexx)   rdefclass                      Assigned : 956 962 968 974 980 986 992 998
Variable (in Stem Set)  rdefclass                      Assigned : 963 969 975 981 987 993 999

Variable (set w/rexx)   rdefddname                     Assigned : 956 962 968 974 980 986 992 998
Variable (used in/rexx) rdefddname                     Reference: 957 959 960 963 965 966 969 971 972 975 977 978 981 983 984 987 989 990 993 995
                        ...                                       996 999 1001 1002
Variable (in Stem Set)  rdefddname                     Assigned : 958 964 970 976 982 988 994 1000

Variable (set w/rexx)   removeuserlist                 Assigned : 906 930 7054
Variable (used in/rexx) removeuserlist                 Reference: 928 930 935 1630 1632 1653 1655 1740 1742 1769 1771 1979 1981 2936 2938 3751
                        ...                                       3753 3754 3977 3979 4183 4185 4217 4219 4559 4561 4591 4593 4645 4647 4710 4712
                        ...                                       4742 4744 4973 4975 5011 5013 5124 5126 5292 5294 5458 5460 5629 5631 5709 5711
                        ...                                       5792 5794 5879 5881 5933 5935 6059 6061 6106 6108 6327 6329 6372 6374 7054

Variable (set w/rexx)   replace                        Assigned : 6760 6966
Variable (in Stem Ref)  replace                        Reference: 6761 6967

Variable (set w/rexx)   resetoption                    Assigned : 755 758 768
Variable (used in/rexx) resetoption                    Reference: 776 1698 1898 2365 2600 2798 3341 3350 3448 3459 3470 3480 3486 3650 3899 4140
                        ...                                       4423 4477 4533 4616 4893 4925 5100 5249 5415 5583 5814 5954 6243 6273

Variable (set w/rexx)   rest                           Assigned : 6838 6875 7021 7030 7291 7295 7302 7394 7398 7405
Variable (used in/rexx) rest                           Reference: 6861 6898 7025 7032 7036 7294 7295 7296 7297 7299 7302 7397 7398 7399 7400 7402
                        ...                                       7405

Variable (set w/rexx)   resumenow                      Assigned : 7365 7366 7460 7461
Variable (used in/rexx) resumenow                      Reference: 7377 7472

Variable (set w/rexx)   revoke                         Assigned : 7247 7330 7350 7356 7357 7375 7379 7384 7385 7445 7451 7452 7470 7474 7479 7480
Variable (used in/rexx) revoke                         Reference: 7256 7415 7491

Variable (set w/rexx)   revokenow                      Assigned : 7369 7370 7464 7465
Variable (used in/rexx) revokenow                      Reference: 7374 7377 7469 7472

Built-In+/External use  RIGHT                          Reference: F(542) F(548) F(550) F(6470) F(6472) F(6671) F(6673)

Label (internal label)  ROUTINE_ATTR                   Defined  : 5491
Label (int. label ref)  ROUTINE_ATTR                   Reference: C(1276) C(1282)

Variable (set w/rexx)   rowsreturned                   Assigned : 1661 1666 1778 1782 1875 1879 1931 1935 1993 1997 2091 2096 2152 2159 2331 2337
                        ...                                       2476 2481 2699 2704 2972 2976 3630 3634 3682 3686 3761 3766 3878 3884 3925 3931
                        ...                                       3985 3992 4090 4095 4226 4230 4387 4392 4515 4519 4599 4603 4665 4670 4751 4757
                        ...                                       4874 4879 5020 5024 5067 5071 5132 5136 5218 5223 5300 5305 5384 5389 5466 5471
                        ...                                       5552 5557 5637 5643 5735 5740 5800 5804 5834 5838 5887 5891 5939 5943 5994 5998
                        ...                                       6113 6117 6224 6229 6381 6385
Variable (used in/rexx) rowsreturned                   Reference: 1666 1782 1879 1935 1997 2096 2159 2337 2481 2704 2976 3634 3686 3766 3884 3931
                        ...                                       3992 4095 4230 4392 4519 4603 4670 4757 4879 5024 5071 5136 5223 5305 5389 5471
                        ...                                       5557 5643 5740 5804 5838 5891 5943 5998 6117 6229 6385 7525 7528

Variable (NEVER SET)    ROWSRETURNEDC2                 Not Assgn: EITHER used as upper case value OR set via cmd
Variable (used in/rexx) ROWSRETURNEDC2                 Reference: 7540 7543

Variable (set w/rexx)   rphtable                       Assigned : 2613 2808
Variable (used in/rexx) rphtable                       Reference: 2808 2811
Variable (in Stem Set)  rphtable                       Assigned : 2809 2810

Variable (set w/rexx)   rphtablecreator                Assigned : 2616 2818
Variable (used in/rexx) rphtablecreator                Reference: 2818 2820 3162
Variable (in Stem Set)  rphtablecreator                Assigned : 2819

Variable (set w/rexx)   rsql                           Assigned : 6541 6544 6622 6625
Variable (used in/rexx) rsql                           Reference: 6542 6543 6544 6548 6623 6624 6625 6628

Variable (set w/rexx)   rsql1                          Assigned : 6543 6624
Variable (used in/rexx) rsql1                          Reference: 6545 6626

Built-In+/External use  RXSUBCOM                       Reference: F(871)

Variable (set w/rexx)   savepriv                       Assigned : 3306 3318
Variable (used in/rexx) savepriv                       Reference: 3319 3325 3408

Variable (set w/rexx)   savetables                     Assigned : 3173
Variable (used in/rexx) savetables                     Reference: 3396

Variable (set w/rexx)   schema                         Assigned : 5224 5306 5390 5472 5558 5644 5741
Variable (used in/rexx) schema                         Reference: 5224 5227 5228 5233 5238 5306 5310 5311 5390 5393 5394 5399 5404 5472 5475 5476
                        ...                                       5558 5561 5562 5567 5572 5644 5648 5649 5741 5745 5746

Label (internal label)  SCHEMA_ATTR                    Defined  : 1581
Label (int. label ref)  SCHEMA_ATTR                    Reference: C(1140) C(1141) C(1142)

Label (internal label)  SEQ_ATTR                       Defined  : 5326
Label (int. label ref)  SEQ_ATTR                       Reference: C(1265) C(1266)

Label (internal label)  SHOWROWCOUNT                   Defined  : 7519
Label (int. label ref)  SHOWROWCOUNT                   Reference: C(1701) C(1794) C(1901) C(1950) C(2008) C(2101) C(2203) C(2393) C(2603) C(2832)
                        ...                                       C(3079) C(3653) C(3701) C(3782) C(3903) C(3946) C(4011) C(4144) C(4246) C(4483)
                        ...                                       C(4536) C(4619) C(4678) C(4788) C(4928) C(5037) C(5073) C(5153) C(5252) C(5318)
                        ...                                       C(5418) C(5483) C(5586) C(5657) C(5754) C(5817) C(5847) C(5903) C(5957) C(6009)
                        ...                                       C(6131) C(6276) C(6399)

Label (internal label)  SHOWROWCOUNT2                  Defined  : 7534
Label (int. label ref)  SHOWROWCOUNT2                  Reference:

SpecialVar(set no-XREF) SIGL                            *Special: No xref; set w/ADDR env cmd and/or REXX itself
SpecialVar(used w/rexx) SIGL                           Reference: 542 544 545 547 6460 6464 6491 6657 7156 7165 7175 7186 7207 7208

Variable (set w/rexx)   skiprest                       Assigned : 4091 4109 4875 4894 6225 6244
Variable (used in/rexx) skiprest                       Reference: 4113 4150 4898 4934 6248 6282

Variable (set w/rexx)   slimadm                        Assigned : 679 682
Variable (used in/rexx) slimadm                        Reference: 1615 1638 1722 1751 1971 3969 4175 4209 4965 5003 5115 5282 5449 5620 5700 5864
                        ...                                       6027 6049 6073 6096 6319 6364

Built-In+/External use  SOURCELINE                     Reference: F(545) F(548) F(550) F(6467) F(6470) F(6472) F(6516) F(6605) F(6668) F(6671)
                        ...                                       F(6673)

Variable (set w/rexx)   sp$udf                         Assigned : 5495
Variable (used in/rexx) sp$udf                         Reference: 5530 5536 5543 5608 5615 5683 5690

Variable (NEVER SET)    SPEC                           Not Assgn: EITHER used as upper case value OR set via cmd
Variable (used in/rexx) SPEC                           Reference: 4101 4120 4882 4908 6232 6258

Label (internal label)  SQL                            Defined  : 7137
Label (int. label ref)  SQL                            Reference: F(1610) F(1612) F(1613) F(1614) F(1617) F(1618) F(1619) F(1620) F(1621) F(1623)
                        ...                                       F(1624) F(1625) F(1626) F(1627) F(1628) F(1629) F(1632) F(1634) F(1635) F(1636)
                        ...                                       F(1637) F(1640) F(1641) F(1642) F(1643) F(1644) F(1646) F(1647) F(1648) F(1649)
                        ...                                       F(1650) F(1651) F(1652) F(1655) F(1657) F(1712) F(1714) F(1715) F(1716) F(1718)
                        ...                                       F(1719) F(1720) F(1721) F(1724) F(1725) F(1726) F(1727) F(1728) F(1729) F(1731)
                        ...                                       F(1732) F(1733) F(1734) F(1735) F(1736) F(1737) F(1738) F(1739) F(1742) F(1743)
                        ...                                       F(1744) F(1745) F(1746) F(1747) F(1748) F(1749) F(1750) F(1753) F(1754) F(1755)
                        ...                                       F(1756) F(1757) F(1758) F(1760) F(1761) F(1762) F(1763) F(1764) F(1765) F(1766)
                        ...                                       F(1767) F(1768) F(1771) F(1772) F(1774) F(1859) F(1861) F(1862) F(1866) F(1867)
                        ...                                       F(1868) F(1871) F(1909) F(1911) F(1912) F(1916) F(1918) F(1919) F(1923) F(1924)
                        ...                                       F(1927) F(1960) F(1962) F(1963) F(1967) F(1969) F(1970) F(1973) F(1974) F(1975)
                        ...                                       F(1976) F(1981) F(1985) F(1986) F(1989) F(2082) F(2084) F(2085) F(2086) F(2117)
                        ...                                       F(2119) F(2120) F(2121) F(2122) F(2123) F(2124) F(2125) F(2126) F(2127) F(2128)
                        ...                                       F(2129) F(2130) F(2131) F(2132) F(2133) F(2272) F(2274) F(2275) F(2276) F(2277)
                        ...                                       F(2278) F(2279) F(2280) F(2281) F(2285) F(2289) F(2291) F(2292) F(2293) F(2294)
                        ...                                       F(2295) F(2296) F(2300) F(2304) F(2306) F(2307) F(2308) F(2309) F(2310) F(2311)
                        ...                                       F(2312) F(2313) F(2314) F(2315) F(2316) F(2317) F(2318) F(2319) F(2320) F(2321)
                        ...                                       F(2322) F(2323) F(2324) F(2325) F(2432) F(2434) F(2435) F(2436) F(2437) F(2438)
                        ...                                       F(2439) F(2440) F(2444) F(2449) F(2453) F(2455) F(2456) F(2457) F(2458) F(2459)
                        ...                                       F(2463) F(2467) F(2469) F(2470) F(2471) F(2472) F(2655) F(2657) F(2658) F(2659)
                        ...                                       F(2660) F(2661) F(2662) F(2663) F(2667) F(2672) F(2676) F(2678) F(2679) F(2680)
                        ...                                       F(2681) F(2682) F(2686) F(2690) F(2692) F(2693) F(2694) F(2695) F(2910) F(2912)
                        ...                                       F(2913) F(2914) F(2915) F(2916) F(2917) F(2918) F(2919) F(2921) F(2922) F(2926)
                        ...                                       F(2930) F(2934) F(2938) F(2940) F(2941) F(2942) F(2943) F(2944) F(2948) F(2952)
                        ...                                       F(2954) F(2955) F(2956) F(2957) F(2958) F(2959) F(2960) F(2961) F(2965) F(2967)
                        ...                                       F(2968) F(3611) F(3613) F(3614) F(3615) F(3616) F(3617) F(3618) F(3619) F(3620)
                        ...                                       F(3621) F(3622) F(3623) F(3624) F(3625) F(3626) F(3664) F(3666) F(3667) F(3668)
                        ...                                       F(3669) F(3670) F(3671) F(3672) F(3673) F(3674) F(3675) F(3676) F(3677) F(3678)
                        ...                                       F(3731) F(3733) F(3734) F(3735) F(3736) F(3737) F(3738) F(3739) F(3740) F(3741)
                        ...                                       F(3742) F(3743) F(3744) F(3745) F(3746) F(3747) F(3748) F(3749) F(3753) F(3754)
                        ...                                       F(3757) F(3865) F(3867) F(3871) F(3873) F(3874) F(3910) F(3912) F(3916) F(3918)
                        ...                                       F(3919) F(3920) F(3921) F(3956) F(3958) F(3959) F(3963) F(3965) F(3966) F(3967)
                        ...                                       F(3968) F(3971) F(3972) F(3973) F(3974) F(3979) F(3981) F(4052) F(4054) F(4055)
                        ...                                       F(4056) F(4057) F(4058) F(4059) F(4060) F(4061) F(4062) F(4063) F(4064) F(4065)
                        ...                                       F(4066) F(4067) F(4068) F(4069) F(4070) F(4071) F(4072) F(4073) F(4074) F(4075)
                        ...                                       F(4076) F(4077) F(4078) F(4079) F(4080) F(4081) F(4082) F(4083) F(4084) F(4085)
                        ...                                       F(4086) F(4156) F(4158) F(4159) F(4160) F(4161) F(4162) F(4163) F(4164) F(4165)
                        ...                                       F(4166) F(4167) F(4168) F(4169) F(4170) F(4171) F(4172) F(4173) F(4174) F(4177)
                        ...                                       F(4178) F(4179) F(4180) F(4185) F(4187) F(4189) F(4190) F(4191) F(4192) F(4193)
                        ...                                       F(4194) F(4195) F(4196) F(4197) F(4198) F(4199) F(4200) F(4201) F(4202) F(4203)
                        ...                                       F(4204) F(4205) F(4206) F(4207) F(4208) F(4211) F(4212) F(4213) F(4214) F(4219)
                        ...                                       F(4221) F(4222) F(4328) F(4330) F(4331) F(4332) F(4333) F(4334) F(4335) F(4336)
                        ...                                       F(4337) F(4338) F(4339) F(4340) F(4341) F(4342) F(4343) F(4344) F(4345) F(4346)
                        ...                                       F(4347) F(4348) F(4349) F(4350) F(4351) F(4352) F(4353) F(4354) F(4355) F(4356)
                        ...                                       F(4357) F(4358) F(4359) F(4360) F(4361) F(4362) F(4363) F(4364) F(4365) F(4366)
                        ...                                       F(4367) F(4368) F(4369) F(4370) F(4371) F(4372) F(4373) F(4374) F(4375) F(4376)
                        ...                                       F(4377) F(4378) F(4379) F(4499) F(4501) F(4502) F(4503) F(4504) F(4505) F(4509)
                        ...                                       F(4511) F(4548) F(4550) F(4551) F(4552) F(4553) F(4557) F(4561) F(4563) F(4564)
                        ...                                       F(4565) F(4566) F(4567) F(4568) F(4569) F(4570) F(4571) F(4572) F(4574) F(4575)
                        ...                                       F(4576) F(4577) F(4578) F(4579) F(4580) F(4581) F(4582) F(4583) F(4584) F(4585)
                        ...                                       F(4586) F(4587) F(4588) F(4589) F(4593) F(4594) F(4595) F(4596) F(4634) F(4635)
                        ...                                       F(4636) F(4637) F(4638) F(4639) F(4643) F(4647) F(4649) F(4650) F(4651) F(4652)
                        ...                                       F(4653) F(4654) F(4655) F(4656) F(4657) F(4658) F(4660) F(4699) F(4701) F(4702)
                        ...                                       F(4703) F(4704) F(4708) F(4712) F(4714) F(4715) F(4716) F(4717) F(4718) F(4719)
                        ...                                       F(4720) F(4721) F(4722) F(4723) F(4725) F(4726) F(4727) F(4728) F(4729) F(4730)
                        ...                                       F(4731) F(4732) F(4733) F(4734) F(4735) F(4736) F(4737) F(4738) F(4739) F(4740)
                        ...                                       F(4744) F(4745) F(4746) F(4747) F(4841) F(4843) F(4844) F(4845) F(4846) F(4847)
                        ...                                       F(4848) F(4849) F(4850) F(4851) F(4852) F(4853) F(4854) F(4855) F(4856) F(4857)
                        ...                                       F(4858) F(4859) F(4860) F(4861) F(4862) F(4863) F(4864) F(4865) F(4866) F(4867)
                        ...                                       F(4868) F(4869) F(4943) F(4945) F(4946) F(4947) F(4948) F(4949) F(4950) F(4951)
                        ...                                       F(4952) F(4953) F(4954) F(4955) F(4956) F(4957) F(4958) F(4959) F(4960) F(4961)
                        ...                                       F(4962) F(4963) F(4964) F(4967) F(4968) F(4969) F(4970) F(4975) F(4977) F(4979)
                        ...                                       F(4980) F(4981) F(4982) F(4983) F(4984) F(4985) F(4986) F(4987) F(4988) F(4989)
                        ...                                       F(4990) F(4991) F(4992) F(4993) F(4994) F(4995) F(4996) F(4997) F(4998) F(4999)
                        ...                                       F(5000) F(5001) F(5002) F(5005) F(5006) F(5007) F(5008) F(5013) F(5015) F(5016)
                        ...                                       F(5058) F(5060) F(5061) F(5062) F(5063) F(5108) F(5110) F(5111) F(5112) F(5113)
                        ...                                       F(5117) F(5118) F(5119) F(5120) F(5121) F(5126) F(5128) F(5193) F(5195) F(5196)
                        ...                                       F(5197) F(5198) F(5199) F(5200) F(5201) F(5202) F(5203) F(5204) F(5205) F(5206)
                        ...                                       F(5207) F(5208) F(5209) F(5210) F(5211) F(5212) F(5213) F(5214) F(5215) F(5263)
                        ...                                       F(5265) F(5266) F(5267) F(5268) F(5269) F(5270) F(5271) F(5272) F(5273) F(5274)
                        ...                                       F(5275) F(5276) F(5277) F(5278) F(5279) F(5280) F(5284) F(5285) F(5286) F(5287)
                        ...                                       F(5288) F(5289) F(5294) F(5296) F(5358) F(5360) F(5361) F(5362) F(5363) F(5364)
                        ...                                       F(5365) F(5366) F(5367) F(5368) F(5369) F(5370) F(5371) F(5372) F(5373) F(5374)
                        ...                                       F(5375) F(5376) F(5377) F(5378) F(5379) F(5380) F(5430) F(5432) F(5433) F(5434)
                        ...                                       F(5435) F(5436) F(5437) F(5438) F(5439) F(5440) F(5441) F(5442) F(5443) F(5444)
                        ...                                       F(5445) F(5446) F(5447) F(5451) F(5452) F(5453) F(5454) F(5455) F(5460) F(5462)
                        ...                                       F(5523) F(5525) F(5526) F(5527) F(5528) F(5529) F(5530) F(5531) F(5532) F(5533)
                        ...                                       F(5534) F(5535) F(5536) F(5537) F(5538) F(5539) F(5540) F(5541) F(5542) F(5543)
                        ...                                       F(5544) F(5545) F(5546) F(5547) F(5548) F(5600) F(5602) F(5603) F(5604) F(5605)
                        ...                                       F(5606) F(5607) F(5608) F(5609) F(5610) F(5611) F(5612) F(5613) F(5614) F(5615)
                        ...                                       F(5616) F(5617) F(5618) F(5619) F(5622) F(5623) F(5624) F(5625) F(5626) F(5631)
                        ...                                       F(5633) F(5671) F(5673) F(5674) F(5675) F(5676) F(5677) F(5678) F(5679) F(5680)
                        ...                                       F(5681) F(5682) F(5683) F(5684) F(5685) F(5686) F(5687) F(5688) F(5689) F(5690)
                        ...                                       F(5691) F(5692) F(5693) F(5694) F(5695) F(5696) F(5697) F(5698) F(5699) F(5702)
                        ...                                       F(5703) F(5704) F(5705) F(5706) F(5711) F(5713) F(5714) F(5715) F(5716) F(5717)
                        ...                                       F(5718) F(5719) F(5720) F(5721) F(5722) F(5723) F(5724) F(5726) F(5785) F(5788)
                        ...                                       F(5789) F(5790) F(5794) F(5796) F(5824) F(5826) F(5827) F(5828) F(5829) F(5830)
                        ...                                       F(5857) F(5859) F(5860) F(5861) F(5862) F(5863) F(5866) F(5867) F(5868) F(5869)
                        ...                                       F(5870) F(5872) F(5873) F(5874) F(5875) F(5876) F(5877) F(5881) F(5883) F(5923)
                        ...                                       F(5925) F(5926) F(5927) F(5928) F(5929) F(5930) F(5931) F(5935) F(5964) F(5966)
                        ...                                       F(5967) F(5968) F(5969) F(5970) F(5971) F(5972) F(5973) F(5974) F(5975) F(5976)
                        ...                                       F(5977) F(5978) F(5979) F(5980) F(5981) F(5982) F(5983) F(5984) F(5985) F(5986)
                        ...                                       F(5987) F(5988) F(5989) F(5990) F(6019) F(6021) F(6022) F(6023) F(6024) F(6025)
                        ...                                       F(6026) F(6029) F(6030) F(6031) F(6032) F(6033) F(6035) F(6036) F(6037) F(6038)
                        ...                                       F(6039) F(6040) F(6041) F(6042) F(6043) F(6044) F(6045) F(6046) F(6047) F(6051)
                        ...                                       F(6052) F(6053) F(6054) F(6055) F(6056) F(6061) F(6066) F(6067) F(6068) F(6069)
                        ...                                       F(6070) F(6071) F(6072) F(6075) F(6076) F(6077) F(6078) F(6079) F(6081) F(6082)
                        ...                                       F(6083) F(6084) F(6085) F(6086) F(6087) F(6088) F(6089) F(6090) F(6091) F(6092)
                        ...                                       F(6093) F(6098) F(6099) F(6100) F(6101) F(6102) F(6103) F(6108) F(6110) F(6174)
                        ...                                       F(6176) F(6177) F(6178) F(6179) F(6180) F(6181) F(6182) F(6183) F(6184) F(6185)
                        ...                                       F(6186) F(6187) F(6188) F(6189) F(6190) F(6191) F(6192) F(6193) F(6194) F(6195)
                        ...                                       F(6196) F(6197) F(6198) F(6199) F(6200) F(6201) F(6202) F(6203) F(6204) F(6205)
                        ...                                       F(6206) F(6207) F(6208) F(6209) F(6210) F(6211) F(6212) F(6213) F(6214) F(6215)
                        ...                                       F(6216) F(6217) F(6218) F(6219) F(6220) F(6289) F(6291) F(6292) F(6293) F(6294)
                        ...                                       F(6295) F(6296) F(6297) F(6298) F(6299) F(6300) F(6301) F(6302) F(6303) F(6304)
                        ...                                       F(6305) F(6306) F(6307) F(6308) F(6309) F(6310) F(6311) F(6312) F(6313) F(6314)
                        ...                                       F(6315) F(6316) F(6317) F(6318) F(6321) F(6322) F(6323) F(6324) F(6329) F(6331)
                        ...                                       F(6333) F(6334) F(6335) F(6336) F(6337) F(6338) F(6339) F(6340) F(6341) F(6342)
                        ...                                       F(6343) F(6344) F(6345) F(6346) F(6347) F(6348) F(6349) F(6350) F(6351) F(6352)
                        ...                                       F(6353) F(6354) F(6355) F(6356) F(6357) F(6358) F(6359) F(6360) F(6361) F(6362)
                        ...                                       F(6363) F(6366) F(6367) F(6368) F(6369) F(6374) F(6376) F(6377)

Variable (set w/rexx)   sql1                           Assigned : 7148
Variable (used in/rexx) sql1                           Reference: 7149

Variable (set w/rexx)   sql2                           Assigned : 7148
Variable (used in/rexx) sql2                           Reference: 7149

SpecialVar(set no-XREF) SQLCODE                         *Special: No xref; set w/ADDR env cmd and/or REXX itself
SpecialVar(used w/rexx) SQLCODE                        Reference: 1663 1665 1702 1705 1779 1781 1795 1798 1876 1878 1902 1905 1932 1934 1951 1954
                        ...                                       1994 1996 2009 2012 2092 2094 2102 2105 2153 2157 2204 2207 2332 2335 2394 2397
                        ...                                       2477 2480 2604 2607 2700 2703 2833 2836 2973 2975 3080 3083 3631 3633 3654 3657
                        ...                                       3683 3685 3702 3705 3762 3765 3783 3786 3879 3883 3904 3907 3926 3930 3947 3950
                        ...                                       3986 3991 4012 4015 4092 4094 4145 4148 4227 4229 4247 4250 4388 4390 4484 4487
                        ...                                       4516 4518 4537 4540 4600 4602 4620 4623 4666 4668 4679 4682 4754 4756 4789 4792
                        ...                                       4876 4878 4929 4932 5021 5023 5038 5041 5069 5075 5133 5135 5154 5157 5219 5221
                        ...                                       5253 5257 5301 5303 5319 5322 5385 5387 5419 5423 5467 5469 5484 5487 5553 5555
                        ...                                       5587 5591 5639 5641 5658 5662 5736 5738 5755 5759 5801 5803 5818 5821 5835 5837
                        ...                                       5848 5851 5888 5890 5904 5907 5940 5942 5958 5961 5995 5997 6010 6013 6114 6116
                        ...                                       6132 6135 6226 6228 6277 6280 6382 6384 6400 6403 6420 6437 6565 6568 6633

SpecialVar(set no-XREF) SQLERRMC                        *Special: No xref; set w/ADDR env cmd and/or REXX itself
SpecialVar(used w/rexx) SQLERRMC                       Reference: 6438 6634

SpecialVar(set no-XREF) SQLERRP                         *Special: No xref; set w/ADDR env cmd and/or REXX itself
SpecialVar(used w/rexx) SQLERRP                        Reference: 6439 6635

Variable (set w/rexx)   sqloption                      Assigned : 704 707 717
Variable (used in/rexx) sqloption                      Reference: 725 6500 7520 7535

SpecialVar(set no-XREF) SQLSTATE                        *Special: No xref; set w/ADDR env cmd and/or REXX itself
SpecialVar(used w/rexx) SQLSTATE                       Reference: 6458 6654

Variable (set w/rexx)   sqlstmt                        Assigned : 7190
Variable (used in/rexx) sqlstmt                        Reference: 7192 7207
Variable (in Stem Set)  sqlstmt                        Assigned : 7193

Variable (set w/rexx)   sqlstmtline                    Assigned : 7191
Variable (used in/rexx) sqlstmtline                    Reference: 7193

Variable (set w/rexx)   sqlstmtvalue                   Assigned : 7170 7182
Variable (used in/rexx) sqlstmtvalue                   Reference: 6496 6538 6540 6562 6563 6565 6567 6568 7187 7207
Variable (in Stem Set)  sqlstmtvalue                   Assigned : 7185 7186 7192 7193 7208
Variable (in Stem Ref)  sqlstmtvalue                   Reference: 6504 6513 6514 6522 6531 6532 6541 6559 6560 7190

Variable (set w/rexx)   ssid                           Assigned : 788
Variable (used in/rexx) ssid                           Reference: 797 802 807 888 942 1071 1105 1147 1251 1261 1272 1278 1583 1599 1601 1670 1678
                        ...                                       1680 1786 1826 1843 1846 1848 1882 1885 1888 1938 1941 1944 2001 2026 2229 2246
                        ...                                       2350 2503 2534 2555 2574 2723 2745 2759 2772 3026 3035 3330 3533 3591 3595 3640
                        ...                                       3644 3692 3696 3772 3814 3828 3830 3832 3834 3842 3854 3856 3858 3860 3891 3939
                        ...                                       4003 4024 4037 4040 4104 4117 4122 4132 4238 4271 4293 4410 4464 4524 4526 4608
                        ...                                       4610 4771 4782 4817 4831 4833 4885 4887 4905 4910 4918 5028 5051 5084 5092 5168
                        ...                                       5180 5184 5228 5233 5238 5311 5332 5346 5348 5394 5399 5404 5476 5497 5511 5513
                        ...                                       5562 5567 5572 5649 5746 5776 5778 5806 5808 5840 5842 5897 5946 5948 6001 6003
                        ...                                       6125 6164 6166 6235 6237 6255 6260 6266 6393

Variable (set w/rexx)   ssidtable                      Assigned : 2231 2248 2352 2509 2540 2561 2580 2727 2748 2762 2775 3029 3037
Variable (used in/rexx) ssidtable                      Reference: 2809
Variable (in Stem Set)  ssidtable                      Assigned : 2811
Variable (in Stem Ref)  ssidtable                      Reference: 2805 2813 3060

Variable (set w/rexx)   ssidtablecol                   Assigned : 3694
Variable (NEVER USED)   ssidtablecol                   No Ref.  : If actually referenced, it must be via a cmd.

Variable (NEVER SET)    STARTSQLCALLER                 Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  STARTSQLCALLER                 Assigned : 7186
Variable (in Stem Ref)  STARTSQLCALLER                 Reference: 6504 6513 6522 6531 6596 6602 6609 6616

Label (internal label)  STARTUP                        Defined  : 569
Label (int. label ref)  STARTUP                        Reference: S(533)

Variable (set w/rexx)   stat                           Assigned : 1429
Variable (used in/rexx) stat                           Reference: 1432 1434

Variable (set w/rexx)   stmtcursornum                  Assigned : 6587 6588
Variable (used in/rexx) stmtcursornum                  Reference: 6591 6619 6621
Variable (in Stem Ref)  stmtcursornum                  Reference: 6596 6602 6603 6609 6616 6617 6622

Built-In+/External use  STRIP                          Reference: F(573) F(783) F(913) F(2230) F(2247) F(2349) F(2350) F(2351) F(2504) F(2507)
                        ...                                       F(2518) F(2533) F(2534) F(2535) F(2538) F(2547) F(2549) F(2554) F(2555) F(2556)
                        ...                                       F(2559) F(2568) F(2569) F(2573) F(2574) F(2575) F(2578) F(2587) F(2588) F(2725)
                        ...                                       F(2726) F(2744) F(2745) F(2746) F(2747) F(2758) F(2759) F(2760) F(2761) F(2771)
                        ...                                       F(2772) F(2773) F(2774) F(3028) F(3034) F(3035) F(3036) F(3185) F(3186) F(3187)
                        ...                                       F(3303) F(3304) F(3305) F(3328) F(3332) F(3386) F(3388) F(3403) F(3404) F(3405)
                        ...                                       F(3429) F(3434) F(3441) F(3452) F(3463) F(3473) F(3506) F(3508) F(3639) F(3640)
                        ...                                       F(3641) F(3691) F(3692) F(3693) F(3771) F(3772) F(3773) F(3890) F(3891) F(3938)
                        ...                                       F(3939) F(4002) F(4003) F(4005) F(4103) F(4104) F(4116) F(4117) F(4237) F(4238)
                        ...                                       F(4240) F(4523) F(4524) F(4526) F(4884) F(4885) F(4904) F(4905) F(5027) F(5028)
                        ...                                       F(5031) F(5805) F(5806) F(5839) F(5840) F(5945) F(5946) F(6000) F(6001) F(6124)
                        ...                                       F(6125) F(6234) F(6235) F(6254) F(6255) F(6392) F(6393) F(6752) F(6958) F(7071)
                        ...                                       F(7074) F(7101) F(7288) F(7317) F(7318)

Built-In+/External use  SUBSTR                         Reference: F(2232) F(2234) F(2510) F(2516) F(2518) F(2728) F(2733) F(3030) F(6544) F(6625)
                        ...                                       F(7125) F(7129) F(7295) F(7398)

Built-In+/External use  SUBWORD                        Reference: F(624) F(625) F(636) F(637) F(650) F(651) F(662) F(663) F(673) F(674) F(687)
                        ...                                       F(688) F(698) F(699) F(711) F(712) F(721) F(722) F(736) F(737) F(746) F(747)
                        ...                                       F(762) F(763) F(772) F(773) F(6834) F(6870) F(6906) F(7020) F(7028)

Variable (set w/rexx)   supergrpname                   Assigned : 7280
Variable (used in/rexx) supergrpname                   Reference: 7313

Label (internal label)  SYNTAX                         Defined  : 536
Label (int. label ref)  SYNTAX                         Reference:

Built-In+/External use  SYNTAX (SIGNAL ON SYNTAX)      Reference: S(532)

Variable (set w/rexx)   syntaxhigh                     Assigned : 545 6467 6668
Variable (used in/rexx) syntaxhigh                     Reference: 546 548 550 6468 6470 6472 6669 6671 6673

Variable (set w/rexx)   syntaxii                       Assigned : 546 6468 6669
Variable (used in/rexx) syntaxii                       Reference: 547 548 550 6469 6470 6472 6670 6671 6673

Variable (set w/rexx)   syntaxlow                      Assigned : 544 6466 6667
Variable (used in/rexx) syntaxlow                      Reference: 546 6468 6669

Label (internal label)  SYS_ATTR                       Defined  : 5045
Label (int. label ref)  SYS_ATTR                       Reference: C(1118) C(1119) C(1120) C(1121) C(1122) C(1123) C(1151) C(1152) C(1154) C(1155)
                        ...                                       C(1156) C(1157) C(1158) C(1159) C(1160) C(1161) C(1162) C(1163) C(1164) C(1165)
                        ...                                       C(1166) C(1167) C(1168) C(1169) C(1170)

Variable (set w/rexx)   s_rc                           Assigned : 871
Variable (NEVER USED)   s_rc                           No Ref.  : If actually referenced, it must be via a cmd.

Variable (set w/rexx)   tab                            Assigned : 1825
Variable (used in/rexx) tab                            Reference: 1845 1847 1862 1864 1884 1887 1912 1914 1921 1937 1940 1963 1965 1983

Variable (set w/rexx)   tablecreator                   Assigned : 2162
Variable (used in/rexx) tablecreator                   Reference: 2162 2191

Variable (set w/rexx)   tablecreatordotname            Assigned : 2500
Variable (used in/rexx) tablecreatordotname            Reference: 2502 2503

Variable (set w/rexx)   tablename                      Assigned : 2163
Variable (used in/rexx) tablename                      Reference: 2163 2191

Variable (set w/rexx)   tablenumber                    Assigned : 2813 3060 3183 3302 3401
Variable (used in/rexx) tablenumber                    Reference: 2826 2827 3222 3249 3258
Variable (in Stem Set)  tablenumber                    Assigned : 3063
Variable (in Stem Ref)  tablenumber                    Reference: 3063 3185 3186 3196 3303 3304 3403 3404 3406 3408 3418 3426 3438 3461

Variable (set w/rexx)   tables                         Assigned : 3171 3183 3396 3401
Variable (used in/rexx) tables                         Reference: 3173 3182 3183 3397 3401

Label (internal label)  TAB_COL                        Defined  : 3519
Label (int. label ref)  TAB_COL                        Reference: C(1188) C(1190)

Label (internal label)  TAB_PRIV                       Defined  : 2016
Label (int. label ref)  TAB_PRIV                       Reference: C(1176) C(1177) C(1178) C(1179) C(1180) C(1181) C(1182) C(1183) C(1184) C(1185)
                        ...                                       C(1186) C(1192) C(1193)

Variable (set w/rexx)   tbcreator                      Assigned : 3171 3328
Variable (used in/rexx) tbcreator                      Reference: 3000 3196 3277 3328 3329 3330 3335 3344 3357 3365 3383 3502
Variable (in Stem Ref)  tbcreator                      Reference: 3269 3275 3276 3280

Variable (set w/rexx)   tbname                         Assigned : 3420 3422
Variable (used in/rexx) tbname                         Reference: 3421
Variable (in Stem Ref)  tbname                         Reference: 3426 3432 3438 3450

Variable (set w/rexx)   tcreator                       Assigned : 2230 2247 2338 2351 2482 2507 2538 2559 2578 2709 2726 2747 2761 2774 2977 3028
                        ...                                       3036 3635 3687 3767
Variable (used in/rexx) tcreator                       Reference: 2230 2247 2338 2340 2349 2350 2351 2355 2386 2482 2502 2503 2505 2507 2516 2518
                        ...                                       2533 2534 2536 2538 2549 2554 2555 2557 2559 2569 2573 2574 2576 2578 2588 2709
                        ...                                       2721 2723 2726 2732 2733 2744 2745 2747 2753 2754 2758 2759 2761 2767 2768 2771
                        ...                                       2772 2774 2780 2781 2819 2977 2983 3024 3026 3028 3034 3035 3036 3045 3635 3639
                        ...                                       3640 3687 3691 3692 3767 3771 3772
Variable (in Stem Set)  tcreator                       Assigned : 2347 2820 3069 3070 3073
Variable (in Stem Ref)  tcreator                       Reference: 2486 2493 2495 2500 2521 2527 2552 2715 2718 2721 2723 2736 2742 2756 2784 2787
                        ...                                       2816 2822 3019 3024 3026 3042 3067 3070 3073 3426 3432 3438 3450

Variable (set w/rexx)   templist                       Assigned : 3269
Variable (used in/rexx) templist                       Reference: 3270

Variable (set w/rexx)   theargs                        Assigned : 572 624 625 636 637 650 651 662 663 673 674 687 688 698 699 711 712 721 722 736
                        ...                                       737 746 747 762 763 772 773
Variable (used in/rexx) theargs                        Reference: 573 575 580 585 590 597 604 617 622 624 625 631 634 636 637 643 648 650 651 654
                        ...                                       660 662 663 668 671 673 674 680 685 687 688 693 696 698 699 705 709 711 712 715
                        ...                                       719 721 722 730 734 736 737 740 744 746 747 756 760 762 763 766 770 772 773 783
                        ...                                       788

Variable (set w/rexx)   thetbcreator                   Assigned : 3022
Variable (NEVER USED)   thetbcreator                   No Ref.  : If actually referenced, it must be via a cmd.

Built-In+/External use  TIME                           Reference: F(945) F(1220) F(1222) F(1224)

Variable (set w/rexx)   toolong                        Assigned : 3203 3204 3206
Variable (used in/rexx) toolong                        Reference: 3204 3205 3206

Variable (NEVER SET)    TOTALCOUNT                     Not Assgn: EITHER used as upper case value OR set via cmd
Variable (used in/rexx) TOTALCOUNT                     Reference: 5079

Variable (set w/rexx)   totaltables                    Assigned : 3172 3193
Variable (used in/rexx) totaltables                    Reference: 3193 3265 3308 3356 3357 3364 3365

Built-In+/External use  TRANSLATE                      Reference: F(3386) F(3388) F(3506) F(3508)

Variable (set w/rexx)   ttname                         Assigned : 2483 2710 2978 3636 3688 3768
Variable (used in/rexx) ttname                         Reference: 2483 2502 2503 2516 2518 2533 2534 2549 2554 2555 2569 2573 2574 2588 2710 2721
                        ...                                       2723 2732 2733 2744 2745 2753 2754 2758 2759 2767 2768 2771 2772 2780 2781 2978
                        ...                                       3024 3026 3034 3035 3636 3639 3640 3688 3691 3692 3768 3771 3772
Variable (in Stem Ref)  ttname                         Reference: 2493 2495 2500 2521 2527 2552 2715 2718 2721 2723 2736 2742 2756 3019 3024 3026

Variable (set w/rexx)   type                           Assigned : 1668 1676 1784 1825 3813 4023
Variable (used in/rexx) type                           Reference: 1668 1672 1679 1692 1784 1826 1827 3814 3815 4024 4025

Variable (set w/rexx)   uac                            Assigned : 5082 5090 5232 5237 5398 5403 5566 5571
Variable (used in/rexx) uac                            Reference: 5084 5092 5243 5409 5577

Variable (set w/rexx)   uacc                           Assigned : 6845 6882 6913
Variable (used in/rexx) uacc                           Reference: 6849 6886 6917

Variable (set w/rexx)   uid                            Assigned : 1059 6768 6974
Variable (used in/rexx) uid                            Reference: 1306 1322 1340 1356 1372 1390 1408 1444 1455 6768 6770 6974 6976
Variable (in Stem Set)  uid                            Assigned : 6769 6975

Variable (set w/rexx)   uidindx                        Assigned : 6783
Variable (in Stem Set)  uidindx                        Assigned : 6784
Variable (in Stem Ref)  uidindx                        Reference: 6784

Variable (set w/rexx)   uidnum                         Assigned : 1444 1455
Variable (in Stem Ref)  uidnum                         Reference: 1445 1446 1456 1457 1459

Variable (set w/rexx)   uidx                           Assigned : 1313 1329 1347 1363 1379 1397 6751 6752 6761 6821 6957 6958 6967 7012 7441
Variable (used in/rexx) uidx                           Reference: 6752 6762 6769 6792 6804 6811 6816 6958 6968 6975 6983 6995 7002 7007
Variable (in Stem Set)  uidx                           Assigned : 6770 6976
Variable (in Stem Ref)  uidx                           Reference: 1314 1316 1330 1332 1348 1350 1364 1366 1380 1398 6754 6757 6760 6766 6783 6800
                        ...                                       6807 6960 6963 6966 6972 6991 6998

Variable (set w/rexx)   uix                            Assigned : 7067 7098
Variable (in Stem Set)  uix                            Assigned : 7068 7099
Variable (in Stem Ref)  uix                            Reference: 7070 7071 7074 7101

Variable (set w/rexx)   useclass                       Assigned : 1591 1834 2031 3097 3121 3353 3538 3819 4029 4283 4822 5055 5172 5336 5501 5770
                        ...                                       5919 6155 6716 6722 6727
Variable (used in/rexx) useclass                       Reference: 6779
Variable (in Stem Set)  useclass                       Assigned : 6780
Variable (in Stem Ref)  useclass                       Reference: 6742 6745 6746 6776 6782

Variable (set w/rexx)   usercreatedate                 Assigned : 7330
Variable (NEVER USED)   usercreatedate                 No Ref.  : If actually referenced, it must be via a cmd.

Label (internal label)  USERGROUPINFO                  Defined  : 7062
Label (int. label ref)  USERGROUPINFO                  Reference: F(1318) F(1334) F(1352) F(1368) F(1382) F(1400) F(1413) F(1430) F(1457) F(6792)
                        ...                                       F(6804) F(6816) F(6983) F(6995) F(7007)

Variable (set w/rexx)   userid                         Assigned : 7088 7089 7237 7253 7412
Variable (used in/rexx) userid                         Reference: 7089 7090 7091 7098 7253 7254 7412 7413 7505 7508
Variable (in Stem Set)  userid                         Assigned : 7092 7093 7094 7095 7096 7255 7256 7257 7258 7259 7260 7261 7414 7415 7416 7417
                        ...                                       7418 7419 7420

Variable (set w/rexx)   useridowner                    Assigned : 7330
Variable (NEVER USED)   useridowner                    No Ref.  : If actually referenced, it must be via a cmd.

Variable (set w/rexx)   username                       Assigned : 7402
Variable (NEVER USED)   username                       No Ref.  : If actually referenced, it must be via a cmd.

Variable (set w/rexx)   userorgroup                    Assigned : 7063 7069 7082 7100
Variable (used in/rexx) userorgroup                    Reference: 7069 7071 7074 7082 7083 7092 7100 7101
Variable (in Stem Set)  userorgroup                    Assigned : 7091
Variable (in Stem Ref)  userorgroup                    Reference: 7064 7067 7077 7080

Variable (set w/rexx)   usersdefaultgroup              Assigned : 7249 7330
Variable (used in/rexx) usersdefaultgroup              Reference: 7258 7417

Variable (set w/rexx)   userslastdate                  Assigned : 7250 7330
Variable (used in/rexx) userslastdate                  Reference: 7260 7419

Variable (set w/rexx)   userslasttime                  Assigned : 7251 7330
Variable (used in/rexx) userslasttime                  Reference: 7261 7420

Variable (set w/rexx)   usersname                      Assigned : 7248 7330 7394 7396 7406
Variable (used in/rexx) usersname                      Reference: 7257 7392 7394 7396 7402 7406 7416

Variable (set w/rexx)   usersresumedate                Assigned : 7330
Variable (used in/rexx) usersresumedate                Reference: 7353 7364 7383

Variable (set w/rexx)   usersrevokedate                Assigned : 7330
Variable (used in/rexx) usersrevokedate                Reference: 7349 7355 7368 7383

Label (internal label)  USE_PRIV                       Defined  : 3809
Label (int. label ref)  USE_PRIV                       Reference: C(1237) C(1240) C(1243) C(1246)

Variable (set w/rexx)   value                          Assigned : 7148
Variable (used in/rexx) value                          Reference: 7153 7161 7167 7170
Built-In+/External use  VALUE                          Reference: F(6538) F(6540) F(6562) F(6591) F(6619) F(6621) F(7187) F(7207)

Variable (NEVER SET)    VEAC0E                         Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Ref)  VEAC0E                         Reference: 2198 2200

Variable (NEVER SET)    VIEW2TABLE                     Not Assgn: EITHER used as upper case value OR set via cmd
Variable (used in/rexx) VIEW2TABLE                     Reference: 3022

Variable (set w/rexx)   viewcreator                    Assigned : 2160
Variable (used in/rexx) viewcreator                    Reference: 2160 2164 2187
Variable (in Stem Set)  viewcreator                    Assigned : 2171 2174 2184 2191

Variable (set w/rexx)   viewname                       Assigned : 2161
Variable (used in/rexx) viewname                       Reference: 2161 2164 2188
Variable (in Stem Set)  viewname                       Assigned : 2171 2174 2184 2191

Variable (set w/rexx)   wgrant                         Assigned : 3186 3304 3374 3379 3404 3492 3497
Variable (used in/rexx) wgrant                         Reference: 3187 3191 3305 3385 3405 3505

Built-In+/External use  WORD                           Reference: F(3276) F(3333) F(3372) F(6712) F(6719) F(6772) F(6787) F(6795) F(6825) F(6827)
                        ...                                       F(6834) F(6870) F(6906) F(6978) F(6986) F(7014) F(7016) F(7020) F(7028)

Variable (set w/rexx)   word1                          Assigned : 908 6585
Variable (used in/rexx) word1                          Reference: 909 910 6586

Variable (set w/rexx)   word2                          Assigned : 6585
Variable (NEVER USED)   word2                          No Ref.  : If actually referenced, it must be via a cmd.

Variable (set w/rexx)   word3                          Assigned : 6585
Variable (NEVER USED)   word3                          No Ref.  : If actually referenced, it must be via a cmd.

Built-In+/External use  WORDPOS                        Reference: F(575) F(580) F(585) F(590) F(597) F(604) F(617) F(622) F(631) F(634) F(643)
                        ...                                       F(648) F(654) F(660) F(668) F(671) F(680) F(685) F(693) F(696) F(705) F(709)
                        ...                                       F(715) F(719) F(730) F(734) F(740) F(744) F(756) F(760) F(766) F(770) F(2826)

Built-In+/External use  WORDS                          Reference: F(3275) F(6719)

Variable (set w/rexx)   x                              Assigned : 622 634 648 660 671 685 696 709 719 734 744 760 770 913 1596 1606 1610 1612 1613
                        ...                                       1614 1617 1618 1619 1620 1621 1623 1624 1625 1626 1627 1628 1629 1632 1634 1635
                        ...                                       1636 1637 1640 1641 1642 1643 1644 1646 1647 1648 1649 1650 1651 1652 1655 1657
                        ...                                       1695 1698 1712 1714 1715 1716 1718 1719 1720 1721 1724 1725 1726 1727 1728 1729
                        ...                                       1731 1732 1733 1734 1735 1736 1737 1738 1739 1742 1743 1744 1745 1746 1747 1748
                        ...                                       1749 1750 1753 1754 1755 1756 1757 1758 1760 1761 1762 1763 1764 1765 1766 1767
                        ...                                       1768 1771 1772 1774 1790 1838 1840 1854 1859 1861 1862 1866 1867 1868 1871 1895
                        ...                                       1898 1909 1911 1912 1916 1918 1919 1923 1924 1927 1947 1960 1962 1963 1967 1969
                        ...                                       1970 1973 1974 1975 1976 1981 1985 1986 1989 2005 2037 2039 2041 2043 2045 2049
                        ...                                       2051 2053 2055 2057 2075 2077 2079 2080 2082 2084 2085 2086 2110 2112 2114 2115
                        ...                                       2117 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133
                        ...                                       2211 2213 2214 2221 2223 2224 2240 2242 2256 2258 2267 2269 2270 2272 2274 2275
                        ...                                       2276 2277 2278 2279 2280 2281 2285 2289 2291 2292 2293 2294 2295 2296 2300 2304
                        ...                                       2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321
                        ...                                       2322 2323 2324 2325 2357 2362 2365 2423 2425 2427 2429 2430 2432 2434 2435 2436
                        ...                                       2437 2438 2439 2440 2444 2449 2453 2455 2456 2457 2458 2459 2463 2467 2469 2470
                        ...                                       2471 2472 2592 2597 2600 2634 2636 2638 2640 2642 2644 2646 2648 2650 2651 2653
                        ...                                       2655 2657 2658 2659 2660 2661 2662 2663 2667 2672 2676 2678 2679 2680 2681 2682
                        ...                                       2686 2690 2692 2693 2694 2695 2795 2798 2842 2844 2846 2848 2850 2852 2854 2856
                        ...                                       2858 2859 2910 2912 2913 2914 2915 2916 2917 2918 2919 2921 2922 2926 2930 2934
                        ...                                       2938 2940 2941 2942 2943 2944 2948 2952 2954 2955 2956 2957 2958 2959 2960 2961
                        ...                                       2965 2967 2968 3050 3099 3101 3102 3106 3108 3109 3123 3125 3127 3129 3131 3133
                        ...                                       3134 3138 3140 3142 3144 3146 3148 3149 3326 3338 3341 3347 3350 3359 3360 3367
                        ...                                       3368 3390 3445 3448 3456 3459 3467 3470 3477 3480 3483 3486 3510 3558 3560 3562
                        ...                                       3564 3566 3571 3573 3575 3577 3579 3586 3588 3598 3599 3607 3609 3611 3613 3614
                        ...                                       3615 3616 3617 3618 3619 3620 3621 3622 3623 3624 3625 3626 3647 3650 3660 3662
                        ...                                       3664 3666 3667 3668 3669 3670 3671 3672 3673 3674 3675 3676 3677 3678 3698 3727
                        ...                                       3729 3731 3733 3734 3735 3736 3737 3738 3739 3740 3741 3742 3743 3744 3745 3746
                        ...                                       3747 3748 3749 3753 3754 3757 3779 3795 3797 3798 3801 3803 3804 3823 3825 3848
                        ...                                       3849 3865 3867 3871 3873 3874 3896 3899 3910 3912 3916 3918 3919 3920 3921 3943
                        ...                                       3956 3958 3959 3963 3965 3966 3967 3968 3971 3972 3973 3974 3979 3981 4008 4033
                        ...                                       4035 4046 4047 4052 4054 4055 4056 4057 4058 4059 4060 4061 4062 4063 4064 4065
                        ...                                       4066 4067 4068 4069 4070 4071 4072 4073 4074 4075 4076 4077 4078 4079 4080 4081
                        ...                                       4082 4083 4084 4085 4086 4108 4137 4140 4156 4158 4159 4160 4161 4162 4163 4164
                        ...                                       4165 4166 4167 4168 4169 4170 4171 4172 4173 4174 4177 4178 4179 4180 4185 4187
                        ...                                       4189 4190 4191 4192 4193 4194 4195 4196 4197 4198 4199 4200 4201 4202 4203 4204
                        ...                                       4205 4206 4207 4208 4211 4212 4213 4214 4219 4221 4222 4243 4288 4290 4298 4302
                        ...                                       4303 4327 4328 4330 4331 4332 4333 4334 4335 4336 4337 4338 4339 4340 4341 4342
                        ...                                       4343 4344 4345 4346 4347 4348 4349 4350 4351 4352 4353 4354 4355 4356 4357 4358
                        ...                                       4359 4360 4361 4362 4363 4364 4365 4366 4367 4368 4369 4370 4371 4372 4373 4374
                        ...                                       4375 4376 4377 4378 4379 4415 4420 4423 4469 4474 4477 4498 4499 4501 4502 4503
                        ...                                       4504 4505 4509 4511 4530 4533 4547 4548 4550 4551 4552 4553 4557 4561 4563 4564
                        ...                                       4565 4566 4567 4568 4569 4570 4571 4572 4574 4575 4576 4577 4578 4579 4580 4581
                        ...                                       4582 4583 4584 4585 4586 4587 4588 4589 4593 4594 4595 4596 4613 4616 4633 4634
                        ...                                       4635 4636 4637 4638 4639 4643 4647 4649 4650 4651 4652 4653 4654 4655 4656 4657
                        ...                                       4658 4660 4685 4699 4701 4702 4703 4704 4708 4712 4714 4715 4716 4717 4718 4719
                        ...                                       4720 4721 4722 4723 4725 4726 4727 4728 4729 4730 4731 4732 4733 4734 4735 4736
                        ...                                       4737 4738 4739 4740 4744 4745 4746 4747 4777 4785 4826 4828 4836 4837 4841 4843
                        ...                                       4844 4845 4846 4847 4848 4849 4850 4851 4852 4853 4854 4855 4856 4857 4858 4859
                        ...                                       4860 4861 4862 4863 4864 4865 4866 4867 4868 4869 4890 4893 4913 4921 4925 4943
                        ...                                       4945 4946 4947 4948 4949 4950 4951 4952 4953 4954 4955 4956 4957 4958 4959 4960
                        ...                                       4961 4962 4963 4964 4967 4968 4969 4970 4975 4977 4979 4980 4981 4982 4983 4984
                        ...                                       4985 4986 4987 4988 4989 4990 4991 4992 4993 4994 4995 4996 4997 4998 4999 5000
                        ...                                       5001 5002 5005 5006 5007 5008 5013 5015 5016 5034 5058 5060 5061 5062 5063 5086
                        ...                                       5094 5100 5108 5110 5111 5112 5113 5117 5118 5119 5120 5121 5126 5128 5143 5176
                        ...                                       5178 5190 5193 5195 5196 5197 5198 5199 5200 5201 5202 5203 5204 5205 5206 5207
                        ...                                       5208 5209 5210 5211 5212 5213 5214 5215 5246 5249 5263 5265 5266 5267 5268 5269
                        ...                                       5270 5271 5272 5273 5274 5275 5276 5277 5278 5279 5280 5284 5285 5286 5287 5288
                        ...                                       5289 5294 5296 5315 5340 5342 5354 5355 5358 5360 5361 5362 5363 5364 5365 5366
                        ...                                       5367 5368 5369 5370 5371 5372 5373 5374 5375 5376 5377 5378 5379 5380 5412 5415
                        ...                                       5430 5432 5433 5434 5435 5436 5437 5438 5439 5440 5441 5442 5443 5444 5445 5446
                        ...                                       5447 5451 5452 5453 5454 5455 5460 5462 5480 5505 5507 5519 5520 5523 5525 5526
                        ...                                       5527 5528 5529 5530 5531 5532 5533 5534 5535 5536 5537 5538 5539 5540 5541 5542
                        ...                                       5543 5544 5545 5546 5547 5548 5580 5583 5600 5602 5603 5604 5605 5606 5607 5608
                        ...                                       5609 5610 5611 5612 5613 5614 5615 5616 5617 5618 5619 5622 5623 5624 5625 5626
                        ...                                       5631 5633 5654 5671 5673 5674 5675 5676 5677 5678 5679 5680 5681 5682 5683 5684
                        ...                                       5685 5686 5687 5688 5689 5690 5691 5692 5693 5694 5695 5696 5697 5698 5699 5702
                        ...                                       5703 5704 5705 5706 5711 5713 5714 5715 5716 5717 5718 5719 5720 5721 5722 5723
                        ...                                       5724 5726 5751 5773 5781 5785 5788 5789 5790 5794 5796 5811 5814 5824 5826 5827
                        ...                                       5828 5829 5830 5844 5857 5859 5860 5861 5862 5863 5866 5867 5868 5869 5870 5872
                        ...                                       5873 5874 5875 5876 5877 5881 5883 5900 5923 5925 5926 5927 5928 5929 5930 5931
                        ...                                       5935 5951 5954 5964 5966 5967 5968 5969 5970 5971 5972 5973 5974 5975 5976 5977
                        ...                                       5978 5979 5980 5981 5982 5983 5984 5985 5986 5987 5988 5989 5990 6006 6019 6021
                        ...                                       6022 6023 6024 6025 6026 6029 6030 6031 6032 6033 6035 6036 6037 6038 6039 6040
                        ...                                       6041 6042 6043 6044 6045 6046 6047 6051 6052 6053 6054 6055 6056 6061 6066 6067
                        ...                                       6068 6069 6070 6071 6072 6075 6076 6077 6078 6079 6081 6082 6083 6084 6085 6086
                        ...                                       6087 6088 6089 6090 6091 6092 6093 6098 6099 6100 6101 6102 6103 6108 6110 6128
                        ...                                       6159 6161 6169 6170 6174 6176 6177 6178 6179 6180 6181 6182 6183 6184 6185 6186
                        ...                                       6187 6188 6189 6190 6191 6192 6193 6194 6195 6196 6197 6198 6199 6200 6201 6202
                        ...                                       6203 6204 6205 6206 6207 6208 6209 6210 6211 6212 6213 6214 6215 6216 6217 6218
                        ...                                       6219 6220 6240 6243 6263 6269 6273 6289 6291 6292 6293 6294 6295 6296 6297 6298
                        ...                                       6299 6300 6301 6302 6303 6304 6305 6306 6307 6308 6309 6310 6311 6312 6313 6314
                        ...                                       6315 6316 6317 6318 6321 6322 6323 6324 6329 6331 6333 6334 6335 6336 6337 6338
                        ...                                       6339 6340 6341 6342 6343 6344 6345 6346 6347 6348 6349 6350 6351 6352 6353 6354
                        ...                                       6355 6356 6357 6358 6359 6360 6361 6362 6363 6366 6367 6368 6369 6374 6376 6377
                        ...                                       6396 6509 6510 6512 6517 6520 6521 6527 6528 6530 6546 6549 6552 6553 6562 7119
                        ...                                       7131 7187 7207 7523 7526 7529 7531 7538 7541 7544 7546
Variable (used in/rexx) x                              Reference: 623 625 635 637 649 651 661 663 672 674 686 688 697 699 710 712 720 722 735 737
                        ...                                       745 747 761 763 771 773 7120 7121 7123 7125 7129

Variable (set w/rexx)   xsysadm                        Assigned : 1114 5147
Variable (used in/rexx) xsysadm                        Reference: 5147 5149
Variable (in Stem Set)  xsysadm                        Assigned : 5148

Variable (set w/rexx)   xxx                            Assigned : 1307 1323 1341 1357 1373 1391 1409
Variable (used in/rexx) xxx                            Reference: 1318 1334 1352 1368 1382 1400 1413 1415
Variable (in Stem Ref)  xxx                            Reference: 1308 1310 1313 1324 1326 1329 1342 1344 1347 1358 1360 1363 1374 1376 1379 1392
                        ...                                       1394 1397 1410 1418

Variable (set w/rexx)   yyyy                           Assigned : 7242
Variable (used in/rexx) yyyy                           Reference: 7243

Label (internal label)  ZSQL                           Defined  : 6490
Label (int. label ref)  ZSQL                           Reference: C(1659) C(1776) C(1873) C(1929) C(1991) C(2088) C(2135) C(2327) C(2474) C(2697)
                        ...                                       C(2970) C(3628) C(3680) C(3759) C(3876) C(3923) C(3983) C(4088) C(4224) C(4381)
                        ...                                       C(4513) C(4597) C(4662) C(4749) C(4871) C(5018) C(5065) C(5130) C(5216) C(5298)
                        ...                                       C(5382) C(5464) C(5550) C(5635) C(5728) C(5798) C(5832) C(5885) C(5937) C(5992)
                        ...                                       C(6111) C(6222) C(6379)

Variable (set w/rexx)   zsqlsigl                       Assigned : 6491 6570
Variable (used in/rexx) zsqlsigl                       Reference: 6502 6594 6656 6659
    xref (1 of 2) ends here
    xref (1 of 2) ends here
    -----------------------

    xref (2 of 2) section 2 is for stem variable xreference.
    xref (2 of 2) section 2 is for stem variable xreference.
    ----------------------------------------------------------
       note:     Assignments/references to rexx stems
              is only for stem references in rexx code
              itself.

                 Therefore, references to stem variables
              that are made INSIDE of quotes, say as
              part of an EXECIO command, will NOT show
              up in the XREF as they are part of a "string
              constant" and not used as a rexx variable or
              rexx stem directly.

                 This is because it often may not be obvious
              which address environment a command may (or may
              not) be valid in.  Or for us to know all the
              ways a rexx stem might be used.

    ----------------------------------------------------------







Stem-1 BUFFERRECS.ddname                                Assigned : 6946 6948
Stem-1 BUFFERRECS.ddname                                Reference: 558 1288 6482 6684 6823
Stem-1 BUFFERRECS.pe$ddname                             Assigned : 1009 1015 1021 1027 1033 1039 1045 1051
Stem-1 BUFFERRECS.rdefddname                            Assigned : 958 964 970 976 982 988 994 1000

Stem-2 BUFFERX.ddname.clistx                            Assigned : 6826 6831 6834 6838 6840 6845 6847 6849 6853 6855 6857 6861 6867 6870 6875 6877
       ...                                                         6882 6884 6886 6890 6892 6894 6898 6903 6906 6913 6915 6917 6921 6923 6925 6929
Stem-2 BUFFERX.ddname.clistx                            Reference: 6836 6838 6840 6841 6843 6845 6847 6851 6853 6855 6873 6875 6877 6878 6880
       ...                                                         6882 6884 6888 6890 6892 6909 6911 6913 6915 6919 6921 6923

Stem-1 CLASSINDX.                                       Assigned : 1062
Stem-1 CLASSINDX.useclass                               Assigned : 6780
Stem-1 CLASSINDX.useclass                               Reference: 6776 6782

Stem-1 CLASSLIST.classlist                              Assigned : 6779
Stem-1 CLASSLIST.classnum                               Reference: 1453 1459

Stem-1 DELETEID.                                        Assigned : 896
Stem-1 DELETEID.excludeid                               Assigned : 7053
Stem-1 DELETEID.uidx                                    Reference: 6754 6960

Stem-1 EXCLIST.0                                        Assigned : 900
Stem-1 EXCLIST.0                                        Reference: 907
Stem-1 EXCLIST.exclist                                  Reference: 908 913

Stem-1 EXCLUDE.                                         Assigned : 892
Stem-1 EXCLUDE.exclude                                  Assigned : 7047
Stem-1 EXCLUDE.ii                                       Reference: 949

Stem-1 EXCLUDEINDX.                                     Assigned : 894
Stem-1 EXCLUDEINDX.excludeid                            Assigned : 7049
Stem-1 EXCLUDEINDX.uidx                                 Reference: 6757 6760 6963 6966
Stem-1 EXCLUDEINDX.xxx                                  Reference: 1310 1326 1344 1360 1376 1394

Stem-1 FEWTABLES4CREATOR.                               Assigned : 2261
Stem-1 FEWTABLES4CREATOR.lastcreator                    Assigned : 2370 2371 2381 2382 2403 2404
Stem-1 FEWTABLES4CREATOR.tcreator                       Assigned : 2347
Stem-1 FEWTABLES4CREATOR.tcreator                       Reference: 2486 2784 2787 3042

Stem-1 GRANTINGENERIC.                                  Assigned : 4664
Stem-2 GRANTINGENERIC.collid.0                          Assigned : 4673
Stem-2 GRANTINGENERIC.collid.0                          Reference: 4673 4674 4773 4774
Stem-2 GRANTINGENERIC.collid.grantingeneric             Assigned : 4675
Stem-2 GRANTINGENERIC.collid.i4                         Reference: 4775

Stem-1 GROUPCREATEDATE.group                            Assigned : 7314

Stem-1 GROUPDESC.                                       Assigned : 7235
Stem-1 GROUPDESC.gix                                    Reference: 7083
Stem-1 GROUPDESC.group                                  Assigned : 7317

Stem-1 GROUPINDX.                                       Assigned : 7233
Stem-1 GROUPINDX.grantee                                Reference: 2985 3000
Stem-1 GROUPINDX.groupname                              Assigned : 7310
Stem-1 GROUPINDX.groupname                              Reference: 7284
Stem-1 GROUPINDX.racfgroup                              Reference: 7487
Stem-1 GROUPINDX.uidx                                   Reference: 6800 6991
Stem-1 GROUPINDX.userorgroup                            Reference: 7077 7080
Stem-1 GROUPINDX.xxx                                    Reference: 1418

Stem-1 GROUPMEMBERS.gix                                 Reference: 1419
Stem-1 GROUPMEMBERS.group                               Assigned : 7320
Stem-1 GROUPMEMBERS.groupindx                           Assigned : 7490
Stem-1 GROUPMEMBERS.groupindx                           Reference: 7490

Stem-1 GROUPMEMBERSSTATUS.gix                           Reference: 1420
Stem-1 GROUPMEMBERSSTATUS.group                         Assigned : 7321
Stem-1 GROUPMEMBERSSTATUS.groupindx                     Assigned : 7491
Stem-1 GROUPMEMBERSSTATUS.groupindx                     Reference: 7491

Stem-1 GROUPMODEL.group                                 Assigned : 7318

Stem-1 GROUPNAME.                                       Assigned : 7234
Stem-1 GROUPNAME.group                                  Assigned : 7311

Stem-1 GROUPOWNER.group                                 Assigned : 7315

Stem-1 GROUPREF.                                        Assigned : 7236
Stem-1 GROUPREF.gix                                     Assigned : 7081

Stem-1 GROUPUACC.group                                  Assigned : 7316

Stem-1 GROUPUNIVERSAL.group                             Assigned : 7319

Stem-1 HANDLEDCOLLID.                                   Assigned : 4275
Stem-1 HANDLEDCOLLID.collid                             Assigned : 4404
Stem-1 HANDLEDCOLLID.collid                             Reference: 4395
Stem-1 HANDLEDCOLLID.lastcollid                         Assigned : 4458

Stem-1 HDR.#                                            Assigned : 940 941 942 943 944 945 946 1056
Stem-1 HDR.0                                            Assigned : 939
Stem-1 HDR.hdr                                          Assigned : 949

Stem-1 IGNOREDTABLEGRANTEE.                             Assigned : 2065
Stem-1 IGNOREDTABLEGRANTEE.grantee                      Assigned : 2991 2995
Stem-1 IGNOREDTABLEGRANTEE.grantee                      Reference: 2989 2995
Stem-1 IGNOREDTABLEGRANTEE.nextg                        Reference: 1510

Stem-1 LONGPRIV.                                        Assigned : 3166
Stem-1 LONGPRIV.longpriv                                Assigned : 3215 3242
Stem-1 LONGPRIV.nextindx                                Reference: 3229

Stem-1 LONGPRIVCOUNT.longpriv                           Assigned : 3216 3243
Stem-1 LONGPRIVCOUNT.nextindx                           Assigned : 3254
Stem-1 LONGPRIVCOUNT.nextindx                           Reference: 3254 3255 3257

Stem-1 LONGPRIVINDX.                                    Assigned : 3167
Stem-1 LONGPRIVINDX.hashkey                             Assigned : 3218
Stem-1 LONGPRIVINDX.hashkey                             Reference: 3211 3227

Stem-1 LONGPRIVNEXTHASH.longpriv                        Assigned : 3217 3244
Stem-1 LONGPRIVNEXTHASH.privindx                        Assigned : 3238
Stem-1 LONGPRIVNEXTHASH.privindx                        Reference: 3231

Stem-1 OPENDDS.i                                        Reference: 557 1287 6481 6683
Stem-1 OPENDDS.opendds                                  Assigned : 959 965 971 977 983 989 995 1001 1010 1016 1022 1028 1034 1040 1046 1052

Stem-1 OPTCLSTX.optclstx                                Assigned : 1301 1303 1305 1320 1336 1339 1354 1370 1384 1387 1389 1402 1405 1407 1415 1424
       ...                                                         1433 1434 1439 1441 1451 1453 1459 1480 1483 1486 1490 1493 1497 1499 1504 1510
       ...                                                         1531 1534 1537 1543 1549 3154 3157 3160 3180 3196 3273 3280 7015 7018 7020 7021
       ...                                                         7023 7025 7028 7030 7034 7036
Stem-1 OPTCLSTX.optclstx                                Reference: 3176 7021 7023 7030 7034

Stem-1 PACKAGEOWNER.                                    Assigned : 2090
Stem-1 PACKAGEOWNER.grantee                             Reference: 2985 3000
Stem-1 PACKAGEOWNER.packageowner                        Assigned : 2098

Stem-1 PACKAGETABLEGRANTEE.                             Assigned : 2068
Stem-1 PACKAGETABLEGRANTEE.grantee                      Assigned : 3007 3011
Stem-1 PACKAGETABLEGRANTEE.grantee                      Reference: 3005 3011

Stem-1 PE$INDX.                                         Assigned : 1008
Stem-1 PE$INDX.pe$class                                 Assigned : 1014 1020 1026 1032 1038 1044 1050
Stem-1 PE$INDX.useclass                                 Reference: 6745

Stem-1 PERMITSBYCLASS.                                  Assigned : 1063
Stem-2 PERMITSBYCLASS.classindx.uidindx                 Assigned : 6784
Stem-2 PERMITSBYCLASS.classindx.uidindx                 Reference: 6784
Stem-2 PERMITSBYCLASS.classnum.uidnum                   Reference: 1456 1459

Stem-1 RACFSMRY.0                                       Reference: 7265
Stem-1 RACFSMRY.racfsmry                                Reference: 7275 7280 7330 7427

Stem-1 RDEFINDX.                                        Assigned : 957
Stem-1 RDEFINDX.rdefclass                               Assigned : 963 969 975 981 987 993 999
Stem-1 RDEFINDX.useclass                                Reference: 6742 6746

Stem-1 REPLACE.                                         Assigned : 895
Stem-1 REPLACE.exclude                                  Assigned : 7048
Stem-1 REPLACE.replace                                  Reference: 6761 6967

Stem-1 REVOKED.uidx                                     Reference: 1314 1316 1330 1332 1348 1350 1364 1366 1380 1398
Stem-1 REVOKED.uix                                      Reference: 7070 7074 7101
Stem-1 REVOKED.userid                                   Assigned : 7093 7256 7415

Stem-1 RPHTABLE.                                        Assigned : 2614
Stem-1 RPHTABLE.rphtable                                Assigned : 2809
Stem-1 RPHTABLE.tablenumber                             Reference: 3196 3418

Stem-1 RPHTABLEAUDITING.                                Assigned : 2624
Stem-1 RPHTABLEAUDITING.rphtable                        Assigned : 2810
Stem-1 RPHTABLEAUDITING.tablenumber                     Reference: 3406 3408 3426 3438 3461

Stem-1 RPHTABLECREATOR.                                 Assigned : 2617
Stem-1 RPHTABLECREATOR.creator                          Reference: 3171
Stem-1 RPHTABLECREATOR.creatornumber                    Assigned : 2827
Stem-1 RPHTABLECREATOR.creatornumber                    Reference: 2826 2827
Stem-1 RPHTABLECREATOR.rphtablecreator                  Assigned : 2819

Stem-1 RPHTABLECREATORINDX.                             Assigned : 2618
Stem-1 RPHTABLECREATORINDX.tcreator                     Assigned : 2820
Stem-1 RPHTABLECREATORINDX.tcreator                     Reference: 2816 2822

Stem-1 RPHTABLEINDX.                                    Assigned : 2615
Stem-1 RPHTABLEINDX.ssidtable                           Assigned : 2811
Stem-1 RPHTABLEINDX.ssidtable                           Reference: 2805 2813 3060

Stem-1 RPHTABLEPRIV.                                    Assigned : 2619
Stem-2 RPHTABLEPRIV.tablenumber.auth                    Assigned : 3063
Stem-2 RPHTABLEPRIV.tablenumber.auth                    Reference: 3063 3185 3303 3403

Stem-1 RPHTABLESCHEMAGRANTEECOUNT.                      Assigned : 2625
Stem-2 RPHTABLESCHEMAGRANTEECOUNT.tbcreator.gw          Reference: 3280
Stem-2 RPHTABLESCHEMAGRANTEECOUNT.tcreator.grantee      Assigned : 3069 3073
Stem-2 RPHTABLESCHEMAGRANTEECOUNT.tcreator.grantee      Reference: 3067 3073

Stem-1 RPHTABLESCHEMAGRANTEELIST.                       Assigned : 2626
Stem-1 RPHTABLESCHEMAGRANTEELIST.tbcreator              Reference: 3269 3275 3276
Stem-1 RPHTABLESCHEMAGRANTEELIST.tcreator               Assigned : 3070
Stem-1 RPHTABLESCHEMAGRANTEELIST.tcreator               Reference: 3070

Stem-1 RPHTABLEWGRANT.                                  Assigned : 2620
Stem-2 RPHTABLEWGRANT.tablenumber.auth                  Reference: 3186 3304 3404

Stem-1 SINGLETABLEINVIEW.                               Assigned : 2146
Stem-2 SINGLETABLEINVIEW.DISETS.VEAC0E                  Reference: 2198
Stem-2 SINGLETABLEINVIEW.tcreator.tbname                Reference: 3426 3432 3438 3450
Stem-2 SINGLETABLEINVIEW.tcreator.ttname                Reference: 2493 2521 2527 2552 2715 2736 2742 2756
Stem-2 SINGLETABLEINVIEW.viewcreator.viewname           Assigned : 2171 2184

Stem-1 SQLERRD.#                                         *Special: Assigned via an ADDR env cmd and/or REXX itself
Stem-1 SQLERRD.#                                        Reference: 6440 6636

Stem-2 SQLSTMT.sqlstmtvalue.0                           Assigned : 7185 7192
Stem-2 SQLSTMT.sqlstmtvalue.0                           Reference: 6559 7190
Stem-2 SQLSTMT.sqlstmtvalue.iii                         Reference: 6560
Stem-2 SQLSTMT.sqlstmtvalue.LASTSQLCALLER               Assigned : 7208
Stem-2 SQLSTMT.sqlstmtvalue.LASTSQLCALLER               Reference: 6504 6514 6522 6532
Stem-2 SQLSTMT.sqlstmtvalue.mmm                         Reference: 6541
Stem-2 SQLSTMT.sqlstmtvalue.sqlstmt                     Assigned : 7193
Stem-2 SQLSTMT.sqlstmtvalue.STARTSQLCALLER              Assigned : 7186
Stem-2 SQLSTMT.sqlstmtvalue.STARTSQLCALLER              Reference: 6504 6513 6522 6531
Stem-2 SQLSTMT.stmtcursornum.LASTSQLCALLER              Reference: 6596 6603 6609 6617
Stem-2 SQLSTMT.stmtcursornum.mmm                        Reference: 6622
Stem-2 SQLSTMT.stmtcursornum.STARTSQLCALLER             Reference: 6596 6602 6609 6616

Stem-1 SQLWARN.#                                         *Special: Assigned via an ADDR env cmd and/or REXX itself
Stem-1 SQLWARN.#                                        Reference: 6447 6643

Stem-1 SUPERGRPNAME.group                               Assigned : 7313

Stem-1 UID.ii                                           Reference: 1307 1320 1323 1336 1341 1354 1357 1370 1373 1384 1391 1402 1409
Stem-1 UID.uid                                          Assigned : 6769 6975
Stem-1 UID.uidnum                                       Reference: 1445 1446 1457 1459

Stem-1 UIDINDX.                                         Assigned : 1060
Stem-1 UIDINDX.uidx                                     Assigned : 6770 6976
Stem-1 UIDINDX.uidx                                     Reference: 6766 6783 6972

Stem-1 USERID.                                          Assigned : 7239
Stem-1 USERID.0                                         Assigned : 7090 7505
Stem-1 USERID.0                                         Reference: 7088 7512
Stem-1 USERID.userid                                    Assigned : 7092 7255 7414

Stem-1 USERIDINDX.                                      Assigned : 7238
Stem-1 USERIDINDX.grantee                               Reference: 2985 3000
Stem-1 USERIDINDX.racfuserid                            Assigned : 7254 7413
Stem-1 USERIDINDX.racfuserid                            Reference: 7441
Stem-1 USERIDINDX.uidx                                  Reference: 6807 6998
Stem-1 USERIDINDX.userorgroup                           Assigned : 7091
Stem-1 USERIDINDX.userorgroup                           Reference: 7064 7067
Stem-1 USERIDINDX.xxx                                   Reference: 1308 1313 1324 1329 1342 1347 1358 1363 1374 1379 1392 1397 1410

Stem-1 USERREF.                                         Assigned : 7240
Stem-1 USERREF.uix                                      Assigned : 7068 7099

Stem-1 USERSDGROUP.uix                                  Reference: 7071 7074 7101
Stem-1 USERSDGROUP.userid                               Assigned : 7095 7258 7417

Stem-1 USERSGROUPS.userid                               Assigned : 7096 7259 7418

Stem-1 USERSLASTDATE.userid                             Assigned : 7260 7419

Stem-1 USERSLASTTIME.userid                             Assigned : 7261 7420

Stem-1 USERSNAME.uix                                    Reference: 7071 7074 7101
Stem-1 USERSNAME.userid                                 Assigned : 7094 7257 7416

Stem-1 VIEW2TABLE.                                      Assigned : 2137
Stem-2 VIEW2TABLE.DISETS.VEAC0E                         Reference: 2200
Stem-2 VIEW2TABLE.tcreator.ttname                       Reference: 2495 2500 2718 2721 2723 3019 3024 3026
Stem-2 VIEW2TABLE.viewcreator.viewname                  Assigned : 2174 2191

Stem-1 XSYSADM.xsysadm                                  Assigned : 5148

Stem-1 XSYSADMINDX.                                     Assigned : 1113
Stem-1 XSYSADMINDX.grantee                              Assigned : 5149
    xref (2 of 2) ends here
    xref (2 of 2) ends here
    -----------------------


 ------------ tips for label references ----------------------------
 ------------ tips for label references ----------------------------
     tip:  c# is a ref to CALL stmt to this   internal/external name
     tip:  f# is a ref to FUNCTION call to    internal/external function
     tip:  s# is a ref to SIGNAL stmt to this internal label


 ------------ now xreference for stem variables (tips) -------------
 ------------ now xreference for stem variables (tips) -------------
     tip:     Note:- stem variables (after 1st period) are in lower case
     tip:          - stem "constants" (will be shown in UPPER case)
     tip:          - stem "constants" that are whole numbers (and not 0)
     tip:               will be summarized as a # sign (in place of
     tip:               individual digits/numbers) so it summarizes them.
     tip:     What XREF for stems can help you fix:
     tip:     -------------------------------------
     tip:      - seeing a variable (lower case) used in a stem where you
     tip:       EXPECTED it to always be a constant.
     tip:      - seeing a constant (upper case) used in a stem where you
     tip:       EXPECTED it to be a variable (maybe it was misspelled).
     tip:                                              )
     tip:line sample rexx code (followed by sample xref)
     tip:---- ------------
     tip:  1     x = "Richard"
     tip:  2     firstName.y.x.1 = "Hi"
     tip:  3     firstName.y.x.2 = "Buddy"
     tip:  4     firstName.y.x.0 = 2
     tip:
     tip:sample xref listing
     tip:-----------
     tip:  --xref section 1 (variables)
     tip:  --xref section 1 (variables)
     tip:
     tip:Variable (set)         X               Assigned : 1
     tip:Variable(w/ stem use): X               Reference: 2 3 4
     tip:Constant(w/ stem use): Y               Reference: 2 3 4
     tip:
     tip:  --xref section 2 (stem variables)
     tip:  --xref section 2 (stem variables)
     tip:
     tip:Stem-3 FIRSTNAME.Y.x.#                 Assigned : 2 3
     tip:Stem-3 FIRSTNAME.Y.x.0                 Assigned : 4
     tip:                                       Reference: 2 3 4
     tip:     note:  Stem-3 refers to # of periods in the stem.
     tip:
     tip:  rexx tip: remember stem value on the right is "tricky":
     tip:        Given following rexx code:
     tip:             x = "RICHARD.HUMPHRIS"
     tip:             y = "RICHARD"
     tip:             z = "HUMPHRIS"
     tip:        References to a stem variable, as shown below, are
     tip:          referring to the SAME stem variable:
     tip:             stem.x     refers to STEM.RICHARD.HUMPHRIS
     tip:             stem.y.z   refers to STEM.RICHARD.HUMPHRIS
     tip:        This is because x contains a period.  And because
     tip:          everything to the right of the first period is evaluated
     tip:          first.  Then the stem variable is "looked up".
     tip:
     tip:   rexx tip:  referencing pgm above, if you set variable "a"
     tip:         to a upper/lower case value.  The stem will NOT upper
     tip:         case it.
     tip:        So if assignment statement set "a" to "richard"
     tip:         then stem.y is NOT the same as stem.a
     tip:        Because stem.y    refers to STEM.RICHARD
     tip:        and     stem.a    refers to STEM.richard
     tip:
