   ==> Scan of exec succeeded (rc <= 4)
   -------------------------------------------------
    1) See trace 's' exec in:
          SFRH66.PUBLIC.REXXXREF.SAMPLE.SCAN(RACLOGIC)

    2) Trace listing + XREF listing in:
          SFRH66.PUBLIC.REXXXREF.SAMPLE.XREF(RACLOGIC)
   -----------------------------------------

READY
    RACLOGIC
    Generated scan code/comment:   trace 's'
    Generated scan code/comment:   /*  rexx member for scan/xref was: */
    Generated scan code/comment:   /*     "SFRH66.CNTL.RACFDB2.PDS(RACLOGIC)"      */
    Generated scan code/comment:   /*      ---------------------------------       */
    Generated scan code/comment:   /*  date/time of XREF was:                      */
    Generated scan code/comment:   /*     20231217 23:04:52                        */
    Generated scan code/comment:   /*      ---------------------------------       */
     1 *-* /* rexx */
     2 *-* /* ***************************************************************** */
     3 *-* /* raclogic - rexx exec                                              */
     4 *-* /* ***************************************************************** */
     5 *-* /*                                                                   */
     6 *-* /* purpose:  Only for human's to read the RDEFs and PERMITs in a     */
     7 *-* /*    way that makes it easier for us to process.                    */
     8 *-* /*                                                                   */
     9 *-* /*    It is totally unneccesary to use this rexx exec.  Or to run    */
    10 *-* /*    the job RACLOG$T which invokes this rexx exec.                 */
    11 *-* /*                                                                   */
    12 *-* /*    However, the output will group the RDEFs and it's associated   */
    13 *-* /*    permits togeather.  Which will help anyone who wishes to       */
    14 *-* /*    validate the RACF output.                                      */
    15 *-* /*                                                                   */
    16 *-* /*    Note:  for MDSNPK, priviledges granted to collid.* will be     */
    17 *-* /*    added to any specific collid.packagename for BIND, COPY,       */
    18 *-* /*    EXECUTE, etc. priviledges.                                     */
    19 *-* /*                                                                   */
    20 *-* /* ***************************************************************** */
    21 *-* /*                                                                   */
    22 *-* /*    Sometimes a group of rdef's will be generated, followed by     */
    23 *-* /* a group of permits for those rdefs.                               */
    24 *-* /*                                                                   */
    25 *-* /*    This will resequence output (and delete comments) so that      */
    26 *-* /* any permits for an rdef will be grouped with that rdef.           */
    27 *-* /*                                                                   */
    28 *-* /* ***************************************************************** */
    29 *-* /*    input1 should contain permits, maybe from PE$TB for example    */
    30 *-* /*    input2 should contain permits, maybe from PE$TB for example    */
    31 *-* /*    input3 should contain RDEFs,   maybe from RDEFTB for example   */
    32 *-* /*                                                                   */
    33 *-* /*      --                                                           */
    34 *-* /*      or they call all be the same file when (noPE was specified)  */
    35 *-* /*      --                                                           */
    36 *-* /*      So, wehen the noPE option is used, then:                     */
    37 *-* /*    input1 should contain permits, maybe from RDEFTB for example   */
    38 *-* /*    input2 should contain permits, maybe from RDEFTB for example   */
    39 *-* /*    input3 should contain RDEFs,   maybe from RDEFTB for example   */
    40 *-* /*                                                                   */
    41 *-* /*    The reason for 2 PE files is that sometimes permits are        */
    42 *-* /*    not generated by the same sql statement, so we need to two     */
    43 *-* /*    input streams to match them all up.                            */
    44 *-* /*                                                                   */
    45 *-* /*    output gets the RDEF and PERMITs in logical groupings without  */
    46 *-* /*          comments.                                                */
    47 *-* /*                                                                   */
    48 *-* /*          This doesn't change any functionality, but makes it      */
    49 *-* /*         easier for humans to understand rdef/permits.             */
    50 *-* /*                                                                   */
    51 *-* /*          The other value is if you want to compare output from    */
    52 *-* /*         one version to another, it also simplifies things.        */
    53 *-* /*                                                                   */
    54 *-* /*                                                                   */
    55 *-* /* ***************************************************************** */
    56 *-* address 'TSO'
    58 *-* 'EXECIO 0 DISKW OUTPUT (OPEN' /* open output file */
    59 *-* outputRc = rc
    60 *-* output = 0 /* no records currently in output buffer */
    62 *-* 'EXECIO 100 DISKR INPUT1 (OPEN STEM INPUT1.' /* read block of recs */
    63 *-* input1Rc = rc
    64 *-* input1   = 0 /* no input1 records processed yet */
    66 *-* 'EXECIO 100 DISKR INPUT2 (OPEN STEM INPUT2.' /* read block of recs */
    67 *-* input2rc = rc
    68 *-* input2   = 0 /* no input2 records processed yet */
    70 *-* 'EXECIO 100 DISKR INPUT3 (OPEN STEM INPUT3.' /* read block of recs */
    71 *-* input3rc = rc
    72 *-* input3   = 0 /* no input2 records processed yet */
    74 *-* if (input1rc <> 0 & input1rc <> 2) , /*   bad open for input1 */         | (input2rc <> 0 & input2rc <> 2) , /*or bad op
en for input2 */         | (input3rc <> 0 & input3rc <> 2) , /*or bad open for input2 */         | outputRc <> 0
  /*or bad open for output */
    78 *-*  then
       *-*  do /* open problems */
    79 *-*   if outputRc <> 0
    80 *-*    then
       *-*    say 'Open for ddname=OUTPUT failed with rc='outputRc
    81 *-*   if input1Rc <> 0 & input1Rc <> 2
    82 *-*    then
       *-*    say 'Open for ddname=INPUT1 failed with rc='input1Rc
    83 *-*   if input2Rc <> 0 & input2Rc <> 2
    84 *-*    then
       *-*    say 'Open for ddname=INPUT2 failed with rc='input2Rc
    85 *-*   if input3Rc <> 0 & input3Rc <> 2
    86 *-*    then
       *-*    say 'Open for ddname=INPUT3 failed with rc='input3Rc
    87 *-*   'EXECIO 0 DISKW OUTPUT (FINIS'
    88 *-*   'EXECIO 0 DISKR INPUT1 (FINIS'
    89 *-*   'EXECIO 0 DISKR INPUT2 (FINIS'
    90 *-*   'EXECIO 0 DISKR INPUT3 (FINIS'
    91 *-*   say 'aborting due to open failures, with rc=8'
    92 *-*   exit 8
    93 *-*  end
    95 *-* rdef = ''
    96 *-* data = ''
    97 *-* permit = ''
    98 *-* totalInput1 = 0
    99 *-* totalInput2 = 0
   100 *-* totalInput3 = 0
   101 *-* /* read input1 skipping ... and only stop skipping when we get to a  */
   102 *-* /*                          real permit that we need to output the   */
   103 *-* /*                          rdef first                               */
   104 *-* do forever
   105 *-*  input1 = input1 + 1  /* get next input1 rec to process */
   106 *-*  if input1 > input1.0 /* out of recs in input1 buffer? */
   107 *-*   then
       *-*   do
   108 *-*    if input1Rc = 2 /* out of records in input1 file? */
   109 *-*     then
       *-*     leave      /* ...yes, leave loop now */
   110 *-*    'EXECIO 100 DISKR INPUT1 (STEM INPUT1.'
   111 *-*    input1 = 0
   112 *-*    input1Rc = rc
   113 *-*    if input1Rc = 0 | input1Rc = 2
   114 *-*     then
       *-*     iterate /* we have a block of recs to process, iterate */
   116 *-*     /* report i/o error and close files */
   117 *-*    say 'Read for ddname=INPUT1 failed with rc='input1Rc
   118 *-*    'EXECIO' output 'DISKW OUTPUT (stem output. FINIS'
   119 *-*    'EXECIO 0 DISKR INPUT1 (FINIS'
   120 *-*    'EXECIO 0 DISKR INPUT2 (FINIS'
   121 *-*    'EXECIO 0 DISKR INPUT3 (FINIS'
   122 *-*    say 'aborting now with rc=8'
   123 *-*    exit 8
   124 *-*   end
   125 *-*  totalInput1 = totalInput1 + 1
   126 *-*  word1 = word(input1.input1,1)
   127 *-*  if word1 = ''
       *-*   then
       *-*   iterate
   128 *-*  if left(word1,2) = '/*'
       *-*   then
       *-*   iterate
   129 *-*  if word1 = 'RDEF'
       *-*   then
       *-*   iterate
   130 *-*  if left(word1,5) = 'DATA('
       *-*   then
       *-*   iterate
   131 *-*  if word1 = 'PERMIT' & wordpos('RESET',input1.input1) > 0
   132 *-*   then
       *-*   iterate
   133 *-*  if word1 = 'PE'     & wordpos('RESET',input1.input1) > 0
   134 *-*   then
       *-*   iterate
   135 *-*  if word1 = 'PERMIT'
   136 *-*   then
       *-*   do
   137 *-*    /* we found a explicit permit */
   138 *-*    /* so set the "permitProfileKey" so we can find a matching rdef */
   139 *-*    /* ...and leave so we can find rdef in next loop.               */
   140 *-*    parse var input1.input1 . permitProfileKey1 .
   141 *-*    startPermit1 = totalinput1
   142 *-*    break1 = totalinput1 /* initialize */
   143 *-*    leave
   144 *-*   end
   145 *-*  if word1 = 'PE'
   146 *-*   then
       *-*   do
   147 *-*    /* we found a explicit permit */
   148 *-*    /* so set the "permitProfileKey" so we can find a matching rdef */
   149 *-*    /* ...and leave so we can find rdef in next loop.               */
   150 *-*    parse var input1.input1 . permitProfileKey1 .
   151 *-*    startPermit1 = totalinput1
   152 *-*    break1 = totalinput1 /* initialize */
   153 *-*    leave
   154 *-*   end
   155 *-* end
   156 *-* if input1 > input1.0 & input1rc <> 2
   157 *-*  then
       *-*  do
   158 *-*   /* fatal error, close files and exit */
   159 *-*   say 'Reading from ddname=INPUT2 the EXECIO failed with rc='input2Rc
   160 *-*   say 'closing files and exiting w/rc = 8'
   161 *-*   'EXECIO 0 DISKR INPUT1 (FINIS'
   162 *-*   'EXECIO 0 DISKR INPUT2 (FINIS'
   163 *-*   'EXECIO 0 DISKR INPUT3 (FINIS'
   164 *-*   'EXECIO' output 'DISKW OUTPUT (STEM OUTPUT. FINIS'
   165 *-*   exit 8
   166 *-*  end
   167 *-* if input1 > input1.0 & input1rc = 2
   168 *-*  then
       *-*  permitProfileKey1= '' /* we found no pending permit, just write */
   169 *-*  /* everything that's left                 */
   171 *-*  /* read input2 skipping ... first position ourselves at same record  */
   172 *-*  /*                          as input1.  Then skip past rows returned,*/
   173 *-*  /*                          then find the next permit (group).       */
   174 *-* if input1rc = 2 & input1 > input1.0 /* at eof on input1? */
   175 *-*  then
       *-*  do
   176 *-*   /* just simulate eof on input2, no need to read file */
   177 *-*   input2rc = 2
   178 *-*   input2 = input2.0 + 1
   179 *-*   permitProfileKey2 = ''
   180 *-*  end
   181 *-* else
       *-*  do
   182 *-*   /* otherwise, we need to reposition to totalinput1 position */
   183 *-*   /* ... and then to line "rowsReturned".                     */
   184 *-*   do forever
   185 *-*    input2 = input2 + 1  /* get next input2 rec to process */
   186 *-*    if input2 > input2.0 /* out of recs in input2 buffer? */
   187 *-*     then
       *-*     do
   188 *-*      if input2Rc = 2 /* out of records in input2 file? */
   189 *-*       then
       *-*       leave      /* ...yes, leave loop now */
   190 *-*      'EXECIO 100 DISKR INPUT2 (STEM INPUT2.'
   191 *-*      input2 = 0
   192 *-*      input2Rc = rc
   193 *-*      if input2Rc = 0 | input2Rc = 2
   194 *-*       then
       *-*       iterate /* we have a block of recs to process, iterate */
   196 *-*       /* report i/o error and close files */
   197 *-*      say 'Read for ddname=INPUT2 failed with rc='input2Rc
   198 *-*      'EXECIO' output 'DISKW OUTPUT (stem output. FINIS'
   199 *-*      'EXECIO 0 DISKR INPUT1 (FINIS'
   200 *-*      'EXECIO 0 DISKR INPUT2 (FINIS'
   201 *-*      'EXECIO 0 DISKR INPUT3 (FINIS'
   202 *-*      say 'aborting now with rc=8'
   203 *-*      exit 8
   204 *-*     end
   205 *-*    totalInput2 = totalInput2 + 1
   206 *-*    if totalInput2 < totalInput1
       *-*     then
       *-*     iterate /*position to input1 */
   208 *-*     /* start looking for "rows returned, only after we're past the */
   209 *-*     /* input1 position.                                            */
   210 *-*    word2 = word(input2.input2,2)
   211 *-*    if word2 = 'rowsReturned'
       *-*     then
       *-*     leave
   212 *-*   end
   213 *-*   /* now we want to position input2 to 2nd group of permits */
   214 *-*   /* ...past those input1 is looking at.                    */
   215 *-*   do forever
   216 *-*    input2 = input2 + 1  /* get next input2 rec to process */
   217 *-*    if input2 > input2.0 /* out of recs in input2 buffer? */
   218 *-*     then
       *-*     do
   219 *-*      if input2Rc = 2 /* out of records in input2 file? */
   220 *-*       then
       *-*       leave      /* ...yes, leave loop now */
   221 *-*      'EXECIO 100 DISKR INPUT2 (STEM INPUT2.'
   222 *-*      input2 = 0
   223 *-*      input2Rc = rc
   224 *-*      if input2Rc = 0 | input2Rc = 2
   225 *-*       then
       *-*       iterate /* we have a block of recs to process, iterate */
   227 *-*       /* report i/o error and close files */
   228 *-*      say 'Read for ddname=INPUT2 failed with rc='input2Rc
   229 *-*      'EXECIO' output 'DISKW OUTPUT (stem output. FINIS'
   230 *-*      'EXECIO 0 DISKR INPUT1 (FINIS'
   231 *-*      'EXECIO 0 DISKR INPUT2 (FINIS'
   232 *-*      'EXECIO 0 DISKR INPUT3 (FINIS'
   233 *-*      say 'aborting now with rc=8'
   234 *-*      exit 8
   235 *-*     end
   236 *-*    totalInput2 = totalInput2 + 1
   237 *-*    word1 = word(input2.input2,1)
   238 *-*    if word1 = ''
       *-*     then
       *-*     iterate
   239 *-*    if left(word1,2) = '/*'
       *-*     then
       *-*     iterate
   240 *-*    if word1 = 'RDEF'
       *-*     then
       *-*     iterate
   241 *-*    if left(word1,5) = 'DATA('
       *-*     then
       *-*     iterate
   242 *-*    if word1 = 'PERMIT' & wordpos('RESET',input2.input2) > 0
   243 *-*     then
       *-*     iterate
   244 *-*    if word1 = 'PE'     & wordpos('RESET',input2.input2) > 0
   245 *-*     then
       *-*     iterate
   246 *-*    if word1 = 'PERMIT'
   247 *-*     then
       *-*     do
   248 *-*      /* we found a explicit permit */
   249 *-*      /* so set the "permitProfileKey2"...to find a matching rdef */
   250 *-*      /* ...and leave so we can find rdef in next loop.           */
   251 *-*      parse var input2.input2 . permitProfileKey2 .
   252 *-*      startPermit2 = totalinput2
   253 *-*      break2 = totalinput2 /* initialize */
   254 *-*      leave
   255 *-*     end
   256 *-*    if word1 = 'PE'
   257 *-*     then
       *-*     do
   258 *-*      /* we found a explicit permit */
   259 *-*      /* so set the "permitProfileKey2"...to find a matching rdef */
   260 *-*      /* ...and leave so we can find rdef in next loop.           */
   261 *-*      parse var input2.input2 . permitProfileKey2 .
   262 *-*      startPermit2 = totalinput2
   263 *-*      break2 = totalinput2 /* initialize */
   264 *-*      leave
   265 *-*     end
   266 *-*   end
   267 *-*  end
   268 *-* if input2 > input2.0 & input2rc <> 2
   269 *-*  then
       *-*  do
   270 *-*   /* fatal error, close files and exit */
   271 *-*   say 'Reading from ddname=INPUT2 the EXECIO failed with rc='input2Rc
   272 *-*   say 'closing files and exiting w/rc = 8'
   273 *-*   'EXECIO 0 DISKR INPUT1 (FINIS'
   274 *-*   'EXECIO 0 DISKR INPUT2 (FINIS'
   275 *-*   'EXECIO 0 DISKR INPUT3 (FINIS'
   276 *-*   'EXECIO' output 'DISKW OUTPUT (STEM OUTPUT. FINIS'
   277 *-*   exit 8
   278 *-*  end
   279 *-* if input2 > input2.0 & input2rc = 2
   280 *-*  then
       *-*  permitProfileKey2= '' /* we found no pending permit, just write */
   281 *-*  /* everything that's left                 */
   283 *-*  /* -------------------------------------------------------------------*/
   284 *-*  /* at this time, INPUT1 will be positioned at the 1st group of permits*/
   285 *-*  /* at this time, INPUT2 will be positioned at the 2nd group of permits*/
   286 *-*  /* and input3, we will use to find rdefs                              */
   287 *-*  /* -------------------------------------------------------------------*/
   289 *-*  /* ------------------------------------------------------------------ */
   290 *-*  /* now start the process to find and output rdefs, ralts, and permits */
   291 *-*  /* ------------------------------------------------------------------ */
   292 *-* do while (input1rc = 0 | input2rc = 0 | input3rc = 0),/*input has data*/       | input1rc = 2 & input1 <= input1.0 ,/* i
nput1 not at eof)    */        | input2rc = 2 & input2 <= input2.0 ,/* input2 not at eof)  */          | input3rc = 2 & input3 <= i
nput3.0  /* input3 not at eof) */
   296 *-*  /*  ...but pending eof   */
   297 *-*  /* while we have data in buffers, we may have an actual PERMIT   */
   298 *-*  /*    PERMIT pending in input1.input1 (or at eof on input1)      */
   299 *-*  /*    PERMIT pending in input2.input2 (or at eof on input2)      */
   300 *-*  /* we need to write out all RDEF/DATA/PERMIT's in input3 until we*/
   301 *-*  /*    find a matching RDEF/DATA/PERMIT for input1/input2 permit  */
   303 *-*  do while input3rc = 0 | (input3rc = 2 & input3 <= input3.0)
   304 *-*   /* keep writting out rdef/data/pemit (reset) sequences we find*/
   305 *-*   /*    in input3.input3                                        */
   306 *-*   /* stop when last sequence (we put in output buffer) matches  */
   307 *-*   /*    the pending (explicit) permit we have in input1.input1  */
   308 *-*   /*                                       or in input2.input2  */
   310 *-*   /* output buffer management, nothing to do with loop logic */
   311 *-*   if output > 100 /* output buffer too full?              */
   312 *-*    then
       *-*    do         /* ...yes, then empty output buffer now */
   313 *-*     /* let's write out an output buffer */
   314 *-*     'EXECIO' output 'DISKW OUTPUT (STEM OUTPUT.'
   315 *-*     output = 0
   316 *-*     outputRc = rc
   317 *-*     if outputRc > 0
   318 *-*      then
       *-*      do
   319 *-*       say 'Error writting to ddname=OUTPUT, rc='outputrc
   320 *-*       say 'aborting now'
   321 *-*       'EXECIO 0 DISKR INPUT1 (FINIS'
   322 *-*       'EXECIO 0 DISKR INPUT2 (FINIS'
   323 *-*       'EXECIO 0 DISKR INPUT3 (FINIS'
   324 *-*       'EXECIO 0 DISKW OUTPUT (FINIS'
   325 *-*       exit 8
   326 *-*      end
   327 *-*      /* output buffer emptied, next buffer ready */
   328 *-*    end
   330 *-*   input3 = input3 + 1  /* get next input3 record to process */
   331 *-*   if input3 > input3.0 /* out of recs in input3 buffer? */
   332 *-*    then
       *-*    do
   333 *-*     if input3Rc = 2 /* out of records in input3 file? */
   334 *-*      then
       *-*      leave      /* ...yes, leave loop now */
   336 *-*      /* get another buffer of input3 records */
   337 *-*     'EXECIO 100 DISKR INPUT3 (STEM INPUT3.'
   338 *-*     input3 = 0 /* no records processed in new buffer */
   339 *-*     input3Rc = rc /* remember execio rc for input2 */
   340 *-*     if input3Rc = 0 | input3Rc = 2 /* ensure good rc on execio */
   341 *-*      then
       *-*      iterate /* we have a block of recs to process */
   343 *-*      /* report i/o error and close files */
   344 *-*     say 'Read for ddname=INPUT3 failed with rc='input3Rc
   345 *-*     'EXECIO' output 'DISKW OUTPUT (stem output. FINIS'
   346 *-*     'EXECIO 0 DISKR INPUT1 (FINIS'
   347 *-*     'EXECIO 0 DISKR INPUT2 (FINIS'
   348 *-*     'EXECIO 0 DISKR INPUT3 (FINIS'
   349 *-*     say 'aborting now with rc=8'
   350 *-*     exit 8
   351 *-*     leave /* leave if bad input2Rc */
   352 *-*    end
   354 *-*    /* we have input record in input2.input2 */
   355 *-*   totalInput3 = totalInput3 + 1 /* count total input3 recs seen*/
   357 *-*   /* set word1 for this input record... to speed tests */
   358 *-*   word1 = word(input3.input3,1)
   359 *-*   if word1 = ''
       *-*    then
       *-*    iterate
   360 *-*   if left(word1,2) = '/*'
       *-*    then
       *-*    iterate
   361 *-*   if word1 = 'RDEF'
   362 *-*    then
       *-*    do
   363 *-*     /* output RDEF record (in RDEF, DATA, PERMIT w/RESET sequence*/
   364 *-*     parse var input3.input3 . rdefClass rdefProfileKey .
   365 *-*     output = output + 1
       *-*     output.output = input3.input3
   366 *-*     iterate /* now get data card in sequence */
   367 *-*    end
   369 *-*   if word1 = 'RALT'
   370 *-*    then
       *-*    do
   371 *-*     /* output RALT record (in RALT, DATA sequence */
   372 *-*     parse var input3.input3 . rdefClass rdefProfileKey .
   373 *-*     output = output + 1
       *-*     output.output = input3.input3
   374 *-*     iterate /* now get data card in sequence */
   375 *-*    end
   377 *-*   if left(word1,5) = 'DATA('
   378 *-*    then
       *-*    do
   379 *-*     /* output DATA record (in RDEF, DATA, PERMIT w/RESET sequence*/
   380 *-*     output = output + 1
       *-*     output.output = input3.input3
   381 *-*     iterate /* now get permit w/ reset in sequence */
   382 *-*    end
   384 *-*   if word1 = 'PERMIT' & wordpos('RESET',input3.input3) > 0
   385 *-*    then
       *-*    do
   386 *-*     /* reset profile found */
   387 *-*     output = output + 1
       *-*     output.output = input3.input3
   389 *-*     /* now after outputing RDEF/DATA/PERMIT w/RESET sequence */
   390 *-*     /* check to see if this rdef is for our pending permit   */
   391 *-*     /* from input1.input1                                    */
   392 *-*     if rdefProfileKey = permitProfileKey1 ,                                  | rdefProfileKey = permitProfileKey2
   394 *-*      then
       *-*      leave   /* time 2 write real permits 4 this profile_key */
   395 *-*     else
       *-*      iterate /* not right rdef/data/permit seq, keep looking */
   396 *-*     /* ... and keep writing out the next rdef/data/ */
   397 *-*     /* ... permit sequence(s) until we find a match.*/
   398 *-*    end
   400 *-*   if word1 = 'PE'     & wordpos('RESET',input3.input3) > 0
   401 *-*    then
       *-*    do
   402 *-*     /* reset profile found */
   403 *-*     output = output + 1
       *-*     output.output = input3.input3
   405 *-*     /* now after outputing RDEF/DATA/PERMIT w/RESET sequence */
   406 *-*     /* check to see if this rdef is for our pending permit   */
   407 *-*     /* from input1.input1                                    */
   408 *-*     if rdefProfileKey = permitProfileKey1 ,                                  | rdefProfileKey = permitProfileKey2
   410 *-*      then
       *-*      leave   /* time 2 write real permits 4 this profile_key */
   411 *-*     else
       *-*      iterate /* not right rdef/data/permit seq, keep looking */
   412 *-*     /* ... and keep writing out the next rdef/data/ */
   413 *-*     /* ... permit sequence(s) until we find a match.*/
   414 *-*    end
   415 *-*  end
   417 *-*  /* if files are out of data, leave now */
   418 *-*  if (input3Rc = 2 & input3 > input3.0) ,                                  & (input2Rc = 2 & input2 > input2.0) ,
                          & (input1Rc = 2 & input1 > input1.0)
   421 *-*   then
       *-*   leave
   423 *-*   /* start writting out matching permits for rdef from input1 file */
   424 *-*  if rdefProfileKey = permitProfileKey1/* if match, write permit  */
   425 *-*   then
       *-*   do
   426 *-*    match = 'INPUT1'
   427 *-*    output = output + 1
       *-*    output.output = input1.input1
   428 *-*   end
   429 *-*  else
       *-*   if rdefProfileKey = permitProfileKey2 /*if match, write permit*/
   430 *-*    then
       *-*    do
   431 *-*     match = 'INPUT2'
   432 *-*     output = output + 1
       *-*     output.output = input2.input2
   433 *-*    end
   434 *-*   else
       *-*    if permitProfileKey1 = '',/* we're at eof, that's ok */                  & permitProfileKey2 = '' /* we're at eof, th
at's ok */
   436 *-*     then
       *-*     nop
   437 *-*    else
       *-*     do
   438 *-*      /* logically this can't happen, we have an explicit permit */
   439 *-*      /* with no matching rdef                                   */
   440 *-*      if permitProfileKey1 <> ''
   441 *-*       then
       *-*       do
   442 *-*        say 'logic error, permit at line' totalInput1 'in ddname=INPUT1:'
   443 *-*        say 'permitProfileKey1="'permitProfileKey1'"'
   444 *-*        say 'startPermit1='startPermit1
   445 *-*        say 'input1.'input1 '='input1.input1
   446 *-*        say 'But no matching RDEF found in ddname=INPUT3'
   447 *-*        say 'closing files, and exiting with rc=8'
   448 *-*       end
   449 *-*      if permitProfileKey2 <> ''
   450 *-*       then
       *-*       do
   451 *-*        say ' '
   452 *-*        say 'logic error, permit at line' totalInput2 'in ddname=INPUT2:'
   453 *-*        say 'permitProfileKey2="'permitProfileKey2'"'
   454 *-*        say 'startPermit2='startPermit2
   455 *-*        say 'input2.'input2 '='input2.input2
   456 *-*        say 'But no matching RDEF found in ddname=INPUT3'
   457 *-*        say 'closing files, and exiting with rc=8'
   458 *-*       end
   459 *-*      'EXECIO 0 DISKR INPUT1 (FINIS'
   460 *-*      'EXECIO 0 DISKR INPUT2 (FINIS'
   461 *-*      'EXECIO 0 DISKR INPUT3 (FINIS'
   462 *-*      'EXECIO' output 'DISKW OUTPUT (STEM OUTPUT. FINIS'
   463 *-*      exit 8
   464 *-*     end
   466 *-*  /* now write out other matching permits (until eof) or until we */
   467 *-*  /* find a new non-matching permit                               */
   468 *-*  if match = 'INPUT1'
   469 *-*   then
       *-*   do
   470 *-*    skip = 0 /* skipping not in effect */
   471 *-*    do while input1rc = 0 | (input1rc = 2 & input1 <= input1.0)
   472 *-*     input1 = input1 + 1 /* bump to next record in input1 buffer */
   473 *-*     if input1 > input1.0 /*input1 buffer empty? */
   474 *-*      then
       *-*      do              /*...yes, we need another buffer */
   475 *-*       if input1Rc = 2          /* if already pending eof */
   476 *-*        then
       *-*        do                  /* then it's real EOF now */
   477 *-*         permitProfileKey1= ''
   478 *-*         leave /* exit this do while loop */
   479 *-*        end
   481 *-*        /* read in next buffer of input records */
   482 *-*       'EXECIO 100 DISKR INPUT1 (STEM INPUT1.'
   483 *-*       input1 = 0     /* reset our buffer point */
   484 *-*       input1Rc = rc  /* save rc                */
   485 *-*       if input1Rc = 0 | input1Rc = 2 /* if good rc, iterate*/
   486 *-*        then
       *-*        iterate                   /*                    */
   488 *-*        /* report i/o error and close files */
   489 *-*       say 'Read for ddname=INPUT1 failed with rc='input1Rc
   490 *-*       'EXECIO' output 'DISKW OUTPUT (stem output. FINIS'
   491 *-*       'EXECIO 0 DISKR INPUT1 (FINIS'
   492 *-*       'EXECIO 0 DISKR INPUT2 (FINIS'
   493 *-*       'EXECIO 0 DISKR INPUT3 (FINIS'
   494 *-*       say 'aborting now with rc=8'
   495 *-*       exit 8
   496 *-*      end
   497 *-*     totalInput1 = totalInput1 + 1
   498 *-*     if totalInput1 = break2 /* we've reached the other */
   499 *-*      then
       *-*      do                 /* ...other group of  permits*/
   500 *-*       skip = 1 /* start skipping until we see 'rowsReturned' */
   501 *-*       iterate
   502 *-*      end
   504 *-*     if skip = 1,/* skipping in effect until we see "rowsReturned"*/          & totalInput1 < startPermit2
   506 *-*      then
       *-*      iterate /*skip until we match current set of permits */
   508 *-*     if skip = 1 /* skipping in effect until we see "rowsReturned"*/
   509 *-*      then
       *-*      if word(input1.input1,2) = 'rowsReturned'
   510 *-*       then
       *-*       do
   511 *-*        skip = 2 /* we no longer need to worry about skipping*/
   512 *-*        iterate  /* stop on next valid permit                */
   513 *-*       end
   514 *-*      else
       *-*       iterate /* continue skipping */
   515 *-*     else
       *-*      if word(input1.input1,2) = 'rowsReturned'
   516 *-*       then
       *-*       do
   517 *-*        skip = 2 /* we will need to reset our startPermit1   */
   518 *-*        iterate  /* stop on next valid permit                */
   519 *-*       end
   520 *-*      else
       *-*       nop    /* continue processing permits normally */
   522 *-*     word1 = word(input1.input1,1)
   523 *-*     if word1 <> 'PERMIT' & word1 <> 'PE'
       *-*      then
       *-*      iterate
   524 *-*     if wordpos('RESET',input1.input1) > 0
       *-*      then
       *-*      iterate
   526 *-*     if skip = 2
   527 *-*      then
       *-*      do
   528 *-*       startPermit1 = totalInput1 /* start of new permits */
   529 *-*       parse var input1.input1 . permitProfileKey1 .
   531 *-*       /* we may increase StartPermit1 multiple times, but we  */
   532 *-*       /* need to have input2 break on either our prior (lower)*/
   533 *-*       /* break1, or we may be forced to set a new break1      */
   534 *-*       if break1 < startPermit2
   535 *-*        then
       *-*        break1 = startPermit1/* we need to set new break for */
   536 *-*        /* input2.                      */
   538 *-*       skip = 0
   539 *-*      end
   541 *-*     parse var input1.input1 . permitProfileKey1 .
   542 *-*     if rdefProfileKey = permitProfileKey1
   543 *-*      then
       *-*      do
   544 *-*       output = output + 1
       *-*       output.output=input1.input1
   545 *-*       iterate /* maybe another permit can be written for rdef,*/
   546 *-*       /* keep reading                                 */
   547 *-*      end
   548 *-*     else
       *-*      if rdefProfileKey = permitProfileKey2
   549 *-*       then
       *-*       do
   550 *-*        match = 'INPUT2' /* also matches INPUT2 process that */
   551 *-*        output = output + 1
       *-*        output.output = input2.input2
   552 *-*        leave            /* leave the input1 do loop         */
   553 *-*       end
   554 *-*      else
       *-*       leave /* exit this "do while" loop; ...               */
   555 *-*     /* we have another pending permit 2 find rdef for*/
   556 *-*    end
   557 *-*   end
   558 *-*  if match = 'INPUT2'
   559 *-*   then
       *-*   do
   560 *-*    skip = 0 /* skipping not in effect */
   561 *-*    do while input2rc = 0 | (input2rc = 2 & input2 <= input2.0)
   562 *-*     input2 = input2 + 1 /* bump to next record in input2 buffer */
   563 *-*     if input2 > input2.0 /*input2 buffer empty? */
   564 *-*      then
       *-*      do              /*...yes, we need another buffer */
   565 *-*       if input2Rc = 2          /* if already pending eof */
   566 *-*        then
       *-*        do                  /* then it's real EOF now */
   567 *-*         permitProfileKey2= ''
   568 *-*         leave /* exit this do while loop */
   569 *-*        end
   571 *-*        /* read in next buffer of input records */
   572 *-*       'EXECIO 100 DISKR INPUT2 (STEM INPUT2.'
   573 *-*       input2 = 0     /* reset our buffer point */
   574 *-*       input2Rc = rc  /* save rc                */
   575 *-*       if input2Rc = 0 | input2Rc = 2 /* if good rc, iterate*/
   576 *-*        then
       *-*        iterate                   /*                    */
   578 *-*        /* report i/o error and close files */
   579 *-*       say 'Read for ddname=INPUT2 failed with rc='input2Rc
   580 *-*       'EXECIO' output 'DISKW OUTPUT (stem output. FINIS'
   581 *-*       'EXECIO 0 DISKR INPUT1 (FINIS'
   582 *-*       'EXECIO 0 DISKR INPUT2 (FINIS'
   583 *-*       'EXECIO 0 DISKR INPUT3 (FINIS'
   584 *-*       say 'aborting now with rc=8'
   585 *-*       exit 8
   586 *-*      end
   587 *-*     totalInput2 = totalInput2 + 1
   588 *-*     if totalInput2 = break1      /* we've reached the other */
   589 *-*      then
       *-*      do                      /* ...other group of  permits*/
   590 *-*       skip = 1 /* start skipping until we see 'rowsReturned' */
   591 *-*       iterate
   592 *-*      end
   594 *-*     if skip = 1,/* skipping in effect until we see "rowsReturned"*/          & totalInput2 < startPermit1
   596 *-*      then
       *-*      iterate /*skip until we match current set of permits */
   598 *-*     if skip = 1 /* skipping in effect until we see "rowsReturned"*/
   599 *-*      then
       *-*      if word(input2.input2,2) = 'rowsReturned'
   600 *-*       then
       *-*       do
   601 *-*        skip = 2 /* we no longer need to worry about skipping*/
   602 *-*        iterate  /* stop on next valid permit                */
   603 *-*       end
   604 *-*      else
       *-*       iterate /* continue skipping */
   605 *-*     else
       *-*      if word(input2.input2,2) = 'rowsReturned'
   606 *-*       then
       *-*       do
   607 *-*        skip = 2 /* we need to reset our startPermit2        */
   608 *-*        iterate  /* stop on next valid permit                */
   609 *-*       end
   610 *-*      else
       *-*       nop    /* continue processing permits normally */
   612 *-*     word1 = word(input2.input2,1)
   613 *-*     if word1 <> 'PERMIT' & word1 <> 'PE'
       *-*      then
       *-*      iterate
   614 *-*     if wordpos('RESET',input2.input2) > 0
       *-*      then
       *-*      iterate
   616 *-*     if skip = 2
   617 *-*      then
       *-*      do
   618 *-*       startPermit2 = totalInput2 /* start of new permits */
   619 *-*       parse var input2.input2 . permitProfileKey2 .
   621 *-*       /* we may increase StartPermit2 multiple times, but we  */
   622 *-*       /* need to have input1 break on either our prior (lower)*/
   623 *-*       /* break2, or we may be forced to set a new break2      */
   624 *-*       if break2 < startPermit1
   625 *-*        then
       *-*        break2 = startPermit2/* we need to set new break for */
   626 *-*        /* input1                       */
   627 *-*       skip = 0
   628 *-*      end
   630 *-*     parse var input2.input2 . permitProfileKey2 .
   631 *-*     if rdefProfileKey = permitProfileKey2
   632 *-*      then
       *-*      do
   633 *-*       output = output + 1
       *-*       output.output=input2.input2
   634 *-*       iterate /* maybe another permit can be written for rdef,*/
   635 *-*       /* keep reading                                 */
   636 *-*      end
   637 *-*     else
       *-*      leave /* exit this "do while" loop; ...               */
   638 *-*     /* we have another pending permit 2 find rdef for*/
   639 *-*    end
   640 *-*   end
   641 *-*   /* loop to find another RDEF */
   642 *-* end
   644 *-* pendingrc = 0
   645 *-* if input1rc <> 2
   646 *-*  then
       *-*  do
   647 *-*   say 'Error reading data from ddname=INPUT1 (after reading' ,                  totalInput1 'records) rc='input1rc
   649 *-*   pendingrc = 8
   650 *-*  end
   651 *-* 'EXECIO 0 DISKR INPUT1 (FINIS'
   653 *-* if input2rc <> 2
   654 *-*  then
       *-*  do
   655 *-*   say 'Error reading data from ddname=INPUT2 (after reading' ,                  totalInput2 'records) rc='input2rc
   657 *-*   pendingRc = 8
   658 *-*  end
   659 *-* 'EXECIO 0 DISKR INPUT2 (FINIS'
   661 *-* if input3rc <> 2
   662 *-*  then
       *-*  do
   663 *-*   say 'Error reading data from ddname=INPUT3 (after reading' ,                  totalInput3 'records) rc='input3rc
   665 *-*   pendingRc = 8
   666 *-*  end
   667 *-* 'EXECIO 0 DISKR INPUT3 (FINIS'
   669 *-* 'EXECIO' output 'DISKW OUTPUT (STEM OUTPUT. FINIS'
   670 *-* outputrc = rc
   671 *-* if outputRc <> 0
   672 *-*  then
       *-*  do
   673 *-*   say 'Error writing to ddname=OUTPUT; rc='outputRc
   674 *-*   exit 8
   675 *-*  end
   676 *-* if pendingrc = 8
   677 *-*  then
       *-*  exit 8
   678 *-* exit 0
READY
END


 ------------ now xreference begins -----------------------
 ------------ now xreference begins -----------------------


    xref (1 of 2) section 1 is for variables (not stem.'s)
    xref (1 of 2) section 1 is for variables (not stem.'s)
    ----------------------------------------------------------

       variables/labels are in "upperCase" if variable was never
                       assigned a value.

                        they are in "lowercase", otherwise.

       variables/stems set via a command, like EXECIO for
                       example, where the stem is within quotes
                       will not be shown in the xref as either
                       an assignment or a reference.

       Note special variables like:  RC, SIGL, can be assigned
                       values explictly.  But rexx can set them
                       as well implicitly.  Implicit assignments
                       are not in the xref.
    ----------------------------------------------------------



Address Envir.Constant: ADDRESS 'TSO'          Reference: 56

Variable (set w/rexx)   break1                 Assigned : 142 152 535
Variable (used in/rexx) break1                 Reference: 534 588

Variable (set w/rexx)   break2                 Assigned : 253 263 625
Variable (used in/rexx) break2                 Reference: 498 624

Variable (set w/rexx)   data                   Assigned : 96
Variable (NEVER USED)   data                   No Ref.  : If actually referenced, it must be via a cmd.

Variable (set w/rexx)   input1                 Assigned : 64 105 111 472 483
Variable (used in/rexx) input1                 Reference: 105 106 156 167 174 292 418 445 471 472 473
Variable (in Stem Ref)  input1                 Reference: 126 131 133 140 150 427 445 509 515 522 524 529 541 544

Variable (set w/rexx)   input1rc               Assigned : 63 112 484
Variable (used in/rexx) input1rc               Reference: 74 81 82 108 113 117 156 167 174 292 418 471 475 485 489 645 647

Variable (set w/rexx)   input2                 Assigned : 68 178 185 191 216 222 562 573
Variable (used in/rexx) input2                 Reference: 185 186 216 217 268 279 292 418 455 561 562 563
Variable (in Stem Ref)  input2                 Reference: 210 237 242 244 251 261 432 455 551 599 605 612 614 619 630 633

Variable (set w/rexx)   input2rc               Assigned : 67 177 192 223 574
Variable (used in/rexx) input2rc               Reference: 74 83 84 159 188 193 197 219 224 228 268 271 279 292 418 561 565 575 579 653 655

Variable (set w/rexx)   input3                 Assigned : 72 330 338
Variable (used in/rexx) input3                 Reference: 292 303 330 331 418
Variable (in Stem Ref)  input3                 Reference: 358 364 365 372 373 380 384 387 400 403

Variable (set w/rexx)   input3rc               Assigned : 71 339
Variable (used in/rexx) input3rc               Reference: 74 85 86 292 303 333 340 344 418 661 663

Built-In+/External use  LEFT                   Reference: F(128) F(130) F(239) F(241) F(360) F(377)

Variable (set w/rexx)   match                  Assigned : 426 431 550
Variable (used in/rexx) match                  Reference: 468 558

Variable (set w/rexx)   output                 Assigned : 60 315 365 373 380 387 403 427 432 544 551 633
Variable (used in/rexx) output                 Reference: 118 164 198 229 276 311 314 345 365 373 380 387 403 427 432 462 490 544 551 580 633 669
Variable (in Stem Set)  output                 Assigned : 365 373 380 387 403 427 432 544 551 633

Variable (set w/rexx)   outputrc               Assigned : 59 316 670
Variable (used in/rexx) outputrc               Reference: 74 79 80 317 319 671 673

Variable (set w/rexx)   pendingrc              Assigned : 644 649 657 665
Variable (used in/rexx) pendingrc              Reference: 676

Variable (set w/rexx)   permit                 Assigned : 97
Variable (NEVER USED)   permit                 No Ref.  : If actually referenced, it must be via a cmd.

Variable (set w/rexx)   permitprofilekey1      Assigned : 140 150 168 477 529 541
Variable (used in/rexx) permitprofilekey1      Reference: 392 408 424 434 440 443 542

Variable (set w/rexx)   permitprofilekey2      Assigned : 179 251 261 280 567 619 630
Variable (used in/rexx) permitprofilekey2      Reference: 392 408 429 434 449 453 548 631

SpecialVar(set no-XREF) RC                      *Special: No xref; set w/ADDR env cmd and/or REXX itself
SpecialVar(used w/rexx) RC                     Reference: 59 63 67 71 112 192 223 316 339 484 574 670

Variable (set w/rexx)   rdef                   Assigned : 95
Variable (NEVER USED)   rdef                   No Ref.  : If actually referenced, it must be via a cmd.

Variable (set w/rexx)   rdefclass              Assigned : 364 372
Variable (NEVER USED)   rdefclass              No Ref.  : If actually referenced, it must be via a cmd.

Variable (set w/rexx)   rdefprofilekey         Assigned : 364 372
Variable (used in/rexx) rdefprofilekey         Reference: 392 408 424 429 542 548 631

Variable (set w/rexx)   skip                   Assigned : 470 500 511 517 538 560 590 601 607 627
Variable (used in/rexx) skip                   Reference: 504 508 526 594 598 616

Variable (set w/rexx)   startpermit1           Assigned : 141 151 528
Variable (used in/rexx) startpermit1           Reference: 444 535 594 624

Variable (set w/rexx)   startpermit2           Assigned : 252 262 618
Variable (used in/rexx) startpermit2           Reference: 454 504 534 625

Variable (set w/rexx)   totalinput1            Assigned : 98 125 497
Variable (used in/rexx) totalinput1            Reference: 125 141 142 151 152 206 442 497 498 504 528 647

Variable (set w/rexx)   totalinput2            Assigned : 99 205 236 587
Variable (used in/rexx) totalinput2            Reference: 205 206 236 252 253 262 263 452 587 588 594 618 655

Variable (set w/rexx)   totalinput3            Assigned : 100 355
Variable (used in/rexx) totalinput3            Reference: 355 663

Built-In+/External use  WORD                   Reference: F(126) F(210) F(237) F(358) F(509) F(515) F(522) F(599) F(605) F(612)

Variable (set w/rexx)   word1                  Assigned : 126 237 358 522 612
Variable (used in/rexx) word1                  Reference: 127 128 129 130 131 133 135 145 238 239 240 241 242 244 246 256 359 360 361 369 377 384
                        ...                               400 523 613

Variable (set w/rexx)   word2                  Assigned : 210
Variable (used in/rexx) word2                  Reference: 211

Built-In+/External use  WORDPOS                Reference: F(131) F(133) F(242) F(244) F(384) F(400) F(524) F(614)
    xref (1 of 2) ends here
    xref (1 of 2) ends here
    -----------------------

    xref (2 of 2) section 2 is for stem variable xreference.
    xref (2 of 2) section 2 is for stem variable xreference.
    ----------------------------------------------------------
       note:     Assignments/references to rexx stems
              is only for stem references in rexx code
              itself.

                 Therefore, references to stem variables
              that are made INSIDE of quotes, say as
              part of an EXECIO command, will NOT show
              up in the XREF as they are part of a "string
              constant" and not used as a rexx variable or
              rexx stem directly.

                 This is because it often may not be obvious
              which address environment a command may (or may
              not) be valid in.  Or for us to know all the
              ways a rexx stem might be used.

    ----------------------------------------------------------







Stem-1 INPUT1.0           Reference: 106 156 167 174 292 418 471 473
Stem-1 INPUT1.input1      Reference: 126 131 133 140 150 427 445 509 515 522 524 529 541 544

Stem-1 INPUT2.0           Reference: 178 186 217 268 279 292 418 561 563
Stem-1 INPUT2.input2      Reference: 210 237 242 244 251 261 432 455 551 599 605 612 614 619 630 633

Stem-1 INPUT3.0           Reference: 292 303 331 418
Stem-1 INPUT3.input3      Reference: 358 364 365 372 373 380 384 387 400 403

Stem-1 OUTPUT.output      Assigned : 365 373 380 387 403 427 432 544 551 633
    xref (2 of 2) ends here
    xref (2 of 2) ends here
    -----------------------


 ------------ tips for label references ----------------------------
 ------------ tips for label references ----------------------------
     tip:  c# is a ref to CALL stmt to this   internal/external name
     tip:  f# is a ref to FUNCTION call to    internal/external function
     tip:  s# is a ref to SIGNAL stmt to this internal label


 ------------ now xreference for stem variables (tips) -------------
 ------------ now xreference for stem variables (tips) -------------
     tip:     Note:- stem variables (after 1st period) are in lower case
     tip:          - stem "constants" (will be shown in UPPER case)
     tip:          - stem "constants" that are whole numbers (and not 0)
     tip:               will be summarized as a # sign (in place of
     tip:               individual digits/numbers) so it summarizes them.
     tip:     What XREF for stems can help you fix:
     tip:     -------------------------------------
     tip:      - seeing a variable (lower case) used in a stem where you
     tip:       EXPECTED it to always be a constant.
     tip:      - seeing a constant (upper case) used in a stem where you
     tip:       EXPECTED it to be a variable (maybe it was misspelled).
     tip:                                              )
     tip:line sample rexx code (followed by sample xref)
     tip:---- ------------
     tip:  1     x = "Richard"
     tip:  2     firstName.y.x.1 = "Hi"
     tip:  3     firstName.y.x.2 = "Buddy"
     tip:  4     firstName.y.x.0 = 2
     tip:
     tip:sample xref listing
     tip:-----------
     tip:  --xref section 1 (variables)
     tip:  --xref section 1 (variables)
     tip:
     tip:Variable (set)         X               Assigned : 1
     tip:Variable(w/ stem use): X               Reference: 2 3 4
     tip:Constant(w/ stem use): Y               Reference: 2 3 4
     tip:
     tip:  --xref section 2 (stem variables)
     tip:  --xref section 2 (stem variables)
     tip:
     tip:Stem-3 FIRSTNAME.Y.x.#                 Assigned : 2 3
     tip:Stem-3 FIRSTNAME.Y.x.0                 Assigned : 4
     tip:                                       Reference: 2 3 4
     tip:     note:  Stem-3 refers to # of periods in the stem.
     tip:
     tip:  rexx tip: remember stem value on the right is "tricky":
     tip:        Given following rexx code:
     tip:             x = "RICHARD.HUMPHRIS"
     tip:             y = "RICHARD"
     tip:             z = "HUMPHRIS"
     tip:        References to a stem variable, as shown below, are
     tip:          referring to the SAME stem variable:
     tip:             stem.x     refers to STEM.RICHARD.HUMPHRIS
     tip:             stem.y.z   refers to STEM.RICHARD.HUMPHRIS
     tip:        This is because x contains a period.  And because
     tip:          everything to the right of the first period is evaluated
     tip:          first.  Then the stem variable is "looked up".
     tip:
     tip:   rexx tip:  referencing pgm above, if you set variable "a"
     tip:         to a upper/lower case value.  The stem will NOT upper
     tip:         case it.
     tip:        So if assignment statement set "a" to "richard"
     tip:         then stem.y is NOT the same as stem.a
     tip:        Because stem.y    refers to STEM.RICHARD
     tip:        and     stem.a    refers to STEM.richard
     tip:
