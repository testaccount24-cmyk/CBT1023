   ==> Scan of exec succeeded (rc <= 4)
   -------------------------------------------------
    1) See trace 's' exec in:
          SFRH66.PUBLIC.REXXXREF.SAMPLE.SCAN(PARTSHUT)

    2) Trace listing + XREF listing in:
          SFRH66.PUBLIC.REXXXREF.SAMPLE.XREF(PARTSHUT)
   -----------------------------------------

READY
    PARTSHUT
    Generated scan code/comment:   trace 's'
    Generated scan code/comment:   /*  rexx member for scan/xref was: */
    Generated scan code/comment:   /*     "SFRH66.CNTL.DB2(PARTSHUT)"      */
    Generated scan code/comment:   /*      -------------------------       */
    Generated scan code/comment:   /*  date/time of XREF was:              */
    Generated scan code/comment:   /*     20231217 23:02:19                */
    Generated scan code/comment:   /*      -------------------------       */
     1 *-* /***************************** REXX **********************************           ***************************************
******************************           *                                                                   *           *  Name:
PARTSHUT                                                  *           *
       *           *  Description:  Either part of the FULLSHUT cmd and/or             *           *    just the PARTSHUT command.
                                    *           *                In either case, the primary function of PARTSHUT is*           *
  to define the phases of how things will be brought down.       *           *                After defining the phase actions it w
ill enable the*           *    TOD rule SHUTPROC.  SHUTPROC will go thru the partshut phases  *           *    (and optionally) the
 fullshut phase as well.                   *           *                                                                   *
    *                                                                   *           ***********************************************
**********************           *                                                                   *           * CHG#  DATE     W
HO               DESCRIPTION                      *           * ----+--------+-------+------------------------------------------- *
           *      02/14/04 SCH059   Initial create                             *           *      04/16/04 SCH059   Added SHOW comm
and                         *           *      02/03/13 SFRH25   Added STOP for IRLM* resources             *           *      06/1
3/18 SFRH66   Added support for FULLSHUT command and     *           *                    updated process of bringing down tasks fo
r     *           *                    PARTSHUT and/or FULLSHUT.                      *           *                        Added PA
RTSHUT CANCEL command too.         *           *      02/18/19 SFRH66   Removed reference to PPRT5 (obsolete)      *           *
   10/21/19 SFRH66   Added                                      *           *                    phase 1:  (db2) stop ddf mode(quie
sce) cmds.   *           *                    phase 2:  (db2) stop ddf mode(force)   cmds.   *           *                    for p
hase 3, when we bring down db2(s) this    *           *                              should prevent any DDF hangs from    *
   *                              preventing DB2(s) from stopping.     *           *      02/16/20 SFRH66
                    *           *                    before, if fullshut, F DFHSM,HOLD ALL was      *           *
                       issued (in phase 1) which *           *                                         blocked all recalls.      *
          *                    now, we'll do HOLD ALL (before phase 1)  .     *           *                    but then RELEASE (ho
ld) on RECALL  in phase 1. *           *                    (find on DFHSM, to see changes)                *           *      01/04
/21 SFRH66                                              *           *                    removed (omegamon ims) CANSI5, as rule no
     *           *                         no longer exists for CANSI5.              *           *      01/19/21 SFRH66
                                  *           *                    shutdown IZUANG1 first (and let af/operator    *           *
                     stop it (not us) in phase 1.              *           *
            *           *                         We had issued p izusvr1 1st, in phase 1   *           *                         w
ithout af/operator control.              *           *                                                                   *
  *                    shutdown IZUSVR1 next  (and let af/operator    *           *                         stop it (not us) in pha
se 2.              *           *                                                                   *           *
      We had issued p izuang1 2nd, in phase 2.  *           *                         without af/operator control.              *
         *                                                                   *           *                    Remove IMS tasks from
 shutdown (no longer      *           *                         active any longer).                       *           *
                                                       *           *                    Remove DSN5/DSN6 commands from shutdown (no
    *           *                         longer exist).                            *           *      02/21/21 SFRH66
                                 *           *                    reverse, izusrvr1 before izuang1               *           *
 05/11/22 sfrh66                                              *           *                    add stop for AXR (system rexx) when
AXR04 is up*           *                    ...this address space is new with z/os 2.5     *           *      05/17/22 sfrh66
                                        *           *                    add stop for CFZCIM (in phase 1)               *
 *                    remove stops for izusrvr1 and izuang1 and let  *           *                    ... F OMVS,SHUTDOWN take them
 down in phase 4. *           *      08/17/22 sfrh66                                              *           *
add trap for IKT012D messages (where TSO stalls*           *                    coming down, where it want to procede (U) or   *
        *                    take a dump (reply DUMP).  For now, just reply *           *                    U.  Trap is SHUTTCAS a
nd there is a rexx by    *           *                    that name that will be fired.                  *           **************
*******************************************************/
    77 *-* trace r
    78 *-* parse upper arg cmd .
    80 *-* x = SYSVGET('AOSYSID') /* get system name ISDPROD or ISDTEST */
    81 *-* say 'AOSYSID='aosysid
    82 *-* x = SHARVGET('SYSTEM','GLOBAL.KPRESHUT.') /* get info on PRESHUT  */
    83 *-* x = SHARVGET('SYSTEM','GLOBAL.KPARTSHUT.') /* get info on PARTSHUT  */
    84 *-* x = SHARVGET('SYSTEM','GLOBAL.KFULLSHUT.') /* get info on FULLSHUT  */
    86 *-* if cmd = 'CANCEL' /* allow PARTSHUT cancel */
    87 *-*  then
       *-*  do /* also cancel's fullshut, if active */
    88 *-*   'TRAP DISABLE(SHUTWTOR)' /* end this from firing */
    89 *-*   'TRAP DISABLE(SHUTPROC)' /* end this from firing */
    90 *-*   'TRAP DISABLE(SHUTTCAS)' /* end this from firing */
    91 *-*   /* dom any highlighted wto's now */
    92 *-*   parse var GLOBAL.Kpreshut.Kpreshut001 dom1 .
    93 *-*   parse var GLOBAL.Kpreshut.Kpreshut002 dom2 .
    94 *-*   parse var GLOBAL.Kpreshut.Kpreshut003 dom3 .
    95 *-*   parse var GLOBAL.Kpreshut.Kpreshut004 dom4 .
    96 *-*   if dom1 <> '' & datatype(dom1,'W')
       *-*    then
       *-*    'DOM' dom1
    97 *-*   if dom2 <> '' & datatype(dom2,'W')
       *-*    then
       *-*    'DOM' dom2
    98 *-*   if dom3 <> '' & datatype(dom3,'W')
       *-*    then
       *-*    'DOM' dom3
    99 *-*   if dom4 <> '' & datatype(dom4,'W')
       *-*    then
       *-*    'DOM' dom4
   101 *-*    /* reinit global variables and exit */
   102 *-*   GLOBAL.Kpreshut.Kpreshut001 = ''
   103 *-*   GLOBAL.Kpreshut.Kpreshut002 = ''
   104 *-*   GLOBAL.Kpreshut.Kpreshut003 = ''
   105 *-*   "WTO 'PARTSHUT cancel completed'" ,                                                "ROUT(2) DESC(2)" ,
                                             "MSGID(PARTSH04) WTONO(GETDOM)"
   108 *-*   x = glbvget('GETDOM')
   109 *-*   GLOBAL.Kpreshut.Kpreshut004 = GETDOM date('b') time('s')
   110 *-*   GLOBAL.kSHUTPROCPHASE.kACTIVE = 0
   111 *-*   GLOBAL.kPARTSHUT.kACTIVE    = 0
   112 *-*   GLOBAL.kFULLSHUT.kACTIVE    = 0
   113 *-*   x = sharvput('SYSTEM','GLOBAL.KPRESHUT.KPRESHUT001')
   114 *-*   x = sharvput('SYSTEM','GLOBAL.KPRESHUT.KPRESHUT002')
   115 *-*   x = sharvput('SYSTEM','GLOBAL.KPRESHUT.KPRESHUT003')
   116 *-*   x = sharvput('SYSTEM','GLOBAL.KPRESHUT.KPRESHUT004')
   117 *-*   x = sharvput('SYSTEM','GLOBAL.KSHUTPROCPHASE.KACTIVE')
   118 *-*   x = sharvput('SYSTEM','GLOBAL.KPARTSHUT.KACTIVE')
   119 *-*   x = sharvput('SYSTEM','GLOBAL.KFULLSHUT.KACTIVE')
   120 *-*   return
   121 *-*  end
   122 *-* if GLOBAL.kSHUTPROCPHASE.kACTIVE > 0 ,                                           | GLOBAL.KPARTSHUT.KACTIVE     = 1
   124 *-*  then
       *-*  do
   125 *-*   parse var global.Kpreshut.Kpreshut004 dom4 .
   127 *-*   if dom4 <> '' & datatype(dom4,'W')
   128 *-*    then
       *-*    'DOM' dom4 /* unhighlight any outstanding wto's */
   130 *-*   "WTO 'PARTSHUT is still running, PARTSHUT cmd ignored'" ,                           "MSGID(PARTSH04) WTONO(GETDOM)"
   132 *-*   x = glbvget('GETDOM')
   133 *-*   GLOBAL.Kpreshut.Kpreshut004 = GETDOM date('b') time('s')
   134 *-*   x = sharvput('SYSTEM','GLOBAL.KPRESHUT.KPRESHUT004')
   135 *-*   return
   136 *-*  end
   138 *-*  /* ******************************************************** */
   139 *-*  /* Now we are in actual  "command" processing.  We need to  */
   140 *-*  /* begin the "PreShut" process of bringing down onlines and */
   141 *-*  /* quiesing things like DFHSM.                              */
   142 *-*  /* ******************************************************** */
   144 *-*  /* dom any highlighted wto's now */
   145 *-* parse var GLOBAL.Kpreshut.Kpreshut001 dom1 .
   146 *-* parse var GLOBAL.Kpreshut.Kpreshut002 dom2 .
   147 *-* parse var GLOBAL.Kpreshut.Kpreshut003 dom3 .
   148 *-* parse var GLOBAL.Kpreshut.Kpreshut004 dom4 .
   149 *-* if dom1 <> '' & datatype(dom1,'W')
       *-*  then
       *-*  'DOM' dom1
   150 *-* if dom2 <> '' & datatype(dom2,'W')
       *-*  then
       *-*  'DOM' dom2
   151 *-* if dom3 <> '' & datatype(dom3,'W')
       *-*  then
       *-*  'DOM' dom3
   152 *-* if dom4 <> '' & datatype(dom4,'W')
       *-*  then
       *-*  'DOM' dom4
   154 *-* GLOBAL.Kpreshut.Kpreshut001 = ''
   155 *-* GLOBAL.Kpreshut.Kpreshut002 = ''
   156 *-* GLOBAL.Kpreshut.Kpreshut003 = ''
   157 *-* GLOBAL.Kpreshut.Kpreshut004 = ''
   158 *-* GLOBAL.kSHUTPROCPHASE.kACTIVE = 0
   159 *-* GLOBAL.KPARTSHUT.KACTIVE = 0
   161 *-* /* call SetPhaseActions... define sequence for shutdown */
   162 *-* /* call SetPhaseActions... define sequence for shutdown */
   163 *-* /* ---------------------------------------------------- */
   165 *-* seterrors = 0
   166 *-* call SetPhaseActions /* set variables for actions to take now (later*/
   167 *-* /*     in this exec) or in the future.         */
   168 *-* if seterrors > 0
   169 *-*  then
       *-*  do /* this rule cannot process correctly */
   170 *-*   msg = 'SetPhaseActions failed, seterrors='seterrors
   171 *-*   "WTO '"msg"'" ,                                                                     "ROUT(2) DESC(2) MSGID(PARTSH03) W
TONO(GETDOM)"
   173 *-*   x = glbvget('GETDOM')
   174 *-*   GLOBAL.Kpreshut.Kpreshut003 = GETDOM date('b') time('s')
   175 *-*   x = sharvput('SYSTEM','GLOBAL.KPRESHUT.KPRESHUT003')
   176 *-*   return
   177 *-*  end
   179 *-*  /*  need to save global variables for SHUTPROC use */
   180 *-*  /*  ---------------------------------------------- */
   181 *-* x = SHARVPUT('SYSTEM','GLOBAL.KSETTASK.')    /* save info  */
   182 *-* x = SHARVPUT('SYSTEM','GLOBAL.KSETRCFTASK.') /* save info  */
   183 *-* x = SHARVPUT('SYSTEM','GLOBAL.KSETRCFGROUP.')/* save info  */
   184 *-* x = SHARVPUT('SYSTEM','GLOBAL.KSETCMD.')     /* save info  */
   186 *-* if cmd = 'TEST' /* test option: for checking SetPhaseActions only */
   187 *-*  then
       *-*  return     /* ... so exit now.                               */
   189 *-* if cmd <> ''
   190 *-*  then
       *-*  do
   191 *-*   /* partshut command has 3 options:                   */
   192 *-*   /*    <no option> normal partshut/fullshut operation */
   193 *-*   msg = 'PARTSHUT cmd ignored; only options are CANCEL or TEST'
   194 *-*   "WTO '"msg"'" ,                                                                     "ROUT(2) DESC(2) MSGID(PARTSH03) W
TONO(GETDOM)"
   196 *-*   x = glbvget('GETDOM')
   197 *-*   GLOBAL.Kpreshut.Kpreshut003 = GETDOM date('b') time('s')
   198 *-*   x = sharvput('SYSTEM','GLOBAL.KPRESHUT.KPRESHUT003')
   199 *-*   return
   200 *-*  end
   202 *-*  /* at this point, add some innocous commands to make sure */
   203 *-*  /* ...we can talk to ca70/ca72 later                      */
   204 *-* "OPER 'F CA70,/LOGON CONSOL'" /* tell ca70/ca72 to listen to */
   205 *-* "OPER 'F CA72,/LOGON CONSOL'" /* ...af/operator.             */
   207 *-* /* if fullshut, disable HSM now... in phase 1, reenable for recall*/
   208 *-* if global.kFULLSHUT.kACTIVE = 1   /* is fullshut in progress? */
   209 *-*  then
       *-*  "OPER 'F DFHSM,HOLD ALL'"    /* yes, quiesce DFHSM now   */
   211 *-*  /* now add add/enable some traps for PARTSHUT/FULLSHUT process*/
   212 *-* "TRAP ADD(SHUTWTOR) WTO(KAO03900) ACTION('EX SHUTWTOR') AOTRAP"
   213 *-* if rc <> 0
   214 *-*  then
       *-*  do
   215 *-*   msg = 'TRAP ADD(SHUTWTOR) failed for PARTSHUT cmd'
   216 *-*   "WTO '"msg"'" ,                                                                     "ROUT(2) DESC(2) MSGID(PARTSH03) W
TONO(GETDOM)"
   218 *-*   x = glbvget('GETDOM')
   219 *-*   GLOBAL.Kpreshut.Kpreshut003 = GETDOM date('b') time('s')
   220 *-*   x = sharvput('SYSTEM','GLOBAL.KPRESHUT.KPRESHUT003')
   221 *-*   return
   222 *-*  end
   224 *-*  /* now add add/enable some traps for PARTSHUT/FULLSHUT process*/
   225 *-* "TRAP ADD(SHUTTCAS) WTO(IKT012D) ACTION('EX SHUTTCAS') AOTRAP"
   226 *-* if rc <> 0
   227 *-*  then
       *-*  do
   228 *-*   msg = 'TRAP ADD(SHUTTCAS) failed for PARTSHUT cmd'
   229 *-*   "WTO '"msg"'" ,                                                                     "ROUT(2) DESC(2) MSGID(PARTSH03) W
TONO(GETDOM)"
   231 *-*   x = glbvget('GETDOM')
   232 *-*   GLOBAL.Kpreshut.Kpreshut003 = GETDOM date('b') time('s')
   233 *-*   x = sharvput('SYSTEM','GLOBAL.KPRESHUT.KPRESHUT003')
   234 *-*   return
   235 *-*  end
   237 *-* "OPER 'RCF CHECK APPC'"  /* APPC is likely in a incorrect state */
   238 *-* /* ... mark started if started.        */
   239 *-* /* (SFRH66) */
   240 *-* 'TRAP ENABLE(SHUTWTOR)' /* start it up */
   241 *-* /* note:  SHUTWTOR will reply cancel to any scheduled */
   242 *-* /*    task that is trying to start while we are       */
   243 *-* /*    shutting down the system.                       */
   245 *-* 'TRAP ENABLE(SHUTTCAS)' /* start it up */
   246 *-* /* note:  SHUTTCAS will reply U to a IKT012D message  */
   247 *-* /*    asking us to procede with TSO shutdown and/or   */
   248 *-* /*    take a DUMP of tso first.                       */
   250 *-* "OPER 'RCF SHOW *'               "
   253 *-* "TRAP ADD(SHUTPROC) TOD(*) INTERVAL(30) ACTION('EX SHUTPROC')"
   254 *-* if rc <> 0
   255 *-*  then
       *-*  do
   256 *-*   if tasks <> ''
   257 *-*    then
       *-*    'DOM' getdom
   258 *-*   msg = 'TRAP ADD(SHUTPROC) failed for PARTSHUT cmd'
   259 *-*   "WTO '"msg"'" ,                                                                     "ROUT(2) DESC(2) MSGID(PARTSH03) W
TONO(GETDOM)"
   261 *-*   x = glbvget('GETDOM')
   262 *-*   GLOBAL.Kpreshut.Kpreshut003 = GETDOM date('b') time('s')
   263 *-*   x = sharvput('SYSTEM','GLOBAL.KPRESHUT.KPRESHUT004')
   264 *-*   return
   265 *-*  end
   267 *-* GLOBAL.kPARTSHUT.kACTIVE      = 1 /* partshut is active */
   268 *-* GLOBAL.kSHUTPROCPHASE.kACTIVE = 1 /* this is phase we are in */
   270 *-* if global.kFULLSHUT.kACTIVE = 1   /* is fullshut in progress? */
   271 *-*  then
       *-*  nop                          /* yes, don't reset variable*/
   272 *-* else
       *-*  global.kFULLSHUT.kACTIVE = 0 /* no, but ensure it has a valid value */
   274 *-* x = sharvput('SYSTEM','GLOBAL.KPRESHUT.KPRESHUT001')
   275 *-* x = sharvput('SYSTEM','GLOBAL.KPRESHUT.KPRESHUT002')
   276 *-* x = sharvput('SYSTEM','GLOBAL.KPRESHUT.KPRESHUT003')
   277 *-* x = sharvput('SYSTEM','GLOBAL.KPRESHUT.KPRESHUT004')
   278 *-* x = sharvput('SYSTEM','GLOBAL.KSHUTPROCPHASE.KACTIVE')
   279 *-* x = sharvput('SYSTEM','GLOBAL.KPARTSHUT.KACTIVE')
   280 *-* x = sharvput('SYSTEM','GLOBAL.KFULLSHUT.KACTIVE')
   282 *-* 'TRAP ENABLE(SHUTPROC)' /* start it up */
   283 *-* /* note:  SHUTPROC will complete the partial shutdown */
   284 *-* /* note:  if FULLSHUT is also in progress, when it    */
   285 *-* /*    completes the partial shutdown, SHUTPROC will   */
   286 *-* /*    also complete the FULLSHUT process as well.     */
   288 *-* /* normal end of PARTSHUT command, before SHUTPROC takes over */
   289 *-* /* normal end of PARTSHUT command, before SHUTPROC takes over */
   290 *-* /* normal end of PARTSHUT command, before SHUTPROC takes over */
   291 *-* /* normal end of PARTSHUT command, before SHUTPROC takes over */
   292 *-* return
   294 *-* /* subroutines follow */
   295 *-* /* subroutines follow */
   296 *-* /* subroutines follow */
   297 *-* /* subroutines follow */
   300 *-* SetPhaseActions:
   301 *-* /* now define the tasks and/or commands and phase of shutdown */
   302 *-* /* ------------------------------------------------------------- */
   303 *-* /* PARTSHUT or FULLSHUT                                   */
   304 *-* /*                   PARTSHUT and FULLSHUT          */
   305 *-* /*                Note: phase 4 only executed when  */
   306 *-* /*                   FULLSHUT was requested.        */
   307 *-* /* phase 1 = execute in PARTSHUT (phase 1) */
   308 *-* /* phase 2 = execute in SHUTPROC (phase 2, after phase 1  */
   309 *-* /*                              tasks are down.     */
   310 *-* /*                                                  */
   311 *-* /* phase 3 = execute in SHUTPROC (phase 3, after phase 2  */
   312 *-* /*                              tasks are down.     */
   313 *-* /*                                                  */
   314 *-* /* phase 4 = exec.maybe SHUTPROC (phase 4, after phase 3  */
   315 *-* /*                              tasks are down.     */
   317 *-* groupindex. = 0 /* Groupindex. set to 0 (one time)*/
   318 *-* /* differences in which routines to call */
   319 *-* /*     phaseInit - called after you set phase=1,2,3 or 4 */
   320 *-* /*                    if you add additional phases you'll*/
   321 *-* /*                    have to modify SHUTPROC so that it */
   322 *-* /*                    knows what phases belong to "PARTSHUT"*/
   323 *-* /*                    and what phases belong to FULLSHUT    */
   324 *-* /*                    At time of documentation:             */
   325 *-* /*                       phase 1,2,3 are part of PARTSHUT   */
   326 *-* /*                       phase 4     is  FULLSHUT.          */
   327 *-* /*                    Critical for SHUTPROC to know that.   */
   328 *-* /*                                                          */
   329 *-* /*     SetTask   - called with 'taskname, command'          */
   330 *-* /*                 Shutproc(one time) will check if         */
   331 *-* /*                       task is up, if so will issue cmd.  */
   332 *-* /*                 Shutproc(everytime) will also want this  */
   333 *-* /*                       task to come down, unless command  */
   334 *-* /*                       is a "drain" command or            */
   335 *-* /*                       when task = C2RSERVE               */
   336 *-* /*                                                          */
   337 *-* /*     SetCmd    - called with 'command'.  Shutproc (onetime)*/
   338 *-* /*                       will issue the command,            */
   339 *-* /*                                                          */
   340 *-* /*     SetRCFtask - called with 'taskname' we will ask the  */
   341 *-* /*                  system state manager to bring down the  */
   342 *-* /*                  task.  We will check task to make sure  */
   343 *-* /*                  it comes down.                          */
   344 *-* /*                                                          */
   345 *-* /*     SetRCFgroup - called with 'groupname task1 task2 etc'*/
   346 *-* /*                  can be called multiple times with same  */
   347 *-* /*                  groupname so you can identify all the   */
   348 *-* /*                  started tasks.  We will check tasks to  */
   349 *-* /*                  make sure they come down.               */
   350 *-* /*                                                          */
   351 *-* /* phase processing (in SHUTPROC):                          */
   352 *-* /*     1st - SetRCFtasks are asked to be brought down       */
   353 *-* /*         for a phase (if task is up).                     */
   354 *-* /*     2nd - SetRCFgroups are asked to be brought down      */
   355 *-* /*         for a phase (if any task is up).                 */
   356 *-* /*     3rd - SetTasks (if task is up, command is issued)    */
   357 *-* /*     4th - SetCmd command is issued.                      */
   358 *-* /*     (repeat, while tasks are up)                         */
   359 *-* /*         - if tasks are still up, inform operator         */
   360 *-* /*         - if reply can be made, do reply.                */
   361 *-* /*         - repeat until tasks in phase are down.          */
   362 *-* /*     Now, that all tasks for phase are down, advance to   */
   363 *-* /*   the next phase.                                        */
   364 *-* /*     When all Partshut phases are complete, see if we're  */
   365 *-* /*   done or if we want a Fullshut to be done.  Either quit */
   366 *-* /*   or continue with fullshut phase.                       */
   367 *-* /*                                                          */
   368 *-* /*                                                          */
   370 *-* /* phase 1 time */
   371 *-* /* --------------- */
   372 *-* phase = 1
   373 *-* call phaseInit
   375 *-* call SetTask 'C2RSERVE, S C2RSLOG' /* extract copy of server log */
   376 *-* /* ...before shutting down C2RSERVE*/
   378 *-* if aosysid = 'ISDPROD'
   379 *-*  then
       *-*  do
   380 *-*   /* above we told DFHSM to "HOLD ALL" during FULLSHUT processing.  */
   381 *-*   /* ...override that to allow recall's                             */
   382 *-*   if global.kFULLSHUT.kACTIVE = 1
   383 *-*    then
       *-*    call SetTask 'DFHSM, F DFHSM,RELEASE RECALL' /*allow recall  */
   384 *-*   else
       *-*    call SetTask 'DFHSM, D A,DFHSM'  /*dummy command for PARTSHUT*/
   385 *-*   /*...PARTSHUT, generally    */
   386 *-*   /*...followed by FULLSHUT   */
   387 *-*   call SetCmd  '-DSN0 STOP DDF MODE(QUIESCE)' /* DDF, if "stopped"     */
   388 *-*   call SetCmd  '-DSN1 STOP DDF MODE(QUIESCE)' /* ...doesn't actually   */
   389 *-*   call SetCmd  '-DSN2 STOP DDF MODE(QUIESCE)' /* ...come down until db2*/
   390 *-*   /* ...does.  Therefore,  */
   391 *-*   /* ...just issue cmd     */
   392 *-*   call SetCmd  '-DSNQ STOP DDF MODE(QUIESCE)' /* ...w/o checking.      */
   394 *-*   /* dsn5/dsn6 are obsolete */
   395 *-*   /*call SetCmd  '-DSN5 STOP DDF MODE(QUIESCE)'  * obsolete              */
   396 *-*   /*call SetCmd  '-DSN6 STOP DDF MODE(QUIESCE)'  * obsolete              */
   398 *-*   call SetRCFtask 'SSHD2'
   400 *-*   call SetRCFtask 'CFZCIM'   /* stop CFZCIM before IZUSVR1 */
   401 *-*   /* ...which now stops w/F OMVS,SHUTDOWN*/
   402 *-*   /* ...in phase4                        */
   404 *-*   /* call SetTask 'CSMTCSRV CSMDBSRV CSMDBMUF, S CSMSTOP' */
   405 *-*   call SETRCFtask 'CSMTCSRV' /* bring down this now, FULLSHUT will*/
   406 *-*   /*                     bring down others*/
   408 *-*   call SetCmd  'F CA70,/SHUTDOWN Z1' /* we don't want to wait....   */
   409 *-*   call SetCmd  'F CA72,/SHUTDOWN Z1' /* ...will be reissued in phase 2*/
   410 *-*   /* and        reissued as SetTask*/
   411 *-*   /* ...in phase2; wait in phase2  */
   412 *-*   /*            no wait in phase1  */
   414 *-*   call SetTask 'ICOM, R x,STOP'     /*"R x," cmds replaced with R #,*/
   415 *-*   call SetTask 'CA72ICOM, R x,STOP' /*"R x," cmds replaced with R #,*/
   417 *-*   /* stop IMS "immediately", sort of */
   418 *-*   /* ------------------------------- */
   419 *-*   /*             --------- ----------- ' */
   420 *-*   /*SETRCFGROUP 'groupname taskname(s) ' */
   421 *-*   /*             --------- ----------- ' */
   422 *-*   /*  note:  stop the IMS control regions with:  R xx,/CHE DUMPQ */
   423 *-*   /*     this will result in the following actions in the following*/
   424 *-*   /*     address spaces (see one of the started tasks that ended): */
   425 *-*   /*  DFS058I checkpoint command in progress                     */
   426 *-*   /*  DFS00126 IMS (communications?) with APPC/MVS has been stopped*/
   427 *-*   /*  DFS552I (multiple msgs) message regions coming down.       */
   428 *-*   /*  DFS994I (presumably) chkpt command completes               */
   429 *-*   /*  DFS091I archive jobs start                                 */
   430 *-*   /*  DFS994I IMS shutdown complete                              */
   431 *-*   /*  Control Region ends HASP395 (ex:  IMSPROD, IMSREFM, etc).  */
   432 *-*   /*                                                             */
   433 *-*   /*                                                             */
   434 *-*   /* obsolete- call SetRCFgroup 'GIMSPROD  IMSPROD' */
   435 *-*   /* obsolete- call SetRCFgroup 'IREFORM   IMSREFM' */
   436 *-*   /* obsolete- call SetRCFgroup 'ISYSTEST  IMSSYST' */
   437 *-*   /* obsolete- call SetRCFgroup 'IMSTEST   IMSTRNG' */
   438 *-*   /* obsolete- call SetRCFgroup 'IMSUATT   IMSUATT' */
   439 *-*   /* obsolete- call SetRCFgroup 'IMSECTL   IMSECTL' */
   441 *-*   /* stop IDMSTEST and IDMSPROD groups immediately */
   442 *-*   /* --------------------------------------------- */
   443 *-*   /* obsolete- call SetRCFgroup 'IDMSTEST  IDMSQE18 IDMSSFR  IDMTST18'*/
   444 *-*   /* obsolete- call SetRCFgroup 'IDMSPROD  IDMDOC18 IDMPRD18 IDMSREVP'*/
   446 *-*   /* stop CICS's immediately */
   447 *-*   /* ----------------------- */
   448 *-*   call SetRCFgroup 'CICSPROD  CICSMCMS CICSVTAM CICS50 CICS60'
   450 *-*   /* call multiple times to identify all CICSTEST regions*/
   451 *-*   call SetRCFgroup 'CICSTEST  CICSTSTA CICSTST2 CICSTST3'
   452 *-*   call SetRCFgroup 'CICSTEST  CICSTST4 CICSTST5 CICSTST6'
   453 *-*   call SetRCFgroup 'CICSTEST  CICSTST7 CICSTST8 CICSTST9'
   454 *-*   call SetRCFgroup 'CICSTEST  CICSVTMA CICSVTM2 CICSVTM3'
   455 *-*   call SetRCFgroup 'CICSTEST  CICSVTM4 CICSVTM5 CICSVTM6'
   456 *-*   call SetRCFgroup 'CICSTEST  CICSVTM7 CICSVTM8 CICSVTM9'
   457 *-*   call SetRCFgroup 'CICSTEST  CICS40'
   459 *-*   call SetRCFtask  'CICSIVTC  CICSIVTC'
   461 *-*   /* drain DLF (before it can be stopped) */
   462 *-*   call SetCmd 'F DLF,MODE=DRAIN'
   464 *-*   call SetCmd 'O340 EX PRTSTOPP'
   465 *-*   call SetRCFTASK 'IDISAMAN'
   466 *-*  end
   467 *-* else
       *-*  do /* ISDTEST */
   469 *-*   call SetTask 'ICOM, R x,STOP'     /*"R x," cmds replaced with R #,*/
   470 *-*   call SetTask 'CA72ICOM, R x,STOP' /*"R x," cmds replaced with R #,*/
   472 *-*   /* above we told DFHSM to "HOLD ALL" during FULLSHUT processing.  */
   473 *-*   /* ...override that to allow recall's                             */
   474 *-*   if global.kFULLSHUT.kACTIVE = 1
   475 *-*    then
       *-*    call SetTask 'DFHSM, F DFHSM,RELEASE RECALL' /*allow recall  */
   476 *-*   else
       *-*    call SetTask 'DFHSM, D A,DFHSM'  /*dummy command for PARTSHUT*/
   478 *-*   /* drain DLF (before it can be stopped) */
   479 *-*   call SetCmd 'F DLF,MODE=DRAIN'
   481 *-*   call SetTask 'SSHD2, P SSHD2'
   482 *-*   call Settask 'IDISAMAN, P IDISAMAN'
   483 *-*  end
   485 *-* /* phase 2 time */
   486 *-* /* --------------- */
   487 *-* phase = 2
   488 *-* call phaseInit
   490 *-* if aosysid = 'ISDPROD'
   491 *-*  then
       *-*  do
   492 *-*   /* reissue these commands */
   493 *-*   call SetTask 'CA70, F CA70,/SHUTDOWN Z1' /* re-issue, now wait */
   494 *-*   call SetTask 'CA72, F CA72,/SHUTDOWN Z1' /* re-issue, now wait */
   496 *-*   /* we already "quieseced DDF, now be more forceful, just in case  */
   497 *-*   call SetCmd  '-DSN0 STOP DDF MODE(FORCE)'   /* DDF, if "stopped"     */
   498 *-*   call SetCmd  '-DSN1 STOP DDF MODE(FORCE)'   /* ...doesn't actually   */
   499 *-*   call SetCmd  '-DSN2 STOP DDF MODE(FORCE)'   /* ...come down until db2*/
   500 *-*   /* ...does.  Therefore,  */
   501 *-*   /* ...just issue cmd     */
   502 *-*   call SetCmd  '-DSNQ STOP DDF MODE(FORCE)'   /* ...w/o checking.      */
   504 *-*   /* dsn5/dsn6 obsolete */
   505 *-*   /*call SetCmd  '-DSN5 STOP DDF MODE(FORCE)'    * obsolete              */
   506 *-*   /*call SetCmd  '-DSN6 STOP DDF MODE(FORCE)'    * obsolete              */
   508 *-*   /* bring down the IMS connect (tcp/ip type) regions */
   509 *-*   /* (obsolete) */
   510 *-*   /* call setRcfTask 'IMSCNCTR'    bring down IMS connect regions */
   511 *-*   /* call setRcfTask 'IMSCONE'     bring down IMS connect regions */
   512 *-*   /* call setRcfTask 'IMSCONR'     bring down IMS connect regions */
   513 *-*   /* call setRcfTask 'IMSCONS'     bring down IMS connect regions */
   514 *-*   /* call setRcfTask 'IMSCONT'     bring down IMS connect regions */
   515 *-*   /* call setRcfTask 'IMSCONU'     bring down IMS connect regions */
   516 *-*   /* call setRcfTask 'IMSCONW1'    bring down IMS connect regions */
   517 *-*   /* call setRcfTask 'IMSCONW2'    bring down IMS connect regions */
   519 *-*   /* bring down the IMS CSL (Common Services Layer) regions */
   520 *-*   /*    IMS*OM  are the Operations Manager regions */
   521 *-*   /*    IMS*SCI are the Structured Call Interface regions */
   522 *-*   /*groupname   task(s) */
   523 *-*   /* (obsolete) */
   524 *-*   /* call SetRCFGroup 'IPROD    IMSPOM IMSPSCI'  * ims support regions */
   525 *-*   /* call SetRCFgroup 'IMSREFM  IMSROM IMSRSCI'  * ims support regions */
   526 *-*   /* call SetRCFgroup 'IREFORMP IMSSOM IMSSSCI'  * ims support regions */
   527 *-*   /* call SetRCFGroup 'ITRAIN   IMSTOM IMSTSCI'  * ims support regions */
   528 *-*   /* call SetRCFGroup 'IUAT     IMSUOM IMSUSCI'  * ims support regions */
   530 *-*   call SetCmd  'F CA70,/SHUTDOWN Z1' /* wait will be caused by SETTASK */
   531 *-*   call SetCmd  'F CA72,/SHUTDOWN Z1' /*    at start of phase 2 for    */
   532 *-*   /*    ca70/ca72; so use SetCmd this*/
   533 *-*   /*    time.                      */
   534 *-*   /* But these same commands issued*/
   535 *-*   /*    in phase 1, may have been  */
   536 *-*   /*    ignored.  So reissue them. */
   537 *-*   /*    a 3rd time, just in case.  */
   539 *-*  end
   542 *-*  /* phase 3 time */
   543 *-*  /* --------------- */
   544 *-* phase = 3
   545 *-* call phaseInit
   547 *-* call SetCmd '$PLOGON1'
   548 *-* call SetCmd '$PLOGON2'
   549 *-* call SetCmd '$PI'
   550 *-* if aosysid = 'ISDPROD'
   551 *-*  then
       *-*  do
   552 *-*   call SetTask 'AOPD, S AOPSTOP'
   553 *-*   call SetRCFtask 'CASAMS'
   555 *-*   /* bring down IMS's (lock manager IRLM regions);IMS already shutdown*/
   556 *-*   /* (obsolete) */
   557 *-*   /* call SetRCFtask 'IRLMPREP' */    /* sfhr66, added IRLMPREP    */
   558 *-*   /* call SetRCFtask 'IRLMPROD' */
   559 *-*   /* call SetRCFtask 'IRLMREFM' */
   560 *-*   /* call SetRCFtask 'IRLMSYST' */
   561 *-*   /* call SetRCFtask 'IRLMTRNG' */
   563 *-*   /* KLS is a pre-req for IMS; since IMS is down, stop KLS now*/
   564 *-*   call SetRCFtask 'KLS' /* supersession */
   566 *-*   /*groupname   task(s) */
   567 *-*   call SetRCFGroup 'CFUSION     CFUSION CFUSION2'
   568 *-*   call SetRCFGroup 'VIEWDIRECT  SFRVDR'
   569 *-*   call SetRCFGroup 'CA7WEB      CA7SRVR  CA7WEBC  CA7XVFB'
   571 *-*   call SetRCFgroup 'OMEGAMON    CANSCN   CANSC20  CANSC5'
   572 *-*   call SetRCFgroup 'OMEGAMON    CANSDS   CANSDSST CANSD2'
   573 *-*   call SetRCFgroup 'OMEGAMON    CANSD5   CANSETE  CANSI2'
   574 *-*   call SetRCFgroup 'OMEGAMON             CANSM2   CANSM2CS'
   575 *-*   call SetRCFgroup 'OMEGAMON    CANSM2EZ CANSM2HD CANSM2HI'
   576 *-*   call SetRCFgroup 'OMEGAMON    CANSM2RC CANSOC0  CANSO2'
   577 *-*   call SetRCFgroup 'OMEGAMON    CANSTOM'
   579 *-*   call SetRCFgroup 'DSN0  DSN0MSTR DSN0DBM1 DSN0DIST DSN0IRLM'
   580 *-*   call SetRCFgroup 'DSN1  DSN1MSTR DSN1DBM1 DSN1DIST DSN1IRLM'
   581 *-*   call SetRCFgroup 'DSN2  DSN2MSTR DSN2DBM1 DSN2DIST DSN2IRLM'
   582 *-*   call SetRCFgroup 'DSNQ  DSNQMSTR DSNQDBM1 DSNQDIST DSNQIRLM'
   584 *-*   /* DSN5/DSN6 are gone */
   585 *-*   /* (obsolete) */
   586 *-*   /* call SetRCFgroup 'DSN5  DSN5MSTR DSN0DBM1 DSN0DIST DSN0IRLM' */
   587 *-*   /* call SetRCFgroup 'DSN6  DSN6MSTR DSN0DBM1 DSN0DIST DSN0IRLM' */
   589 *-*   call SetRCFgroup 'VTAMAPP  IMSCONE IMSCONR  IMSCONS  IMSCONT'
   590 *-*   call SetRCFgroup 'VTAMAPP  IMSCONU IMSCONW1 IMSCONW2'
   592 *-*   /* now this */
   593 *-*   call SetTask 'CA11, CA11 SHUTDOWN ALL'
   594 *-*   call SetTask 'CA11, R x,Y'
   596 *-*  end
   597 *-* else
       *-*  do /* ISDTEST*/
   598 *-*   call Settask     'KLS, P KLS'
   599 *-*  end
   601 *-* call SetRCFgroup 'ZSECURE  C2RSERVE'
   603 *-* /* phase 4 time */
   604 *-* /* --------------- */
   605 *-* phase = 4 /* FULLSHUT (partshut completed already) */
   606 *-* /* ...this phase only executed when doing FULLSHUT */
   607 *-* call phaseInit
   609 *-* call SetCmd 'RCF STOP *'
   610 *-* if aosysid = 'ISDTEST'
   611 *-*  then
       *-*  do
   612 *-*   call SetTask 'APPC,     C APPC' /* this is how ISDPROD does it*/
   613 *-*   call Settask 'ENFCCI,   P ENF'/* stop this task */
   614 *-*   call Settask 'ENFCCI,   R x,Y'/* ...reply to WTOR so it comes down */
   615 *-*   call SetTask 'HZSPROC,  P HZSPROC'
   616 *-*   call SetTask 'TSO,      P TSO'
   617 *-*   call SetTask 'TN3270,   P TN3270'
   618 *-*   call SetTask 'OAM,      P OAM'
   619 *-*   call SetTask 'ADBTCXX,  P ADBTCXX'
   620 *-*   call SetTask 'CSF,      P CSF'
   621 *-*   call SetTask 'VLF,      P VLF'
   622 *-*   call SetTask 'DLF,      P DLF'
   623 *-*   call SetTask 'LLA,      P LLA'
   624 *-*   call SetTask 'FFST,     P FFST'
   625 *-*   call SetTask 'VTAM,     Z NET,QUICK'
   626 *-*   call SetTask 'TCPIP,    P TCPIP'
   627 *-*   call Setcmd  'F OMVS,SHUTDOWN'
   628 *-*   call SetTask 'RRS,      SETRRS SHUTDOWN'
   629 *-*   call SetTask 'C2PACMON, P C2PACMON'
   630 *-*   call SetTask 'C2POLICE, P C2POLICE'
   631 *-*   call SetTask 'TSO, R x,FSTOP'     /*"R x," cmds replaced with R #,*/
   632 *-*   call SetTask 'AXR04,    P AXR'    /* stop AXR, stops AXR04 */
   633 *-*  end
   634 *-* else
       *-*  do
   635 *-*   call SetTask 'TSO, R x,FSTOP'     /*"R x," cmds replaced with R #,*/
   636 *-*   call SetTask 'C2PACMON, P C2PACMON'
   637 *-*   call SetTask 'C2POLICE, P C2POLICE'
   638 *-*   call SetTask 'APPC,     C APPC' /* this is how ISDPROD does it*/
   639 *-*   call SetTask 'AXR04,    P AXR'    /* stop AXR, stops AXR04 */
   640 *-*  end
   641 *-* return
   643 *-* /* PhaseInit                                                    */
   644 *-* /* ---------                                                    */
   645 *-* /* There are some standard variables we need to create at the   */
   646 *-* /* start of every new phase.                                    */
   647 *-* /*                                                              */
   648 *-* /* This will create those variables used by:                    */
   649 *-* /*    SetCmd                                                    */
   650 *-* /*    SetTask                                                   */
   651 *-* /*    SetRCFtask                                                */
   652 *-* /*    and SetRCFgroup                                           */
   653 *-* PhaseInit:
   654 *-* if datatype(phase,'W') = 0 ,                                                     | phase < 1               ,
                                         | phase > 4               ,
   657 *-*  then
       *-*  do
   658 *-*   seterrors = seterrors + 1
   659 *-*   say 'SETTASK: Bad phase #; found phase="'phase'"'
   660 *-*   return
   661 *-*  end
   662 *-*  /* some variable initialization */
   663 *-* GLOBAL.KsetTASK.phase.0       = 0 /* no SetTask(s)     for this phase */
   664 *-* GLOBAL.KsetRCFTASK.phase.0    = 0 /* no SetRCFtask(s)  for this phase */
   665 *-* GLOBAL.KsetRCFGROUP.phase.0   = 0 /* no SetRCFgroup(s) for this phase */
   666 *-* GLOBAL.KsetCMD.phase.0        = 0 /* no SetCMD(s)      for this phase */
   667 *-* return
   669 *-* /* SetTask                                                      */
   670 *-* /* -------                                                      */
   671 *-* /*    call SetTask('taskname1 taskname2 ...,command')           */
   672 *-* /*       if one (or more) of the tasks is up, the command is    */
   673 *-* /*      issued at time "phase".                                 */
   674 *-* /*       Normally, it would be one task, one command.           */
   675 *-* /*       However, in following examples you see why multiple    */
   676 *-* /*      tasks would be allowed:                                 */
   677 *-* /*       note:  anything after the first COMMA, is the command  */
   678 *-* /*                                                              */
   679 *-* /* ex:  call SetTask 'SSHD2,F SSHD2,STOP'                       */
   680 *-* /*    this would result in:  if SSHD2 is up                     */
   681 *-* /*                           then issue cmd:  F SSHD2,STOP      */
   682 *-* /*                                                              */
   683 *-* /*    note:  anything before first comma are the tasks; anything*/
   684 *-* /*       after the first comma is the command.                  */
   685 *-* /*                                                              */
   686 *-* /* ex:  call SetTask 'CSMTCSRV CSMDBSRV CSMDBMUF,S CSMSTOP'     */
   687 *-* /*    this sould result in:  if any of specified tasks are up   */
   688 *-* /*                           then issue cmd:  S CSMSTOP         */
   689 *-* /*                                                              */
   690 *-* /*                                                              */
   691 *-* SetTask:
   692 *-* parse upper arg tasks ',' command
   693 *-* command = strip(command)
   694 *-* if datatype(phase,'W') = 0
   695 *-*  then
       *-*  do
   696 *-*   seterrors = seterrors + 1
   697 *-*   say 'SETTASK: Bad phase #; found phase="'phase'"'
   698 *-*   return
   699 *-*  end
   700 *-* if tasks = ''
   701 *-*  then
       *-*  do
   702 *-*   seterrors = seterrors + 1
   703 *-*   say 'SETTASK:  tasks=""'
   704 *-*   return
   705 *-*  end
   706 *-* if command = ''
   707 *-*  then
       *-*  do
   708 *-*   seterrors = seterrors + 1
   709 *-*   say 'SETTASK:  tasks="'tasks'"; but command=""'
   710 *-*   return
   711 *-*  end
   712 *-* GLOBAL.KsetTASK.phase.0 = GLOBAL.KsetTASK.phase.0 + 1
   713 *-* tasknum = GLOBAL.KsetTASK.phase.0
   714 *-* GLOBAL.KsetTASK.phase.tasknum.KtaskNames = tasks
   715 *-* GLOBAL.KsetTASK.phase.tasknum.Kcmd = command
   716 *-* return
   718 *-* /* SetRCFtask                                                   */
   719 *-* /*    call SetRCFtask(taskname)                                 */
   720 *-* /*                                                              */
   721 *-* /*    assumption is we will just stop the rcf task so no command*/
   722 *-* /*    is needed.                                                */
   723 *-* /*                                                              */
   724 *-* /*    example:  call SetRCFtask 'sshd2'                         */
   725 *-* /*    then at time (phase) if sshd2 is up                       */
   726 *-* /*                            then RCF STOP SSHD2 will be issued*/
   727 *-* /*                                                              */
   728 *-* SetRCFtask:
   729 *-* parse upper arg task .
   730 *-* if datatype(phase,'W') = 0
   731 *-*  then
       *-*  do
   732 *-*   seterrors = seterrors + 1
   733 *-*   say 'SetRCFtask: Bad phase #; found phase="'phase'"'
   734 *-*   return
   735 *-*  end
   736 *-* if task = ''
   737 *-*  then
       *-*  do
   738 *-*   seterrors = seterrors + 1
   739 *-*   say 'SetRCFtask:  task=""'
   740 *-*   return
   741 *-*  end
   742 *-* GLOBAL.KsetRCFtask.phase.0 = GLOBAL.KsetRCFtask.phase.0 + 1
   743 *-* tasknum = GLOBAL.KsetRCFtask.phase.0
   744 *-* GLOBAL.KsetRCFtask.phase.tasknum = task
   745 *-* return
   748 *-* /* SetRCFGroup                                                  */
   749 *-* /*    call SetRCFGroup(groupname taskname(s))                   */
   750 *-* /*                                                              */
   751 *-* /*    assumption is we will just stop the rcf group so no cmd   */
   752 *-* /*    is needed.                                                */
   753 *-* /*                                                              */
   754 *-* /*    call as often as needed to identify all the tasks         */
   755 *-* /*                                                              */
   756 *-* /*    examples:                                                 */
   757 *-* /*       call SetRCFGroup 'CICSTEST CICSTSTA CICSTST2 CICSTST3' */
   758 *-* /*       call SetRCFGroup 'CICSTEST CICSTST4 CICSTST5 CICSTST6' */
   759 *-* /*       call SetRCFGroup 'CICSTEST CICSTST7 CICSTST8 CICSTST9' */
   760 *-* /*       call SetRCFGroup 'CICSTEST CICSVTMA CICSVTM2 CICSVTM3' */
   761 *-* /*       call SetRCFGroup 'CICSTEST CICSVTM4 CICSTST5 CICSTST6' */
   762 *-* /*       call SetRCFGroup 'CICSTEST CICSVTM7 CICSTST8 CICSTST9' */
   763 *-* /*       call SetRCFGroup 'CICSTEST CICS40'                     */
   764 *-* /*                                                              */
   765 *-* /*    this will identify all the tasks controlled by RCF Group  */
   766 *-* /*       CICSTEST                                               */
   767 *-* /*                                                              */
   768 *-* /*    then if any of those tasks are up at time identified via  */
   769 *-* /*       phase number, then RCF STOP GROUP=CICSTEST will be     */
   770 *-* /*       issued.                                                */
   771 *-* SetRCFGroup:
   772 *-* parse upper arg VgroupName Vtasks
   773 *-* if datatype(phase,'W') = 0
   774 *-*  then
       *-*  do
   775 *-*   seterrors = seterrors + 1
   776 *-*   say 'SetRCFgroup: Bad phase #; found phase="'phase'"'
   777 *-*   return
   778 *-*  end
   779 *-* if VgroupName = ''
   780 *-*  then
       *-*  do
   781 *-*   seterrors = seterrors + 1
   782 *-*   say 'SetRCFgroup error:  group=""'
   783 *-*   return
   784 *-*  end
   785 *-* if Vtasks = ''
   786 *-*  then
       *-*  do
   787 *-*   seterrors = seterrors + 1
   788 *-*   say 'SetRCFgroup:  tasks=""'
   789 *-*   return
   790 *-*  end
   791 *-* if groupindex.phase.VgroupName = 0
   792 *-*  then
       *-*  do
   793 *-*   /* new group, get next groupnum variable created */
   794 *-*   GLOBAL.KsetRCFGROUP.phase.0 = GLOBAL.KsetRCFGROUP.phase.0 + 1
   795 *-*   groupNum =                  GLOBAL.KsetRCFGROUP.phase.0
   796 *-*   groupIndex.phase.VgroupName = groupNum
   797 *-*   GLOBAL.KsetRCFGROUP.phase.groupnum.KgroupName = VgroupName
   798 *-*   GLOBAL.KsetRCFGROUP.phase.groupnum.KgroupTasks = Vtasks
   799 *-*   return
   800 *-*  end
   801 *-*  /* existing group, just add more tasks */
   802 *-* groupnum = groupINdex.phase.VgroupName /* reuse existing one */
   803 *-* /* append tasks to list of existing tasks */
   804 *-* GLOBAL.KsetRCFGROUP.phase.groupnum.KgroupTasks = ,                                    GLOBAL.KsetRCFGROUP.phase.groupnum
.KgroupTasks Vtasks
   806 *-* return
   808 *-* /* SetCmd                                                       */
   809 *-* /* -------                                                      */
   810 *-* /*    call Setcmd(command)                                      */
   811 *-* /*       at time identified in phase, this command will be      */
   812 *-* /*      issued.                                                 */
   813 *-* /*                                                              */
   814 *-* /* ex:  call SetCmd('F DLF,MODE=DRAIN')                         */
   815 *-* /*    this would result in command being issued at time         */
   816 *-* /*      identified in phase.                                    */
   817 *-* /*                                                              */
   818 *-* /*                                                              */
   819 *-* SetCmd:
   820 *-* parse upper arg command
   821 *-* if datatype(phase,'W') = 0
   822 *-*  then
       *-*  do
   823 *-*   seterrors = seterrors + 1
   824 *-*   say 'SETCMD:  Bad phase #; found phase="'phase'"'
   825 *-*   return
   826 *-*  end
   827 *-* if command = ''
   828 *-*  then
       *-*  do
   829 *-*   seterrors = seterrors + 1
   830 *-*   say 'SETCMD error:  command=""'
   831 *-*   return
   832 *-*  end
   833 *-* GLOBAL.KsetCMD.phase.0 = GLOBAL.KsetCMD.phase.0 + 1
   834 *-* cmdnum = GLOBAL.KsetCMD.phase.0
   835 *-* GLOBAL.KsetCMD.phase.cmdnum = command
   836 *-* return
READY
END


 ------------ now xreference begins -----------------------
 ------------ now xreference begins -----------------------


    xref (1 of 2) section 1 is for variables (not stem.'s)
    xref (1 of 2) section 1 is for variables (not stem.'s)
    ----------------------------------------------------------

       variables/labels are in "upperCase" if variable was never
                       assigned a value.

                        they are in "lowercase", otherwise.

       variables/stems set via a command, like EXECIO for
                       example, where the stem is within quotes
                       will not be shown in the xref as either
                       an assignment or a reference.

       Note special variables like:  RC, SIGL, can be assigned
                       values explictly.  But rexx can set them
                       as well implicitly.  Implicit assignments
                       are not in the xref.
    ----------------------------------------------------------



Variable (NEVER SET)    AOSYSID              Not Assgn: EITHER used as upper case value OR set via cmd
Variable (used in/rexx) AOSYSID              Reference: 81 378 490 550 610

Variable (set w/rexx)   cmd                  Assigned : 78
Variable (used in/rexx) cmd                  Reference: 86 186 189

Variable (set w/rexx)   cmdnum               Assigned : 834
Variable (in Stem Set)  cmdnum               Assigned : 835

Variable (set w/rexx)   command              Assigned : 692 693 820
Variable (used in/rexx) command              Reference: 693 706 715 827 835

Built-In+/External use  DATATYPE             Reference: F(96) F(97) F(98) F(99) F(127) F(149) F(150) F(151) F(152) F(654) F(694) F(730) F(773)
                        ...                             F(821)

Built-In+/External use  DATE                 Reference: F(109) F(133) F(174) F(197) F(219) F(232) F(262)

Variable (set w/rexx)   dom1                 Assigned : 92 145
Variable (used in/rexx) dom1                 Reference: 96 149

Variable (set w/rexx)   dom2                 Assigned : 93 146
Variable (used in/rexx) dom2                 Reference: 97 150

Variable (set w/rexx)   dom3                 Assigned : 94 147
Variable (used in/rexx) dom3                 Reference: 98 151

Variable (set w/rexx)   dom4                 Assigned : 95 125 148
Variable (used in/rexx) dom4                 Reference: 99 127 128 152

Variable (NEVER SET)    GETDOM               Not Assgn: EITHER used as upper case value OR set via cmd
Variable (used in/rexx) GETDOM               Reference: 109 133 174 197 219 232 257 262

Built-In+/External use  GLBVGET              Reference: F(108) F(132) F(173) F(196) F(218) F(231) F(261)

Variable (set w/rexx)   groupnum             Assigned : 795 802
Variable (used in/rexx) groupnum             Reference: 796
Variable (in Stem Set)  groupnum             Assigned : 797 798 804
Variable (in Stem Ref)  groupnum             Reference: 804

Variable (NEVER SET)    KACTIVE              Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  KACTIVE              Assigned : 110 111 112 158 159 267 268 272
Variable (in Stem Ref)  KACTIVE              Reference: 122 208 270 382 474

Variable (NEVER SET)    KCMD                 Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  KCMD                 Assigned : 715

Variable (NEVER SET)    KFULLSHUT            Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  KFULLSHUT            Assigned : 112 272
Variable (in Stem Ref)  KFULLSHUT            Reference: 208 270 382 474

Variable (NEVER SET)    KGROUPNAME           Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  KGROUPNAME           Assigned : 797

Variable (NEVER SET)    KGROUPTASKS          Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  KGROUPTASKS          Assigned : 798 804
Variable (in Stem Ref)  KGROUPTASKS          Reference: 804

Variable (NEVER SET)    KPARTSHUT            Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  KPARTSHUT            Assigned : 111 159 267
Variable (in Stem Ref)  KPARTSHUT            Reference: 122

Variable (NEVER SET)    KPRESHUT             Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  KPRESHUT             Assigned : 102 103 104 109 133 154 155 156 157 174 197 219 232 262
Variable (in Stem Ref)  KPRESHUT             Reference: 92 93 94 95 125 145 146 147 148

Variable (NEVER SET)    KPRESHUT001          Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  KPRESHUT001          Assigned : 102 154
Variable (in Stem Ref)  KPRESHUT001          Reference: 92 145

Variable (NEVER SET)    KPRESHUT002          Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  KPRESHUT002          Assigned : 103 155
Variable (in Stem Ref)  KPRESHUT002          Reference: 93 146

Variable (NEVER SET)    KPRESHUT003          Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  KPRESHUT003          Assigned : 104 156 174 197 219 232 262
Variable (in Stem Ref)  KPRESHUT003          Reference: 94 147

Variable (NEVER SET)    KPRESHUT004          Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  KPRESHUT004          Assigned : 109 133 157
Variable (in Stem Ref)  KPRESHUT004          Reference: 95 125 148

Variable (NEVER SET)    KSETCMD              Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  KSETCMD              Assigned : 666 833 835
Variable (in Stem Ref)  KSETCMD              Reference: 833 834

Variable (NEVER SET)    KSETRCFGROUP         Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  KSETRCFGROUP         Assigned : 665 794 797 798 804
Variable (in Stem Ref)  KSETRCFGROUP         Reference: 794 795 804

Variable (NEVER SET)    KSETRCFTASK          Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  KSETRCFTASK          Assigned : 664 742 744
Variable (in Stem Ref)  KSETRCFTASK          Reference: 742 743

Variable (NEVER SET)    KSETTASK             Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  KSETTASK             Assigned : 663 712 714 715
Variable (in Stem Ref)  KSETTASK             Reference: 712 713

Variable (NEVER SET)    KSHUTPROCPHASE       Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  KSHUTPROCPHASE       Assigned : 110 158 268
Variable (in Stem Ref)  KSHUTPROCPHASE       Reference: 122

Variable (NEVER SET)    KTASKNAMES           Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  KTASKNAMES           Assigned : 714

Variable (set w/rexx)   msg                  Assigned : 170 193 215 228 258
Variable (used in/rexx) msg                  Reference: 171 194 216 229 259

Variable (set w/rexx)   phase                Assigned : 372 487 544 605
Variable (used in/rexx) phase                Reference: 654 659 694 697 730 733 773 776 821 824
Variable (in Stem Set)  phase                Assigned : 663 664 665 666 712 714 715 742 744 794 796 797 798 804 833 835
Variable (in Stem Ref)  phase                Reference: 712 713 742 743 791 794 795 802 804 833 834

Label (internal label)  PHASEINIT            Defined  : 653
Label (int. label ref)  PHASEINIT            Reference: C(373) C(488) C(545) C(607)

SpecialVar(set no-XREF) RC                    *Special: No xref; set w/ADDR env cmd and/or REXX itself
SpecialVar(used w/rexx) RC                   Reference: 213 226 254

Label (internal label)  SETCMD               Defined  : 819
Label (int. label ref)  SETCMD               Reference: C(387) C(388) C(389) C(392) C(408) C(409) C(462) C(464) C(479) C(497) C(498) C(499) C(502)
                        ...                             C(530) C(531) C(547) C(548) C(549) C(609) C(627)

Variable (set w/rexx)   seterrors            Assigned : 165 658 696 702 708 732 738 775 781 787 823 829
Variable (used in/rexx) seterrors            Reference: 168 170 658 696 702 708 732 738 775 781 787 823 829

Label (internal label)  SETPHASEACTIONS      Defined  : 300
Label (int. label ref)  SETPHASEACTIONS      Reference: C(166)

Label (internal label)  SETRCFGROUP          Defined  : 771
Label (int. label ref)  SETRCFGROUP          Reference: C(448) C(451) C(452) C(453) C(454) C(455) C(456) C(457) C(567) C(568) C(569) C(571) C(572)
                        ...                             C(573) C(574) C(575) C(576) C(577) C(579) C(580) C(581) C(582) C(589) C(590) C(601)

Label (internal label)  SETRCFTASK           Defined  : 728
Label (int. label ref)  SETRCFTASK           Reference: C(398) C(400) C(405) C(459) C(465) C(553) C(564)

Label (internal label)  SETTASK              Defined  : 691
Label (int. label ref)  SETTASK              Reference: C(375) C(383) C(384) C(414) C(415) C(469) C(470) C(475) C(476) C(481) C(482) C(493) C(494)
                        ...                             C(552) C(593) C(594) C(598) C(612) C(613) C(614) C(615) C(616) C(617) C(618) C(619) C(620)
                        ...                             C(621) C(622) C(623) C(624) C(625) C(626) C(628) C(629) C(630) C(631) C(632) C(635) C(636)
                        ...                             C(637) C(638) C(639)

Built-In+/External use  SHARVGET             Reference: F(82) F(83) F(84)

Built-In+/External use  SHARVPUT             Reference: F(113) F(114) F(115) F(116) F(117) F(118) F(119) F(134) F(175) F(181) F(182) F(183) F(184)
                        ...                             F(198) F(220) F(233) F(263) F(274) F(275) F(276) F(277) F(278) F(279) F(280)

Built-In+/External use  STRIP                Reference: F(693)

Built-In+/External use  SYSVGET              Reference: F(80)

Variable (set w/rexx)   task                 Assigned : 729
Variable (used in/rexx) task                 Reference: 736 744

Variable (set w/rexx)   tasknum              Assigned : 713 743
Variable (in Stem Set)  tasknum              Assigned : 714 715 744

Variable (set w/rexx)   tasks                Assigned : 692
Variable (used in/rexx) tasks                Reference: 256 700 709 714

Built-In+/External use  TIME                 Reference: F(109) F(133) F(174) F(197) F(219) F(232) F(262)

Variable (set w/rexx)   vgroupname           Assigned : 772
Variable (used in/rexx) vgroupname           Reference: 779 797
Variable (in Stem Set)  vgroupname           Assigned : 796
Variable (in Stem Ref)  vgroupname           Reference: 791 802

Variable (set w/rexx)   vtasks               Assigned : 772
Variable (used in/rexx) vtasks               Reference: 785 798 804

Variable (set w/rexx)   x                    Assigned : 80 82 83 84 108 113 114 115 116 117 118 119 132 134 173 175 181 182 183 184 196 198 218
                        ...                             220 231 233 261 263 274 275 276 277 278 279 280
Variable (NEVER USED)   x                    No Ref.  : If actually referenced, it must be via a cmd.
    xref (1 of 2) ends here
    xref (1 of 2) ends here
    -----------------------

    xref (2 of 2) section 2 is for stem variable xreference.
    xref (2 of 2) section 2 is for stem variable xreference.
    ----------------------------------------------------------
       note:     Assignments/references to rexx stems
              is only for stem references in rexx code
              itself.

                 Therefore, references to stem variables
              that are made INSIDE of quotes, say as
              part of an EXECIO command, will NOT show
              up in the XREF as they are part of a "string
              constant" and not used as a rexx variable or
              rexx stem directly.

                 This is because it often may not be obvious
              which address environment a command may (or may
              not) be valid in.  Or for us to know all the
              ways a rexx stem might be used.

    ----------------------------------------------------------







Stem-2 GLOBAL.KFULLSHUT.KACTIVE                           Assigned : 112 272
Stem-2 GLOBAL.KFULLSHUT.KACTIVE                           Reference: 208 270 382 474
Stem-2 GLOBAL.KPARTSHUT.KACTIVE                           Assigned : 111 159 267
Stem-2 GLOBAL.KPARTSHUT.KACTIVE                           Reference: 122
Stem-2 GLOBAL.KPRESHUT.KPRESHUT001                        Assigned : 102 154
Stem-2 GLOBAL.KPRESHUT.KPRESHUT001                        Reference: 92 145
Stem-2 GLOBAL.KPRESHUT.KPRESHUT002                        Assigned : 103 155
Stem-2 GLOBAL.KPRESHUT.KPRESHUT002                        Reference: 93 146
Stem-2 GLOBAL.KPRESHUT.KPRESHUT003                        Assigned : 104 156 174 197 219 232 262
Stem-2 GLOBAL.KPRESHUT.KPRESHUT003                        Reference: 94 147
Stem-2 GLOBAL.KPRESHUT.KPRESHUT004                        Assigned : 109 133 157
Stem-2 GLOBAL.KPRESHUT.KPRESHUT004                        Reference: 95 125 148
Stem-3 GLOBAL.KSETCMD.phase.0                             Assigned : 666 833
Stem-3 GLOBAL.KSETCMD.phase.0                             Reference: 833 834
Stem-3 GLOBAL.KSETCMD.phase.cmdnum                        Assigned : 835
Stem-3 GLOBAL.KSETRCFGROUP.phase.0                        Assigned : 665 794
Stem-3 GLOBAL.KSETRCFGROUP.phase.0                        Reference: 794 795
Stem-4 GLOBAL.KSETRCFGROUP.phase.groupnum.KGROUPNAME      Assigned : 797
Stem-4 GLOBAL.KSETRCFGROUP.phase.groupnum.KGROUPTASKS     Assigned : 798 804
Stem-4 GLOBAL.KSETRCFGROUP.phase.groupnum.KGROUPTASKS     Reference: 804
Stem-3 GLOBAL.KSETRCFTASK.phase.0                         Assigned : 664 742
Stem-3 GLOBAL.KSETRCFTASK.phase.0                         Reference: 742 743
Stem-3 GLOBAL.KSETRCFTASK.phase.tasknum                   Assigned : 744
Stem-3 GLOBAL.KSETTASK.phase.0                            Assigned : 663 712
Stem-3 GLOBAL.KSETTASK.phase.0                            Reference: 712 713
Stem-4 GLOBAL.KSETTASK.phase.tasknum.KCMD                 Assigned : 715
Stem-4 GLOBAL.KSETTASK.phase.tasknum.KTASKNAMES           Assigned : 714
Stem-2 GLOBAL.KSHUTPROCPHASE.KACTIVE                      Assigned : 110 158 268
Stem-2 GLOBAL.KSHUTPROCPHASE.KACTIVE                      Reference: 122

Stem-1 GROUPINDEX.                                        Assigned : 317
Stem-2 GROUPINDEX.phase.vgroupname                        Assigned : 796
Stem-2 GROUPINDEX.phase.vgroupname                        Reference: 791 802
    xref (2 of 2) ends here
    xref (2 of 2) ends here
    -----------------------


 ------------ tips for label references ----------------------------
 ------------ tips for label references ----------------------------
     tip:  c# is a ref to CALL stmt to this   internal/external name
     tip:  f# is a ref to FUNCTION call to    internal/external function
     tip:  s# is a ref to SIGNAL stmt to this internal label


 ------------ now xreference for stem variables (tips) -------------
 ------------ now xreference for stem variables (tips) -------------
     tip:     Note:- stem variables (after 1st period) are in lower case
     tip:          - stem "constants" (will be shown in UPPER case)
     tip:          - stem "constants" that are whole numbers (and not 0)
     tip:               will be summarized as a # sign (in place of
     tip:               individual digits/numbers) so it summarizes them.
     tip:     What XREF for stems can help you fix:
     tip:     -------------------------------------
     tip:      - seeing a variable (lower case) used in a stem where you
     tip:       EXPECTED it to always be a constant.
     tip:      - seeing a constant (upper case) used in a stem where you
     tip:       EXPECTED it to be a variable (maybe it was misspelled).
     tip:                                              )
     tip:line sample rexx code (followed by sample xref)
     tip:---- ------------
     tip:  1     x = "Richard"
     tip:  2     firstName.y.x.1 = "Hi"
     tip:  3     firstName.y.x.2 = "Buddy"
     tip:  4     firstName.y.x.0 = 2
     tip:
     tip:sample xref listing
     tip:-----------
     tip:  --xref section 1 (variables)
     tip:  --xref section 1 (variables)
     tip:
     tip:Variable (set)         X               Assigned : 1
     tip:Variable(w/ stem use): X               Reference: 2 3 4
     tip:Constant(w/ stem use): Y               Reference: 2 3 4
     tip:
     tip:  --xref section 2 (stem variables)
     tip:  --xref section 2 (stem variables)
     tip:
     tip:Stem-3 FIRSTNAME.Y.x.#                 Assigned : 2 3
     tip:Stem-3 FIRSTNAME.Y.x.0                 Assigned : 4
     tip:                                       Reference: 2 3 4
     tip:     note:  Stem-3 refers to # of periods in the stem.
     tip:
     tip:  rexx tip: remember stem value on the right is "tricky":
     tip:        Given following rexx code:
     tip:             x = "RICHARD.HUMPHRIS"
     tip:             y = "RICHARD"
     tip:             z = "HUMPHRIS"
     tip:        References to a stem variable, as shown below, are
     tip:          referring to the SAME stem variable:
     tip:             stem.x     refers to STEM.RICHARD.HUMPHRIS
     tip:             stem.y.z   refers to STEM.RICHARD.HUMPHRIS
     tip:        This is because x contains a period.  And because
     tip:          everything to the right of the first period is evaluated
     tip:          first.  Then the stem variable is "looked up".
     tip:
     tip:   rexx tip:  referencing pgm above, if you set variable "a"
     tip:         to a upper/lower case value.  The stem will NOT upper
     tip:         case it.
     tip:        So if assignment statement set "a" to "richard"
     tip:         then stem.y is NOT the same as stem.a
     tip:        Because stem.y    refers to STEM.RICHARD
     tip:        and     stem.a    refers to STEM.richard
     tip:
