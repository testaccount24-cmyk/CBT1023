   ==> Scan of exec succeeded (rc <= 4)
   -------------------------------------------------
    1) See trace 's' exec in:
          SFRH66.PUBLIC.REXXXREF.SAMPLE.SCAN(REX$XRE2)

    2) Trace listing + XREF listing in:
          SFRH66.PUBLIC.REXXXREF.SAMPLE.XREF(REX$XRE2)
   -----------------------------------------

READY
    REX$XRE2
    Generated scan code/comment:   trace 's'
    Generated scan code/comment:   /*  rexx member for scan/xref was: */
    Generated scan code/comment:   /*     "SFRH66.REXX(REX$XRE2)"      */
    Generated scan code/comment:   /*      ---------------------       */
    Generated scan code/comment:   /*  date/time of XREF was:          */
    Generated scan code/comment:   /*     20231215 14:30:59            */
    Generated scan code/comment:   /*      ---------------------       */
     1 *-* /* REXX */
     2 *-* /*                                                                           */
     3 *-* /* written by:  Richard Humphris                                             */
     4 *-* /* email:       richard.humphris@netnitco.net                                */
     5 *-* /* cell:        219-707-1409                                                 */
     6 *-* /*                                                                           */
     7 *-* /* version      change                                                       */
     8 *-* /* -------      ------------------------------------------------------------ */
     9 *-* /* 1.02         update "address" command:                                    */
    10 *-* /*              1. add explicit address commands to xreference for ease of use*/
    11 *-* /*              2. fix:  address syntax                                      */
    12 *-* /*                                                                           */
    13 *-* /*                 syntax 1:  address environment [exprc]                    */
    14 *-* /*                 syntax 2:  address [VALUE] exprv                          */
    15 *-* /*                    a) environment names                                   */
    16 *-* /*                         1) environment (1st format) is an environment if  */
    17 *-* /*                        it 1st word is a symbol or a constant.  In either  */
    18 *-* /*                        case, a symbol is treated as a constant, not a     */
    19 *-* /*                        variable.                                          */
    20 *-* /*                         2) exprv is an expression that evaluates to a     */
    21 *-* /*                        environment name if 1st word is not a symbol or    */
    22 *-* /*                        a constant.  Or if "VALUE" is explicitly specified.*/
    23 *-* /*                    b) command to be executed [exprc] only is an option w/ */
    24 *-* /*                      the 1st syntax of the address command.               */
    25 *-* /*                    c) The fixes to the address command:                   */
    26 *-* /*                         1) if VALUE was not specified, we always treated  */
    27 *-* /*                        the implied syntax 2 (w/o VALUE) as syntax 1.      */
    28 *-* /*                         2) environment (in syntax 1) is specified as a    */
    29 *-* /*                        constant did not appear in the xref, only "variables"*/
    30 *-* /*                        did.  But "variables" as "environment" in syntax 1 */
    31 *-* /*               3. new function.                                            */
    32 *-* /*                    a)  we will add a xref section for address environments*/
    33 *-* /*                   like:                                                   */
    34 *-* /*                       address 'environment'                               */
    35 *-* /*                       address 'environment' <cmd>                         */
    36 *-* /*                       address VALUE exprv                                 */
    37 *-* /*                                                                           */
    38 *-* /*              4. internal changes include:                                 */
    39 *-* /*                 a.  variableAddrDef.      stem added                      */
    40 *-* /*                     variableAddrDefValue. stem added                      */
    41 *-* /*                 b.  called routine "c0480AddressDefine:" created          */
    42 *-* /*                 c.  code for ADDRESS command modified.                    */
    43 *-* /*                           among other things, to call c0480               */
    44 *-* /*                           and it will use variable "line_without_comments"*/
    45 *-* /*                           for "ADDRESS VALUE" syntax.                     */
    46 *-* /*                 d.  xref code updated to output address info.             */
    47 *-* /*                 e.  change routine c0070ParseLinePass1:                   */
    48 *-* /*                     1.  remove comments and labels to set variable:       */
    49 *-* /*                            "LineWithoutCommentsNlabels"                   */
    50 *-* /*                     2.  Then continue parsing as before with the other    */
    51 *-* /*                            variables.                                     */
    52 *-* /*                                                                           */
    53 *-* /* 1.01         initial "release"                                            */
    54 *-* /*                                                                           */
    55 *-* /*                                                                           */
    56 *-* /*    summarize process:                                                     */
    57 *-* /*    ------------------                                                     */
    58 *-* /*          Input:  a rexx exec you want a cross reference for.              */
    59 *-* /*                                                                           */
    60 *-* /*          process:                                                         */
    61 *-* /*             1) read rexx exec from libraryX.(member) (your exec library)  */
    62 *-* /*                                                                           */
    63 *-* /*             2) create member in hlq.SCAN(member)                          */
    64 *-* /*                                                                           */
    65 *-* /*                a) if fb, change to vb (hlq.SCAN) is vb                    */
    66 *-* /*                                                                           */
    67 *-* /*                b) remove seq #'s (either fb or vb)                        */
    68 *-* /*                                                                           */
    69 *-* /*                c) add header information (comments) to converted exec     */
    70 *-* /*                                                                           */
    71 *-* /*                d) add trace 's' after header        in converted exec     */
    72 *-* /*                                                                           */
    73 *-* /*             3) run converted member with/  trace 's'                      */
    74 *-* /*                                                                           */
    75 *-* /*                a) save output in a temporary file.                        */
    76 *-* /*                                                                           */
    77 *-* /*                b) if trace unsuccessful, update hlq.XREF with scan        */
    78 *-* /*                 output and we're done.                                    */
    79 *-* /*                                                                           */
    80 *-* /* ====>       4) run REX$XREF (this exec) to create the cross reference     */
    81 *-* /*                                                                           */
    82 *-* /*                a) save xref in a temporary file.                          */
    83 *-* /*                                                                           */
    84 *-* /*             5) create header, copy scan output, copy xref output and      */
    85 *-* /*               create a member in hlq.XREF(member)                         */
    86 *-* /*                                                                           */
    87 *-* /*    purpose of REX$XREF:                                                   */
    88 *-* /*    --------------------                                                   */
    89 *-* /*                                                                           */
    90 *-* /*         1)  input:  trace 's' output of exec; we want to gen a xref for.  */
    91 *-* /*                                                                           */
    92 *-* /*         2)  process trace 's' output and create s xref                    */
    93 *-* /*                                                                           */
    94 *-* /*             a)  "pass 1" reads rexx code and looks for labels, call       */
    95 *-* /*            instructions, function calls, signal instructions, variables   */
    96 *-* /*            used (assigned and/or referrenced) and stems used and/or       */
    97 *-* /*            referenced.  All labels, variable and stems are saved in       */
    98 *-* /*                                                                           */
    99 *-* /*                 1)  all labels, variables, stems (with variables used)    */
   100 *-* /*                are all saved in upperCase.                                */
   101 *-* /*                                                                           */
   102 *-* /*                 2)  stems with numeric values after the period are changed*/
   103 *-* /*                to # (except for 0).                                       */
   104 *-* /*                                                                           */
   105 *-* /*                    For example:                                           */
   106 *-* /*                                                                           */
   107 *-* /*                     stem as used     stem as saved for xref               */
   108 *-* /*                     ------------     ----------------------               */
   109 *-* /*                     xyz.var1.0       XYZ.VAR1.0                           */
   110 *-* /*                     xyz.var1.1       XYZ.VAR1.#                           */
   111 *-* /*                     xyz.var1.2         (see above)                        */
   112 *-* /*                     xyz.var1.3         (see above)                        */
   113 *-* /*                                                                           */
   114 *-* /*                                                                           */
   115 *-* /*             b)  "pass 2" the "output pass"                                */
   116 *-* /*                                                                           */
   117 *-* /*                 1) the "constant" xref section 1                          */
   118 *-* /*                                                                           */
   119 *-* /*                    a) variables are sorted                                */
   120 *-* /*                                                                           */
   121 *-* /*                    b) only variables that aren't assigned in rexx code    */
   122 *-* /*                   appear here.                                            */
   123 *-* /*                                                                           */
   124 *-* /*                    c) so labels (also used as variables) are only reported*/
   125 *-* /*                   here if the variable use was only a reference.          */
   126 *-* /*                                                                           */
   127 *-* /*                                                                           */
   128 *-* /*                                                                           */
   129 *-* /*    Note:                                                                  */
   130 *-* /*          NO syntax checking is done.  We ran the rexx syntax checker and  */
   131 *-* /*         what's "good" for rexx is "good" for us.                          */
   132 *-* /*                                                                           */
   133 *-* /*          Therefore, it greatly simplifies code.  For example, if you put  */
   134 *-* /*         a variable on a "ITERATE" statement, for example, we just assume  */
   135 *-* /*         it will be a single variable and references a active do loop. BUT */
   136 *-* /*         to simplify this code, we treat value like any other expression   */
   137 *-* /*         on the right hand side of an assignment statement say.  We depend */
   138 *-* /*         on REXX to pick up syntax problems.                               */
   139 *-* /*                                                                           */
   140 *-* /*          Also, we do NOT look at "constants" enclosed in quotes.  So if   */
   141 *-* /*         for example,you code a "EXECIO" command with STEM X. in quotes    */
   142 *-* /*         we will NOT generate a assignment for the rexx stem X. (for that  */
   143 *-* /*         statement).                                                       */
   144 *-* /*                                                                           */
   145 *-* /*                                                                           */
   147 *-* signal on syntax /* set trap for syntax errors */
   148 *-* parse source . . . . . . . addressSpace .
   149 *-* if addressSpace = 'OMVS'
   150 *-*  then
       *-*  do
   151 *-*   omvsSeg = 1 /* user can use bpxwunix() function */
   152 *-*  end
   153 *-* else
       *-*  do
   154 *-*   x = syscalls('ON')
   155 *-*   if x = 0
   156 *-*    then
       *-*    do
   157 *-*     omvsSeg = 1 /* user can use bpxwunix function */
   158 *-*     x = syscalls('OFF')
   159 *-*    end
   160 *-*   else
       *-*    omvsSeg = 0 /* will have to use rexx subroutine to do sorting (slow)*/
   161 *-*  end
   163 *-* say ' '
   164 *-* if omvsSeg = 1
   165 *-*  then
       *-*  say 'XREF will be able to use a fast omvs sort, as we have an OMVS segment)'
   166 *-* else
       *-*  say 'XREF can''t do a fast omvs sort (no OMVS segment); will use rexx code to sort'
   167 *-* say ' '
   169 *-* signal startUp      /* "branch" over the syntax handling routine */
   171 *-* syntax:
   172 *-* /*-------*/
   173 *-* /*-------*/
   174 *-* /* syntax:  error handling */
   175 *-* /*   rc    is set to the syntax error number;                        */
   176 *-* /*         ... equivelent to IRX00nnL as rc = 00, 01 to 99           */
   177 *-* /*   sigl  is set to the line number in error                        */
   178 *-* parse source . . execname .
   179 *-* say 'IRX00'right('00'rc,2)'I Error running exec' ,              execName 'line' sigl':' errortext(rc)
   181 *-* syntaxLow = max(sigl-7,1)            /* -7 before (or pgm start) */
   182 *-* syntaxHigh= min(sigl+7,sourceline()) /* +7 after  (or pgm end)   */
   183 *-* do syntaxII = syntaxLow to syntaxHigh/* -7 lines back to +7 lines*/
   184 *-*  if syntaxII <> sigl
   185 *-*   then
       *-*   say 'line   ' right(syntaxii,length(syntaxHigh))':' ,                     sourceline(syntaxII)
   187 *-*  else
       *-*   say 'line==>' right(syntaxii,length(syntaxHigh))':' ,                     sourceline(syntaxII)
   189 *-* end
   190 *-* say 'exiting exec with rc=12'
   191 *-* exit 12
   193 *-* startUp:
   194 *-* /*--------*/
   195 *-* /*--------*/
   196 *-* /* start of pgm... skipped error routine "syntax:" */
   197 *-* /* ----------------------------------------------- */
   199 *-* /* handle arguments/options for the execution of this exec */
   200 *-* /* ------------------------------------------------------- */
   201 *-* debug = 'OFF'  /* set to ON or OFF; will do more say statements if ON */
   202 *-* parse upper arg . 'DEBUG=' valuex .
   203 *-* parse upper arg . 'REXXLINE=' valuey .
   204 *-* parse upper arg . 'WIDTH=' valuez .
   205 *-* parse upper arg . 'BLANK=' valueb .
   207 *-* say ' '
   208 *-* say 'Options used:'
   209 *-* say '-------------'
   210 *-* say ' '
   212 *-* if valuex = 'ON' | valuex = 'OFF'
   213 *-*  then
       *-*  debug = valuex
   214 *-* else
       *-*  debug = 'OFF'
   215 *-* say 'DEBUG option is DEBUG='debug
   216 *-* say '   For DEBUG=ON, you will have to look at SYSTSPRT in step //XREF for debug output'
   218 *-* if datatype(valueY,'W') = 0 | valueY < 0
   219 *-*  then
       *-*  TraceRexxLine = 0
   220 *-* else
       *-*  TraceRexxline = valueY  /* line of input exec to trace */
   222 *-* if traceRexxLine > 0
   223 *-*  then
       *-*  do
   224 *-*   say ' '
   225 *-*   say 'REXXLINE='tracerexxLine'; we will turn on:  trace ''r'' while processing line' tracerexxline 'of input exec'
   226 *-*   say 'REXXLINE trace, you will have to look at SYSTSPRT in step //XREF for debug output'
   227 *-*  end
   229 *-* say ' '
   230 *-* if datatype(valuez,'W') = 0 | valuez = ''
   231 *-*  then
       *-*  do
   232 *-*   say 'WIDTH option:  we will be using default width = 150'
   233 *-*   width = 150
   234 *-*   defaultMaxoutputvar = 50 /* use longer default */
   235 *-*  end
   236 *-* else
       *-*  if valuez < 130
   237 *-*   then
       *-*   do
   238 *-*    say 'WIDTH optione:  width='valuez 'specified, but minimum width=130 used instead'
   239 *-*    width = 130
   240 *-*    defaultMaxoutputvar = 30 /* shorten default size */
   241 *-*   end
   242 *-*  else
       *-*   do
   243 *-*    say 'WIDTH option:  width='valuez 'will be used'
   244 *-*    width = valuez
   245 *-*    defaultMaxoutputvar = 50 /* use longer default */
   246 *-*   end
   248 *-* say ' '
   249 *-* if valueb = 'BYVAR'
   250 *-*  then
       *-*  do
   251 *-*   blankOption = valueb
   252 *-*   say 'Blank=BYVAR, indicates there will be a blank line between groups of xref lines w/same variable/label name'
   253 *-*  end
   254 *-* else
       *-*  if valueB = 'NONE'
   255 *-*   then
       *-*   do
   256 *-*    blankOption = valueb
   257 *-*    say 'Blank=NONE, indicates there will be no blank lines in XREF'
   258 *-*   end
   259 *-*  else
       *-*   do
   260 *-*    blankOption = 'BYVAR'
   261 *-*    say 'Blank="'valueb'" was an invalid option, using Blank=BYVAR instead'
   262 *-*    say 'Blank=BYVAR, indicates there will be a blank line between groups of xref lines w/same variable/label name'
   263 *-*   end
   265 *-* say 'finished process options'
   266 *-* say ' '
   268 *-* /* end of options handling */
   269 *-* /* ----------------------- */
   271 *-* /* define some "special" variable handling for xref */
   272 *-* /* ------------------------------------------------ */
   273 *-* specialVar. = 0 /* default (not special) */
   274 *-* /* --------------------- */
   275 *-* special = 'RC'
   276 *-* specialVar.special = 1   /* set specialVar.RC = 1  */
   278 *-* special = 'SIGL'
   279 *-* specialVar.special = 1   /* set specialVar.SIGL =1 */
   281 *-* special = 'RESULT'
   282 *-* specialVar.special = 1   /* set specialVar.RESULT = 1 */
   284 *-* special = 'SQLCODE'
   285 *-* specialVar.special = 1   /* set specialVar.SQLCODE = 1   (db2) dsnrexx */
   287 *-* special = 'SQLERRMC'
   288 *-* specialVar.special = 1   /* set specialVar.SQLERRMC = 1  (db2) dsnrexx */
   290 *-* special = 'SQLERRP'
   291 *-* specialVar.special = 1   /* set specialVar.SQLERRP  = 1  (db2) dsnrexx */
   293 *-* special = 'SQLSTATE'
   294 *-* specialVar.special = 1   /* set specialVar.SQLSTATE = 1  (db2) dsnrexx */
   296 *-* specialStem. = 0
   297 *-* specialStem.SQLERRD = 1
   298 *-* specialStem.SQLWARN = 1
   299 *-* /* end of special xref defaults */
   300 *-* /* ---------------------------= */
   302 *-* /* define rexx statement keywords we will handle */
   303 *-* /* --------------------------------------------- */
   304 *-* rexxStmt. = 0
   305 *-* rexxStmt = 'ADDRESS'
       *-* rexxStmt.rexxStmt = 1
   306 *-* rexxStmt = 'ARG'
       *-* rexxStmt.rexxStmt = 1
   307 *-* rexxStmt = 'CALL'
       *-* rexxStmt.rexxStmt = 1
   308 *-* rexxStmt = 'DO'
       *-* rexxStmt.rexxStmt = 1
   309 *-* rexxStmt = 'END'
       *-* rexxStmt.rexxStmt = 1 /* not really a stmt, but 'end'(s) DO or SELECT */
   310 *-* rexxStmt = 'DROP'
       *-* rexxStmt.rexxStmt = 1
   311 *-* rexxStmt = 'EXIT'
       *-* rexxStmt.rexxStmt = 1
   312 *-* rexxStmt = 'IF'
       *-* rexxStmt.rexxStmt = 1
   313 *-* rexxStmt = 'THEN'
       *-* rexxStmt.rexxStmt = 1 /* not really a stmt, but used in IF or SELECT */
   314 *-* rexxStmt = 'ELSE'
       *-* rexxStmt.rexxStmt = 1 /* not really a stmt, but used with IF stmt    */
   315 *-* rexxStmt = 'INTERPRET'
       *-* rexxStmt.rexxStmt = 1
   316 *-* rexxStmt = 'ITERATE'
       *-* rexxStmt.rexxStmt = 1
   317 *-* rexxStmt = 'LEAVE'
       *-* rexxStmt.rexxStmt = 1
   318 *-* rexxStmt = 'NOP'
       *-* rexxStmt.rexxStmt = 1
   319 *-* rexxStmt = 'NUMERIC'
       *-* rexxStmt.rexxStmt = 1
   320 *-* rexxStmt = 'OPTIONS'
       *-* rexxStmt.rexxStmt = 1
   321 *-* rexxStmt = 'PARSE'
       *-* rexxStmt.rexxStmt = 1
   322 *-* rexxStmt = 'PROCEDURE'
       *-* rexxStmt.rexxStmt = 1
   323 *-* rexxStmt = 'PULL'
       *-* rexxStmt.rexxStmt = 1
   324 *-* rexxStmt = 'PUSH'
       *-* rexxStmt.rexxStmt = 1
   325 *-* rexxStmt = 'QUEUE'
       *-* rexxStmt.rexxStmt = 1
   326 *-* rexxStmt = 'RETURN'
       *-* rexxStmt.rexxStmt = 1
   327 *-* rexxStmt = 'SAY'
       *-* rexxStmt.rexxStmt = 1
   328 *-* rexxStmt = 'SELECT'
       *-* rexxStmt.rexxStmt = 1
   329 *-* rexxStmt = 'WHEN'
       *-* rexxStmt.rexxStmt = 1 /* not really a stmt, but used with SELECT stmt */
   330 *-* rexxStmt = 'OTHERWISE'
       *-* rexxStmt.rexxStmt = 1 /* not really a stmt, but used with SELECT stmt */
   331 *-* rexxStmt = 'SIGNAL'
       *-* rexxStmt.rexxStmt = 1
   332 *-* rexxStmt = 'TRACE'
       *-* rexxStmt.rexxStmt = 1
   333 *-* rexxStmt = 'UPPER'
       *-* rexxStmt.rexxStmt = 1
   334 *-* /* end of special rexxStmt. keywords. */
   335 *-* /* ---------------------------------- */
   337 *-* validSymbolChars  ='ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$¢.!?_' /* full set of valid symbol chars */
   338 *-* validVariableStart='ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$¢!?_'            /* variable can't start with . or digit */
   340 *-* 'EXECIO 0 DISKW RESULTS (OPEN'
   341 *-* if rc <> 0
   342 *-*  then
       *-*  do
   343 *-*   say 'DDname RESULTS failed to open for output; rc='rc
   344 *-*   say 'exit 8'
   345 *-*   'EXECIO 0 DISKW RESULTS (FINIS'
   346 *-*   exit 8
   347 *-*  end
   349 *-* call c0050Pass1 /* find and identify variables */
   350 *-* call c9900OutputResults /* now, output our results */
   351 *-* exit 0
   353 *-* c0050Pass1:
   354 *-* 'EXECIO 100 DISKR SCANINP (OPEN STEM IN.'
   355 *-* inRc = rc
   356 *-* if inRc = 0 | inRc = 2
   357 *-*  then
       *-*  nop
   358 *-* else
       *-*  do
   359 *-*   say 'error opening ddname=SCANINP; rc='inRc
   360 *-*   say 'exiting w/rc=8'
   361 *-*   'EXECIO 0 DISKR SCANINP (FINIS'
   362 *-*   exit 8
   363 *-*  end
   364 *-* if in.0 > 0 /* in input read, copy to output */
   365 *-*  then
       *-*  do
   366 *-*   /* copy scan to output member, followed by xref */
   367 *-*   'EXECIO' in.0 'DISKW RESULTS (STEM IN.'
   368 *-*   if rc <> 0
   369 *-*    then
       *-*    do
   370 *-*     say 'error writing to ddname=RESULTS, rc='rc
   371 *-*     say 'exiting w/rc=8'
   372 *-*     'EXECIO 0 DISKR SCANINP (FINIS'
   373 *-*     'EXECIO 0 DISKW RESULTS  (FINIS'
   374 *-*     exit 8
   375 *-*    end
   376 *-*  end
   377 *-* variablesIndx. = 0
   378 *-* variable = 0
   379 *-* /* define defaults for structures associated with "variable." */
   380 *-* /* ---------------------------------------------------------- */
   381 *-* variable.          = '' /* name of variable like USER; always UpperCase*/
   382 *-* variableRef.       = '' /* referencing a variable,   list of line #'s */
   383 *-* variableExposeRef. = '' /* expose list ref. variable,list of line #'s */
   384 *-* variableSet.       = '' /* setting     a variable,   list of line #'s */
   385 *-* variableStemSet.   = '' /* used in setting stem var, list of line #'s */
   386 *-* variableStemRef.   = '' /* used in ref.    stem var, list of line #'s */
   387 *-* variableLabelDef.  = '' /* label definition,         list of line #'s */
   388 *-* variableLabelRef.  = '' /* label reference,          list of line #'s */
   389 *-* variableAddrDef.      = '' /* address definition,        list of line #'s */ /* v1.02 update */
   390 *-* variableAddrDefValue. = '' /* address value definition,  list of line #'s */ /* v1.02 update */
   391 *-* /* end of defaults */
   393 *-* stemIndx.      = 0
   394 *-* stem     = 0
   395 *-* /* define defaults for structures associated with "stem." */
   396 *-* /* ------------------------------------------------------ */
   397 *-* stemVariable.     = '' /* name of stem variable (like NAME.FIRST.LAST) always upper case */
   398 *-* stemPeriods.      = '' /* # of periods used in stem variable */
   399 *-* stemRef.          = '' /* stem variable references, list of line #'s */
   400 *-* stemExposeRef.    = '' /* stem variable references, list of line #'s */
   401 *-* StemAsg.          = '' /* stem variable assignment, list of line #'s */
   402 *-* /* end of defaults */
   404 *-* exposeRef = 0 /* only set to 1 when reference "PROCEDURE EXPOSE" list of variables */
   405 *-* line = ''
   406 *-* startcmd = 0
   407 *-* totalLine= 0
   408 *-* in = 0
   409 *-* do forever /* identify variables / stems */
   410 *-*  in = in + 1
   411 *-*  if in > in.0
   412 *-*   then
       *-*   do
   413 *-*    /* need another buffer */
   414 *-*    if inRc = 2/* finished using last buffer? */
   415 *-*     then
       *-*     leave /* ...yes, time to leave.      */
   417 *-*     /* get next buffer */
   418 *-*    in = 0 /* reset buffer pointer, very important for forever loop */
   419 *-*    'EXECIO 100 DISKR SCANINP (STEM IN.'
   420 *-*    inRc = rc /* save read rc */
   421 *-*    if inRc = 0 | inRc = 2
   422 *-*     then
       *-*     do /* got next input buffer */
   423 *-*      if in.0 > 0 /* if input recs, copy to output */
   424 *-*       then
       *-*       do
   425 *-*        /* copy scan to output member, followed by xref */
   426 *-*        'EXECIO' in.0 'DISKW RESULTS (STEM IN.'
   427 *-*        if rc <> 0
   428 *-*         then
       *-*         do
   429 *-*          say 'error writing to ddname=RESULTS, rc='rc
   430 *-*          say 'exiting w/rc=8'
   431 *-*          'EXECIO 0 DISKR SCANINP (FINIS'
   432 *-*          'EXECIO 0 DISKW RESULTS  (FINIS'
   433 *-*          exit 8
   434 *-*         end
   435 *-*       end
   436 *-*       /* normal, we read buffer successfully */
   437 *-*       /*         we wrote buffer successfully*/
   438 *-*       /*         time to resume loop         */
   439 *-*       /*         and variable "in" equals zero*/
   440 *-*      iterate /* got next input buffer, resume forever loop*/
   441 *-*     end
   443 *-*     /* bad read rc */
   444 *-*    say 'error reading from ddname=SCANINP; rc='rc
   445 *-*    say 'exit w/rc=8'
   446 *-*    'EXECIO 0 DISKR SCANINP (FINIS'
   447 *-*    exit 8
   448 *-*   end
   450 *-*   /* next input line in "in.in" is ready to process */
   451 *-*  totalLine = totalLine + 1
   452 *-*  if startcmd = 1
   453 *-*   then
       *-*   do /* put most likely choice first */
   454 *-*    parse var in.in rexxLine2 8 cmd 12 pendingCmd
   455 *-*    if datatype(strip(rexxLine2),'W') & cmd = '*-* '
   456 *-*     then
       *-*     do /* we have start of a "command" to process */
   457 *-*      call c0070ParseLinePass1 /* process previous line first */
   458 *-*      rexxline = strip(rexxline2)
   459 *-*      line = pendingCmd   /* now save start of next cmd  */
   460 *-*      iterate
   461 *-*     end
   463 *-*     /* command continued, add to line, for full line to parse*/
   464 *-*    if left(in.in,10) = '*-*'
   465 *-*     then
       *-*     do
   466 *-*      call c0070ParseLinePass1 /* process previous cmd first */
   467 *-*      /* rexxline is still set... multiple cmds on same line  */
   468 *-*      line = pendingCmd   /* now save start of next cmd  */
   469 *-*      iterate
   470 *-*     end
   471 *-*    else
       *-*     line = line || in.in /* continuation of a command, append it together */
   472 *-*    iterate
   473 *-*   end
   474 *-*  else
       *-*   do
   475 *-*    /* this happens first, but once we set startcmd to 1*/
   476 *-*    /* ... it will never be reset.  So this is least used*/
   477 *-*    /* portion of this loop.                             */
   478 *-*    parse var in.in rexxline 8 cmd 12 rest
   479 *-*    if datatype(strip(rexxline),'W') & cmd = '*-* '
   480 *-*     then
       *-*     do /* we have start of a "command" to process */
   481 *-*      startcmd = 1
   482 *-*      line = rest
   483 *-*      rexxline = strip(rexxline)
   484 *-*      iterate
   485 *-*     end
   486 *-*    else
       *-*     iterate /* ignore nonsense */
   487 *-*   end
   488 *-* end
   489 *-* if startcmd = 1
   490 *-*  then
       *-*  do
   491 *-*   if right(line,8) = 'READYEND' & length(line) > 8 /* sure it is */
   492 *-*    then
       *-*    line = left(line,length(line)-8) /* remove "READYEND" */
   493 *-*   call c0070ParseLinePass1
   494 *-*  end
   495 *-* 'EXECIO 0 DISKR SCANINP (FINIS'
   496 *-* return /* 1st pass is complete */
   498 *-* c0070ParseLinePass1:
   499 *-* /* 1.  remove comments from line, as they just confuse things. */
   500 *-* /*                                                             */
   501 *-* /* 2.  replace 'all literals'               with " 'LIT###     */
   502 *-* /* 2.  replace 'all literal functions       with " 'FUN###(    */
   503 *-* /*     replace '0101 1100'b BINARY literals with " 'LIT###B    */
   504 *-* /*     replace '04E3 DD3C'x HEX literals    with " 'LIT###X    */
   505 *-* /*     ... as they just confuse things.                        */
   506 *-* /*                                                             */
   507 *-* /* After this, any digits left in "line" are digits used by    */
   508 *-* /* rexx, as opposed to those that used to be in:               */
   509 *-* /*          1. comments (removed)                              */
   510 *-* /*          2. literals (removed)                              */
   511 *-* /*                                                             */
   512 *-* if traceRexxLine > 0
   513 *-*  then
       *-*  if rexxLine = traceRexxLine
   514 *-*   then
       *-*   do
   515 *-*    trace 'n'
   516 *-*    say ' '
   517 *-*    say 'Turning on and/or continuing Tracing while processing line' rexxline 'of the input exec'
   518 *-*    trace 'i' /* turn on tracing for this one line of 'input' rexx code */
   519 *-*   end
   520 *-*  else
       *-*   if rexxLine > traceRexxLine
   521 *-*    then
       *-*    do
   522 *-*     traceRexxLine = 0 /* nothing more to trace */
   523 *-*     trace 'n'         /* keep tracing off      */
   524 *-*    end
   526 *-* originalLine = line /* save original line  */
   527 *-* if debug = 'ON'
   528 *-*  then
       *-*  do
   529 *-*   say ' '
   530 *-*   say 'rexxline='rexxline
   531 *-*   say 'debug:  originalLine="'originalLine'"'
   532 *-*  end
   534 *-*  /* v1.02 ... remove comments first */
   535 *-*  /* ------------------------------- */
   537 *-* lowerLine    = line /* in case of literals */
   538 *-* upper line /* just upper case it */
   539 *-* startPos = 1
   540 *-* commentNested = 0
   541 *-* commentStart  = 0
   542 *-* literalStart  = 0
   543 *-* LitValue. = ''   /* save lit values here */
   544 *-* litNext    = 0   /* # of lit values saved*/
   545 *-* do while pos('/*',line,startPos) > 0 ,                  | pos('*/',line,startPos) > 0 ,                  | pos("'",line,
startPos)  > 0 ,                  | pos('"',line,startPos)  > 0
   549 *-*  /* we have a possible comment and/or literal */
   550 *-*  x1= pos('/*',line'/*',startPos)
   551 *-*  x2= pos('*/',line'*/',startPos)
   552 *-*  y1= pos("'",line"'",startPos)
   553 *-*  y2= pos('"',line'"',startPos)
   555 *-*  x = min(x1,x2)
   556 *-*  y = min(y1,y2)
   558 *-*  if commentStart > 0 /* at least one comment active */
   559 *-*   then
       *-*   do
   560 *-*    /* ignore "y" literals inside of comments */
   561 *-*    if x1 = x2 /* should be impossible */
   562 *-*     then
       *-*     leave /* ... rexx syntax should have found this */
   563 *-*    if x1 = x  /* start of another nested comment? */
   564 *-*     then
       *-*     do
   565 *-*      commentNested = commentNested + 1 /* bump number nested*/
   566 *-*      startPos = x + 2 /* skip past this comment delimiter */
   567 *-*      iterate
   568 *-*     end
   569 *-*     /* found end of a comment */
   570 *-*    commentNested = commentNested - 1 /* decrement number of active comments*/
   572 *-*    if commentNested > 0
   573 *-*     then
       *-*     do
   574 *-*      /* nested comments, we need to find more end of comment literals */
   575 *-*      startPos = x + 2 /* skip past this comment delimiter */
   576 *-*      iterate
   577 *-*     end
   578 *-*     /* finally entire comment "commentStart to x" can be removed */
   579 *-*     /* replace with a blank, if imbedded comment                 */
   580 *-*    if commentStart = 1
   581 *-*     then
       *-*     do
   582 *-*      /* remove comment from start of line */
   583 *-*      line      = strip(substr(line,x+2))
   584 *-*      lowerLine = strip(substr(lowerLine,x+2))
   585 *-*      startPos = 1
   586 *-*      commentStart = 0 /* with no comment active any longer, this is now zero */
   587 *-*      iterate
   588 *-*     end
   589 *-*     /* remove comment from middle of line; replace with blank */
   590 *-*    line      = left(line,commentStart-1)      substr(line,x+2)
   591 *-*    lowerLine = left(lowerLine,commentStart-1) substr(lowerLine,x+2)
   592 *-*    startPos = commentStart + 1
   593 *-*    commentStart = 0 /* with no comment active any longer, this is now zero */
   594 *-*    iterate
   595 *-*   end
   597 *-*  if x < y /* comment started before literal? */
   598 *-*   then
       *-*   do
   599 *-*    /* logic says (see prior "if commentNested > 0" that commentNested must be zero */
   600 *-*    if substr(line,x,2) = '/*'
   601 *-*     then
       *-*     do
   602 *-*      /* this must be true for rexx syntax approved code */
   603 *-*      commentNested = 1 /* this is start of a comment */
   604 *-*      commentStart  = x /* ... and started here       */
   605 *-*      startPos = x + 2  /* start looking for end of comment here */
   606 *-*      iterate
   607 *-*     end
   608 *-*    call logicMsg 'how can a comment end, that was never started?'
   609 *-*    startPos = x+2
   610 *-*    iterate
   611 *-*   end
   613 *-*   /* start of literal found, it may be a:            */
   614 *-*   /*    'some literal value' a regular literal       */
   615 *-*   /* or '1010 1100'b         a binary  literal       */
   616 *-*   /* or '03ef ff'x           a hex     literal       */
   617 *-*   /*                                                 */
   618 *-*   /* note:  we won't verify contents of binary or hex*/
   619 *-*   /*    literals, the rexx syntax checker did that.  */
   620 *-*   /*                                                 */
   621 *-*   /* so we will remove literal and replace it with   */
   622 *-*   /*    " 'LIT' "  i.e. with 'LIT' with blanks around*/
   623 *-*   /*    it.                                          */
   624 *-*   /*                                                 */
   625 *-*  LiteralStart = y
   626 *-*  LitQuote = substr(line,y,1)
   627 *-*  do forever /* find end of literal */
   628 *-*   yy= pos(litQuote,line,y+1) /* find ending quote */
   629 *-*   if yy = 0
   630 *-*    then
       *-*    do
   631 *-*     /* literal should have ended, if syntax corrrect */
   632 *-*     /* add closing quote (that should have been in literal */
   633 *-*     litValue = substr(lowerLine,LiteralStart) || litQuote
   634 *-*     litNext = litNext + 1
   635 *-*     litValue.litNext = litValue
   637 *-*     call logicMsg 'Why didn''t literal end'
   638 *-*     if LiteralStart = 1
   639 *-*      then
       *-*      return /* basically one long literal, even if it didn't end */
   641 *-*     line = left(line,y-1) " 'LIT"||litnext
   642 *-*     literalStart = 0          /* basically end of parsing */
   643 *-*     startPos = length(line)+1 /* basically end of parsing */
   644 *-*     leave
   645 *-*    end
   646 *-*   if substr(line,yy,1) = substr(line,yy+1,1) /* double " or double ' */
   647 *-*    then
       *-*    do
   648 *-*     /* skip them by */
   649 *-*     y = yy + 2
   650 *-*     iterate
   651 *-*    end
   652 *-*    /* we found end of literal at yy*/
   653 *-*   leave
   654 *-*  end
   655 *-*  if literalStart = 0
   656 *-*   then
       *-*   leave
   658 *-*   /* normal case, found end of literal */
   660 *-*   /* is it really a binary literal.... don't want "b" to be a variable */
   661 *-*  if  substr(line,yy+1,2) = 'B ' ,                                       /* if B<blank>                    then a binary
literal */       | (substr(line,yy+1,1) = 'B'  & datatype(substr(line,yy+1,2),'S')= 0) /* or B<?>     is not a symbol... then a bin
ary literal */
   663 *-*   then
       *-*   do
   664 *-*    startPos = yy+2                             )
   665 *-*    literalStart = 0
   666 *-*    iterate
   667 *-*   end
   669 *-*   /* is it really a hex literal.... don't want "x" to be a variable */
   670 *-*  if  substr(line,yy+1,2) = 'X ' ,                                       /* if X<blank>                    then a hex lit
eral */       | (substr(line,yy+1,1) = 'X'  & datatype(substr(line,yy+1,2),'S')= 0) /* or X<?>     is not a symbol... then a hex li
teral */
   672 *-*   then
       *-*   do
   673 *-*    startPos = yy+2
   674 *-*    literalStart = 0
   675 *-*    iterate
   676 *-*   end
   678 *-*   /* just a simple literal */
   679 *-*  startPos = yy+1
   680 *-*  literalStart = 0
   681 *-*  iterate
   682 *-* end
   684 *-* /* now comments have been removed */
   685 *-* if line = ''
       *-*  then
       *-*  return
   687 *-*  /* remove label(s), if found, from lineWithoutCommentsNLabels */
   688 *-* LineWithoutCommentsNlabels = line
   689 *-* do forever
   690 *-*  LineWithoutCommentsNlabels = strip(LineWithoutCommentsNlabels)
   691 *-*  if LineWithoutCommentsNlabels = ''
       *-*   then
       *-*   leave
   693 *-*  if pos(':',LineWithoutCommentsNlabels) = 0
   694 *-*   then
       *-*   leave
   696 *-*  parse var LineWithoutCommentsNlabels varX ':' rest
   697 *-*  if words(varx) = 1
   698 *-*   then
       *-*   if datatype(varx,'s') = 1
   699 *-*    then
       *-*    do
   700 *-*     LineWithoutCommentsNlabels = rest /* remove label:      */
   701 *-*     iterate                           /* continue looking for more labels */
   702 *-*    end
   703 *-*   else
       *-*    leave /* we've removed all labels, LineWithoutCommentsNlabels variable set correctly */
   704 *-*  else
       *-*   leave    /* we've removed all labels, LineWithoutCommentsNlabels variable set correctly */
   705 *-* end
   706 *-* lineWithoutCommentsNlabels = strip(LineWithoutCommentsNlabels) /* keep this for address command */
   707 *-* if debug = 'ON'
   708 *-*  then
       *-*  say 'debug:  LineWithoutCommentsNlabels="'LineWithoutCommentsNlabels'"'
   711 *-*  /* ===>  comments, if any, now removed from "line", but labels and literals are still in "line" */
   712 *-*  /* ===>  -------------------------------------------------------------------------------------- */
   714 *-*  /* end of V1.02 ... now do the "traditional"  c0070 code */
   715 *-*  /* ----------------------------------------------------- */
   717 *-* lowerLine    = line /* in case of literals */
   718 *-* upper line /* just upper case it */
   719 *-* startPos = 1
   720 *-* commentNested = 0
   721 *-* commentStart  = 0
   722 *-* literalStart  = 0
   723 *-* LitValue. = ''   /* save lit values here */
   724 *-* litNext    = 0   /* # of lit values saved*/
   725 *-* do while pos('/*',line,startPos) > 0 ,                  | pos('*/',line,startPos) > 0 ,                  | pos("'",line,
startPos)  > 0 ,                  | pos('"',line,startPos)  > 0
   729 *-*  /* we have a possible comment and/or literal */
   730 *-*  x1= pos('/*',line'/*',startPos)
   731 *-*  x2= pos('*/',line'*/',startPos)
   732 *-*  y1= pos("'",line"'",startPos)
   733 *-*  y2= pos('"',line'"',startPos)
   735 *-*  x = min(x1,x2)
   736 *-*  y = min(y1,y2)
   738 *-*  if commentStart > 0 /* at least one comment active */
   739 *-*   then
       *-*   do
   740 *-*    /* ignore "y" literals inside of comments */
   741 *-*    if x1 = x2 /* should be impossible */
   742 *-*     then
       *-*     leave /* ... rexx syntax should have found this */
   743 *-*    if x1 = x  /* start of another nested comment? */
   744 *-*     then
       *-*     do
   745 *-*      commentNested = commentNested + 1 /* bump number nested*/
   746 *-*      startPos = x + 2 /* skip past this comment delimiter */
   747 *-*      iterate
   748 *-*     end
   749 *-*     /* found end of a comment */
   750 *-*    commentNested = commentNested - 1 /* decrement number of active comments*/
   752 *-*    if commentNested > 0
   753 *-*     then
       *-*     do
   754 *-*      /* nested comments, we need to find more end of comment literals */
   755 *-*      startPos = x + 2 /* skip past this comment delimiter */
   756 *-*      iterate
   757 *-*     end
   758 *-*     /* finally entire comment "commentStart to x" can be removed */
   759 *-*     /* replace with a blank, if imbedded comment                 */
   760 *-*    if commentStart = 1
   761 *-*     then
       *-*     do
   762 *-*      /* remove comment from start of line */
   763 *-*      line      = strip(substr(line,x+2))
   764 *-*      lowerLine = strip(substr(lowerLine,x+2))
   765 *-*      startPos = 1
   766 *-*      commentStart = 0 /* with no comment active any longer, this is now zero */
   767 *-*      iterate
   768 *-*     end
   769 *-*     /* remove comment from middle of line; replace with blank */
   770 *-*    line      = left(line,commentStart-1)      substr(line,x+2)
   771 *-*    lowerLine = left(lowerLine,commentStart-1) substr(lowerLine,x+2)
   772 *-*    startPos = commentStart + 1
   773 *-*    commentStart = 0 /* with no comment active any longer, this is now zero */
   774 *-*    iterate
   775 *-*   end
   777 *-*  if x < y /* comment started before literal? */
   778 *-*   then
       *-*   do
   779 *-*    /* logic says (see prior "if commentNested > 0" that commentNested must be zero */
   780 *-*    if substr(line,x,2) = '/*'
   781 *-*     then
       *-*     do
   782 *-*      /* this must be true for rexx syntax approved code */
   783 *-*      commentNested = 1 /* this is start of a comment */
   784 *-*      commentStart  = x /* ... and started here       */
   785 *-*      startPos = x + 2  /* start looking for end of comment here */
   786 *-*      iterate
   787 *-*     end
   788 *-*    call logicMsg 'how can a comment end, that was never started?'
   789 *-*    startPos = x+2
   790 *-*    iterate
   791 *-*   end
   793 *-*   /* start of literal found, it may be a:            */
   794 *-*   /*    'some literal value' a regular literal       */
   795 *-*   /* or '1010 1100'b         a binary  literal       */
   796 *-*   /* or '03ef ff'x           a hex     literal       */
   797 *-*   /*                                                 */
   798 *-*   /* note:  we won't verify contents of binary or hex*/
   799 *-*   /*    literals, the rexx syntax checker did that.  */
   800 *-*   /*                                                 */
   801 *-*   /* so we will remove literal and replace it with   */
   802 *-*   /*    " 'LIT' "  i.e. with 'LIT' with blanks around*/
   803 *-*   /*    it.                                          */
   804 *-*   /*                                                 */
   805 *-*  LiteralStart = y
   806 *-*  LitQuote = substr(line,y,1)
   807 *-*  do forever /* find end of literal */
   808 *-*   yy= pos(litQuote,line,y+1) /* find ending quote */
   809 *-*   if yy = 0
   810 *-*    then
       *-*    do
   811 *-*     /* literal should have ended, if syntax corrrect */
   812 *-*     /* add closing quote (that should have been in literal */
   813 *-*     litValue = substr(lowerLine,LiteralStart) || litQuote
   814 *-*     litNext = litNext + 1
   815 *-*     litValue.litNext = litValue
   817 *-*     call logicMsg 'Why didn''t literal end'
   818 *-*     if LiteralStart = 1
   819 *-*      then
       *-*      return /* basically one long literal, even if it didn't end */
   821 *-*     line = left(line,y-1) " 'LIT"||litnext
   822 *-*     literalStart = 0          /* basically end of parsing */
   823 *-*     startPos = length(line)+1 /* basically end of parsing */
   824 *-*     leave
   825 *-*    end
   826 *-*   if substr(line,yy,1) = substr(line,yy+1,1) /* double " or double ' */
   827 *-*    then
       *-*    do
   828 *-*     /* skip them by */
   829 *-*     y = yy + 2
   830 *-*     iterate
   831 *-*    end
   832 *-*    /* we found end of literal at yy*/
   833 *-*   leave
   834 *-*  end
   835 *-*  if literalStart = 0
   836 *-*   then
       *-*   leave
   838 *-*   /* normal case, found end of literal */
   839 *-*  Litvalue = substr(lowerLine,LiteralStart,yy-literalStart+1)
   841 *-*  /* is it really a binary literal.... don't want "b" to be a variable */
   842 *-*  if  substr(line,yy+1,2) = 'B ' ,                                       /* if B<blank>                    then a binary
literal */       | (substr(line,yy+1,1) = 'B'  & datatype(substr(line,yy+1,2),'S')= 0) /* or B<?>     is not a symbol... then a bin
ary literal */
   844 *-*   then
       *-*   do
   845 *-*    /* it's a binary/hex literal */
   846 *-*    litValue = litValue||'B'
   847 *-*    litNext = litNext + 1
   848 *-*    litValue.litNext = litValue /* save literal value */
   850 *-*    /* now replace literal with " 'LIT#' " in line/lowerLine */
   851 *-*    if literalStart = 1
   852 *-*     then
       *-*     do
   853 *-*      line      = "'LITB"||litNext strip(substr(line,yy+2))
   854 *-*      lowerLine = "'LITB"||litNext strip(substr(lowerLine,yy+2))
   855 *-*      startPos = 6 + length(litNext)
   856 *-*      literalStart = 0
   857 *-*      iterate
   858 *-*     end
   860 *-*    line      = left(line,literalStart-1) "'LITB"litNext substr(line,yy+2)
   861 *-*    lowerline = left(line,literalStart-1) "'LITB"litNext substr(lowerline,yy+2)
   862 *-*    startPos = literalStart + 6 + length(litNext)
   863 *-*    literalStart = 0
   864 *-*    iterate
   865 *-*   end
   867 *-*   /* is it really a hex literal.... don't want "x" to be a variable */
   868 *-*  if  substr(line,yy+1,2) = 'X ' ,                                       /* if X<blank>                    then a hex lit
eral */       | (substr(line,yy+1,1) = 'X'  & datatype(substr(line,yy+1,2),'S')= 0) /* or X<?>     is not a symbol... then a hex li
teral */
   870 *-*   then
       *-*   do
   871 *-*    /* it's a binary/hex literal */
   872 *-*    litValue = litValue||'X'
   873 *-*    litNext = litNext + 1
   874 *-*    litValue.litNext = litValue /* save literal value */
   876 *-*    /* now replace literal with " 'LIT#' " in line/lowerLine */
   877 *-*    if literalStart = 1
   878 *-*     then
       *-*     do
   879 *-*      line      = "'LITX"||litNext strip(substr(line,yy+2))
   880 *-*      lowerLine = "'LITX"||litNext strip(substr(lowerLine,yy+2))
   881 *-*      startPos = 6 + length(litNext)
   882 *-*      iterate
   883 *-*     end
   885 *-*    line      = left(line,literalStart-1) "'LITX"litNext substr(line,yy+2)
   886 *-*    lowerline = left(line,literalStart-1) "'LITX"litNext substr(lowerline,yy+2)
   887 *-*    startPos = literalStart + 6 + length(litNext)
   888 *-*    literalStart = 0
   889 *-*    iterate
   890 *-*   end
   892 *-*   /* just a simple literal */
   893 *-*  litNext = litNext + 1
   894 *-*  litValue.litNext = litValue /* save literal value */
   896 *-*  if literalStart = 1
   897 *-*   then
       *-*   do
   898 *-*    if substr(line,yy+1) = '(' /* looks like a function? */
   899 *-*     then
       *-*     do /*function... remove left paren...add space before/after like 'FUN# ... */
   900 *-*      line      = "'FUN"||litNext strip(substr(line,yy+2))
   901 *-*      lowerLine = "'FUN"||litNext strip(substr(lowerLine,yy+2))
   902 *-*      startPos = 5 + length(litNext)
   903 *-*     end
   904 *-*    else
       *-*     do /* not a function... add space before/after              like 'LIT# ... */
   905 *-*      line      = "'LIT"||litNext strip(substr(line,yy+1))
   906 *-*      lowerLine = "'LIT"||litNext strip(substr(lowerLine,yy+1))
   907 *-*      startPos = 5 + length(litNext)
   908 *-*     end
   909 *-*    literalStart = 0
   910 *-*    iterate
   911 *-*   end
   913 *-*   /* insert literal in middle of line */
   914 *-*  if substr(line,yy+1,1) = '(' /* looks like a function? */
   915 *-*   then
       *-*   do /* function... remove left paren.. add space before/after like 'FUN# ... */
   916 *-*    line      = left(line,literalStart-1)      "'FUN"||litnext substr(line,yy+2)
   917 *-*    lowerLine = left(lowerLine,LiteralStart-1) "'FUN"||litnext substr(lowerLine,yy+2)
   918 *-*    startPos = literalStart + 5 + length(litNext)
   919 *-*   end
   920 *-*  else
       *-*   do /* not a function... add space before/after               like 'LIT# ... */
   921 *-*    line      = left(line,literalStart-1)      "'LIT"||litnext substr(line,yy+1)
   922 *-*    lowerLine = left(lowerLine,LiteralStart-1) "'LIT"||litnext substr(lowerLine,yy+1)
   923 *-*    startPos = literalStart + 5 + length(litNext)
   924 *-*   end
   925 *-*  literalStart = 0
   926 *-*  iterate
   927 *-* end
   929 *-* /* now comments have been removed */
   930 *-* /* literals changed to 'LIT'      */
   931 *-* if line = ''
       *-*  then
       *-*  return
   933 *-*  /* handle label(s), and if found, remove them from line */
   934 *-* do forever
   935 *-*  line = strip(line)
   936 *-*  if line = ''
       *-*   then
       *-*   return
   938 *-*  if pos(':',line) = 0
   939 *-*   then
       *-*   leave
   941 *-*  parse var line varX ':' rest
   942 *-*  if words(varx) = 1
   943 *-*   then
       *-*   if datatype(varx,'s') = 1
   944 *-*    then
       *-*    do
   945 *-*     call c0470LabelDefine /* define this internal label */
   946 *-*     line = rest           /* remove label:              */
   947 *-*     iterate               /* continue looking for more labels */
   948 *-*    end
   949 *-*   else
       *-*    leave /* we've removed all labels, line variable set correctly */
   950 *-*  else
       *-*   leave    /* we've removed all labels, line variable set correctly */
   951 *-* end
   952 *-* line = strip(line)
   953 *-* if line = ''
       *-*  then
       *-*  return
   957 *-*  /* ===>  comments, if any, now removed */
   958 *-*  /* ===>  literals changed to 'LIT'     */
   959 *-*  /* ===>  scientific notation #E# change to # before E   */
   960 *-*  /* ===>  scientific notation #E+# changed to # before E */
   961 *-*  /* ===>  scientific notation #E-# changed to # before E */
   962 *-* call c0100ParseStatement
   963 *-* return
   965 *-* c0100ParseStatement:
   966 *-* /* handle statement */
   967 *-* /* Note:   to handle if expression THEN statement      */
   968 *-* /*                   or else statement                 */
   969 *-* /*                   or when expression THEN statement */
   970 *-* /*         we need the c0100var loop                   */
   971 *-* /* look at line, rid us of scientific notation; don't want extra variable 'E' in xref */
   972 *-* /* for scientic notation just get rid of E# or E+# or E-# (keep preceding #)          */
   973 *-* /*                                                                                    */
   974 *-* /* ---------------------------------------------------------------------------------- */
   976 *-* /* handle first symbol in line:  */
   977 *-* /*    1)  an assignment statement*/
   978 *-* /*    2)  a rexx statement       */
   979 *-* /*    3)  or a command for env.  */
   981 *-* if debug = 'ON'
   982 *-*  then
       *-*  do
   983 *-*   say 'debug:     lowerLine="'lowerLine'"'
   984 *-*   say 'debug:          line="'line'"'
   985 *-*  end
   988 *-* rexxStmt = ''     /* assume not processing a rexx statement  */
   989 *-* if left(line,4) = "'LIT"
   990 *-*  then
       *-*  nop /* can't be assignment and/or rexx statement */
   991 *-* else
       *-*  do
   992 *-*   x = verify(line'+',validSymbolChars,,1) /* find where it is no longer a symbol*/
   993 *-*   if x = 1 , /* = 1, it's not a symbol */                                     | pos(left(line,1),'ABCDEFGHIJKLMNOPQRSTUV
WXYZ_?!') = 0 /* variable/stem had to start with one of these*/
   995 *-*    then
       *-*    nop /* can't be an assignment stmt (has to start with a variable and/or stem */
   996 *-*   else
       *-*    do /* it's the start of a symbol & symbol looks like a variable and/or stem */
   997 *-*     /* we have start of a symbol   */
   999 *-*     /* but it could be an assignment statement */
  1000 *-*     /*              or an rexx       statement */
  1001 *-*     /*              or a command for envirnoment*/
  1002 *-*     theSymbol = substr(line,1,x-1) /* we have stem and/or variable (or rexx stmt)*/
  1003 *-*     if substr(line,x,1) = '='   , /* looks like variable/stem = something ? */          & substr(line,x,2) <> '=='   /*
... except variable/stem == somthing is not an assignment */
  1005 *-*      then
       *-*      do
  1006 *-*       /* it's an assignment statement; handle it and return   */
  1007 *-*       varx = theSymbol
  1008 *-*       call c0500AddVarStemAssignment /* varx being assigned a value */
  1010 *-*       line = strip(substr(line,x+1))
  1011 *-*       if line <> ''
  1012 *-*        then
       *-*        call c0300ParseRemaining /* expression to be evaluated */
  1013 *-*       return
  1014 *-*      end
  1015 *-*     else
       *-*      if substr(line,x,1) = ' ' /* could be a rexx stmt or an assignment statement or command */
  1016 *-*       then
       *-*       do
  1017 *-*        y = verify(line'+',' ',,x)      /* find next position of non-blank after x */
  1018 *-*        if substr(line,y,1) = '='     , /* looks like an assignment statement? */               & substr(line,y,2) <> '==
'   /* ... == (says its not)               */
  1020 *-*         then
       *-*         do
  1021 *-*          /* it's an assignment statement; handle it and return   */
  1022 *-*          varx = theSymbol
  1023 *-*          call c0500AddVarStemAssignment /* varx being assigned a value */
  1025 *-*          line = strip(substr(line,y+1))
  1026 *-*          if line <> ''
  1027 *-*           then
       *-*           call c0300ParseRemaining /* expression to be evaluated */
  1028 *-*          return
  1029 *-*         end
  1030 *-*       end
  1032 *-*       /* could be a rexx statement */
  1033 *-*     if rexxStmt.theSymbol = 1
  1034 *-*      then
       *-*      rexxStmt = theSymbol /* it is, set rexxStmt to theSymbol */
  1035 *-*    end
  1036 *-*  end
  1038 *-* if rexxStmt <> ''
  1039 *-*  then
       *-*  do /* we know we are processing a rexx statement. */
  1040 *-*   /* start processing REXX statements */
  1041 *-*   /* -------------------------------- */
  1042 *-*   if rexxStmt = 'ADDRESS'
  1043 *-*    then
       *-*    do
  1044 *-*     parse var line . line /* remove ADDRESS */
  1045 *-*     /* v1.02 fix address command */
  1046 *-*     if left(line,6) = 'VALUE'
  1047 *-*      then
       *-*      do
  1048 *-*       varx = 'ADDRESS VALUE' subword(LineWithoutCommentsNlabels,3) /* set for c0480's use */
  1049 *-*       call c0482AddrDefineValue    /* set up for special address xref */
  1051 *-*       line = strip(substr(line,7)) /* remove "value" ... and parse everything else to add to xref */
  1052 *-*       call c0300ParseRemaining     /* parse line for references */
  1053 *-*       return
  1054 *-*      end
  1056 *-*     if line = ''
  1057 *-*      then
       *-*      do
  1058 *-*       varx = 'ADDRESS'                /* address command by itself   */
  1059 *-*       call c0480AddrDefine            /* add environment to the xref */
  1060 *-*       return
  1061 *-*      end
  1063 *-*     if substr(word(line,1),1,4) <> "'LIT"  /* if NOT a literal, must be a variable? */
  1064 *-*      then
       *-*      do
  1065 *-*       varx = 'ADDRESS' "'"word(line,1)"'" /* set environment (variable is really a "constant" when it comes to address c
md) */
  1066 *-*       upper varx
  1067 *-*       if word(line,2) <> ''
       *-*        then
       *-*        varx = varx '<cmd>'
  1068 *-*       call c0480AddrDefine            /* add environment to the xref */
  1070 *-*       parse var line . line    /* remove environment from line, it's not a variable and shouldn't be xreferenced as such
*/
  1071 *-*       if line <> ''                 /* if line contains a "command", parse remaining line for references */
  1072 *-*        then
       *-*        call c0300ParseRemaining /* and parse remaining line for references */
  1073 *-*       return
  1074 *-*      end
  1076 *-*      /* starts with a literal, 1st word in literal is the environment */
  1077 *-*     if word(line,1) = "'LIT1"
  1078 *-*      then
       *-*      do
  1079 *-*       varx = word(substr(litvalue.1,2,length(litvalue.1)-2),1) /* extract 1st word from literal (for environment name) *
/
  1080 *-*       upper varx
  1081 *-*       parse varx varx potentialcmd        /* get environ potentialcmd */
  1083 *-*       if potentialcmd = '' & word(line,2) = ''
  1084 *-*        then
       *-*        varx = 'ADDRESS' "'"varx"'"         /* set environment name for xref*/
  1085 *-*       else
       *-*        varx = 'ADDRESS' "'"varx"'" '<cmd>' /* set environment name for xref*/
  1087 *-*       call c0480AddrDefine     /* add environment to the xref */
  1089 *-*       call c0300ParseRemaining /* and parse remaining line for references */
  1090 *-*       return
  1091 *-*      end
  1092 *-*     if word(line,1) = "'LITB1" | word(line,1) = "'LITX1"
  1093 *-*      then
       *-*      do /* this is too weird, just use full constant value, as no one would do this anyway */
  1094 *-*       upper litvalue.1
  1095 *-*       if word(line,2) = ''
  1096 *-*        then
       *-*        varx = 'ADDRESS' litvalue.1 '<cmd???>' /*set environment for address command */
  1097 *-*       else
       *-*        varx = 'ADDRESS' litvalue.1 '<cmd>'    /*set environment for address command */
  1098 *-*       call c0480AddrDefine       /* add environment to the xref */
  1100 *-*       call c0300ParseRemaining /* and parse remaining line for references */
  1101 *-*       return
  1102 *-*      end
  1103 *-*     return
  1104 *-*    end
  1105 *-*   else
       *-*    if rexxStmt = 'ARG'
  1106 *-*     then
       *-*     do
  1107 *-*      parse var line . template /* remove ARG */
  1108 *-*      call c0325TemplateAssignments /* handle parse template */
  1109 *-*      return
  1110 *-*     end
  1111 *-*    else
       *-*     if rexxStmt = 'CALL'
  1112 *-*      then
       *-*      do
  1113 *-*       parse var line . line /* remove 'call' from line */
  1114 *-*       if left(line,4) = 'OFF'
  1115 *-*        then
       *-*        return /* since valid syntax, must all be valid keywords, just return */
  1116 *-*       if left(line,3) = 'ON' /* this may specify a "trapname" */
  1117 *-*        then
       *-*        do
  1118 *-*         parse var Line onx verbx namex trapname
  1119 *-*         /* verbx must have been ERROR, FAILURE or HALT ... for rexx to like syntax */
  1120 *-*         /* if trapname <> '' then namex must have been NAME ... for rexx to like syntax */
  1121 *-*         if trapname <> ''
  1122 *-*          then
       *-*          do
  1123 *-*           if left(trapName,4) = "'LIT"
  1124 *-*            then
       *-*            do
  1125 *-*             parse var trapName . 'LIT' litNum "'" .
  1126 *-*             varX = litValue.Litnum
  1127 *-*            end
  1128 *-*           else
       *-*            varX = strip(trapName)
  1129 *-*           varx = varx '(CALL ON' verbx')'
  1130 *-*           call c0400CallReference
  1131 *-*           return /* and we're done here */
  1132 *-*          end
  1133 *-*         else
       *-*          do
  1134 *-*           varx = verbx '(CALL ON' verbx')'
  1135 *-*           call c0400CallReference
  1136 *-*           return /* and we're done here */
  1137 *-*          end
  1138 *-*        end
  1139 *-*       parse var line namex expression
  1140 *-*       if left(namex,4) = "'LIT"
  1141 *-*        then
       *-*        do
  1142 *-*         parse var namex . 'LIT' litNum "'" .
  1143 *-*         varX = litValue.LitNum
  1144 *-*         line = strip(expression)
  1145 *-*        end
  1146 *-*       else
       *-*        do
  1147 *-*         x = verify(line'+',validSymbolChars,,1) /* find where it is no longer a symbol*/
  1148 *-*         varX = left(line,x-1)
  1149 *-*         line = strip(substr(line,x))
  1150 *-*        end
  1151 *-*       call C0400CallReference /* reference call to routine in "varx" */
  1153 *-*       call c0300ParseRemaining
  1154 *-*       return
  1155 *-*      end
  1156 *-*     else
       *-*      if rexxStmt = 'DO'
  1157 *-*       then
       *-*       do
  1159 *-*        doLine = subword(line,2)  /* start with everything after "DO" */
  1161 *-*        if doLine = '' | doline = 'FOREVER'
  1162 *-*         then
       *-*         return  /* nothing more to do */
  1164 *-*        if word(doline,1) = 'WHILE' ,          | word(doline,1) = 'UNTIL'
  1166 *-*         then
       *-*         do
  1167 *-*          /* it began with WHILE expr or UNTIL expr; handle it quickly */
  1168 *-*          parse var doline . line
  1169 *-*          if line <> ''
  1170 *-*           then
       *-*           call c0300ParseRemaining
  1171 *-*          return
  1172 *-*         end
  1174 *-*        if subword(doline,1,2) = 'FOREVER WHILE' ,          | subword(doline,1,2) = 'FOREVER UNTIL'
  1176 *-*         then
       *-*         do
  1177 *-*          /* remove 'forever while' or 'forever until' and process remaining expression */
  1178 *-*          parse var doline . . line
  1179 *-*          if line <> ''
  1180 *-*           then
       *-*           call c0300ParseRemaining
  1181 *-*          return
  1182 *-*         end
  1184 *-*         /* figure out if we have a conditional expression (and remove word) */
  1185 *-*         /* ---------------------------------------------------------------- */
  1186 *-*        x1 = wordpos('WHILE',doline 'WHILE') /* note:  illegal to have both WHILE and UNTIL in same do stmt */
  1187 *-*        x2 = wordpos('UNTIL',doline 'UNTIL') /* note:  illegal to have both WHILE and UNTIL in same do stmt */
  1189 *-*        if x1 < x2
  1190 *-*         then
       *-*         doline = subword(doline,1,x1-1) subword(doline,x1+1) /* just make longer expression, remove WHILE */
  1191 *-*        else
       *-*         if x1 > x2
  1192 *-*          then
       *-*          doline = subword(doline,1,x2-1) subword(doline,x2+1) /* just make longer expression, remove UNTIL */
  1195 *-*          /* now, let's look at 'repetitor */
  1196 *-*          /* ----------------------------- */
  1197 *-*        repetitor = doLine
  1198 *-*        if repetitor = '' | repetitor = 'FOREVER'
  1199 *-*         then
       *-*         return
  1201 *-*        parse var repetitor namex '=' doRest
  1202 *-*        if namex <> '' & f9920VerifyRexxSymbol(nameX,'S') = 1 ,                                                & dorest <
> ''                                       ,          & left(strip(doRest),1) <> '=' /* variable/Stem '=' expri (not == expr) */
  1205 *-*         then
       *-*         do
  1206 *-*          /* we've got:  do name=expri <TO exprt> <BY exprb> <FOR exprf> */
  1207 *-*          /* ... eliminate 'TO' 'BY' or 'FOR' */
  1208 *-*          /* and use one big expression */
  1210 *-*          /* namex used in an assignement */
  1211 *-*          varx = namex
  1212 *-*          call c0500AddVarStemAssignment /* add assignment reference */
  1214 *-*          /* TO exprt (BY exprb) or (FOR exprf) can occur in any order */
  1215 *-*          x = min(wordpos('TO',dorest' TO'),wordpos('BY',dorest' BY'),wordpos('FOR',dorest' FOR'))
  1217 *-*          if x > words(dorest)
  1218 *-*           then
       *-*           do
  1219 *-*            line = strip(dorest)
  1220 *-*            if line <> ''
  1221 *-*             then
       *-*             call c0300ParseRemaining /* parse expri for references */
  1222 *-*            return
  1223 *-*           end
  1225 *-*          doKeyword = word(dorest,x)    /* remember keyword (TO, BY or FOR */
  1226 *-*          dorest = subword(dorest,1,x-1) subword(dorest,x+1) /* just remove keyword, make longer expression */
  1228 *-*          /* find end of next expression, at unused 'TO' 'BY' or 'FOR' */
  1229 *-*          if doKeyword = 'TO'
  1230 *-*           then
       *-*           x = min(wordpos('BY',dorest' BY'),wordpos('FOR',dorest' FOR'))
  1231 *-*          else
       *-*           if doKeyword = 'BY'
  1232 *-*            then
       *-*            x = min(wordpos('TO',dorest' TO'),wordpos('FOR',dorest' FOR'))
  1233 *-*           else
       *-*            if doKeyword = 'FOR'
  1234 *-*             then
       *-*             x = min(wordpos('TO',dorest' TO'),wordpos('BY',dorest' BY'))
  1235 *-*            else
       *-*             x = words(dorest) + 1 /* this can't happen, but looks good */
  1237 *-*          if x > words(dorest)
  1238 *-*           then
       *-*           do /* just one more expression to process */
  1239 *-*            line = strip(dorest)
  1240 *-*            if line <> ''
  1241 *-*             then
       *-*             call c0300ParseRemaining /* process this expression */
  1242 *-*            return
  1243 *-*           end
  1245 *-*           /* multiple expressions */
  1246 *-*           /* ... just remove keyword... and make a longer expression */
  1247 *-*          doKeyword = doKeyword word(dorest,x)
  1248 *-*          dorest = subword(dorest,1,x-1) subword(dorest,x+1) /* just remove keyword, make longer expression */
  1250 *-*          /* find end of next expression, at unused 'TO' 'BY' or 'FOR' */
  1251 *-*          if wordpos('TO',doKeyword)  = 0
       *-*           then
       *-*           x = wordpos('TO',dorest)
  1252 *-*          else
       *-*           if wordpos('BY',doKeyword)  = 0
       *-*            then
       *-*            x = wordpos('BY',dorest)
  1253 *-*           else
       *-*            if wordpos('FOR',doKeyword) = 0
       *-*             then
       *-*             x = wordpos('FOR',dorest)
  1254 *-*            else
       *-*             x = 0 /* just looks good */
  1256 *-*          if x > 0
  1257 *-*           then
       *-*           dorest = subword(dorest,1,x-1) subword(dorest,x+1) /* just remove keyword, make longer expression */
  1259 *-*          line = strip(dorest)
  1260 *-*          if line <> ''
  1261 *-*           then
       *-*           call c0300ParseRemaining /* parse references to one big expression */
  1262 *-*          return
  1263 *-*         end
  1264 *-*        else
       *-*         do
  1265 *-*          line = strip(repetitor)
  1266 *-*          if line = ''
  1267 *-*           then
       *-*           return
  1269 *-*          call c0300ParseRemaining /* parse line for references */
  1270 *-*          return
  1271 *-*         end
  1272 *-*       end
  1273 *-*      else
       *-*       if rexxStmt = 'END' /* end could be for "do" or for "select" */
  1274 *-*        then
       *-*        do
  1275 *-*         parse var line . line . /* remove 'end' */
  1276 *-*         if line <> ''
  1277 *-*          then
       *-*          call c0300ParseRemaining /* might have been:  end <name> */
  1278 *-*         return
  1279 *-*        end
  1280 *-*       else
       *-*        if rexxStmt = 'DROP'
  1281 *-*         then
       *-*         do
  1282 *-*          parse var line . line
  1283 *-*          line = translate(line,'  ','()') /* remove parens */
  1284 *-*          call c0300ParseRemaining /* parse line for references */
  1285 *-*          return
  1286 *-*         end
  1287 *-*        else
       *-*         if rexxStmt = 'EXIT'
  1288 *-*          then
       *-*          do
  1289 *-*           parse var line . line
  1290 *-*           call c0300ParseRemaining /* parse line for references */
  1291 *-*           return
  1292 *-*          end
  1293 *-*         else
       *-*          if rexxStmt = 'IF'
  1294 *-*           then
       *-*           do
  1295 *-*            parse var line . line
  1296 *-*            call c0300ParseRemaining /* parse line for references */
  1297 *-*            return
  1298 *-*           end
  1299 *-*          else
       *-*           if rexxStmt = 'THEN' /* it's either just "THEN" or "THEN ," */
  1300 *-*            then
       *-*            return
  1301 *-*           else
       *-*            if rexxStmt = 'ELSE' /* it's either just "ELSE" or "ELSE ," */
  1302 *-*             then
       *-*             return
  1303 *-*            else
       *-*             if rexxStmt = 'INTERPRET'
  1304 *-*              then
       *-*              do
  1305 *-*               parse var line . line
  1306 *-*               call c0300ParseRemaining /* parse line for references */
  1307 *-*               return
  1308 *-*              end
  1309 *-*             else
       *-*              if rexxStmt = 'ITERATE'
  1310 *-*               then
       *-*               do
  1311 *-*                parse var line . line
  1312 *-*                call c0300ParseRemaining /* parse line for references */
  1313 *-*                return
  1314 *-*               end
  1315 *-*              else
       *-*               if rexxStmt = 'LEAVE'
  1316 *-*                then
       *-*                do
  1317 *-*                 parse var line . line
  1318 *-*                 call c0300ParseRemaining /* parse line for references */
  1319 *-*                 return
  1320 *-*                end
  1321 *-*               else
       *-*                if rexxStmt = 'NOP'
  1322 *-*                 then
       *-*                 return
  1323 *-*                else
       *-*                 if rexxStmt = 'NUMERIC'
  1324 *-*                  then
       *-*                  do
  1325 *-*                   parse var line word1 word2 word3 .
  1327 *-*                   if word2 word3 = 'FORM SCIENTIFIC'
       *-*                    then
       *-*                    return
  1328 *-*                   if word2 word3 = 'FORM ENGINEERING'
       *-*                    then
       *-*                    return
  1330 *-*                   if word2 word3 = 'FORM VALUE'
       *-*                    then
       *-*                    parse var line . . . line
  1331 *-*                   else
       *-*                    if word2  = 'FORM'
       *-*                     then
       *-*                     parse var line . . line
  1332 *-*                    else
       *-*                     if word2  = 'DIGITS'
       *-*                      then
       *-*                      parse var line . . line
  1333 *-*                     else
       *-*                      if word2  = 'FUZZ'
       *-*                       then
       *-*                       parse var line . . line
  1334 *-*                      else
       *-*                       return /* this looks wrong, but can't happen with syntax checking*/
  1336 *-*                   call c0300ParseRemaining /* parse line for references */
  1337 *-*                   return
  1338 *-*                  end
  1339 *-*                 else
       *-*                  if rexxStmt = 'OPTIONS'
  1340 *-*                   then
       *-*                   return /* we don't handle the options statement */
  1341 *-*                  else
       *-*                   if rexxStmt = 'PARSE'
  1342 *-*                    then
       *-*                    do
  1343 *-*                     parse var line . line      /* remove 'parse' from line */
  1345 *-*                     if word(line,1) = 'UPPER'
  1346 *-*                      then
       *-*                      parse var line . line /* remove 'upper' from line */
  1348 *-*                     if wordpos(word(line,1),'ARG EXTERNAL NUMERIC PULL SOURCE VERSION') > 0
  1349 *-*                      then
       *-*                      do
  1350 *-*                       parse var line . template     /* get template */
  1351 *-*                       call c0325TemplateAssignments /* handle parse template */
  1352 *-*                       return
  1353 *-*                      end
  1354 *-*                     if word(line,1) = 'VALUE'
  1355 *-*                      then
       *-*                      do
  1356 *-*                       /* parse ... VALUE expression WITH template */
  1357 *-*                       parse var line . expression ' WITH ' template
  1358 *-*                       line = expression
  1359 *-*                       call c0300ParseRemaining      /* handle references in expression */
  1361 *-*                       call c0325TemplateAssignments /* handle parse template */
  1362 *-*                       return
  1363 *-*                      end
  1364 *-*                     if word(line,1) = 'VAR'
  1365 *-*                      then
       *-*                      do
  1366 *-*                       /* parse ... VAR name template */
  1367 *-*                       parse var line . name template
  1368 *-*                       line = name
  1369 *-*                       call c0300ParseRemaining      /* handle references in expression */
  1371 *-*                       call c0325TemplateAssignments /* handle parse template */
  1372 *-*                       return
  1373 *-*                      end
  1374 *-*                     return /* this would be invalid syntax (which can't happen) but it looks better */
  1375 *-*                    end
  1376 *-*                   else
       *-*                    if rexxStmt = 'PROCEDURE'
  1377 *-*                     then
       *-*                     do
  1378 *-*                      parse var line . line      /* remove 'procedure' from line */
  1380 *-*                      if word(line,1) = 'EXPOSE'
  1381 *-*                       then
       *-*                       do
  1382 *-*                        parse var line . line /* remove 'expose' from line */
  1383 *-*                        line = translate(line,'  ','()') /* remove any parens from line */
  1384 *-*                        if line <> ''
  1385 *-*                         then
       *-*                         do
  1386 *-*                          exposeRef = 1 /* turn on now */
  1387 *-*                          template = line
  1388 *-*                          call c0326TemplateList   /* handle references in rest of line */
  1389 *-*                          exposeRef = 0 /* turn off now */
  1390 *-*                         end
  1391 *-*                        return
  1392 *-*                       end
  1393 *-*                      return
  1394 *-*                     end
  1395 *-*                    else
       *-*                     if rexxStmt = 'PULL'
  1396 *-*                      then
       *-*                      do
  1397 *-*                       parse var line . template  /* remove 'pull' from line, put rest into template */
  1398 *-*                       if template <> ''
  1399 *-*                        then
       *-*                        call c0325TemplateAssignments /* handle parse template */
  1400 *-*                       return
  1401 *-*                      end
  1402 *-*                     else
       *-*                      if rexxStmt = 'PUSH'
  1403 *-*                       then
       *-*                       do
  1404 *-*                        parse var line . line      /* remove 'push' from line */
  1405 *-*                        if line <> ''
  1406 *-*                         then
       *-*                         call c0300ParseRemaining /* handle references in expression */
  1407 *-*                        return
  1408 *-*                       end
  1409 *-*                      else
       *-*                       if rexxStmt = 'QUEUE'
  1410 *-*                        then
       *-*                        do
  1411 *-*                         parse var line . line      /* remove 'queue' from line */
  1412 *-*                         if line <> ''
  1413 *-*                          then
       *-*                          call c0300ParseRemaining /* handle references in expression */
  1414 *-*                         return
  1415 *-*                        end
  1416 *-*                       else
       *-*                        if rexxStmt = 'RETURN'
  1417 *-*                         then
       *-*                         do
  1418 *-*                          parse var line . line      /* remove 'return' from line */
  1419 *-*                          if line <> ''
  1420 *-*                           then
       *-*                           call c0300ParseRemaining /* handle references in expression */
  1421 *-*                          return
  1422 *-*                         end
  1423 *-*                        else
       *-*                         if rexxStmt = 'SAY'
  1424 *-*                          then
       *-*                          do
  1425 *-*                           parse var line . line      /* remove 'say' from line */
  1426 *-*                           if line <> ''
  1427 *-*                            then
       *-*                            call c0300ParseRemaining /* handle references in expression */
  1428 *-*                           return
  1429 *-*                          end
  1430 *-*                         else
       *-*                          if rexxStmt = 'SELECT'
  1431 *-*                           then
       *-*                           do
  1432 *-*                            parse var line . ' WHEN ' expression ' THEN ' statement
  1433 *-*                            if expression <> ''
  1434 *-*                             then
       *-*                             do
  1435 *-*                              line = expression
  1436 *-*                              call c0300ParseRemaining /* handle references in expression */
  1438 *-*                              if statement <> ''
  1439 *-*                               then
       *-*                               do
  1440 *-*                                line = statement
  1441 *-*                                call c0100ParseStatement /* recursive call to ourselves */
  1442 *-*                               end
  1443 *-*                             end
  1444 *-*                            return
  1445 *-*                           end
  1446 *-*                          else
       *-*                           if rexxStmt = 'UPPER'
  1447 *-*                            then
       *-*                            do
  1448 *-*                             parse var line . template /* get template */
  1449 *-*                             if template <> ''
  1450 *-*                              then
       *-*                              call c0325TemplateAssignments /* handle parse template */
  1451 *-*                             return
  1452 *-*                            end
  1453 *-*                           else
       *-*                            if rexxStmt = 'WHEN'
  1454 *-*                             then
       *-*                             do
  1455 *-*                              parse var line . line /* remove 'when' from line */
  1456 *-*                              if line <> ''
  1457 *-*                               then
       *-*                               call c0300ParseRemaining /* handle references in expression */
  1458 *-*                              return
  1459 *-*                             end
  1460 *-*                            else
       *-*                             if rexxStmt = 'OTHERWISE'
  1461 *-*                              then
       *-*                              return /* trace 's' puts 'select' by itself.  "when expression" by itself. "otherwise" by i
tself. */
  1462 *-*                             else
       *-*                              if rexxStmt = 'SIGNAL'
  1463 *-*                               then
       *-*                               do
  1464 *-*                                parse var line . line      /* remove 'signal' from line */
  1465 *-*                                parse var line word1 word2 word3 word4 word5
  1466 *-*                                if word1 = 'VALUE'
  1467 *-*                                 then
       *-*                                 do
  1468 *-*                                  parse var line . line /* remove 'value' */
  1469 *-*                                  call c0300ParseRemaining /* handle references in expression */
  1470 *-*                                  return
  1471 *-*                                 end
  1472 *-*                                if word1 = 'OFF'
  1473 *-*                                 then
       *-*                                 do
  1474 *-*                                  parse var line . sType . /* sType will = ERROR, FAILURE, HALT, NOVALUE or SYNTAX */
  1475 *-*                                  varX = sType '(SIGNAL OFF' stype')'
  1476 *-*                                  call c0430SignalReference
  1477 *-*                                  return
  1478 *-*                                 end
  1479 *-*                                if word1 = 'ON'
  1480 *-*                                 then
       *-*                                 do
  1481 *-*                                  /* sType will = ERROR, FAILURE, HALT, NOVALUE or SYNTAX */
  1482 *-*                                  /* if namex and/or trapname not null; then NAMEX=NAME and trapname will be routine for
sType */
  1483 *-*                                  parse var line . sType namex trapname
  1484 *-*                                  if namex = 'NAME' & trapname <> ''
  1485 *-*                                   then
       *-*                                   do
  1486 *-*                                    varx = trapname '(SIGNAL ON' stype trapname')'
  1487 *-*                                    call c0430SignalReference
  1488 *-*                                   end
  1489 *-*                                  else
       *-*                                   do
  1490 *-*                                    varx = stype '(SIGNAL ON' stype')'
  1491 *-*                                    call c0430SignalReference
  1492 *-*                                   end
  1493 *-*                                  return
  1494 *-*                                 end
  1495 *-*                                 /* line has label */
  1496 *-*                                parse var line varx .
  1497 *-*                                if varx <> ''
  1498 *-*                                 then
       *-*                                 call c0430SignalReference /* generate reference for: signal labelname */
  1499 *-*                                return
  1500 *-*                               end
  1501 *-*                              else
       *-*                               if rexxStmt = 'TRACE'
  1502 *-*                                then
       *-*                                return
  1503 *-*  end /* end of handling rexx commands */
  1505 *-*  /* anything else is just an expression/command for the enviornment */
  1506 *-* call c0300ParseRemaining
  1507 *-* return
  1509 *-* c0300ParseRemaining:
  1510 *-* /* this is an expression */
  1511 *-* /*    1.  let's remove operators  */
  1512 *-* /*    2.  let's remove functions  */
  1513 *-* /*    3.  let's remove literals   */
  1514 *-* /* then look for variables and reference them */
  1516 *-* /* remove the "easy" operators to remove */
  1517 *-* line = translate(line,'            ','+-*/%=<>,|&¬\;)')
  1518 *-* /*   say 'rexxline='rexxline 'line="'line'"' */
  1520 *-* /* now, (easier) find and remove literals and (literal)functions */
  1521 *-* /*   while removing 'LIT### or 'FUN### from expression           */
  1522 *-* /* ------------------------------------------------------------- */
  1523 *-* do while pos("'",line) > 0
  1525 *-*  /* starting at "'" get LIT### or FUN### */
  1526 *-*  /* ...and remove it from 'line'         */
  1527 *-*  parse var line leftLine "'" litFun rightline
  1528 *-*  line = leftLine rightLine
  1530 *-*  /* either LIT### or FUN### */
  1531 *-*  if left(litFun,3) = 'LIT'
  1532 *-*   then
       *-*   iterate
  1534 *-*   /* FUN### */
  1535 *-*  parse var litfun . 4 functionNum .
  1536 *-*  varx = litValue.functionNum /* reference the function name */
  1537 *-*  call c0415FunctionReference
  1538 *-* end
  1540 *-* /* now, find variable/stem and/or built=in or internal functions */
  1541 *-* /* ------------------------------------------------------------- */
  1542 *-* line = strip(line)
  1543 *-* do forever
  1544 *-*  if line = ''
  1545 *-*   then
       *-*   return
  1547 *-*  line = strip(line)
  1548 *-*  if left(line,1) = '('
  1549 *-*   then
       *-*   do
  1550 *-*    line = strip(substr(line,2))
  1551 *-*    iterate
  1552 *-*   end
  1554 *-*  x = min(pos(' ',line' '),pos('(',line'('))
  1555 *-*  if substr(line,x,1) = '('
  1556 *-*   then
       *-*   do                            /* token(something*/
  1557 *-*    token = left(line,x)            /* token = token( */
  1558 *-*    line  = strip(substr(line,x+1)) /* line  = something */
  1559 *-*   end
  1560 *-*  else
       *-*   parse var line token line     /* token something*/
  1562 *-*  if right(token,1) = '('
  1563 *-*   then
       *-*   do
  1564 *-*    /* potential built-in and/or internal function */
  1565 *-*    varX = substr(token,1,length(token)-1)
  1566 *-*    if f9920VerifyRexxSymbol(varX,'S') = 1   /* valid symbol */
  1567 *-*     then
       *-*     do
  1568 *-*      /* token looks good */
  1569 *-*      if pos('.',varX) = 0
  1570 *-*       then
       *-*       do
  1571 *-*        /* we have a built-in or internal function call */
  1572 *-*        varx = substr(token,1,length(token)-1)
  1573 *-*        call c0415FunctionReference
  1574 *-*        line = strip(line)
  1575 *-*        iterate
  1576 *-*       end
  1577 *-*       /* we have a stem variable followed by a ( paren */
  1578 *-*       /* ... just ignore paren and handle stem         */
  1579 *-*      call c0510AddVarStemReference
  1580 *-*      line = strip(line)
  1581 *-*      iterate
  1582 *-*     end
  1584 *-*    iterate
  1585 *-*   end
  1588 *-*   /* if token is a valid variable/stem then reference it */
  1589 *-*   /* --------------------------------------------------- */
  1590 *-*  varX = token
  1591 *-*  if f9920VerifyRexxSymbol(varX,'S') = 1   /* valid symbol */
  1592 *-*   then
       *-*   do
  1593 *-*    call c0510AddVarStemReference /* add reference */
  1594 *-*    line = strip(line)
  1595 *-*    iterate
  1596 *-*   end
  1598 *-*  iterate
  1599 *-* end
  1601 *-* return
  1603 *-* c0325TemplateAssignments:
       *-* /* these variables are assigned values */
  1604 *-* /* this is an template   */
  1605 *-* /*    1.  let's remove operators  */
  1606 *-* /*    2.  let's remove literals   */
  1607 *-* /* then look for variables and reference them */
  1609 *-* /* remove the operators (but not parens) */
  1610 *-* template = translate(template,'              ','+-*/%=<>,|&;,')
  1612 *-* /* look for and remove (var) */
  1613 *-* /* these are references, not assignments */
  1614 *-* do while pos('(',template) > 0
  1615 *-*  parse var template leftTemplate '(' expression ')' rightTemplate
  1616 *-*  template = leftTemplate rightTemplate
  1618 *-*  do while expression <> ''
  1619 *-*   parse var expression word1 expression
  1620 *-*   if left(word1,1) = "'"
  1621 *-*    then
       *-*    iterate
  1623 *-*   if f9920VerifyRexxSymbol(word1,'S') = 1 /* valid symbol? */
  1624 *-*    then
       *-*    do
  1625 *-*     varX = word1
  1626 *-*     call c0510AddVarStemReference /* reference var */
  1627 *-*    end
  1628 *-*  end
  1629 *-* end
  1631 *-* /* we turned literals into 'LIT just ignore those */
  1632 *-* do while template <> ''
  1633 *-*  parse var template word1 template
  1634 *-*  if left(word1,1) = "'"
  1635 *-*   then
       *-*   iterate
  1636 *-*  if f9920VerifyRexxSymbol(word1,'S') = 1 /* valid symbol */
  1637 *-*   then
       *-*   do
  1638 *-*    /* we have a variable / stem reference */
  1639 *-*    varX = word1
  1640 *-*    call c0500AddVarStemAssignment /* this is assigned a value */
  1641 *-*   end
  1642 *-* end
  1643 *-* return
  1645 *-* c0326TemplateList:
       *-* /* these variables are referenced */
  1646 *-* /* this is an template   */
  1647 *-* /*    1.  let's remove operators  */
  1648 *-* /*    2.  let's remove literals   */
  1649 *-* /* then look for variables and reference them */
  1651 *-* /* remove the operators */
  1652 *-* template = translate(template,'                ','+-*/%=<>,|&;,()')
  1655 *-* /* we turned literals into 'LIT just ignore those */
  1656 *-* do while template <> ''
  1657 *-*  parse var template word1 template
  1658 *-*  if left(word1,1) = "'"
  1659 *-*   then
       *-*   iterate
  1660 *-*  if f9920VerifyRexxSymbol(word1,'S') = 1 /* valid symbol */
  1661 *-*   then
       *-*   do
  1662 *-*    /* we have a variable / stem reference */
  1663 *-*    varX = word1
  1664 *-*    call c0510AddVarStemReference  /* this variable is being referenced */
  1665 *-*   end
  1666 *-* end
  1667 *-* return
  1669 *-* /* these routine handle references to a varx subroutine:  CALL varx        */
  1670 *-* /*                                 to a varx function:    varx()           */
  1671 *-* /*                                 to a signal:           SIGNAL varx      */
  1672 *-* /*                                 to a signal on:        SIGNAL ON  varx  */
  1673 *-* /*                                 to a signal off:       SIGNAL OFF varx  */
  1674 *-* /*                   or defining a label                                   */
  1676 *-* c0400CallReference:
  1677 *-* /* make a reference for:  call varx */
  1678 *-* labelRefx = 'C('rexxline')'
  1679 *-* call c0450LabelReference
  1680 *-* return
  1682 *-* c0415FunctionReference:
  1683 *-* /* make a reference for function:  varx() */
  1684 *-* LabelRefx = 'F('rexxline')'
  1685 *-* call c0450LabelReference
  1686 *-* return
  1688 *-* c0430SignalReference:
  1689 *-* /* make a reference for signal  :  varx   */
  1690 *-* labelRefx = 'S('rexxline')'
  1691 *-* call c0450LabelReference
  1692 *-* return
  1694 *-* c0450LabelReference:
  1695 *-* /* code to update label references for calls, functions and/or signals */
  1696 *-* varX = strip(varX)
  1697 *-* upper varX
  1699 *-* /* note:  all valid symbols including numbers, periods, etc, are used "as is" */
  1700 *-* /* this is a simple variable (label)*/
  1701 *-* if variablesIndx.varX = 0
  1702 *-*  then
       *-*  do /* we need to add variable */
  1703 *-*   variable = variable + 1
  1704 *-*   variable.variable = varX
  1705 *-*   variableLabelRef.variable = labelRefx
  1706 *-*   /* we need to define quick lookup (index) to find this entry */
  1707 *-*   variablesIndx.varX = variable        /* create quick index .Varx to # (variable) */
  1709 *-*   if debug = 'ON'
  1710 *-*    then
       *-*    say 'debug:  c0450LabelReference: ('labelRefx') label='varx
  1712 *-*  end
  1713 *-* else
       *-*  do
  1714 *-*   /* known simple var re-referenced */
  1715 *-*   /*    this is illegal, but reference it anyway */
  1716 *-*   /*    this is illegal, but reference it anyway */
  1717 *-*   indx = variablesINdx.varX
  1719 *-*   /* make sure we only add one RexxLine reference */
  1720 *-*   if wordpos(labelRefx,variableLabelRef.indx) = 0
  1721 *-*    then
       *-*    do
  1722 *-*     variableLabelRef.indx = variableLabelRef.indx labelRefx
  1724 *-*     if debug = 'ON'
  1725 *-*      then
       *-*      say 'debug:  c0450LabelReference: ('labelRefx') label='varx
  1726 *-*    end
  1727 *-*  end
  1728 *-* return
  1730 *-* c0470LabelDefine:
  1731 *-* /* code to define a label used in the rexx code */
  1732 *-* varX = strip(varX)
  1733 *-* upper varX
  1734 *-* if datatype(varX,'S') <> 1
  1735 *-*  then
       *-*  return /* if not a symbol, return */
  1737 *-*  /* but all symbols including .123 or X.Y.Z etc are allowed */
  1738 *-*  /* this is a simple variable (label)*/
  1739 *-* if variablesIndx.varX = 0
  1740 *-*  then
       *-*  do /* we need to add variable */
  1741 *-*   variable = variable + 1
  1742 *-*   variable.variable = varX             /* remember label */
  1743 *-*   variableLabelDef.variable= rexxline  /* remember where defined          */
  1744 *-*   /* we need to define quick lookup (index) to find this entry */
  1745 *-*   variablesIndx.varX = variable        /* create quick index .Varx to # (variable) */
  1747 *-*   if debug = 'ON'
  1748 *-*    then
       *-*    say 'debug:  c0470LabelDefine: ('rexxline') label='varx
  1749 *-*  end
  1750 *-* else
       *-*  do
  1751 *-*   /* known simple var re-referenced */
  1752 *-*   /*    it can be defined multiple times, but only first label used in call/function/signal */
  1753 *-*   /*    will actually be used.                                                              */
  1754 *-*   indx = variablesINdx.varX
  1756 *-*   /* make sure we only add one RexxLine reference */
  1757 *-*   if wordpos(rexxline,variableLabelDef.indx) = 0
  1758 *-*    then
       *-*    do
  1759 *-*     if words(variableLabelDef.indx) = 1
  1760 *-*      then
       *-*      do
  1761 *-*       /* start of (potentially) many duplicate labels */
  1762 *-*       variableLabelDef.indx = variableLabelDef.indx ,                                     '///Dup. IGNORED LABEL def''s:
'
  1764 *-*      end
  1765 *-*     variableLabelDef.indx = variableLabelDef.indx rexxline
  1767 *-*     if debug = 'ON'
  1768 *-*      then
       *-*      say 'debug:  c0470LabelDefine: ('rexxline') label='varx
  1769 *-*    end
  1770 *-*  end
  1771 *-* return
  1773 *-* /* v1.02 update... c0480AddrDefine: added */
  1774 *-* /* -------------------------------------- */
  1775 *-* c0480AddrDefine:
  1776 *-* /* code to define a address 'constant' used in the rexx code */
  1777 *-* /*   caller set varx to something like:  address 'TSO'              for:  address TSO               OR address 'TSO'
      */
  1778 *-* /*   caller set varx to something like:  address 'TSO' expression   for:  address TSO anything      OR address 'TSO' any
thing */
  1779 *-* /*   caller set varx to something like:  address VALUE environment  for:  address VALUE environment
      */
  1780 *-* /*   caller set varx to something like:  address VALUE environment expression
      */
  1781 *-* /*                                                                  for:  address VALUE environement anything
      */
  1783 *-* if variablesIndx.varX = 0
  1784 *-*  then
       *-*  do /* we need to add variable */
  1785 *-*   variable = variable + 1
  1786 *-*   variable.variable = varX            /* remember addr def */
  1787 *-*   variableAddrDef.variable= rexxline  /* remember where defined          */
  1788 *-*   /* we need to define quick lookup (index) to find this entry */
  1789 *-*   variablesIndx.varX = variable        /* create quick index .Varx to # (variable) */
  1791 *-*   if debug = 'ON'
  1792 *-*    then
       *-*    say 'debug:  c0480AddrDefine: ('rexxline') addr='varx
  1793 *-*  end
  1794 *-* else
       *-*  do
  1795 *-*   /* add to references of this type of address command */
  1796 *-*   indx = variablesINdx.varX
  1797 *-*   variableAddrDef.indx = variableAddrDef.indx rexxline /* keep adding references */
  1799 *-*   if debug = 'ON'
  1800 *-*    then
       *-*    say 'debug:  c0480AddrDefine: ('rexxline') addr='varx
  1801 *-*  end
  1802 *-* return
  1804 *-* /* v1.02 update... c0480AddrDefine: added */
  1805 *-* /* -------------------------------------- */
  1806 *-* c0482AddrDefineValue:
  1807 *-* /* code to define a address value expression used in the rexx code */
  1808 *-* /*   caller set varx to something like:  address 'TSO'              for:  address TSO               OR address 'TSO'
      */
  1809 *-* /*   caller set varx to something like:  address 'TSO' expression   for:  address TSO anything      OR address 'TSO' any
thing */
  1810 *-* /*   caller set varx to something like:  address VALUE environment  for:  address VALUE environment
      */
  1811 *-* /*   caller set varx to something like:  address VALUE environment expression
      */
  1812 *-* /*                                                                  for:  address VALUE environement anything
      */
  1814 *-* if variablesIndx.varX = 0
  1815 *-*  then
       *-*  do /* we need to add variable */
  1816 *-*   variable = variable + 1
  1817 *-*   variable.variable = varX                 /* remember addr def */
  1818 *-*   variableAddrDefValue.variable= rexxline  /* remember where defined          */
  1819 *-*   /* we need to define quick lookup (index) to find this entry */
  1820 *-*   variablesIndx.varX = variable        /* create quick index .Varx to # (variable) */
  1822 *-*   if debug = 'ON'
  1823 *-*    then
       *-*    say 'debug:  c0480AddrDefine: ('rexxline') addr='varx
  1824 *-*  end
  1825 *-* else
       *-*  do
  1826 *-*   /* add to references of this type of address command */
  1827 *-*   indx = variablesINdx.varX
  1828 *-*   variableAddrDefValue.indx = variableAddrDefValue.indx rexxline /* keep adding references */
  1830 *-*   if debug = 'ON'
  1831 *-*    then
       *-*    say 'debug:  c0480AddrDefine: ('rexxline') addr='varx
  1832 *-*  end
  1833 *-* return
  1836 *-* c0500AddVarStemAssignment:
  1837 *-* /* this could be a "simple" variable in varx or a "stem" variable being set */
  1838 *-* /* ... we need to keep track of assignments (and in case of a stem, also    */
  1839 *-* /* ... variables and/or constants referenced in the stem).                  */
  1840 *-* /* */
  1841 *-* varX = strip(varX)
  1842 *-* upper varX
  1843 *-* if pos('.',varX) = 0
  1844 *-*  then
       *-*  do
  1845 *-*   /* this is a simple variable */
  1846 *-*   if variablesIndx.varX = 0
  1847 *-*    then
       *-*    do /* we need to add variable */
  1848 *-*     variable = variable + 1
  1849 *-*     variable.variable = varX        /* remember variable name */
  1850 *-*     variableSet.variable = rexxLine /* remember where it was set */
  1851 *-*     /* we need to define quick lookup (index) to find this entry */
  1852 *-*     variablesIndx.varX = variable        /* create quick index .Varx to # (variable) */
  1854 *-*     if debug = 'ON'
  1855 *-*      then
       *-*      say 'debug:  c0500AddVarStemAssignment: ('rexxline') var='varx
  1856 *-*    end
  1857 *-*   else
       *-*    do
  1858 *-*     /* known simple var re-referenced */
  1859 *-*     indx = variablesINdx.varX
  1861 *-*     /* make sure we only add one RexxLine reference */
  1862 *-*     if wordpos(rexxLine,variableSet.indx) = 0
  1863 *-*      then
       *-*      do
  1864 *-*       variableSet.indx = variableSet.indx rexxline
  1866 *-*       if debug = 'ON'
  1867 *-*        then
       *-*        say 'debug:  c0500AddVarStemAssignment: ('rexxline') var='varx
  1868 *-*      end
  1869 *-*    end
  1870 *-*   return
  1871 *-*  end
  1873 *-*  /* this is a stem variable */
  1874 *-* periods = 0
  1875 *-* pPos = pos('.',varX)
  1876 *-* do while pPos <> 0
  1877 *-*  periods = periods + 1
  1878 *-*  pPos = pos('.',varX,pPos+1)
  1879 *-* end
  1881 *-* /* if part of stem is a hard coded # (other than zero), replace with # sign*/
  1882 *-* parse var varx psuedoVar '.' rest
  1883 *-* do while rest <> ''
  1884 *-*  psuedoVar = psuedoVar'.'
  1885 *-*  parse var rest stemPortion '.' rest
  1886 *-*  if datatype(stemPortion,'W')
  1887 *-*   then
       *-*   if stemPortion == '0'
  1888 *-*    then
       *-*    psuedoVar = psuedoVar || '0'
  1889 *-*   else
       *-*    psuedoVar = psuedoVar || '#'
  1890 *-*  else
       *-*   psuedoVar = psuedoVar || stemPortion
  1891 *-* end
  1892 *-* if right(varx,1) = '.'
  1893 *-*  then
       *-*  psuedoVar = psuedoVar'.'
  1895 *-*  /* define psuedoVar for tracking stems */
  1896 *-* if stemIndx.psuedoVar = 0
  1897 *-*  then
       *-*  do
  1898 *-*   /* add to stem variables */
  1899 *-*   stem = stem + 1
  1900 *-*   stemVariable.stem = psuedoVar
  1901 *-*   stemPeriods.stem  = periods
  1902 *-*   stemRef.stem= ''
  1903 *-*   StemAsg.stem= RexxLine
  1904 *-*   /* we need to define quick lookup (index) to find this psuedoVar */
  1905 *-*   stemIndx.psuedoVar = stem
  1907 *-*   if debug = 'ON'
  1908 *-*    then
       *-*    say 'debug:  c0500AddVarStemAssignment: ('rexxline') var='psuedoVar
  1909 *-*  end
  1910 *-* else
       *-*  do
  1911 *-*   /* known stem var re-referenced */
  1912 *-*   indx = stemIndx.psuedoVar
  1914 *-*   /* only one RexxLine assignment needed */
  1915 *-*   if wordpos(rexxLine,stemAsg.indx) = 0
  1916 *-*    then
       *-*    do
  1917 *-*     stemAsg.indx= stemAsg.indx rexxLine
  1919 *-*     if debug = 'ON'
  1920 *-*      then
       *-*      say 'debug:  c0500AddVarStemAssignment: ('rexxline') var='psuedoVar
  1921 *-*    end
  1922 *-*  end
  1924 *-* /* now go thru stem's and "reference" those vars */
  1925 *-* parse var varX . '.' varX /* throw away top level */
  1926 *-* do while varX <> ''
  1927 *-*  parse var varX simpleVar '.' varX /* get next potential stem var */
  1928 *-*  if f9920VerifyRexxSymbol(simpleVar,'S') = 1 /* if a symbol and not a digit */
  1929 *-*   then
       *-*   do
  1930 *-*    /* add simple variable reference's from the stem */
  1931 *-*    if variablesIndx.simpleVar = 0
  1932 *-*     then
       *-*     do /* we need to add variable */
  1933 *-*      variable = variable + 1
  1934 *-*      variable.variable     = simpleVar   /* remember the name */
  1935 *-*      variableStemSet.variable = rexxline /* remember where it was used to help set stem var */
  1936 *-*      /* we need to define quick lookup (index) to find this simpleVar */
  1937 *-*      variablesIndx.simpleVar = variable
  1939 *-*      if debug = 'ON'
  1940 *-*       then
       *-*       say 'debug:  (VarRef In stem) c0500AddVarStemAssignment: ('rexxline') var='simpleVar
  1941 *-*     end
  1942 *-*    else
       *-*     do
  1943 *-*      /* known simple var re-referenced */
  1944 *-*      indx = variablesINdx.simpleVar
  1946 *-*      /* make sure we only add one RexxLine reference */
  1947 *-*      if wordpos(rexxLine,variableStemRef.indx) = 0
  1948 *-*       then
       *-*       do
  1949 *-*        variableStemSet.indx = variableStemSet.indx rexxline
  1951 *-*        if debug = 'ON'
  1952 *-*         then
       *-*         say 'debug:  (VarRef in stem) c0500AddVarStemAssignment: ('rexxline') var='simpleVar
  1953 *-*       end
  1954 *-*     end
  1955 *-*   end
  1956 *-* end
  1957 *-* return
  1960 *-* c0510AddVarStemReference:
  1961 *-* /* this could be a "simple" variable in varx or a "stem" variable reference */
  1962 *-* /* ... we need to keep track of references  (and in case of a stem, also    */
  1963 *-* /* ... variables and/or constants referenced in the stem).                  */
  1964 *-* /* */
  1965 *-* varX = strip(varX)
  1966 *-* upper varX
  1968 *-* if pos('.',varX) = 0  /* not stem variable by definition */
  1969 *-*  then
       *-*  do
  1970 *-*   /* this is a simple variable */
  1971 *-*   if variablesIndx.varX = 0
  1972 *-*    then
       *-*    do /* we need to add variable */
  1973 *-*     variable = variable + 1
  1974 *-*     variable.variable = varX              /* remember the name */
  1975 *-*     if exposeRef = 1
  1976 *-*      then
       *-*      variableExposeRef.variable = rexxLine /* remember line # in reference */
  1977 *-*     else
       *-*      variableRef.variable       = rexxLine /* remember line # in reference */
  1978 *-*     /* we need to define quick lookup (index) to find this entry */
  1979 *-*     variablesIndx.varX = variable        /* create quick index .Varx to # (variable) */
  1981 *-*     if debug = 'ON'
  1982 *-*      then
       *-*      say 'debug:  (Var.Ref) c0510AddVarStemReference: ('rexxline') var='varx
  1983 *-*    end
  1984 *-*   else
       *-*    do
  1985 *-*     /* known simple var re-referenced */
  1986 *-*     indx = variablesINdx.varX
  1988 *-*     /* make sure we only add one RexxLine reference */
  1989 *-*     if exposeref = 1
  1990 *-*      then
       *-*      do
  1991 *-*       if wordpos(rexxLine,variableExposeRef.indx) = 0
  1992 *-*        then
       *-*        do
  1993 *-*         variableExposeRef.indx = variableExposeRef.indx rexxline
  1995 *-*         if debug = 'ON'
  1996 *-*          then
       *-*          say 'debug:  (Var.Ref) c0510AddVarStemReference: ('rexxline') var='varx
  1997 *-*        end
  1998 *-*      end
  1999 *-*     else
       *-*      do
  2000 *-*       if wordpos(rexxLine,variableRef.indx) = 0
  2001 *-*        then
       *-*        do
  2002 *-*         variableRef.indx = variableRef.indx rexxline
  2004 *-*         if debug = 'ON'
  2005 *-*          then
       *-*          say 'debug:  (Var.Ref) c0510AddVarStemReference: ('rexxline') var='varx
  2006 *-*        end
  2007 *-*      end
  2008 *-*    end
  2009 *-*   return
  2010 *-*  end
  2012 *-*  /* this is a stem variable */
  2013 *-* periods = 0
  2014 *-* pPos = pos('.',varX)
  2015 *-* do while pPos <> 0
  2016 *-*  periods = periods + 1
  2017 *-*  pPos = pos('.',varX,pPos+1)
  2018 *-* end
  2020 *-* /* if part of stem is a hard coded # (other than zero), replace with # sign*/
  2021 *-* parse var varx psuedoVar '.' rest
  2022 *-* do while rest <> ''
  2023 *-*  psuedoVar = psuedoVar'.'
  2024 *-*  parse var rest stemPortion '.' rest
  2025 *-*  if datatype(stemPortion,'W')
  2026 *-*   then
       *-*   if stemPortion == '0'
  2027 *-*    then
       *-*    psuedoVar = psuedoVar || '0'
  2028 *-*   else
       *-*    psuedoVar = psuedoVar || '#'
  2029 *-*  else
       *-*   psuedoVar = psuedoVar || stemPortion
  2030 *-* end
  2031 *-* if right(varx,1) = '.'
  2032 *-*  then
       *-*  psuedoVar = psuedoVar'.'
  2034 *-*  /* define psuedoVar for tracking stems */
  2035 *-* if stemIndx.psuedoVar = 0
  2036 *-*  then
       *-*  do
  2037 *-*   /* add to stem variables */
  2038 *-*   stem = stem + 1
  2039 *-*   stemVariable.stem = psuedoVar
  2040 *-*   stemPeriods.stem  = periods
  2041 *-*   if exposeRef = 1
  2042 *-*    then
       *-*    stemExposeRef.stem = RexxLine
  2043 *-*   else
       *-*    stemRef.stem       = RexxLine
  2044 *-*   /* we need to define quick lookup (index) to find this psuedoVar */
  2045 *-*   stemIndx.psuedoVar = stem
  2047 *-*   if debug = 'ON'
  2048 *-*    then
       *-*    say 'debug:  (StemRef) c0510AddVarStemReference: ('rexxline') var='psuedoVar
  2049 *-*  end
  2050 *-* else
       *-*  do
  2051 *-*   /* known stem var re-referenced */
  2052 *-*   indx = stemIndx.psuedoVar
  2054 *-*   /* only one RexxLine reference needed */
  2055 *-*   if exposeRef = 1
  2056 *-*    then
       *-*    do
  2057 *-*     if wordpos(rexxLine,stemExposeRef.indx) = 0
  2058 *-*      then
       *-*      do
  2059 *-*       stemExposeRef.indx= stemExposeRef.indx rexxLine
  2061 *-*       if debug = 'ON'
  2062 *-*        then
       *-*        say 'debug:  (StemRef) c0510AddVarStemReference: ('rexxline') var='psuedoVar
  2063 *-*      end
  2064 *-*    end
  2065 *-*   else
       *-*    do
  2066 *-*     if wordpos(rexxLine,stemRef.indx) = 0
  2067 *-*      then
       *-*      do
  2068 *-*       stemRef.indx= stemRef.indx rexxLine
  2070 *-*       if debug = 'ON'
  2071 *-*        then
       *-*        say 'debug:  (StemRef) c0510AddVarStemReference: ('rexxline') var='psuedoVar
  2072 *-*      end
  2073 *-*    end
  2074 *-*  end
  2076 *-* /* now go thru stem's and "reference" those vars */
  2077 *-* parse var varX . '.' varX /* throw away top level */
  2078 *-* do while varX <> ''
  2079 *-*  parse var varX simpleVar '.' varX /* get next potential stem var */
  2080 *-*  if f9920VerifyRexxSymbol(simpleVar,'S') = 1 /* if a symbol and not a digit */
  2081 *-*   then
       *-*   do
  2082 *-*    /* add simple variable reference's from the stem */
  2083 *-*    if variablesIndx.simpleVar = 0
  2084 *-*     then
       *-*     do /* we need to add variable */
  2085 *-*      variable = variable + 1
  2086 *-*      variable.variable     = simpleVar    /* remember the name */
  2087 *-*      variableStemRef.variable = rexxline  /* used in stem */
  2088 *-*      /* we need to define quick lookup (index) to find this simpleVar */
  2089 *-*      variablesIndx.simpleVar = variable
  2091 *-*      if debug = 'ON'
  2092 *-*       then
       *-*       say 'debug:  (varRef in stem) c0510AddVarStemReference: ('rexxline') var='simpleVar
  2093 *-*     end
  2094 *-*    else
       *-*     do
  2095 *-*      /* known simple var re-referenced */
  2096 *-*      indx = variablesINdx.simpleVar
  2098 *-*      /* make sure we only add one RexxLine reference */
  2099 *-*      if wordpos(rexxLine,variableStemRef.indx) = 0
  2100 *-*       then
       *-*       do
  2101 *-*        variableStemRef.indx = variableStemRef.indx rexxline
  2103 *-*        if debug = 'ON'
  2104 *-*         then
       *-*         say 'debug:  (varRef in stem) C0510AddVarStemReference: ('rexxline') var='simpleVar
  2105 *-*       end
  2106 *-*     end
  2107 *-*   end
  2108 *-* end
  2109 *-* return
  2111 *-* c9900OutputResults:
  2112 *-* if debug = 'ON'
  2113 *-*  then
       *-*  say 'debug:  before variable sort'
  2114 *-* maxVarLength = 0
  2115 *-* do sortedVariable = 1 by 1 for variable
  2116 *-*  sortedVariable.sortedVariable = variable.sortedVariable /* copy variable name */
  2117 *-*  if length(sortedVariable.sortedVariable) > maxVarLength
  2118 *-*   then
       *-*   maxVarLength = length(sortedVariable.sortedVariable)
  2119 *-*  if debug = 'ON'
  2120 *-*   then
       *-*   say 'debug:  sortedVariable.'sortedVariable'='sortedVariable.sortedVariable
  2121 *-* end
  2122 *-* sortedVariable.0 = variable
  2124 *-* /* sort variables for xref listing */
  2125 *-* /* ------------------------------- */
  2126 *-* if omvsSeg = 1
  2127 *-*  then
       *-*  y2=      BPXWUNIX('sort','sortedVariable.','sortedVariable.') /* fast omvs sort */
  2128 *-* else
       *-*  y2= f9910SlowSort('sort','sortedVariable.','sortedVariable.') /* slow rexx sort */
  2130 *-* if y2<> 0
       *-*  then
       *-*  say 'error:  stemsort returned y2='y2'; omvsSeg='omvsSeg
  2131 *-* if debug = 'ON'
  2132 *-*  then
       *-*  do
  2133 *-*   say ' '
  2134 *-*   say 'debug:  after variable sort'
  2135 *-*   do sortedVariable = 1 by 1 for variable
  2136 *-*    say 'debug:  SortedVariable.'sortedVariable'='SortedVariable.sortedVariable
  2137 *-*   end
  2138 *-*   say ' '
  2139 *-*  end
  2141 *-* if debug = 'ON'
  2142 *-*  then
       *-*  say 'debug:  before stem sort'
  2143 *-* maxStemLength = 0
  2144 *-* do sortedStemVariable = 1 by 1 for stem
  2145 *-*  sortedStemVariable.sortedStemVariable = StemVariable.sortedStemVariable /* copy stem name */
  2146 *-*  if length(sortedStemVariable.sortedStemVariable) > maxStemLength
  2147 *-*   then
       *-*   maxStemLength = length(sortedStemVariable.sortedStemVariable)
  2148 *-*  if debug = 'ON'
  2149 *-*   then
       *-*   say 'debug:  sortedStemVariable.'sortedStemVariable'='sortedStemVariable.sortedStemVariable
  2150 *-* end
  2151 *-* sortedStemVariable.0 = stem
  2153 *-* /* sort stem variables for xref listing */
  2154 *-* /* ------------------------------------ */
  2155 *-* if omvsSeg = 1
  2156 *-*  then
       *-*  y3=      BPXWUNIX('sort','sortedStemVariable.','sortedStemVariable.') /* fast omvs sort */
  2157 *-* else
       *-*  y3= f9910SlowSort('sort','sortedStemVariable.','sortedStemVariable.') /* slow rexx sort */
  2159 *-* if y3<> 0
       *-*  then
       *-*  say 'error:  stemsort returned y3='y3'; omvsSeg='omvsSeg
  2160 *-* if debug = 'ON'
  2161 *-*  then
       *-*  do
  2162 *-*   say ' '
  2163 *-*   say 'debug:  after stem sort'
  2164 *-*   do sortedStemVariable = 1 by 1 for stem
  2165 *-*    say 'debug:  SortedStemVariable.'sortedStemVariable'='SortedStemVariable.sortedStemVariable
  2166 *-*   end
  2167 *-*   say ' '
  2168 *-*  end
  2170 *-* out = 0
  2171 *-* x = f9970Card(' ')
  2172 *-* x = f9970Card(' ')
  2173 *-* x = f9970Card(' ------------ now xreference begins -----------------------')
  2174 *-* x = f9970Card(' ------------ now xreference begins -----------------------')
  2175 *-* x = f9970Card(' ')
  2176 *-* x = f9970Card('                                                                 ')
  2177 *-* x = f9970Card('    xref (1 of 2) section 1 is for variables (not stem.''s)       ')
  2178 *-* x = f9970Card('    xref (1 of 2) section 1 is for variables (not stem.''s)       ')
  2179 *-* x = f9970Card('    ----------------------------------------------------------   ')
  2180 *-* x = f9970Card('                                                                 ')
  2181 *-* x = f9970Card('       variables/labels are in "upperCase" if variable was never ')
  2182 *-* x = f9970Card('                       assigned a value.                         ')
  2183 *-* x = f9970Card('                                                                 ')
  2184 *-* x = f9970Card('                        they are in "lowercase", otherwise.      ')
  2185 *-* x = f9970Card('                                                                 ')
  2186 *-* x = f9970Card('       variables/stems set via a command, like EXECIO for        ')
  2187 *-* x = f9970Card('                       example, where the stem is within quotes  ')
  2188 *-* x = f9970Card('                       will not be shown in the xref as either   ')
  2189 *-* x = f9970Card('                       an assignment or a reference.             ')
  2190 *-* x = f9970Card('                                                                 ')
  2191 *-* x = f9970Card('       Note special variables like:  RC, SIGL, can be assigned   ')
  2192 *-* x = f9970Card('                       values explictly.  But rexx can set them  ')
  2193 *-* x = f9970Card('                       as well implicitly.  Implicit assignments ')
  2194 *-* x = f9970Card('                       are not in the xref.                      ')
  2195 *-* x = f9970Card('    ----------------------------------------------------------   ')
  2196 *-* x = f9970Card('                                                                 ')
  2197 *-* x = f9970Card(' ')
  2198 *-* x = f9970Card(' ')
  2199 *-* /* variables used as constants */
  2200 *-* maxOutputVar = min(DefaultMaxOutputVar,maxVarLength+5) /* maxoutputvar was 30, 40 or 50 */
  2201 *-* do indx2 = 1 by 1 for variable
  2202 *-*  /* get next sorted variable, then report it's information */
  2203 *-*  sortedVariable =  SortedVariable.indx2
  2204 *-*  indx = variablesIndx.sortedVariable /* use indx to info for this variable */
  2206 *-*  if variableSet.indx <> ''     /* if assigned a value, make variable name "lowerCase */
  2207 *-*   then
       *-*   tempname = translate(variable.indx,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')
  2208 *-*  else
       *-*   if right(sortedVariable,1) = '+' /* v1.02 */
  2209 *-*    then
       *-*    tempname = left(sortedVariable,length(sortedVariable)-1)
  2210 *-*   else
       *-*    tempname = variable.indx /* else, keep upper case */
  2212 *-*  if specialVar.sortedVariable > 0
  2213 *-*   then
       *-*   do
  2215 *-*    if variableSet.indx <> ''       , /* if special variable used in rexx somehow; mention it's special attributes */
      | variableRef.indx <> ''       , /* if special variable used in rexx somehow; mention it's special attributes */          | v
ariableExposeRef.indx <> '' , /* if special variable used in rexx somehow; mention it's special attributes */          | variableSt
emSet.indx   <> '' , /* if special variable used in rexx somehow; mention it's special attributes */          | variableStemRef.ind
x   <> ''   /* if special variable used in rexx somehow; mention it's special attributes */
  2220 *-*     then
       *-*     x = f9930OutputVarInfo('SpecialVar(set no-XREF)',tempName,' *Special:',' No xref; set w/ADDR env cmd and/or REXX its
elf')
  2222 *-*    if variableSet.indx <> ''
  2223 *-*     then
       *-*     x = f9930OutputVarInfo('SpecialVar(set w/ code)',tempName,'Assigned :',variableSet.indx)
  2225 *-*    if variableRef.indx <> ''
  2226 *-*     then
       *-*     x = f9930OutputVarInfo('SpecialVar(used w/rexx)',tempName,'Reference:',variableRef.indx)
  2228 *-*    if variableExposeRef.indx <> ''
  2229 *-*     then
       *-*     x = f9930OutputVarInfo('SpecialVar(used w/rexx)',tempName,'Expose Ref:',variableExposeRef.indx)
  2231 *-*    if variableStemSet.indx   <> ''
  2232 *-*     then
       *-*     x = f9930OutputVarInfo('SpecialVar(w/stem set):',tempName,'w/Stem set',variableStemSet.indx)
  2234 *-*    if variableStemRef.indx   <> ''
  2235 *-*     then
       *-*     x = f9930OutputVarInfo('SpecialVar(w/stem ref):',tempName,'W/Stem ref',variableStemRef.indx)
  2237 *-*    if variableLabelDef.indx  <> ''
  2238 *-*     then
       *-*     x = f9930OutputVarInfo('Label (internal label) ',variable.indx,'Defined  :',variableLabelDef.indx)
  2240 *-*    if variableLabelRef.indx  <> '' & variableLabelDef.indx <> ''
  2241 *-*     then
       *-*     x = f9930OutputVarInfo('Label (int. label ref) ',variable.indx,'Reference:',variableLabelRef.indx)
  2243 *-*    if variableLabelRef.indx  <> '' & variableLabelDef.indx = ''
  2244 *-*     then
       *-*     x = f9930OutputVarInfo('BuiltoIn+/External use ',variable.indx,'Reference:',variableLabelRef.indx)
  2246 *-*     /* v1.02 if an address reference, report it */
  2247 *-*    if variableAddrDef.indx   <> ''
  2248 *-*     then
       *-*     x = f9930OutputVarInfo('Address Envir.Constant)',variable.indx,'Reference:',variableAddrDef.indx)
  2249 *-*    if variableAddrDefValue.indx <> ''
  2250 *-*     then
       *-*     x = f9930OutputVarInfo('Address Envir.ValueExp)',variable.indx,'Reference:',variableAddrDefValue.indx)
  2252 *-*    iterate
  2254 *-*   end
  2256 *-*   /* if not assigned a value... but referenced "as a variable" in rexx code... report it */
  2257 *-*  if variableSet.indx = '' ,         & ( variableRef.indx <> '' | variableStemSet.indx   <> '' | variableStemRef.indx   <
> '' ,                |variableExposeRef.indx <> '')
  2260 *-*   then
       *-*   x = f9930OutputVarInfo('Variable (NEVER SET)   ',tempName,'Not Assgn:',' EITHER used as upper case value OR set via cm
d')
  2262 *-*   /* if assigned a value, report it */
  2263 *-*  if variableSet.indx <> ''                                          /* assigned a value, report it */
  2264 *-*   then
       *-*   x = f9930OutputVarInfo('Variable (set w/rexx)  ',tempName,'Assigned :',variableSet.indx)
  2266 *-*  if variableRef.indx       <> '' ,       | variableExposeRef.indx <> '' ,       | variableStemSet.indx   <> '' ,       |
 variableStemRef.indx   <> ''
  2270 *-*   then
       *-*   do
  2271 *-*    /* if variable refernce, report it*/
  2272 *-*    if variableRef.indx <> ''
  2273 *-*     then
       *-*     x = f9930OutputVarInfo('Variable (used in/rexx)',tempName,'Reference:',variableRef.indx)
  2275 *-*     /* if variable expose refernce, report it*/
  2276 *-*    if variableExposeRef.indx <> ''
  2277 *-*     then
       *-*     x = f9930OutputVarInfo('Variable (used in/rexx)',tempName,'Expose Ref:',variableExposeRef.indx)
  2279 *-*     /* if variable used in stem, report it */
  2280 *-*    if variableStemSet.indx   <> ''
  2281 *-*     then
       *-*     x = f9930OutputVarInfo('Variable (in Stem Set) ',tempName,'Assigned :',variableStemSet.indx)
  2283 *-*     /* if variable used in stem, report it */
  2284 *-*    if variableStemRef.indx   <> ''
  2285 *-*     then
       *-*     x = f9930OutputVarInfo('Variable (in Stem Ref) ',tempName,'Reference:',variableStemRef.indx)
  2286 *-*   end
  2287 *-*  else
       *-*   if variableSet.Indx <> '' /* if wasn't referenced, but it was assigned a value */
  2288 *-*    then
       *-*    x = f9930OutputVarInfo('Variable (NEVER USED)  ',tempName,'No Ref.  :',' If actually referenced, it must be via a cmd
.')
  2290 *-*    /* if it's an internal label, report it */
  2291 *-*  if variableLabelDef.indx  <> ''
  2292 *-*   then
       *-*   x = f9930OutputVarInfo('Label (internal label) ',variable.indx,'Defined  :',variableLabelDef.indx)
  2294 *-*   /* if label (internal or external) is used, report it */
  2295 *-*  if 7ariableLabelRef.indx  <> '' & variableLabelDef.Indx <> ''
  2296 *-*   then
       *-*   x = f9930OutputVarInfo('Label (int. label ref) ',variable.indx,'Reference:',variableLabelRef.indx)
  2297 *-*  else
       *-*   if variableLabelRef.indx  <> ''
  2298 *-*    then
       *-*    x = f9930OutputVarInfo('Built-In+/External use ',variable.indx,'Reference:',variableLabelRef.indx)
  2300 *-*    /* v1.02 if an address reference, report it */
  2301 *-*  if variableAddrDef.indx   <> ''
  2302 *-*   then
       *-*   x = f9930OutputVarInfo('Address Envir.Constant)',variable.indx,'Reference:',variableAddrDef.indx)
  2303 *-*  if variableAddrDefValue.indx <> ''
  2304 *-*   then
       *-*   x = f9930OutputVarInfo('Address Envir.ValueExp)',variable.indx,'Reference:',variableAddrDefValue.indx)
  2307 *-* end
  2309 *-* 'EXECIO' out 'DISKW RESULTS (STEM OUT.'
  2310 *-* if rc <> 0
  2311 *-*  then
       *-*  do
  2312 *-*   say 'error writing to RESULTS ddname; rc='rc
  2313 *-*   say 'exit 8'
  2314 *-*   'EXECIO 0 DISKW RESULTS (FINIS'
  2315 *-*   exit 8
  2316 *-*  end
  2318 *-*  /* variables used as variables */
  2319 *-* out = 0
  2320 *-* x = f9970Card('    xref (1 of 2) ends here                                      ')
  2321 *-* x = f9970Card('    xref (1 of 2) ends here                                      ')
  2322 *-* x = f9970Card('    -----------------------                                      ')
  2323 *-* x = f9970Card('                                                                 ')
  2324 *-* x = f9970Card('    xref (2 of 2) section 2 is for stem variable xreference.     ')
  2325 *-* x = f9970Card('    xref (2 of 2) section 2 is for stem variable xreference.     ')
  2326 *-* x = f9970Card('    ----------------------------------------------------------   ')
  2327 *-* x = f9970Card('       note:     Assignments/references to rexx stems            ')
  2328 *-* x = f9970Card('              is only for stem references in rexx code           ')
  2329 *-* x = f9970Card('              itself.                                            ')
  2330 *-* x = f9970Card('                                                                 ')
  2331 *-* x = f9970Card('                 Therefore, references to stem variables         ')
  2332 *-* x = f9970Card('              that are made INSIDE of quotes, say as             ')
  2333 *-* x = f9970Card('              part of an EXECIO command, will NOT show           ')
  2334 *-* x = f9970Card('              up in the XREF as they are part of a "string       ')
  2335 *-* x = f9970Card('              constant" and not used as a rexx variable or       ')
  2336 *-* x = f9970Card('              rexx stem directly.                                ')
  2337 *-* x = f9970Card('                                                                 ')
  2338 *-* x = f9970Card('                 This is because it often may not be obvious     ')
  2339 *-* x = f9970Card('              which address environment a command may (or may    ')
  2340 *-* x = f9970Card('              not) be valid in.  Or for us to know all the       ')
  2341 *-* x = f9970Card('              ways a rexx stem might be used.                    ')
  2342 *-* x = f9970Card('                                                                 ')
  2343 *-* x = f9970Card('    ----------------------------------------------------------   ')
  2344 *-* x = f9970Card('                                                                 ')
  2345 *-* x = f9970Card(' ')
  2346 *-* x = f9970Card(' ')
  2347 *-* x = f9970Card(' ')
  2348 *-* x = f9970Card(' ')
  2349 *-* x = f9970Card(' ')
  2350 *-* maxOutputVar = min(defaultMaxOutputVar,maxStemLength+5)
  2351 *-* do indx2 = 1 by 1 for stem
  2352 *-*  /* get next sorted stem variable, then report it's information */
  2353 *-*  sortedStemVariable =  SortedStemVariable.indx2
  2354 *-*  indx = stemIndx.sortedStemVariable /* use indx to info for this variable */
  2356 *-*  /* now report on it */
  2357 *-*  tempname = stemVariable.indx /* get name of stem variable w/all variables*/
  2358 *-*  parse var tempname buildname '.' rest
  2359 *-*  stemName = buildName
  2360 *-*  do while rest <> ''
  2361 *-*   parse var rest tempname '.' rest
  2362 *-*   x = variablesIndx.tempname
  2363 *-*   if variableSet.x <> '' | specialVar.tempname = 1 /* upper case to lower case */
  2364 *-*    then
       *-*    tempname = translate(tempname,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')
  2365 *-*   buildname = buildname'.'tempname
  2366 *-*  end
  2367 *-*  if substr(stemVariable.indx,length(stemVariable.indx),1) = '.'
  2368 *-*   then
       *-*   buildname = buildname'.'
  2370 *-*  if specialStem.stemName
  2371 *-*   then
       *-*   x = f9930OutputVarInfo('Stem-'stemPeriods.indx,buildname,' *Special:',' Assigned via an ADDR env cmd and/or REXX itsel
f')
  2373 *-*  if stemAsg.indx <> ' '
  2374 *-*   then
       *-*   x = f9930OutputVarInfo('Stem-'stemPeriods.indx,buildname,'Assigned :',stemAsg.indx)
  2376 *-*  if stemRef.indx <>  ' '
  2377 *-*   then
       *-*   x = f9930OutputVarInfo('Stem-'stemPeriods.indx,buildname,'Reference:',stemRef.indx)
  2379 *-*  if stemExposeRef.indx <>  ' '
  2380 *-*   then
       *-*   x = f9930OutputVarInfo('Stem-'stemPeriods.indx,buildname,'Expose Ref:',stemExposeRef.indx)
  2382 *-*  if out > 99
  2383 *-*   then
       *-*   do
  2384 *-*    'EXECIO' out 'DISKW RESULTS (STEM OUT.'
  2385 *-*    if rc <> 0
  2386 *-*     then
       *-*     do
  2387 *-*      say 'error writing to ddname= RESULTS; rc='rc
  2388 *-*      say 'exit 8'
  2389 *-*      'EXECIO 0 DISKW RESULTS (FINIS'
  2390 *-*      exit 8
  2391 *-*     end
  2392 *-*    out = 0
  2393 *-*   end
  2394 *-* end
  2395 *-* 'EXECIO' out 'DISKW RESULTS (STEM OUT.'
  2396 *-* out = 0
  2397 *-* x = f9970Card('    xref (2 of 2) ends here                                      ')
  2398 *-* x = f9970Card('    xref (2 of 2) ends here                                      ')
  2399 *-* x = f9970Card('    -----------------------                                      ')
  2400 *-* x = f9970Card(' ')
  2401 *-* x = f9970Card(' ')
  2402 *-* x = f9970Card(' ------------ tips for label references ----------------------------')
  2403 *-* x = f9970Card(' ------------ tips for label references ----------------------------')
  2404 *-* x = f9970Card('     tip:  c# is a ref to CALL stmt to this   internal/external name')
  2405 *-* x = f9970Card('     tip:  f# is a ref to FUNCTION call to    internal/external function')
  2406 *-* x = f9970Card('     tip:  s# is a ref to SIGNAL stmt to this internal label     ')
  2407 *-* x = f9970Card(' ')
  2408 *-* x = f9970Card(' ')
  2409 *-* x = f9970Card(' ------------ now xreference for stem variables (tips) -------------')
  2410 *-* x = f9970Card(' ------------ now xreference for stem variables (tips) -------------')
  2411 *-* x = f9970Card('     tip:     Note:- stem variables (after 1st period) are in lower case  ')
  2412 *-* x = f9970Card('     tip:          - stem "constants" (will be shown in UPPER case)       ')
  2413 *-* x = f9970Card('     tip:          - stem "constants" that are whole numbers (and not 0)  ')
  2414 *-* x = f9970Card('     tip:               will be summarized as a # sign (in place of       ')
  2415 *-* x = f9970Card('     tip:               individual digits/numbers) so it summarizes them. ')
  2416 *-* x = f9970Card('     tip:     What XREF for stems can help you fix:                       ')
  2417 *-* x = f9970Card('     tip:     -------------------------------------                       ')
  2418 *-* x = f9970Card('     tip:      - seeing a variable (lower case) used in a stem where you  ')
  2419 *-* x = f9970Card('     tip:       EXPECTED it to always be a constant.                      ')
  2420 *-* x = f9970Card('     tip:      - seeing a constant (upper case) used in a stem where you  ')
  2421 *-* x = f9970Card('     tip:       EXPECTED it to be a variable (maybe it was misspelled).   ')
  2422 *-* x = f9970Card('     tip:                                              )                  ')
  2423 *-* x = f9970Card('     tip:line sample rexx code (followed by sample xref)                  ')
  2424 *-* x = f9970Card('     tip:---- ------------                                                ')
  2425 *-* x = f9970Card('     tip:  1     x = "Richard"                                            ')
  2426 *-* x = f9970Card('     tip:  2     firstName.y.x.1 = "Hi"                                   ')
  2427 *-* x = f9970Card('     tip:  3     firstName.y.x.2 = "Buddy"                                ')
  2428 *-* x = f9970Card('     tip:  4     firstName.y.x.0 = 2                                      ')
  2429 *-* x = f9970Card('     tip:                                                                 ')
  2430 *-* x = f9970Card('     tip:sample xref listing                                              ')
  2431 *-* x = f9970Card('     tip:-----------                                                      ')
  2432 *-* x = f9970Card('     tip:  --xref section 1 (variables)                                   ')
  2433 *-* x = f9970Card('     tip:  --xref section 1 (variables)                                   ')
  2434 *-* x = f9970Card('     tip:                                                         ')
  2435 *-* x = f9970Card('     tip:Variable (set)         X               Assigned : 1      ')
  2436 *-* x = f9970Card('     tip:Variable(w/ stem use): X               Reference: 2 3 4  ')
  2437 *-* x = f9970Card('     tip:Constant(w/ stem use): Y               Reference: 2 3 4  ')
  2438 *-* x = f9970Card('     tip:                                                         ')
  2439 *-* x = f9970Card('     tip:  --xref section 2 (stem variables)                              ')
  2440 *-* x = f9970Card('     tip:  --xref section 2 (stem variables)                              ')
  2441 *-* x = f9970Card('     tip:                                                         ')
  2442 *-* x = f9970Card('     tip:Stem-3 FIRSTNAME.Y.x.#                 Assigned : 2 3    ')
  2443 *-* x = f9970Card('     tip:Stem-3 FIRSTNAME.Y.x.0                 Assigned : 4      ')
  2444 *-* x = f9970Card('     tip:                                       Reference: 2 3 4  ')
  2445 *-* x = f9970Card('     tip:     note:  Stem-3 refers to # of periods in the stem.           ')
  2446 *-* x = f9970Card('     tip:                                                                 ')
  2447 *-* x = f9970Card('     tip:  rexx tip: remember stem value on the right is "tricky":        ')
  2448 *-* x = f9970Card('     tip:        Given following rexx code:                               ')
  2449 *-* x = f9970Card('     tip:             x = "RICHARD.HUMPHRIS"                              ')
  2450 *-* x = f9970Card('     tip:             y = "RICHARD"                                       ')
  2451 *-* x = f9970Card('     tip:             z = "HUMPHRIS"                                      ')
  2452 *-* x = f9970Card('     tip:        References to a stem variable, as shown below, are       ')
  2453 *-* x = f9970Card('     tip:          referring to the SAME stem variable:                   ')
  2454 *-* x = f9970Card('     tip:             stem.x     refers to STEM.RICHARD.HUMPHRIS          ')
  2455 *-* x = f9970Card('     tip:             stem.y.z   refers to STEM.RICHARD.HUMPHRIS          ')
  2456 *-* x = f9970Card('     tip:        This is because x contains a period.  And because      ')
  2457 *-* x = f9970Card('     tip:          everything to the right of the first period is evaluated')
  2458 *-* x = f9970Card('     tip:          first.  Then the stem variable is "looked up".         ')
  2459 *-* x = f9970Card('     tip:                                                                 ')
  2460 *-* x = f9970Card('     tip:   rexx tip:  referencing pgm above, if you set variable "a"     ')
  2461 *-* x = f9970Card('     tip:         to a upper/lower case value.  The stem will NOT upper   ')
  2462 *-* x = f9970Card('     tip:         case it.                                                ')
  2463 *-* x = f9970Card('     tip:        So if assignment statement set "a" to "richard"          ')
  2464 *-* x = f9970Card('     tip:         then stem.y is NOT the same as stem.a                   ')
  2465 *-* x = f9970Card('     tip:        Because stem.y    refers to STEM.RICHARD                 ')
  2466 *-* x = f9970Card('     tip:        and     stem.a    refers to STEM.richard                 ')
  2467 *-* x = f9970Card('     tip:                                                                 ')
  2468 *-* 'EXECIO' out 'DISKW RESULTS (STEM OUT. FINIS'
  2469 *-* if rc <> 0
  2470 *-*  then
       *-*  do
  2471 *-*   say 'error writing/closing ddname= RESULTS; rc='rc
  2472 *-*   say 'exit 8'
  2473 *-*   'EXECIO 0 DISKW RESULTS (FINIS'
  2474 *-*   exit 8
  2475 *-*  end
  2476 *-* return
  2478 *-* f9910SlowSort:
  2479 *-* /* x = f9910SlowSort('sort','unsortedVariable.','sortedVariable.') */ /* slow rexx sort */
  2480 *-* /* ... */
  2481 *-* /* we don't have an omvs segment... so we have to do sort (slowly) using rexx code instead*/
  2482 *-* /* ---------------------------------------------------------------------------------------*/
  2484 *-* parse upper arg f9910_sort . , f9910_Stem1 . , f9910_Stem2 .
  2486 *-* /* need to verify 1st parm is "SORT" */
  2487 *-* /* --------------------------------- */
  2488 *-* if f9910_sort <> 'SORT'
  2489 *-*  then
       *-*  return 1  /* error, 1st parm must be "sort" */
  2491 *-*  /* need to verify f9910_stem1 is not null */
  2492 *-*  /* -------------------------------------- */
  2493 *-* if f9910_Stem1 = ''
  2494 *-*  then
       *-*  return 2  /* error, 2nd parm must be specified */
  2496 *-*  /* need to verify f9910_stem1 is a valid symbol */
  2497 *-*  /* -------------------------------------------- */
  2498 *-* if f9920VerifyRexxSymbol(f9910_Stem1,'S') <> 1
  2499 *-*  then
       *-*  return 3                    /* invalid symbol */
  2501 *-*  /* default stem2 and/or verify it's a symbol */
  2502 *-*  /* ----------------------------------------- */
  2503 *-* if f9910_stem2 = ''
  2504 *-*  then
       *-*  f9910_stem2 = f9910_stem1 /* default to stem1 */
  2505 *-* else
       *-*  do
  2506 *-*   /* need to verify f9910_stem2 is a valid symbol */
  2507 *-*   /* -------------------------------------------- */
  2508 *-*   if f9920VerifyRexxSymbol(f9910_Stem2,'S') <> 1
  2509 *-*    then
       *-*    return 3                    /* invalid symbol */
  2510 *-*  end
  2512 *-* /* verify stem1.0 coutains a valid whole number >= 0 */
  2513 *-* /* ------------------------------------------------- */
  2514 *-* if value(f9910_stem1||'0') = ''
  2515 *-*  then
       *-*  return 4
  2516 *-* if datatype(value(f9910_Stem1 || '0'),'W') = 0 | value(f9910_Stem1 || '0') < 0
  2517 *-*  then
       *-*  return 4  /* error, stem 0 must be numeric and a whole number*/
  2519 *-*  /* anything to sort? */
  2520 *-*  /* ----------------- */
  2521 *-* if value(f9910_Stem1 || '0') = 0
  2522 *-*  then
       *-*  do
  2523 *-*   /* nothing to sort, return 0 */
  2524 *-*   if f9910_Stem2 <> f9910_Stem1
  2525 *-*    then
       *-*    x = value(f9910_Stem2 || '0','0') /* set f9910_stem2.0 = 0 */
  2526 *-*   return 0
  2527 *-*  end
  2529 *-*  /* time to sort stems */
  2530 *-*  /* ------------------ */
  2531 *-* top = value(f9910_Stem1||'0')
  2532 *-* if f9910_Stem2 <> f9910_Stem1
  2533 *-*  then
       *-*  do
  2534 *-*   /* 1st copy stem1 into stem2; as stem2 should get sorted output */
  2535 *-*   do f9910_k = 0 by 1 while f9910_k <= top
  2536 *-*    x = value(f9910_stem2||f9910_k,value(f9910_stem1||f9910_k))
  2537 *-*   end
  2538 *-*  end
  2540 *-*  /* now sort stems in output stem f9910_stem2 */
  2541 *-*  /* ----------------------------------------- */
  2542 *-* f9910_varX = top /* all stem rows need to be checked */
  2543 *-* do until f9910_varX < 2
  2544 *-*  f9910_LastSwap = 1 /* set to 1, if never changed it's all sorted */
  2545 *-*  f9910_varX_minus1 = f9910_varX - 1
  2546 *-*  do f9910_VarY = 1 until f9910_VarY >= f9910_VarX_minus1
  2547 *-*   if value(f9910_Stem2||f9910_VarY) > value(f9910_Stem2||f9910_VarY+1)
  2548 *-*    then
       *-*    do
  2549 *-*     swap = value(f9910_Stem2||f9910_VarY+1,value(f9910_Stem2||f9910_VarY))
  2550 *-*     x    = value(f9910_Stem2||f9910_VarY,swap)
  2551 *-*     f9910_LastSwap = f9910_VarY /* last swap occured here */
  2552 *-*    end
  2553 *-*  end
  2554 *-*  f9910_VarX = f9910_LastSwap /* next loop, only have to check from 1 to here */
  2555 *-* end
  2556 *-* return 0
  2558 *-* f9920VerifyRexxSymbol:
  2559 *-* /* datatype(var,'s') returns a 1 even for numeric symbols starting with 0-9 or a period */
  2560 *-* /*            ... so we need to consistently check if numeric (and if truly a symbol).  */
  2562 *-* arg f9920_symbol . , f9920_option .
  2564 *-* if f9920_option <> 'S'
  2565 *-*  then
       *-*  do
  2566 *-*   say "someone called function f9920VerifyRexxSymbol without the 'S' option"
  2567 *-*   say 'function called from line' sigl
  2568 *-*   say 'f9920_option = "'f9920_option'" expected "S"'
  2569 *-*   say 'exiting w/rc=12'
  2570 *-*   exit 12
  2571 *-*  end
  2573 *-* if f9920_symbol = ''
  2574 *-*  then
       *-*  return 0 /* not a symbol, return 0 */
  2576 *-* if datatype(f9920_symbol,'S') = 0
  2577 *-*  then
       *-*  return 0 /* not a symbol, return 0 */
  2579 *-* if pos(left(f9920_symbol,1),'0123456789.') > 0
  2580 *-*  then
       *-*  return 0 /* not a symbol (looks numeric), return 0 */
  2581 *-* return 1      /* this is a real rexx symbol */
  2583 *-* f9930OutputVarInfo:
  2584 *-* parse arg f9930LHS, f9930Var, f9930RHS, f9930Ref
  2586 *-* if firstTime = 'FIRSTTIME'
  2587 *-*  then
       *-*  do
  2588 *-*   parse upper var f9930Var lastF9930Var '.' .
  2589 *-*   firstTime = ''
  2590 *-*  end
  2592 *-* if blankOption = 'BYVAR'
  2593 *-*  then
       *-*  do
  2594 *-*   parse upper var f9930Var leftSide '.' .
  2595 *-*   if leftSide <> lastF9930Var
  2596 *-*    then
       *-*    do /* add a blank line between variables */
  2597 *-*     out = out + 1.
  2598 *-*     out.out = ' '
  2599 *-*     lastF9930Var = leftSide
  2600 *-*    end
  2601 *-*  end
  2603 *-* if length(f9930Var) > maxOutputVar
  2604 *-*  then
       *-*  do  /* have var and contents on seperate lines */
  2605 *-*   out = out + 1 /* output variable, of any length */
  2606 *-*   out.out = f9930LHS f9930Var /* output long variable name */
  2607 *-*   f9930Lhs = left('',length(f9930LHS))
  2608 *-*   f9930Var = left('...',maxoutputvar)
  2609 *-*  end
  2610 *-* else
       *-*  f9930var = left(f9930Var,maxoutputvar)
  2612 *-* spaceremaining = width - length(f9930lhs f9930var f9930rhs) - 3
  2614 *-* if length(f9930ref) < spaceRemaining
  2615 *-*  then
       *-*  wordx = words(f9930ref)
  2616 *-* else
       *-*  wordx = words(left(f9930ref,spaceRemaining)) - 1
  2618 *-* if wordx < 1
  2619 *-*  then
       *-*  wordx = 1
  2621 *-* leftwords = subword(f9930ref,1,wordx)
  2622 *-* f9930ref  = subword(f9930ref,wordx+1)
  2624 *-* out = out+1 /* output 1st (or 2nd) line */
  2625 *-* out.out = f9930LHS f9930var f9930rhs leftwords
  2627 *-* f9930Lhs = left('',length(f9930LHS))
  2628 *-* f9930Var = left('...',maxoutputvar)
  2629 *-* f9930Rhs = left('',length(f9930RHS))
  2630 *-* spaceremaining = width - length(f9930lhs f9930var f9930rhs) - 3
  2632 *-* do while f9930ref <> ''
  2633 *-*  if length(f9930ref) < spaceRemaining
  2634 *-*   then
       *-*   wordx = words(f9930ref)
  2635 *-*  else
       *-*   wordx = words(left(f9930ref,spaceRemaining)) - 1
  2637 *-*  if wordx < 1
  2638 *-*   then
       *-*   wordx = 1
  2640 *-*  leftwords = subword(f9930ref,1,wordx)
  2641 *-*  f9930ref  = subword(f9930ref,wordx+1)
  2643 *-*  out = out+1 /* output continuation lines*/
  2644 *-*  out.out = f9930LHS f9930var f9930rhs leftwords
  2645 *-* end
  2647 *-* return 0
  2650 *-* f9970Card:
  2651 *-* /* just output info */
  2652 *-* parse arg cardx
  2653 *-* /* we only need one out.out stem created for this call */
  2654 *-* out = out + 1
  2655 *-* out.out = cardx
  2656 *-* return 0
  2658 *-* logicMsg:
  2659 *-* parse arg logicMsg1
  2660 *-* say 'LogicMsg001I line('sigl')' logicMsg1 /* give logic message w/line + msg */
  2661 *-* return
READY
END


 ------------ now xreference begins -----------------------
 ------------ now xreference begins -----------------------


    xref (1 of 2) section 1 is for variables (not stem.'s)
    xref (1 of 2) section 1 is for variables (not stem.'s)
    ----------------------------------------------------------

       variables/labels are in "upperCase" if variable was never
                       assigned a value.

                        they are in "lowercase", otherwise.

       variables/stems set via a command, like EXECIO for
                       example, where the stem is within quotes
                       will not be shown in the xref as either
                       an assignment or a reference.

       Note special variables like:  RC, SIGL, can be assigned
                       values explictly.  But rexx can set them
                       as well implicitly.  Implicit assignments
                       are not in the xref.
    ----------------------------------------------------------



Variable (set w/rexx)   addressspace                    Assigned : 148
Variable (used in/rexx) addressspace                    Reference: 149

Variable (set w/rexx)   blankoption                     Assigned : 251 256 260
Variable (used in/rexx) blankoption                     Reference: 2592

Built-In+/External use  BPXWUNIX                        Reference: F(2127) F(2156)

Variable (set w/rexx)   buildname                       Assigned : 2358 2365 2368
Variable (used in/rexx) buildname                       Reference: 2359 2365 2368 2371 2374 2377 2380

Label (internal label)  C0050PASS1                      Defined  : 353
Label (int. label ref)  C0050PASS1                      Reference: C(349)

Label (internal label)  C0070PARSELINEPASS1             Defined  : 498
Label (int. label ref)  C0070PARSELINEPASS1             Reference: C(457) C(466) C(493)

Label (internal label)  C0100PARSESTATEMENT             Defined  : 965
Label (int. label ref)  C0100PARSESTATEMENT             Reference: C(962) C(1441)

Label (internal label)  C0300PARSEREMAINING             Defined  : 1509
Label (int. label ref)  C0300PARSEREMAINING             Reference: C(1012) C(1027) C(1052) C(1072) C(1089) C(1100) C(1153) C(1170) C(1180) C(1221)
                        ...                                        C(1241) C(1261) C(1269) C(1277) C(1284) C(1290) C(1296) C(1306) C(1312) C(1318)
                        ...                                        C(1336) C(1359) C(1369) C(1406) C(1413) C(1420) C(1427) C(1436) C(1457) C(1469)
                        ...                                        C(1506)

Label (internal label)  C0325TEMPLATEASSIGNMENTS        Defined  : 1603
Label (int. label ref)  C0325TEMPLATEASSIGNMENTS        Reference: C(1108) C(1351) C(1361) C(1371) C(1399) C(1450)

Label (internal label)  C0326TEMPLATELIST               Defined  : 1645
Label (int. label ref)  C0326TEMPLATELIST               Reference: C(1388)

Label (internal label)  C0400CALLREFERENCE              Defined  : 1676
Label (int. label ref)  C0400CALLREFERENCE              Reference: C(1130) C(1135) C(1151)

Label (internal label)  C0415FUNCTIONREFERENCE          Defined  : 1682
Label (int. label ref)  C0415FUNCTIONREFERENCE          Reference: C(1537) C(1573)

Label (internal label)  C0430SIGNALREFERENCE            Defined  : 1688
Label (int. label ref)  C0430SIGNALREFERENCE            Reference: C(1476) C(1487) C(1491) C(1498)

Label (internal label)  C0450LABELREFERENCE             Defined  : 1694
Label (int. label ref)  C0450LABELREFERENCE             Reference: C(1679) C(1685) C(1691)

Label (internal label)  C0470LABELDEFINE                Defined  : 1730
Label (int. label ref)  C0470LABELDEFINE                Reference: C(945)

Label (internal label)  C0480ADDRDEFINE                 Defined  : 1775
Label (int. label ref)  C0480ADDRDEFINE                 Reference: C(1059) C(1068) C(1087) C(1098)

Label (internal label)  C0482ADDRDEFINEVALUE            Defined  : 1806
Label (int. label ref)  C0482ADDRDEFINEVALUE            Reference: C(1049)

Label (internal label)  C0500ADDVARSTEMASSIGNMENT       Defined  : 1836
Label (int. label ref)  C0500ADDVARSTEMASSIGNMENT       Reference: C(1008) C(1023) C(1212) C(1640)

Label (internal label)  C0510ADDVARSTEMREFERENCE        Defined  : 1960
Label (int. label ref)  C0510ADDVARSTEMREFERENCE        Reference: C(1579) C(1593) C(1626) C(1664)

Label (internal label)  C9900OUTPUTRESULTS              Defined  : 2111
Label (int. label ref)  C9900OUTPUTRESULTS              Reference: C(350)

Variable (set w/rexx)   cardx                           Assigned : 2652
Variable (used in/rexx) cardx                           Reference: 2655

Variable (set w/rexx)   cmd                             Assigned : 454 478
Variable (used in/rexx) cmd                             Reference: 455 479

Variable (set w/rexx)   commentnested                   Assigned : 540 565 570 603 720 745 750 783
Variable (used in/rexx) commentnested                   Reference: 565 570 572 745 750 752

Variable (set w/rexx)   commentstart                    Assigned : 541 586 593 604 721 766 773 784
Variable (used in/rexx) commentstart                    Reference: 558 580 590 591 592 738 760 770 771 772

Built-In+/External use  DATATYPE                        Reference: F(218) F(230) F(455) F(479) F(661) F(670) F(698) F(842) F(868) F(943) F(1734)
                        ...                                        F(1886) F(2025) F(2516) F(2576)

Variable (set w/rexx)   debug                           Assigned : 201 213 214
Variable (used in/rexx) debug                           Reference: 215 527 707 981 1709 1724 1747 1767 1791 1799 1822 1830 1854 1866 1907 1919
                        ...                                        1939 1951 1981 1995 2004 2047 2061 2070 2091 2103 2112 2119 2131 2141 2148 2160

Variable (set w/rexx)   defaultmaxoutputvar             Assigned : 234 240 245
Variable (used in/rexx) defaultmaxoutputvar             Reference: 2200 2350

Variable (set w/rexx)   dokeyword                       Assigned : 1225 1247
Variable (used in/rexx) dokeyword                       Reference: 1229 1231 1233 1247 1251 1252 1253

Variable (set w/rexx)   doline                          Assigned : 1159 1190 1192
Variable (used in/rexx) doline                          Reference: 1161 1164 1168 1174 1178 1186 1187 1190 1192 1197

Variable (set w/rexx)   dorest                          Assigned : 1201 1226 1248 1257
Variable (used in/rexx) dorest                          Reference: 1202 1215 1217 1219 1225 1226 1230 1232 1234 1235 1237 1239 1247 1248 1251
                        ...                                        1252 1253 1257 1259

Built-In+/External use  ERRORTEXT                       Reference: F(179)

Variable (set w/rexx)   execname                        Assigned : 178
Variable (used in/rexx) execname                        Reference: 179

Variable (set w/rexx)   exposeref                       Assigned : 404 1386 1389
Variable (used in/rexx) exposeref                       Reference: 1975 1989 2041 2055

Variable (set w/rexx)   expression                      Assigned : 1139 1357 1432 1615 1619
Variable (used in/rexx) expression                      Reference: 1144 1358 1433 1435 1618 1619

Label (internal label)  F9910SLOWSORT                   Defined  : 2478
Label (int. label ref)  F9910SLOWSORT                   Reference: F(2128) F(2157)

Variable (set w/rexx)   f9910_k                         Assigned : 2535
Variable (used in/rexx) f9910_k                         Reference: 2535 2536

Variable (set w/rexx)   f9910_lastswap                  Assigned : 2544 2551
Variable (used in/rexx) f9910_lastswap                  Reference: 2554

Variable (set w/rexx)   f9910_sort                      Assigned : 2484
Variable (used in/rexx) f9910_sort                      Reference: 2488

Variable (set w/rexx)   f9910_stem1                     Assigned : 2484
Variable (used in/rexx) f9910_stem1                     Reference: 2493 2498 2504 2514 2516 2521 2524 2531 2532 2536

Variable (set w/rexx)   f9910_stem2                     Assigned : 2484 2504
Variable (used in/rexx) f9910_stem2                     Reference: 2503 2508 2524 2525 2532 2536 2547 2549 2550

Variable (set w/rexx)   f9910_varx                      Assigned : 2542 2554
Variable (used in/rexx) f9910_varx                      Reference: 2543 2545

Variable (set w/rexx)   f9910_varx_minus1               Assigned : 2545
Variable (used in/rexx) f9910_varx_minus1               Reference: 2546

Variable (set w/rexx)   f9910_vary                      Assigned : 2546
Variable (used in/rexx) f9910_vary                      Reference: 2546 2547 2549 2550 2551

Label (internal label)  F9920VERIFYREXXSYMBOL           Defined  : 2558
Label (int. label ref)  F9920VERIFYREXXSYMBOL           Reference: F(1202) F(1566) F(1591) F(1623) F(1636) F(1660) F(1928) F(2080) F(2498) F(2508)

Variable (set w/rexx)   f9920_option                    Assigned : 2562
Variable (used in/rexx) f9920_option                    Reference: 2564 2568

Variable (set w/rexx)   f9920_symbol                    Assigned : 2562
Variable (used in/rexx) f9920_symbol                    Reference: 2573 2576 2579

Variable (set w/rexx)   f9930lhs                        Assigned : 2584 2607 2627
Variable (used in/rexx) f9930lhs                        Reference: 2606 2607 2612 2625 2627 2630 2644

Label (internal label)  F9930OUTPUTVARINFO              Defined  : 2583
Label (int. label ref)  F9930OUTPUTVARINFO              Reference: F(2220) F(2223) F(2226) F(2229) F(2232) F(2235) F(2238) F(2241) F(2244) F(2248)
                        ...                                        F(2250) F(2260) F(2264) F(2273) F(2277) F(2281) F(2285) F(2288) F(2292) F(2296)
                        ...                                        F(2298) F(2302) F(2304) F(2371) F(2374) F(2377) F(2380)

Variable (set w/rexx)   f9930ref                        Assigned : 2584 2622 2641
Variable (used in/rexx) f9930ref                        Reference: 2614 2615 2616 2621 2622 2632 2633 2634 2635 2640 2641

Variable (set w/rexx)   f9930rhs                        Assigned : 2584 2629
Variable (used in/rexx) f9930rhs                        Reference: 2612 2625 2629 2630 2644

Variable (set w/rexx)   f9930var                        Assigned : 2584 2608 2610 2628
Variable (used in/rexx) f9930var                        Reference: 2588 2594 2603 2606 2610 2612 2625 2630 2644

Label (internal label)  F9970CARD                       Defined  : 2650
Label (int. label ref)  F9970CARD                       Reference: F(2171) F(2172) F(2173) F(2174) F(2175) F(2176) F(2177) F(2178) F(2179) F(2180)
                        ...                                        F(2181) F(2182) F(2183) F(2184) F(2185) F(2186) F(2187) F(2188) F(2189) F(2190)
                        ...                                        F(2191) F(2192) F(2193) F(2194) F(2195) F(2196) F(2197) F(2198) F(2320) F(2321)
                        ...                                        F(2322) F(2323) F(2324) F(2325) F(2326) F(2327) F(2328) F(2329) F(2330) F(2331)
                        ...                                        F(2332) F(2333) F(2334) F(2335) F(2336) F(2337) F(2338) F(2339) F(2340) F(2341)
                        ...                                        F(2342) F(2343) F(2344) F(2345) F(2346) F(2347) F(2348) F(2349) F(2397) F(2398)
                        ...                                        F(2399) F(2400) F(2401) F(2402) F(2403) F(2404) F(2405) F(2406) F(2407) F(2408)
                        ...                                        F(2409) F(2410) F(2411) F(2412) F(2413) F(2414) F(2415) F(2416) F(2417) F(2418)
                        ...                                        F(2419) F(2420) F(2421) F(2422) F(2423) F(2424) F(2425) F(2426) F(2427) F(2428)
                        ...                                        F(2429) F(2430) F(2431) F(2432) F(2433) F(2434) F(2435) F(2436) F(2437) F(2438)
                        ...                                        F(2439) F(2440) F(2441) F(2442) F(2443) F(2444) F(2445) F(2446) F(2447) F(2448)
                        ...                                        F(2449) F(2450) F(2451) F(2452) F(2453) F(2454) F(2455) F(2456) F(2457) F(2458)
                        ...                                        F(2459) F(2460) F(2461) F(2462) F(2463) F(2464) F(2465) F(2466) F(2467)

Variable (set w/rexx)   firsttime                       Assigned : 2589
Variable (used in/rexx) firsttime                       Reference: 2586

Variable (set w/rexx)   functionnum                     Assigned : 1535
Variable (in Stem Ref)  functionnum                     Reference: 1536

Variable (set w/rexx)   in                              Assigned : 408 410 418
Variable (used in/rexx) in                              Reference: 410 411
Variable (in Stem Ref)  in                              Reference: 454 464 471 478

Variable (set w/rexx)   indx                            Assigned : 1717 1754 1796 1827 1859 1912 1944 1986 2052 2096 2204 2354
Variable (in Stem Set)  indx                            Assigned : 1722 1762 1765 1797 1828 1864 1917 1949 1993 2002 2059 2068 2101
Variable (in Stem Ref)  indx                            Reference: 1720 1722 1757 1759 1762 1765 1797 1828 1862 1864 1915 1917 1947 1949 1991
                        ...                                        1993 2000 2002 2057 2059 2066 2068 2099 2101 2206 2207 2210 2215 2222 2223 2225
                        ...                                        2226 2228 2229 2231 2232 2234 2235 2237 2238 2240 2241 2243 2244 2247 2248 2249
                        ...                                        2250 2257 2263 2264 2266 2272 2273 2276 2277 2280 2281 2284 2285 2287 2291 2292
                        ...                                        2295 2296 2297 2298 2301 2302 2303 2304 2357 2367 2371 2373 2374 2376 2377 2379
                        ...                                        2380

Variable (set w/rexx)   indx2                           Assigned : 2201 2351
Variable (in Stem Ref)  indx2                           Reference: 2203 2353

Variable (set w/rexx)   inrc                            Assigned : 355 420
Variable (used in/rexx) inrc                            Reference: 356 359 414 421

Variable (set w/rexx)   labelrefx                       Assigned : 1678 1684 1690
Variable (used in/rexx) labelrefx                       Reference: 1705 1710 1720 1722 1725

Variable (set w/rexx)   lastf9930var                    Assigned : 2588 2599
Variable (used in/rexx) lastf9930var                    Reference: 2595

Built-In+/External use  LEFT                            Reference: F(464) F(492) F(590) F(591) F(641) F(770) F(771) F(821) F(860) F(861) F(885)
                        ...                                        F(886) F(916) F(917) F(921) F(922) F(989) F(993) F(1046) F(1114) F(1116)
                        ...                                        F(1123) F(1140) F(1148) F(1202) F(1531) F(1548) F(1557) F(1620) F(1634) F(1658)
                        ...                                        F(2209) F(2579) F(2607) F(2608) F(2610) F(2616) F(2627) F(2628) F(2629) F(2635)

Variable (set w/rexx)   leftline                        Assigned : 1527
Variable (used in/rexx) leftline                        Reference: 1528

Variable (set w/rexx)   leftside                        Assigned : 2594
Variable (used in/rexx) leftside                        Reference: 2595 2599

Variable (set w/rexx)   lefttemplate                    Assigned : 1615
Variable (used in/rexx) lefttemplate                    Reference: 1616

Variable (set w/rexx)   leftwords                       Assigned : 2621 2640
Variable (used in/rexx) leftwords                       Reference: 2625 2644

Built-In+/External use  LENGTH                          Reference: F(185) F(187) F(491) F(492) F(643) F(823) F(855) F(862) F(881) F(887) F(902)
                        ...                                        F(907) F(918) F(923) F(1079) F(1565) F(1572) F(2117) F(2118) F(2146) F(2147)
                        ...                                        F(2209) F(2367) F(2603) F(2607) F(2612) F(2614) F(2627) F(2629) F(2630) F(2633)

Variable (set w/rexx)   line                            Assigned : 405 459 468 471 482 492 538 583 590 641 718 763 770 821 853 860 879 885 900 905
                        ...                                        916 921 935 946 952 1010 1025 1044 1051 1070 1113 1144 1149 1168 1178 1219 1239
                        ...                                        1259 1265 1275 1282 1283 1289 1295 1305 1311 1317 1330 1331 1332 1333 1343 1346
                        ...                                        1358 1368 1378 1382 1383 1404 1411 1418 1425 1435 1440 1455 1464 1468 1517 1528
                        ...                                        1542 1547 1550 1558 1560 1574 1580 1594
Variable (used in/rexx) line                            Reference: 471 491 492 526 537 545 550 551 552 553 583 590 600 626 628 641 643 646 661
                        ...                                        670 685 688 717 725 730 731 732 733 763 770 780 806 808 821 823 826 842 853 860
                        ...                                        861 868 879 885 886 898 900 905 914 916 921 931 935 936 938 941 952 953 984 989
                        ...                                        992 993 1002 1003 1010 1011 1015 1017 1018 1025 1026 1044 1046 1051 1056 1063
                        ...                                        1065 1067 1070 1071 1077 1083 1092 1095 1107 1113 1114 1116 1118 1139 1147 1148
                        ...                                        1149 1159 1169 1179 1220 1240 1260 1266 1275 1276 1282 1283 1289 1295 1305 1311
                        ...                                        1317 1325 1330 1331 1332 1333 1343 1345 1346 1348 1350 1354 1357 1364 1367 1378
                        ...                                        1380 1382 1383 1384 1387 1397 1404 1405 1411 1412 1418 1419 1425 1426 1432 1448
                        ...                                        1455 1456 1464 1465 1468 1474 1483 1496 1517 1523 1527 1542 1544 1547 1548 1550
                        ...                                        1554 1555 1557 1558 1560 1574 1580 1594

Variable (set w/rexx)   linewithoutcommentsnlabels      Assigned : 688 690 700 706
Variable (used in/rexx) linewithoutcommentsnlabels      Reference: 690 691 693 696 706 708 1048

Variable (set w/rexx)   literalstart                    Assigned : 542 625 642 665 674 680 722 805 822 856 863 888 909 925
Variable (used in/rexx) literalstart                    Reference: 633 638 655 813 818 835 839 851 860 861 862 877 885 886 887 896 916 917 918
                        ...                                        921 922 923

Variable (set w/rexx)   litfun                          Assigned : 1527
Variable (used in/rexx) litfun                          Reference: 1531 1535

Variable (set w/rexx)   litnext                         Assigned : 544 634 724 814 847 873 893
Variable (used in/rexx) litnext                         Reference: 634 641 814 821 847 853 854 855 860 861 862 873 879 880 881 885 886 887 893
                        ...                                        900 901 902 905 906 907 916 917 918 921 922 923
Variable (in Stem Set)  litnext                         Assigned : 635 815 848 874 894

Variable (set w/rexx)   litnum                          Assigned : 1125 1142
Variable (in Stem Ref)  litnum                          Reference: 1126 1143

Variable (set w/rexx)   litquote                        Assigned : 626 806
Variable (used in/rexx) litquote                        Reference: 628 633 808 813

Variable (set w/rexx)   litvalue                        Assigned : 633 813 839 846 872
Variable (used in/rexx) litvalue                        Reference: 635 815 846 848 872 874 894

Label (internal label)  LOGICMSG                        Defined  : 2658
Label (int. label ref)  LOGICMSG                        Reference: C(608) C(637) C(788) C(817)

Variable (set w/rexx)   logicmsg1                       Assigned : 2659
Variable (used in/rexx) logicmsg1                       Reference: 2660

Variable (set w/rexx)   lowerline                       Assigned : 537 584 591 717 764 771 854 861 880 886 901 906 917 922
Variable (used in/rexx) lowerline                       Reference: 584 591 633 764 771 813 839 854 861 880 886 901 906 917 922 983

Built-In+/External use  MAX                             Reference: F(181)

Variable (set w/rexx)   maxoutputvar                    Assigned : 2200 2350
Variable (used in/rexx) maxoutputvar                    Reference: 2603 2608 2610 2628

Variable (set w/rexx)   maxstemlength                   Assigned : 2143 2147
Variable (used in/rexx) maxstemlength                   Reference: 2146 2350

Variable (set w/rexx)   maxvarlength                    Assigned : 2114 2118
Variable (used in/rexx) maxvarlength                    Reference: 2117 2200

Built-In+/External use  MIN                             Reference: F(182) F(555) F(556) F(735) F(736) F(1215) F(1230) F(1232) F(1234) F(1554)
                        ...                                        F(2200) F(2350)

Variable (set w/rexx)   name                            Assigned : 1367
Variable (used in/rexx) name                            Reference: 1368

Variable (set w/rexx)   namex                           Assigned : 1118 1139 1201 1483
Variable (used in/rexx) namex                           Reference: 1140 1142 1202 1211 1484

Variable (set w/rexx)   omvsseg                         Assigned : 151 157 160
Variable (used in/rexx) omvsseg                         Reference: 164 2126 2130 2155 2159

Variable (set w/rexx)   onx                             Assigned : 1118
Variable (NEVER USED)   onx                             No Ref.  : If actually referenced, it must be via a cmd.

Variable (set w/rexx)   originalline                    Assigned : 526
Variable (used in/rexx) originalline                    Reference: 531

Variable (set w/rexx)   out                             Assigned : 2170 2319 2392 2396 2597 2605 2624 2643 2654
Variable (used in/rexx) out                             Reference: 2309 2382 2384 2395 2468 2597 2605 2624 2643 2654
Variable (in Stem Set)  out                             Assigned : 2598 2606 2625 2644 2655

Variable (set w/rexx)   pendingcmd                      Assigned : 454
Variable (used in/rexx) pendingcmd                      Reference: 459 468

Variable (set w/rexx)   periods                         Assigned : 1874 1877 2013 2016
Variable (used in/rexx) periods                         Reference: 1877 1901 2016 2040

Built-In+/External use  POS                             Reference: F(545) F(550) F(551) F(552) F(553) F(628) F(693) F(725) F(730) F(731) F(732)
                        ...                                        F(733) F(808) F(938) F(993) F(1523) F(1554) F(1569) F(1614) F(1843) F(1875)
                        ...                                        F(1878) F(1968) F(2014) F(2017) F(2579)

Variable (NEVER SET)    POTENTIALCMD                    Not Assgn: EITHER used as upper case value OR set via cmd
Variable (used in/rexx) POTENTIALCMD                    Reference: 1083

Variable (set w/rexx)   ppos                            Assigned : 1875 1878 2014 2017
Variable (used in/rexx) ppos                            Reference: 1876 1878 2015 2017

Variable (set w/rexx)   psuedovar                       Assigned : 1882 1884 1888 1889 1890 1893 2021 2023 2027 2028 2029 2032
Variable (used in/rexx) psuedovar                       Reference: 1884 1888 1889 1890 1893 1900 1908 1920 2023 2027 2028 2029 2032 2039 2048
                        ...                                        2062 2071
Variable (in Stem Set)  psuedovar                       Assigned : 1905 2045
Variable (in Stem Ref)  psuedovar                       Reference: 1896 1912 2035 2052

SpecialVar(set no-XREF) RC                               *Special: No xref; set w/ADDR env cmd and/or REXX itself
SpecialVar(used w/rexx) RC                              Reference: 179 341 343 355 368 370 420 427 429 444 2310 2312 2385 2387 2469 2471

Variable (set w/rexx)   repetitor                       Assigned : 1197
Variable (used in/rexx) repetitor                       Reference: 1198 1201 1265

Variable (set w/rexx)   rest                            Assigned : 478 696 941 1882 1885 2021 2024 2358 2361
Variable (used in/rexx) rest                            Reference: 482 700 946 1883 1885 2022 2024 2360 2361

Variable (set w/rexx)   rexxline                        Assigned : 458 478 483
Variable (used in/rexx) rexxline                        Reference: 479 483 513 517 520 530 1678 1684 1690 1743 1748 1757 1765 1768 1787 1792 1797
                        ...                                        1800 1818 1823 1828 1831 1850 1855 1862 1864 1867 1903 1908 1915 1917 1920 1935
                        ...                                        1940 1947 1949 1952 1976 1977 1982 1991 1993 1996 2000 2002 2005 2042 2043 2048
                        ...                                        2057 2059 2062 2066 2068 2071 2087 2092 2099 2101 2104

Variable (set w/rexx)   rexxline2                       Assigned : 454
Variable (used in/rexx) rexxline2                       Reference: 455 458

Variable (set w/rexx)   rexxstmt                        Assigned : 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324
                        ...                                        325 326 327 328 329 330 331 332 333 988 1034
Variable (used in/rexx) rexxstmt                        Reference: 1038 1042 1105 1111 1156 1273 1280 1287 1293 1299 1301 1303 1309 1315 1321
                        ...                                        1323 1339 1341 1376 1395 1402 1409 1416 1423 1430 1446 1453 1460 1462 1501
Variable (in Stem Set)  rexxstmt                        Assigned : 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323
                        ...                                        324 325 326 327 328 329 330 331 332 333

Built-In+/External use  RIGHT                           Reference: F(179) F(185) F(187) F(491) F(1562) F(1892) F(2031) F(2208)

Variable (set w/rexx)   rightline                       Assigned : 1527
Variable (used in/rexx) rightline                       Reference: 1528

Variable (set w/rexx)   righttemplate                   Assigned : 1615
Variable (used in/rexx) righttemplate                   Reference: 1616

SpecialVar(set no-XREF) SIGL                             *Special: No xref; set w/ADDR env cmd and/or REXX itself
SpecialVar(used w/rexx) SIGL                            Reference: 179 181 182 184 2567 2660

Variable (set w/rexx)   simplevar                       Assigned : 1927 2079
Variable (used in/rexx) simplevar                       Reference: 1928 1934 1940 1952 2080 2086 2092 2104
Variable (in Stem Set)  simplevar                       Assigned : 1937 2089
Variable (in Stem Ref)  simplevar                       Reference: 1931 1944 2083 2096

Variable (set w/rexx)   sortedstemvariable              Assigned : 2144 2164 2353
Variable (used in/rexx) sortedstemvariable              Reference: 2149 2165
Variable (in Stem Set)  sortedstemvariable              Assigned : 2145
Variable (in Stem Ref)  sortedstemvariable              Reference: 2145 2146 2147 2149 2165 2354

Variable (set w/rexx)   sortedvariable                  Assigned : 2115 2135 2203
Variable (used in/rexx) sortedvariable                  Reference: 2120 2136 2208 2209
Variable (in Stem Set)  sortedvariable                  Assigned : 2116
Variable (in Stem Ref)  sortedvariable                  Reference: 2116 2117 2118 2120 2136 2204 2212

Built-In+/External use  SOURCELINE                      Reference: F(182) F(185) F(187)

Variable (set w/rexx)   spaceremaining                  Assigned : 2612 2630
Variable (used in/rexx) spaceremaining                  Reference: 2614 2616 2633 2635

Variable (set w/rexx)   special                         Assigned : 275 278 281 284 287 290 293
Variable (in Stem Set)  special                         Assigned : 276 279 282 285 288 291 294

Variable (NEVER SET)    SQLERRD                         Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  SQLERRD                         Assigned : 297

Variable (NEVER SET)    SQLWARN                         Not Assgn: EITHER used as upper case value OR set via cmd
Variable (in Stem Set)  SQLWARN                         Assigned : 298

Variable (set w/rexx)   startcmd                        Assigned : 406 481
Variable (used in/rexx) startcmd                        Reference: 452 489

Variable (set w/rexx)   startpos                        Assigned : 539 566 575 585 592 605 609 643 664 673 679 719 746 755 765 772 785 789 823 855
                        ...                                        862 881 887 902 907 918 923
Variable (used in/rexx) startpos                        Reference: 545 550 551 552 553 725 730 731 732 733

Label (internal label)  STARTUP                         Defined  : 193
Label (int. label ref)  STARTUP                         Reference: S(169)

Variable (set w/rexx)   statement                       Assigned : 1432
Variable (used in/rexx) statement                       Reference: 1438 1440

Variable (set w/rexx)   stem                            Assigned : 394 1899 2038
Variable (used in/rexx) stem                            Reference: 1899 1905 2038 2045 2144 2151 2164 2351
Variable (in Stem Set)  stem                            Assigned : 1900 1901 1902 1903 2039 2040 2042 2043

Variable (set w/rexx)   stemname                        Assigned : 2359
Variable (in Stem Ref)  stemname                        Reference: 2370

Variable (set w/rexx)   stemportion                     Assigned : 1885 2024
Variable (used in/rexx) stemportion                     Reference: 1886 1887 1890 2025 2026 2029

Built-In+/External use  STRIP                           Reference: F(455) F(458) F(479) F(483) F(583) F(584) F(690) F(706) F(763) F(764) F(853)
                        ...                                        F(854) F(879) F(880) F(900) F(901) F(905) F(906) F(935) F(952) F(1010) F(1025)
                        ...                                        F(1051) F(1128) F(1144) F(1149) F(1202) F(1219) F(1239) F(1259) F(1265) F(1542)
                        ...                                        F(1547) F(1550) F(1558) F(1574) F(1580) F(1594) F(1696) F(1732) F(1841) F(1965)

Variable (set w/rexx)   stype                           Assigned : 1474 1483
Variable (used in/rexx) stype                           Reference: 1475 1486 1490

Built-In+/External use  SUBSTR                          Reference: F(583) F(584) F(590) F(591) F(600) F(626) F(633) F(646) F(661) F(670) F(763)
                        ...                                        F(764) F(770) F(771) F(780) F(806) F(813) F(826) F(839) F(842) F(853) F(854)
                        ...                                        F(860) F(861) F(868) F(879) F(880) F(885) F(886) F(898) F(900) F(901) F(905)
                        ...                                        F(906) F(914) F(916) F(917) F(921) F(922) F(1002) F(1003) F(1010) F(1015)
                        ...                                        F(1018) F(1025) F(1051) F(1063) F(1079) F(1149) F(1550) F(1555) F(1558) F(1565)
                        ...                                        F(1572) F(2367)

Built-In+/External use  SUBWORD                         Reference: F(1048) F(1159) F(1174) F(1190) F(1192) F(1226) F(1248) F(1257) F(2621) F(2622)
                        ...                                        F(2640) F(2641)

Variable (set w/rexx)   swap                            Assigned : 2549
Variable (used in/rexx) swap                            Reference: 2550

Label (internal label)  SYNTAX                          Defined  : 171

Built-In+/External use  SYNTAX (SIGNAL ON SYNTAX)       Reference: S(147)

Variable (set w/rexx)   syntaxhigh                      Assigned : 182
Variable (used in/rexx) syntaxhigh                      Reference: 183 185 187

Variable (set w/rexx)   syntaxii                        Assigned : 183
Variable (used in/rexx) syntaxii                        Reference: 184 185 187

Variable (set w/rexx)   syntaxlow                       Assigned : 181
Variable (used in/rexx) syntaxlow                       Reference: 183

Built-In+/External use  SYSCALLS                        Reference: F(154) F(158)

Variable (set w/rexx)   template                        Assigned : 1107 1350 1357 1367 1387 1397 1448 1610 1616 1633 1652 1657
Variable (used in/rexx) template                        Reference: 1398 1449 1610 1614 1615 1632 1633 1652 1656 1657

Variable (set w/rexx)   tempname                        Assigned : 2207 2209 2210 2357 2361 2364
Variable (used in/rexx) tempname                        Reference: 2220 2223 2226 2229 2232 2235 2260 2264 2273 2277 2281 2285 2288 2358 2364 2365
Variable (in Stem Ref)  tempname                        Reference: 2362 2363

Variable (set w/rexx)   thesymbol                       Assigned : 1002
Variable (used in/rexx) thesymbol                       Reference: 1007 1022 1034
Variable (in Stem Ref)  thesymbol                       Reference: 1033

Variable (set w/rexx)   token                           Assigned : 1557 1560
Variable (used in/rexx) token                           Reference: 1562 1565 1572 1590

Variable (set w/rexx)   top                             Assigned : 2531
Variable (used in/rexx) top                             Reference: 2535 2542

Variable (set w/rexx)   totalline                       Assigned : 407 451
Variable (used in/rexx) totalline                       Reference: 451

Variable (set w/rexx)   tracerexxline                   Assigned : 219 220 522
Variable (used in/rexx) tracerexxline                   Reference: 222 225 512 513 520

Built-In+/External use  TRANSLATE                       Reference: F(1283) F(1383) F(1517) F(1610) F(1652) F(2207) F(2364)

Variable (set w/rexx)   trapname                        Assigned : 1118 1483
Variable (used in/rexx) trapname                        Reference: 1121 1123 1125 1128 1484 1486

Variable (set w/rexx)   validsymbolchars                Assigned : 337
Variable (used in/rexx) validsymbolchars                Reference: 992 1147

Variable (set w/rexx)   validvariablestart              Assigned : 338
Variable (NEVER USED)   validvariablestart              No Ref.  : If actually referenced, it must be via a cmd.

Built-In+/External use  VALUE                           Reference: F(2514) F(2516) F(2521) F(2525) F(2531) F(2536) F(2547) F(2549) F(2550)

Variable (set w/rexx)   valueb                          Assigned : 205
Variable (used in/rexx) valueb                          Reference: 249 251 254 256 261

Variable (set w/rexx)   valuex                          Assigned : 202
Variable (used in/rexx) valuex                          Reference: 212 213

Variable (set w/rexx)   valuey                          Assigned : 203
Variable (used in/rexx) valuey                          Reference: 218 220

Variable (set w/rexx)   valuez                          Assigned : 204
Variable (used in/rexx) valuez                          Reference: 230 236 238 243 244

Variable (set w/rexx)   variable                        Assigned : 378 1703 1741 1785 1816 1848 1933 1973 2085
Variable (used in/rexx) variable                        Reference: 1703 1707 1741 1745 1785 1789 1816 1820 1848 1852 1933 1937 1973 1979 2085
                        ...                                        2089 2115 2122 2135 2201
Variable (in Stem Set)  variable                        Assigned : 1704 1705 1742 1743 1786 1787 1817 1818 1849 1850 1934 1935 1974 1976 1977
                        ...                                        2086 2087

Variable (set w/rexx)   varx                            Assigned : 696 941 1007 1022 1048 1058 1065 1066 1067 1079 1080 1084 1085 1096 1097 1126
                        ...                                        1128 1129 1134 1143 1148 1211 1475 1486 1490 1496 1536 1565 1572 1590 1625 1639
                        ...                                        1663 1696 1697 1732 1733 1841 1842 1925 1927 1965 1966 2077 2079
Variable (used in/rexx) varx                            Reference: 697 698 942 943 1067 1084 1085 1129 1497 1566 1569 1591 1696 1704 1710 1725
                        ...                                        1732 1734 1742 1748 1768 1786 1792 1800 1817 1823 1831 1841 1843 1849 1855 1867
                        ...                                        1875 1878 1882 1892 1925 1926 1927 1965 1968 1974 1982 1996 2005 2014 2017 2021
                        ...                                        2031 2077 2078 2079
Variable (in Stem Set)  varx                            Assigned : 1707 1745 1789 1820 1852 1979
Variable (in Stem Ref)  varx                            Reference: 1701 1717 1739 1754 1783 1796 1814 1827 1846 1859 1971 1986

Variable (set w/rexx)   verbx                           Assigned : 1118
Variable (used in/rexx) verbx                           Reference: 1129 1134

Built-In+/External use  VERIFY                          Reference: F(992) F(1017) F(1147)

Variable (set w/rexx)   width                           Assigned : 233 239 244
Variable (used in/rexx) width                           Reference: 2612 2630

Built-In+/External use  WORD                            Reference: F(1063) F(1065) F(1067) F(1077) F(1079) F(1083) F(1092) F(1095) F(1164) F(1225)
                        ...                                        F(1247) F(1345) F(1348) F(1354) F(1364) F(1380)

Variable (set w/rexx)   word1                           Assigned : 1325 1465 1619 1633 1657
Variable (used in/rexx) word1                           Reference: 1466 1472 1479 1620 1623 1625 1634 1636 1639 1658 1660 1663

Variable (set w/rexx)   word2                           Assigned : 1325 1465
Variable (used in/rexx) word2                           Reference: 1327 1328 1330 1331 1332 1333

Variable (set w/rexx)   word3                           Assigned : 1325 1465
Variable (used in/rexx) word3                           Reference: 1327 1328 1330

Variable (set w/rexx)   word4                           Assigned : 1465
Variable (NEVER USED)   word4                           No Ref.  : If actually referenced, it must be via a cmd.

Variable (set w/rexx)   word5                           Assigned : 1465
Variable (NEVER USED)   word5                           No Ref.  : If actually referenced, it must be via a cmd.

Built-In+/External use  WORDPOS                         Reference: F(1186) F(1187) F(1215) F(1230) F(1232) F(1234) F(1251) F(1252) F(1253) F(1348)
                        ...                                        F(1720) F(1757) F(1862) F(1915) F(1947) F(1991) F(2000) F(2057) F(2066) F(2099)

Built-In+/External use  WORDS                           Reference: F(697) F(942) F(1217) F(1235) F(1237) F(1759) F(2615) F(2616) F(2634) F(2635)

Variable (set w/rexx)   wordx                           Assigned : 2615 2616 2619 2634 2635 2638
Variable (used in/rexx) wordx                           Reference: 2618 2621 2622 2637 2640 2641

Variable (set w/rexx)   x                               Assigned : 154 158 555 735 992 1147 1215 1230 1232 1234 1235 1251 1252 1253 1254 1554 2171
                        ...                                        2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187
                        ...                                        2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2220 2223 2226 2229 2232
                        ...                                        2235 2238 2241 2244 2248 2250 2260 2264 2273 2277 2281 2285 2288 2292 2296 2298
                        ...                                        2302 2304 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333
                        ...                                        2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349
                        ...                                        2362 2371 2374 2377 2380 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407
                        ...                                        2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423
                        ...                                        2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439
                        ...                                        2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455
                        ...                                        2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2525 2536 2550
Variable (used in/rexx) x                               Reference: 155 563 566 575 583 584 590 591 597 600 604 605 609 743 746 755 763 764 770
                        ...                                        771 777 780 784 785 789 993 1002 1003 1010 1015 1017 1148 1149 1217 1225 1226
                        ...                                        1237 1247 1248 1256 1257 1555 1557 1558
Variable (in Stem Ref)  x                               Reference: 2363

Variable (set w/rexx)   x1                              Assigned : 550 730 1186
Variable (used in/rexx) x1                              Reference: 555 561 563 735 741 743 1189 1190 1191

Variable (set w/rexx)   x2                              Assigned : 551 731 1187
Variable (used in/rexx) x2                              Reference: 555 561 735 741 1189 1191 1192

Variable (set w/rexx)   y                               Assigned : 556 649 736 829 1017
Variable (used in/rexx) y                               Reference: 597 625 626 628 641 777 805 806 808 821 1018 1025

Variable (set w/rexx)   y1                              Assigned : 552 732
Variable (used in/rexx) y1                              Reference: 556 736

Variable (set w/rexx)   y2                              Assigned : 553 733 2127 2128
Variable (used in/rexx) y2                              Reference: 556 736 2130

Variable (set w/rexx)   y3                              Assigned : 2156 2157
Variable (used in/rexx) y3                              Reference: 2159

Variable (set w/rexx)   yy                              Assigned : 628 808
Variable (used in/rexx) yy                              Reference: 629 646 649 661 664 670 673 679 809 826 829 839 842 853 854 860 861 868 879
                        ...                                        880 885 886 898 900 901 905 906 914 916 917 921 922
    xref (1 of 2) ends here
    xref (1 of 2) ends here
    -----------------------

    xref (2 of 2) section 2 is for stem variable xreference.
    xref (2 of 2) section 2 is for stem variable xreference.
    ----------------------------------------------------------
       note:     Assignments/references to rexx stems
              is only for stem references in rexx code
              itself.

                 Therefore, references to stem variables
              that are made INSIDE of quotes, say as
              part of an EXECIO command, will NOT show
              up in the XREF as they are part of a "string
              constant" and not used as a rexx variable or
              rexx stem directly.

                 This is because it often may not be obvious
              which address environment a command may (or may
              not) be valid in.  Or for us to know all the
              ways a rexx stem might be used.

    ----------------------------------------------------------







Stem-1 IN.0                                       Reference: 364 367 411 423 426
Stem-1 IN.in                                      Reference: 454 464 471 478

Stem-1 LITVALUE.                                  Assigned : 543 723
Stem-1 LITVALUE.#                                 Assigned : 1094
Stem-1 LITVALUE.#                                 Reference: 1079 1096 1097
Stem-1 LITVALUE.functionnum                       Reference: 1536
Stem-1 LITVALUE.litnext                           Assigned : 635 815 848 874 894
Stem-1 LITVALUE.litnum                            Reference: 1126 1143

Stem-1 OUT.out                                    Assigned : 2598 2606 2625 2644 2655

Stem-1 REXXSTMT.                                  Assigned : 304
Stem-1 REXXSTMT.rexxstmt                          Assigned : 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325
       ...                                                   326 327 328 329 330 331 332 333
Stem-1 REXXSTMT.thesymbol                         Reference: 1033

Stem-1 SORTEDSTEMVARIABLE.0                       Assigned : 2151
Stem-1 SORTEDSTEMVARIABLE.indx2                   Reference: 2353
Stem-1 SORTEDSTEMVARIABLE.sortedstemvariable      Assigned : 2145
Stem-1 SORTEDSTEMVARIABLE.sortedstemvariable      Reference: 2146 2147 2149 2165

Stem-1 SORTEDVARIABLE.0                           Assigned : 2122
Stem-1 SORTEDVARIABLE.indx2                       Reference: 2203
Stem-1 SORTEDVARIABLE.sortedvariable              Assigned : 2116
Stem-1 SORTEDVARIABLE.sortedvariable              Reference: 2117 2118 2120 2136

Stem-1 SPECIALSTEM.                               Assigned : 296
Stem-1 SPECIALSTEM.SQLERRD                        Assigned : 297
Stem-1 SPECIALSTEM.SQLWARN                        Assigned : 298
Stem-1 SPECIALSTEM.stemname                       Reference: 2370

Stem-1 SPECIALVAR.                                Assigned : 273
Stem-1 SPECIALVAR.sortedvariable                  Reference: 2212
Stem-1 SPECIALVAR.special                         Assigned : 276 279 282 285 288 291 294
Stem-1 SPECIALVAR.tempname                        Reference: 2363

Stem-1 STEMASG.                                   Assigned : 401
Stem-1 STEMASG.indx                               Assigned : 1917
Stem-1 STEMASG.indx                               Reference: 1915 1917 2373 2374
Stem-1 STEMASG.stem                               Assigned : 1903

Stem-1 STEMEXPOSEREF.                             Assigned : 400
Stem-1 STEMEXPOSEREF.indx                         Assigned : 2059
Stem-1 STEMEXPOSEREF.indx                         Reference: 2057 2059 2379 2380
Stem-1 STEMEXPOSEREF.stem                         Assigned : 2042

Stem-1 STEMINDX.                                  Assigned : 393
Stem-1 STEMINDX.psuedovar                         Assigned : 1905 2045
Stem-1 STEMINDX.psuedovar                         Reference: 1896 1912 2035 2052
Stem-1 STEMINDX.sortedstemvariable                Reference: 2354

Stem-1 STEMPERIODS.                               Assigned : 398
Stem-1 STEMPERIODS.indx                           Reference: 2371 2374 2377 2380
Stem-1 STEMPERIODS.stem                           Assigned : 1901 2040

Stem-1 STEMREF.                                   Assigned : 399
Stem-1 STEMREF.indx                               Assigned : 2068
Stem-1 STEMREF.indx                               Reference: 2066 2068 2376 2377
Stem-1 STEMREF.stem                               Assigned : 1902 2043

Stem-1 STEMVARIABLE.                              Assigned : 397
Stem-1 STEMVARIABLE.indx                          Reference: 2357 2367
Stem-1 STEMVARIABLE.sortedstemvariable            Reference: 2145
Stem-1 STEMVARIABLE.stem                          Assigned : 1900 2039

Stem-1 VARIABLE.                                  Assigned : 381
Stem-1 VARIABLE.indx                              Reference: 2207 2210 2238 2241 2244 2248 2250 2292 2296 2298 2302 2304
Stem-1 VARIABLE.sortedvariable                    Reference: 2116
Stem-1 VARIABLE.variable                          Assigned : 1704 1742 1786 1817 1849 1934 1974 2086

Stem-1 VARIABLEADDRDEF.                           Assigned : 389
Stem-1 VARIABLEADDRDEF.indx                       Assigned : 1797
Stem-1 VARIABLEADDRDEF.indx                       Reference: 1797 2247 2248 2301 2302
Stem-1 VARIABLEADDRDEF.variable                   Assigned : 1787

Stem-1 VARIABLEADDRDEFVALUE.                      Assigned : 390
Stem-1 VARIABLEADDRDEFVALUE.indx                  Assigned : 1828
Stem-1 VARIABLEADDRDEFVALUE.indx                  Reference: 1828 2249 2250 2303 2304
Stem-1 VARIABLEADDRDEFVALUE.variable              Assigned : 1818

Stem-1 VARIABLEEXPOSEREF.                         Assigned : 383
Stem-1 VARIABLEEXPOSEREF.indx                     Assigned : 1993
Stem-1 VARIABLEEXPOSEREF.indx                     Reference: 1991 1993 2215 2228 2229 2257 2266 2276 2277
Stem-1 VARIABLEEXPOSEREF.variable                 Assigned : 1976

Stem-1 VARIABLELABELDEF.                          Assigned : 387
Stem-1 VARIABLELABELDEF.indx                      Assigned : 1762 1765
Stem-1 VARIABLELABELDEF.indx                      Reference: 1757 1759 1762 1765 2237 2238 2240 2243 2291 2292 2295
Stem-1 VARIABLELABELDEF.variable                  Assigned : 1743

Stem-1 VARIABLELABELREF.                          Assigned : 388
Stem-1 VARIABLELABELREF.indx                      Assigned : 1722
Stem-1 VARIABLELABELREF.indx                      Reference: 1720 1722 2240 2241 2243 2244 2296 2297 2298
Stem-1 VARIABLELABELREF.variable                  Assigned : 1705

Stem-1 VARIABLEREF.                               Assigned : 382
Stem-1 VARIABLEREF.indx                           Assigned : 2002
Stem-1 VARIABLEREF.indx                           Reference: 2000 2002 2215 2225 2226 2257 2266 2272 2273
Stem-1 VARIABLEREF.variable                       Assigned : 1977

Stem-1 VARIABLESET.                               Assigned : 384
Stem-1 VARIABLESET.indx                           Assigned : 1864
Stem-1 VARIABLESET.indx                           Reference: 1862 1864 2206 2215 2222 2223 2257 2263 2264 2287
Stem-1 VARIABLESET.variable                       Assigned : 1850
Stem-1 VARIABLESET.x                              Reference: 2363

Stem-1 VARIABLESINDX.                             Assigned : 377
Stem-1 VARIABLESINDX.simplevar                    Assigned : 1937 2089
Stem-1 VARIABLESINDX.simplevar                    Reference: 1931 1944 2083 2096
Stem-1 VARIABLESINDX.sortedvariable               Reference: 2204
Stem-1 VARIABLESINDX.tempname                     Reference: 2362
Stem-1 VARIABLESINDX.varx                         Assigned : 1707 1745 1789 1820 1852 1979
Stem-1 VARIABLESINDX.varx                         Reference: 1701 1717 1739 1754 1783 1796 1814 1827 1846 1859 1971 1986

Stem-1 VARIABLESTEMREF.                           Assigned : 386
Stem-1 VARIABLESTEMREF.indx                       Assigned : 2101
Stem-1 VARIABLESTEMREF.indx                       Reference: 1947 2099 2101 2215 2234 2235 2257 2266 2284 2285
Stem-1 VARIABLESTEMREF.variable                   Assigned : 2087

Stem-1 VARIABLESTEMSET.                           Assigned : 385
Stem-1 VARIABLESTEMSET.indx                       Assigned : 1949
Stem-1 VARIABLESTEMSET.indx                       Reference: 1949 2215 2231 2232 2257 2266 2280 2281
Stem-1 VARIABLESTEMSET.variable                   Assigned : 1935
    xref (2 of 2) ends here
    xref (2 of 2) ends here
    -----------------------


 ------------ tips for label references ----------------------------
 ------------ tips for label references ----------------------------
     tip:  c# is a ref to CALL stmt to this   internal/external name
     tip:  f# is a ref to FUNCTION call to    internal/external function
     tip:  s# is a ref to SIGNAL stmt to this internal label


 ------------ now xreference for stem variables (tips) -------------
 ------------ now xreference for stem variables (tips) -------------
     tip:     Note:- stem variables (after 1st period) are in lower case
     tip:          - stem "constants" (will be shown in UPPER case)
     tip:          - stem "constants" that are whole numbers (and not 0)
     tip:               will be summarized as a # sign (in place of
     tip:               individual digits/numbers) so it summarizes them.
     tip:     What XREF for stems can help you fix:
     tip:     -------------------------------------
     tip:      - seeing a variable (lower case) used in a stem where you
     tip:       EXPECTED it to always be a constant.
     tip:      - seeing a constant (upper case) used in a stem where you
     tip:       EXPECTED it to be a variable (maybe it was misspelled).
     tip:                                              )
     tip:line sample rexx code (followed by sample xref)
     tip:---- ------------
     tip:  1     x = "Richard"
     tip:  2     firstName.y.x.1 = "Hi"
     tip:  3     firstName.y.x.2 = "Buddy"
     tip:  4     firstName.y.x.0 = 2
     tip:
     tip:sample xref listing
     tip:-----------
     tip:  --xref section 1 (variables)
     tip:  --xref section 1 (variables)
     tip:
     tip:Variable (set)         X               Assigned : 1
     tip:Variable(w/ stem use): X               Reference: 2 3 4
     tip:Constant(w/ stem use): Y               Reference: 2 3 4
     tip:
     tip:  --xref section 2 (stem variables)
     tip:  --xref section 2 (stem variables)
     tip:
     tip:Stem-3 FIRSTNAME.Y.x.#                 Assigned : 2 3
     tip:Stem-3 FIRSTNAME.Y.x.0                 Assigned : 4
     tip:                                       Reference: 2 3 4
     tip:     note:  Stem-3 refers to # of periods in the stem.
     tip:
     tip:  rexx tip: remember stem value on the right is "tricky":
     tip:        Given following rexx code:
     tip:             x = "RICHARD.HUMPHRIS"
     tip:             y = "RICHARD"
     tip:             z = "HUMPHRIS"
     tip:        References to a stem variable, as shown below, are
     tip:          referring to the SAME stem variable:
     tip:             stem.x     refers to STEM.RICHARD.HUMPHRIS
     tip:             stem.y.z   refers to STEM.RICHARD.HUMPHRIS
     tip:        This is because x contains a period.  And because
     tip:          everything to the right of the first period is evaluated
     tip:          first.  Then the stem variable is "looked up".
     tip:
     tip:   rexx tip:  referencing pgm above, if you set variable "a"
     tip:         to a upper/lower case value.  The stem will NOT upper
     tip:         case it.
     tip:        So if assignment statement set "a" to "richard"
     tip:         then stem.y is NOT the same as stem.a
     tip:        Because stem.y    refers to STEM.RICHARD
     tip:        and     stem.a    refers to STEM.richard
     tip:
