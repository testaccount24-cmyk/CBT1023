/* rexx */
  trace 's'

/*  rexx member for scan/xref was: */
/*     "SFRH66.REXX(REX$XRE2)"      */
/*      ---------------------       */
/*  date/time of XREF was:          */
/*     20231215 14:30:59            */
/*      ---------------------       */

/* REXX */
/*                                                                           */
/* written by:  Richard Humphris                                             */
/* email:       richard.humphris@netnitco.net                                */
/* cell:        219-707-1409                                                 */
/*                                                                           */
/* version      change                                                       */
/* -------      ------------------------------------------------------------ */
/* 1.02         update "address" command:                                    */
/*              1. add explicit address commands to xreference for ease of use*/
/*              2. fix:  address syntax                                      */
/*                                                                           */
/*                 syntax 1:  address environment [exprc]                    */
/*                 syntax 2:  address [VALUE] exprv                          */
/*                    a) environment names                                   */
/*                         1) environment (1st format) is an environment if  */
/*                        it 1st word is a symbol or a constant.  In either  */
/*                        case, a symbol is treated as a constant, not a     */
/*                        variable.                                          */
/*                         2) exprv is an expression that evaluates to a     */
/*                        environment name if 1st word is not a symbol or    */
/*                        a constant.  Or if "VALUE" is explicitly specified.*/
/*                    b) command to be executed [exprc] only is an option w/ */
/*                      the 1st syntax of the address command.               */
/*                    c) The fixes to the address command:                   */
/*                         1) if VALUE was not specified, we always treated  */
/*                        the implied syntax 2 (w/o VALUE) as syntax 1.      */
/*                         2) environment (in syntax 1) is specified as a    */
/*                        constant did not appear in the xref, only "variables"*/
/*                        did.  But "variables" as "environment" in syntax 1 */
/*               3. new function.                                            */
/*                    a)  we will add a xref section for address environments*/
/*                   like:                                                   */
/*                       address 'environment'                               */
/*                       address 'environment' <cmd>                         */
/*                       address VALUE exprv                                 */
/*                                                                           */
/*              4. internal changes include:                                 */
/*                 a.  variableAddrDef.      stem added                      */
/*                     variableAddrDefValue. stem added                      */
/*                 b.  called routine "c0480AddressDefine:" created          */
/*                 c.  code for ADDRESS command modified.                    */
/*                           among other things, to call c0480               */
/*                           and it will use variable "line_without_comments"*/
/*                           for "ADDRESS VALUE" syntax.                     */
/*                 d.  xref code updated to output address info.             */
/*                 e.  change routine c0070ParseLinePass1:                   */
/*                     1.  remove comments and labels to set variable:       */
/*                            "LineWithoutCommentsNlabels"                   */
/*                     2.  Then continue parsing as before with the other    */
/*                            variables.                                     */
/*                                                                           */
/* 1.01         initial "release"                                            */
/*                                                                           */
/*                                                                           */
/*    summarize process:                                                     */
/*    ------------------                                                     */
/*          Input:  a rexx exec you want a cross reference for.              */
/*                                                                           */
/*          process:                                                         */
/*             1) read rexx exec from libraryX.(member) (your exec library)  */
/*                                                                           */
/*             2) create member in hlq.SCAN(member)                          */
/*                                                                           */
/*                a) if fb, change to vb (hlq.SCAN) is vb                    */
/*                                                                           */
/*                b) remove seq #'s (either fb or vb)                        */
/*                                                                           */
/*                c) add header information (comments) to converted exec     */
/*                                                                           */
/*                d) add trace 's' after header        in converted exec     */
/*                                                                           */
/*             3) run converted member with/  trace 's'                      */
/*                                                                           */
/*                a) save output in a temporary file.                        */
/*                                                                           */
/*                b) if trace unsuccessful, update hlq.XREF with scan        */
/*                 output and we're done.                                    */
/*                                                                           */
/* ====>       4) run REX$XREF (this exec) to create the cross reference     */
/*                                                                           */
/*                a) save xref in a temporary file.                          */
/*                                                                           */
/*             5) create header, copy scan output, copy xref output and      */
/*               create a member in hlq.XREF(member)                         */
/*                                                                           */
/*    purpose of REX$XREF:                                                   */
/*    --------------------                                                   */
/*                                                                           */
/*         1)  input:  trace 's' output of exec; we want to gen a xref for.  */
/*                                                                           */
/*         2)  process trace 's' output and create s xref                    */
/*                                                                           */
/*             a)  "pass 1" reads rexx code and looks for labels, call       */
/*            instructions, function calls, signal instructions, variables   */
/*            used (assigned and/or referrenced) and stems used and/or       */
/*            referenced.  All labels, variable and stems are saved in       */
/*                                                                           */
/*                 1)  all labels, variables, stems (with variables used)    */
/*                are all saved in upperCase.                                */
/*                                                                           */
/*                 2)  stems with numeric values after the period are changed*/
/*                to # (except for 0).                                       */
/*                                                                           */
/*                    For example:                                           */
/*                                                                           */
/*                     stem as used     stem as saved for xref               */
/*                     ------------     ----------------------               */
/*                     xyz.var1.0       XYZ.VAR1.0                           */
/*                     xyz.var1.1       XYZ.VAR1.#                           */
/*                     xyz.var1.2         (see above)                        */
/*                     xyz.var1.3         (see above)                        */
/*                                                                           */
/*                                                                           */
/*             b)  "pass 2" the "output pass"                                */
/*                                                                           */
/*                 1) the "constant" xref section 1                          */
/*                                                                           */
/*                    a) variables are sorted                                */
/*                                                                           */
/*                    b) only variables that aren't assigned in rexx code    */
/*                   appear here.                                            */
/*                                                                           */
/*                    c) so labels (also used as variables) are only reported*/
/*                   here if the variable use was only a reference.          */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*    Note:                                                                  */
/*          NO syntax checking is done.  We ran the rexx syntax checker and  */
/*         what's "good" for rexx is "good" for us.                          */
/*                                                                           */
/*          Therefore, it greatly simplifies code.  For example, if you put  */
/*         a variable on a "ITERATE" statement, for example, we just assume  */
/*         it will be a single variable and references a active do loop. BUT */
/*         to simplify this code, we treat value like any other expression   */
/*         on the right hand side of an assignment statement say.  We depend */
/*         on REXX to pick up syntax problems.                               */
/*                                                                           */
/*          Also, we do NOT look at "constants" enclosed in quotes.  So if   */
/*         for example,you code a "EXECIO" command with STEM X. in quotes    */
/*         we will NOT generate a assignment for the rexx stem X. (for that  */
/*         statement).                                                       */
/*                                                                           */
/*                                                                           */

   signal on syntax /* set trap for syntax errors */
   parse source . . . . . . . addressSpace .
   if addressSpace = 'OMVS'
   then do
      omvsSeg = 1 /* user can use bpxwunix() function */
   end
   else do
      x = syscalls('ON')
      if x = 0
      then do
           omvsSeg = 1 /* user can use bpxwunix function */
           x = syscalls('OFF')
      end
      else omvsSeg = 0 /* will have to use rexx subroutine to do sorting (slow)*/
   end

   say ' '
   if omvsSeg = 1
   then say 'XREF will be able to use a fast omvs sort, as we have an OMVS segment)'
   else say 'XREF can''t do a fast omvs sort (no OMVS segment); will use rexx code to sort'
   say ' '

signal startUp      /* "branch" over the syntax handling routine */

  syntax:
/*-------*/
/*-------*/
/* syntax:  error handling */
/*   rc    is set to the syntax error number;                        */
/*         ... equivelent to IRX00nnL as rc = 00, 01 to 99           */
/*   sigl  is set to the line number in error                        */
   parse source . . execname .
   say 'IRX00'right('00'rc,2)'I Error running exec' ,
              execName 'line' sigl':' errortext(rc)
   syntaxLow = max(sigl-7,1)            /* -7 before (or pgm start) */
   syntaxHigh= min(sigl+7,sourceline()) /* +7 after  (or pgm end)   */
   do syntaxII = syntaxLow to syntaxHigh/* -7 lines back to +7 lines*/
      if syntaxII <> sigl
      then say 'line   ' right(syntaxii,length(syntaxHigh))':' ,
                     sourceline(syntaxII)
      else say 'line==>' right(syntaxii,length(syntaxHigh))':' ,
                     sourceline(syntaxII)
   end
   say 'exiting exec with rc=12'
   exit 12

  startUp:
/*--------*/
/*--------*/
   /* start of pgm... skipped error routine "syntax:" */
   /* ----------------------------------------------- */

   /* handle arguments/options for the execution of this exec */
   /* ------------------------------------------------------- */
debug = 'OFF'  /* set to ON or OFF; will do more say statements if ON */
parse upper arg . 'DEBUG=' valuex .
parse upper arg . 'REXXLINE=' valuey .
parse upper arg . 'WIDTH=' valuez .
parse upper arg . 'BLANK=' valueb .

say ' '
say 'Options used:'
say '-------------'
say ' '

if valuex = 'ON' | valuex = 'OFF'
then debug = valuex
else debug = 'OFF'
say 'DEBUG option is DEBUG='debug
say '   For DEBUG=ON, you will have to look at SYSTSPRT in step //XREF for debug output'

if datatype(valueY,'W') = 0 | valueY < 0
then TraceRexxLine = 0
else TraceRexxline = valueY  /* line of input exec to trace */

if traceRexxLine > 0
then do
   say ' '
   say 'REXXLINE='tracerexxLine'; we will turn on:  trace ''r'' while processing line' tracerexxline 'of input exec'
   say 'REXXLINE trace, you will have to look at SYSTSPRT in step //XREF for debug output'
end

say ' '
if datatype(valuez,'W') = 0 | valuez = ''
then do
   say 'WIDTH option:  we will be using default width = 150'
   width = 150
   defaultMaxoutputvar = 50 /* use longer default */
end
else if valuez < 130
then do
   say 'WIDTH optione:  width='valuez 'specified, but minimum width=130 used instead'
   width = 130
   defaultMaxoutputvar = 30 /* shorten default size */
end
else do
   say 'WIDTH option:  width='valuez 'will be used'
   width = valuez
   defaultMaxoutputvar = 50 /* use longer default */
end

say ' '
if valueb = 'BYVAR'
then do
   blankOption = valueb
   say 'Blank=BYVAR, indicates there will be a blank line between groups of xref lines w/same variable/label name'
end
else if valueB = 'NONE'
then do
   blankOption = valueb
   say 'Blank=NONE, indicates there will be no blank lines in XREF'
end
else do
   blankOption = 'BYVAR'
   say 'Blank="'valueb'" was an invalid option, using Blank=BYVAR instead'
   say 'Blank=BYVAR, indicates there will be a blank line between groups of xref lines w/same variable/label name'
end

say 'finished process options'
say ' '

   /* end of options handling */
   /* ----------------------- */

   /* define some "special" variable handling for xref */
   /* ------------------------------------------------ */
specialVar. = 0 /* default (not special) */
                /* --------------------- */
special = 'RC'
specialVar.special = 1   /* set specialVar.RC = 1  */

special = 'SIGL'
specialVar.special = 1   /* set specialVar.SIGL =1 */

special = 'RESULT'
specialVar.special = 1   /* set specialVar.RESULT = 1 */

special = 'SQLCODE'
specialVar.special = 1   /* set specialVar.SQLCODE = 1   (db2) dsnrexx */

special = 'SQLERRMC'
specialVar.special = 1   /* set specialVar.SQLERRMC = 1  (db2) dsnrexx */

special = 'SQLERRP'
specialVar.special = 1   /* set specialVar.SQLERRP  = 1  (db2) dsnrexx */

special = 'SQLSTATE'
specialVar.special = 1   /* set specialVar.SQLSTATE = 1  (db2) dsnrexx */

specialStem. = 0
specialStem.SQLERRD = 1
specialStem.SQLWARN = 1
   /* end of special xref defaults */
   /* ---------------------------= */

   /* define rexx statement keywords we will handle */
   /* --------------------------------------------- */
rexxStmt. = 0
rexxStmt = 'ADDRESS'    ; rexxStmt.rexxStmt = 1
rexxStmt = 'ARG'        ; rexxStmt.rexxStmt = 1
rexxStmt = 'CALL'       ; rexxStmt.rexxStmt = 1
rexxStmt = 'DO'         ; rexxStmt.rexxStmt = 1
rexxStmt = 'END'        ; rexxStmt.rexxStmt = 1 /* not really a stmt, but 'end'(s) DO or SELECT */
rexxStmt = 'DROP'       ; rexxStmt.rexxStmt = 1
rexxStmt = 'EXIT'       ; rexxStmt.rexxStmt = 1
rexxStmt = 'IF'         ; rexxStmt.rexxStmt = 1
rexxStmt = 'THEN'       ; rexxStmt.rexxStmt = 1 /* not really a stmt, but used in IF or SELECT */
rexxStmt = 'ELSE'       ; rexxStmt.rexxStmt = 1 /* not really a stmt, but used with IF stmt    */
rexxStmt = 'INTERPRET'  ; rexxStmt.rexxStmt = 1
rexxStmt = 'ITERATE'    ; rexxStmt.rexxStmt = 1
rexxStmt = 'LEAVE'      ; rexxStmt.rexxStmt = 1
rexxStmt = 'NOP'        ; rexxStmt.rexxStmt = 1
rexxStmt = 'NUMERIC'    ; rexxStmt.rexxStmt = 1
rexxStmt = 'OPTIONS'    ; rexxStmt.rexxStmt = 1
rexxStmt = 'PARSE'      ; rexxStmt.rexxStmt = 1
rexxStmt = 'PROCEDURE'  ; rexxStmt.rexxStmt = 1
rexxStmt = 'PULL'       ; rexxStmt.rexxStmt = 1
rexxStmt = 'PUSH'       ; rexxStmt.rexxStmt = 1
rexxStmt = 'QUEUE'      ; rexxStmt.rexxStmt = 1
rexxStmt = 'RETURN'     ; rexxStmt.rexxStmt = 1
rexxStmt = 'SAY'        ; rexxStmt.rexxStmt = 1
rexxStmt = 'SELECT'     ; rexxStmt.rexxStmt = 1
rexxStmt = 'WHEN'       ; rexxStmt.rexxStmt = 1 /* not really a stmt, but used with SELECT stmt */
rexxStmt = 'OTHERWISE'  ; rexxStmt.rexxStmt = 1 /* not really a stmt, but used with SELECT stmt */
rexxStmt = 'SIGNAL'     ; rexxStmt.rexxStmt = 1
rexxStmt = 'TRACE'      ; rexxStmt.rexxStmt = 1
rexxStmt = 'UPPER'      ; rexxStmt.rexxStmt = 1
   /* end of special rexxStmt. keywords. */
   /* ---------------------------------- */

validSymbolChars  ='ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$¢.!?_' /* full set of valid symbol chars */
validVariableStart='ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$¢!?_'            /* variable can't start with . or digit */

'EXECIO 0 DISKW RESULTS (OPEN'
if rc <> 0
then do
   say 'DDname RESULTS failed to open for output; rc='rc
   say 'exit 8'
   'EXECIO 0 DISKW RESULTS (FINIS'
   exit 8
end

call c0050Pass1 /* find and identify variables */
call c9900OutputResults /* now, output our results */
exit 0

c0050Pass1:
   'EXECIO 100 DISKR SCANINP (OPEN STEM IN.'
   inRc = rc
   if inRc = 0 | inRc = 2
   then nop
   else do
      say 'error opening ddname=SCANINP; rc='inRc
      say 'exiting w/rc=8'
      'EXECIO 0 DISKR SCANINP (FINIS'
      exit 8
   end
   if in.0 > 0 /* in input read, copy to output */
   then do
      /* copy scan to output member, followed by xref */
      'EXECIO' in.0 'DISKW RESULTS (STEM IN.'
      if rc <> 0
      then do
         say 'error writing to ddname=RESULTS, rc='rc
         say 'exiting w/rc=8'
         'EXECIO 0 DISKR SCANINP (FINIS'
         'EXECIO 0 DISKW RESULTS  (FINIS'
         exit 8
      end
   end
   variablesIndx. = 0
   variable = 0
      /* define defaults for structures associated with "variable." */
      /* ---------------------------------------------------------- */
      variable.          = '' /* name of variable like USER; always UpperCase*/
      variableRef.       = '' /* referencing a variable,   list of line #'s */
      variableExposeRef. = '' /* expose list ref. variable,list of line #'s */
      variableSet.       = '' /* setting     a variable,   list of line #'s */
      variableStemSet.   = '' /* used in setting stem var, list of line #'s */
      variableStemRef.   = '' /* used in ref.    stem var, list of line #'s */
      variableLabelDef.  = '' /* label definition,         list of line #'s */
      variableLabelRef.  = '' /* label reference,          list of line #'s */
      variableAddrDef.      = '' /* address definition,        list of line #'s */ /* v1.02 update */
      variableAddrDefValue. = '' /* address value definition,  list of line #'s */ /* v1.02 update */
      /* end of defaults */

   stemIndx.      = 0
   stem     = 0
      /* define defaults for structures associated with "stem." */
      /* ------------------------------------------------------ */
      stemVariable.     = '' /* name of stem variable (like NAME.FIRST.LAST) always upper case */
      stemPeriods.      = '' /* # of periods used in stem variable */
      stemRef.          = '' /* stem variable references, list of line #'s */
      stemExposeRef.    = '' /* stem variable references, list of line #'s */
      StemAsg.          = '' /* stem variable assignment, list of line #'s */
      /* end of defaults */

   exposeRef = 0 /* only set to 1 when reference "PROCEDURE EXPOSE" list of variables */
   line = ''
   startcmd = 0
   totalLine= 0
   in = 0
   do forever /* identify variables / stems */
      in = in + 1
      if in > in.0
      then do
         /* need another buffer */
         if inRc = 2/* finished using last buffer? */
         then leave /* ...yes, time to leave.      */

         /* get next buffer */
         in = 0 /* reset buffer pointer, very important for forever loop */
         'EXECIO 100 DISKR SCANINP (STEM IN.'
         inRc = rc /* save read rc */
         if inRc = 0 | inRc = 2
         then do /* got next input buffer */
            if in.0 > 0 /* if input recs, copy to output */
            then do
               /* copy scan to output member, followed by xref */
               'EXECIO' in.0 'DISKW RESULTS (STEM IN.'
               if rc <> 0
               then do
                  say 'error writing to ddname=RESULTS, rc='rc
                  say 'exiting w/rc=8'
                  'EXECIO 0 DISKR SCANINP (FINIS'
                  'EXECIO 0 DISKW RESULTS  (FINIS'
                  exit 8
               end
            end
            /* normal, we read buffer successfully */
            /*         we wrote buffer successfully*/
            /*         time to resume loop         */
            /*         and variable "in" equals zero*/
            iterate /* got next input buffer, resume forever loop*/
         end

         /* bad read rc */
         say 'error reading from ddname=SCANINP; rc='rc
         say 'exit w/rc=8'
         'EXECIO 0 DISKR SCANINP (FINIS'
         exit 8
      end

      /* next input line in "in.in" is ready to process */
      totalLine = totalLine + 1
      if startcmd = 1
      then do /* put most likely choice first */
         parse var in.in rexxLine2 8 cmd 12 pendingCmd
         if datatype(strip(rexxLine2),'W') & cmd = '*-* '
         then do /* we have start of a "command" to process */
            call c0070ParseLinePass1 /* process previous line first */
            rexxline = strip(rexxline2)
            line = pendingCmd   /* now save start of next cmd  */
            iterate
         end

         /* command continued, add to line, for full line to parse*/
         if left(in.in,10) = '*-*'
         then do
            call c0070ParseLinePass1 /* process previous cmd first */
            /* rexxline is still set... multiple cmds on same line  */
            line = pendingCmd   /* now save start of next cmd  */
            iterate
         end
         else line = line || in.in /* continuation of a command, append it together */
         iterate
      end
      else do
         /* this happens first, but once we set startcmd to 1*/
         /* ... it will never be reset.  So this is least used*/
         /* portion of this loop.                             */
         parse var in.in rexxline 8 cmd 12 rest
         if datatype(strip(rexxline),'W') & cmd = '*-* '
         then do /* we have start of a "command" to process */
            startcmd = 1
            line = rest
            rexxline = strip(rexxline)
            iterate
         end
         else iterate /* ignore nonsense */
      end
   end
   if startcmd = 1
   then do
      if right(line,8) = 'READYEND' & length(line) > 8 /* sure it is */
      then line = left(line,length(line)-8) /* remove "READYEND" */
      call c0070ParseLinePass1
   end
   'EXECIO 0 DISKR SCANINP (FINIS'
   return /* 1st pass is complete */

c0070ParseLinePass1:
   /* 1.  remove comments from line, as they just confuse things. */
   /*                                                             */
   /* 2.  replace 'all literals'               with " 'LIT###     */
   /* 2.  replace 'all literal functions       with " 'FUN###(    */
   /*     replace '0101 1100'b BINARY literals with " 'LIT###B    */
   /*     replace '04E3 DD3C'x HEX literals    with " 'LIT###X    */
   /*     ... as they just confuse things.                        */
   /*                                                             */
   /* After this, any digits left in "line" are digits used by    */
   /* rexx, as opposed to those that used to be in:               */
   /*          1. comments (removed)                              */
   /*          2. literals (removed)                              */
   /*                                                             */
   if traceRexxLine > 0
   then if rexxLine = traceRexxLine
      then do
         trace 'n'
         say ' '
         say 'Turning on and/or continuing Tracing while processing line' rexxline 'of the input exec'
         trace 'i' /* turn on tracing for this one line of 'input' rexx code */
      end
   else if rexxLine > traceRexxLine
      then do
         traceRexxLine = 0 /* nothing more to trace */
         trace 'n'         /* keep tracing off      */
      end

   originalLine = line /* save original line  */
   if debug = 'ON'
   then do
      say ' '
      say 'rexxline='rexxline
      say 'debug:  originalLine="'originalLine'"'
   end

   /* v1.02 ... remove comments first */
   /* ------------------------------- */

   lowerLine    = line /* in case of literals */
   upper line /* just upper case it */
   startPos = 1
   commentNested = 0
   commentStart  = 0
   literalStart  = 0
   LitValue. = ''   /* save lit values here */
   litNext    = 0   /* # of lit values saved*/
   do while pos('/*',line,startPos) > 0 ,
          | pos('*/',line,startPos) > 0 ,
          | pos("'",line,startPos)  > 0 ,
          | pos('"',line,startPos)  > 0
      /* we have a possible comment and/or literal */
      x1= pos('/*',line'/*',startPos)
      x2= pos('*/',line'*/',startPos)
      y1= pos("'",line"'",startPos)
      y2= pos('"',line'"',startPos)

      x = min(x1,x2)
      y = min(y1,y2)

      if commentStart > 0 /* at least one comment active */
      then do
         /* ignore "y" literals inside of comments */
         if x1 = x2 /* should be impossible */
         then leave /* ... rexx syntax should have found this */
         if x1 = x  /* start of another nested comment? */
         then do
            commentNested = commentNested + 1 /* bump number nested*/
            startPos = x + 2 /* skip past this comment delimiter */
            iterate
         end
         /* found end of a comment */
         commentNested = commentNested - 1 /* decrement number of active comments*/

         if commentNested > 0
         then do
            /* nested comments, we need to find more end of comment literals */
            startPos = x + 2 /* skip past this comment delimiter */
            iterate
         end
         /* finally entire comment "commentStart to x" can be removed */
         /* replace with a blank, if imbedded comment                 */
         if commentStart = 1
         then do
            /* remove comment from start of line */
            line      = strip(substr(line,x+2))
            lowerLine = strip(substr(lowerLine,x+2))
            startPos = 1
            commentStart = 0 /* with no comment active any longer, this is now zero */
            iterate
         end
         /* remove comment from middle of line; replace with blank */
         line      = left(line,commentStart-1)      substr(line,x+2)
         lowerLine = left(lowerLine,commentStart-1) substr(lowerLine,x+2)
         startPos = commentStart + 1
         commentStart = 0 /* with no comment active any longer, this is now zero */
         iterate
      end

      if x < y /* comment started before literal? */
      then do
         /* logic says (see prior "if commentNested > 0" that commentNested must be zero */
         if substr(line,x,2) = '/*'
         then do
            /* this must be true for rexx syntax approved code */
            commentNested = 1 /* this is start of a comment */
            commentStart  = x /* ... and started here       */
            startPos = x + 2  /* start looking for end of comment here */
            iterate
         end
         call logicMsg 'how can a comment end, that was never started?'
         startPos = x+2
         iterate
      end

      /* start of literal found, it may be a:            */
      /*    'some literal value' a regular literal       */
      /* or '1010 1100'b         a binary  literal       */
      /* or '03ef ff'x           a hex     literal       */
      /*                                                 */
      /* note:  we won't verify contents of binary or hex*/
      /*    literals, the rexx syntax checker did that.  */
      /*                                                 */
      /* so we will remove literal and replace it with   */
      /*    " 'LIT' "  i.e. with 'LIT' with blanks around*/
      /*    it.                                          */
      /*                                                 */
      LiteralStart = y
      LitQuote = substr(line,y,1)
      do forever /* find end of literal */
         yy= pos(litQuote,line,y+1) /* find ending quote */
         if yy = 0
         then do
            /* literal should have ended, if syntax corrrect */
            /* add closing quote (that should have been in literal */
            litValue = substr(lowerLine,LiteralStart) || litQuote
            litNext = litNext + 1
            litValue.litNext = litValue

            call logicMsg 'Why didn''t literal end'
            if LiteralStart = 1
            then return /* basically one long literal, even if it didn't end */

            line = left(line,y-1) " 'LIT"||litnext
            literalStart = 0          /* basically end of parsing */
            startPos = length(line)+1 /* basically end of parsing */
            leave
         end
         if substr(line,yy,1) = substr(line,yy+1,1) /* double " or double ' */
         then do
            /* skip them by */
            y = yy + 2
            iterate
         end
         /* we found end of literal at yy*/
         leave
      end
      if literalStart = 0
      then leave

      /* normal case, found end of literal */

      /* is it really a binary literal.... don't want "b" to be a variable */
      if  substr(line,yy+1,2) = 'B ' ,                                       /* if B<blank>                    then a binary literal */
       | (substr(line,yy+1,1) = 'B'  & datatype(substr(line,yy+1,2),'S')= 0) /* or B<?>     is not a symbol... then a binary literal */
      then do
         startPos = yy+2                             )
         literalStart = 0
         iterate
      end

      /* is it really a hex literal.... don't want "x" to be a variable */
      if  substr(line,yy+1,2) = 'X ' ,                                       /* if X<blank>                    then a hex literal */
       | (substr(line,yy+1,1) = 'X'  & datatype(substr(line,yy+1,2),'S')= 0) /* or X<?>     is not a symbol... then a hex literal */
      then do
         startPos = yy+2
         literalStart = 0
         iterate
      end

      /* just a simple literal */
      startPos = yy+1
      literalStart = 0
      iterate
   end

   /* now comments have been removed */
   if line = '' then return

   /* remove label(s), if found, from lineWithoutCommentsNLabels */
   LineWithoutCommentsNlabels = line
   do forever
      LineWithoutCommentsNlabels = strip(LineWithoutCommentsNlabels)
      if LineWithoutCommentsNlabels = '' then leave

      if pos(':',LineWithoutCommentsNlabels) = 0
      then leave

      parse var LineWithoutCommentsNlabels varX ':' rest
      if words(varx) = 1
      then if datatype(varx,'s') = 1
         then do
            LineWithoutCommentsNlabels = rest /* remove label:      */
            iterate                           /* continue looking for more labels */
         end
         else leave /* we've removed all labels, LineWithoutCommentsNlabels variable set correctly */
      else leave    /* we've removed all labels, LineWithoutCommentsNlabels variable set correctly */
   end
   lineWithoutCommentsNlabels = strip(LineWithoutCommentsNlabels) /* keep this for address command */
   if debug = 'ON'
   then say 'debug:  LineWithoutCommentsNlabels="'LineWithoutCommentsNlabels'"'


      /* ===>  comments, if any, now removed from "line", but labels and literals are still in "line" */
      /* ===>  -------------------------------------------------------------------------------------- */

   /* end of V1.02 ... now do the "traditional"  c0070 code */
   /* ----------------------------------------------------- */

   lowerLine    = line /* in case of literals */
   upper line /* just upper case it */
   startPos = 1
   commentNested = 0
   commentStart  = 0
   literalStart  = 0
   LitValue. = ''   /* save lit values here */
   litNext    = 0   /* # of lit values saved*/
   do while pos('/*',line,startPos) > 0 ,
          | pos('*/',line,startPos) > 0 ,
          | pos("'",line,startPos)  > 0 ,
          | pos('"',line,startPos)  > 0
      /* we have a possible comment and/or literal */
      x1= pos('/*',line'/*',startPos)
      x2= pos('*/',line'*/',startPos)
      y1= pos("'",line"'",startPos)
      y2= pos('"',line'"',startPos)

      x = min(x1,x2)
      y = min(y1,y2)

      if commentStart > 0 /* at least one comment active */
      then do
         /* ignore "y" literals inside of comments */
         if x1 = x2 /* should be impossible */
         then leave /* ... rexx syntax should have found this */
         if x1 = x  /* start of another nested comment? */
         then do
            commentNested = commentNested + 1 /* bump number nested*/
            startPos = x + 2 /* skip past this comment delimiter */
            iterate
         end
         /* found end of a comment */
         commentNested = commentNested - 1 /* decrement number of active comments*/

         if commentNested > 0
         then do
            /* nested comments, we need to find more end of comment literals */
            startPos = x + 2 /* skip past this comment delimiter */
            iterate
         end
         /* finally entire comment "commentStart to x" can be removed */
         /* replace with a blank, if imbedded comment                 */
         if commentStart = 1
         then do
            /* remove comment from start of line */
            line      = strip(substr(line,x+2))
            lowerLine = strip(substr(lowerLine,x+2))
            startPos = 1
            commentStart = 0 /* with no comment active any longer, this is now zero */
            iterate
         end
         /* remove comment from middle of line; replace with blank */
         line      = left(line,commentStart-1)      substr(line,x+2)
         lowerLine = left(lowerLine,commentStart-1) substr(lowerLine,x+2)
         startPos = commentStart + 1
         commentStart = 0 /* with no comment active any longer, this is now zero */
         iterate
      end

      if x < y /* comment started before literal? */
      then do
         /* logic says (see prior "if commentNested > 0" that commentNested must be zero */
         if substr(line,x,2) = '/*'
         then do
            /* this must be true for rexx syntax approved code */
            commentNested = 1 /* this is start of a comment */
            commentStart  = x /* ... and started here       */
            startPos = x + 2  /* start looking for end of comment here */
            iterate
         end
         call logicMsg 'how can a comment end, that was never started?'
         startPos = x+2
         iterate
      end

      /* start of literal found, it may be a:            */
      /*    'some literal value' a regular literal       */
      /* or '1010 1100'b         a binary  literal       */
      /* or '03ef ff'x           a hex     literal       */
      /*                                                 */
      /* note:  we won't verify contents of binary or hex*/
      /*    literals, the rexx syntax checker did that.  */
      /*                                                 */
      /* so we will remove literal and replace it with   */
      /*    " 'LIT' "  i.e. with 'LIT' with blanks around*/
      /*    it.                                          */
      /*                                                 */
      LiteralStart = y
      LitQuote = substr(line,y,1)
      do forever /* find end of literal */
         yy= pos(litQuote,line,y+1) /* find ending quote */
         if yy = 0
         then do
            /* literal should have ended, if syntax corrrect */
            /* add closing quote (that should have been in literal */
            litValue = substr(lowerLine,LiteralStart) || litQuote
            litNext = litNext + 1
            litValue.litNext = litValue

            call logicMsg 'Why didn''t literal end'
            if LiteralStart = 1
            then return /* basically one long literal, even if it didn't end */

            line = left(line,y-1) " 'LIT"||litnext
            literalStart = 0          /* basically end of parsing */
            startPos = length(line)+1 /* basically end of parsing */
            leave
         end
         if substr(line,yy,1) = substr(line,yy+1,1) /* double " or double ' */
         then do
            /* skip them by */
            y = yy + 2
            iterate
         end
         /* we found end of literal at yy*/
         leave
      end
      if literalStart = 0
      then leave

      /* normal case, found end of literal */
      Litvalue = substr(lowerLine,LiteralStart,yy-literalStart+1)

      /* is it really a binary literal.... don't want "b" to be a variable */
      if  substr(line,yy+1,2) = 'B ' ,                                       /* if B<blank>                    then a binary literal */
       | (substr(line,yy+1,1) = 'B'  & datatype(substr(line,yy+1,2),'S')= 0) /* or B<?>     is not a symbol... then a binary literal */
      then do
         /* it's a binary/hex literal */
         litValue = litValue||'B'
         litNext = litNext + 1
         litValue.litNext = litValue /* save literal value */

         /* now replace literal with " 'LIT#' " in line/lowerLine */
         if literalStart = 1
         then do
            line      = "'LITB"||litNext strip(substr(line,yy+2))
            lowerLine = "'LITB"||litNext strip(substr(lowerLine,yy+2))
            startPos = 6 + length(litNext)
            literalStart = 0
            iterate
         end

         line      = left(line,literalStart-1) "'LITB"litNext substr(line,yy+2)
         lowerline = left(line,literalStart-1) "'LITB"litNext substr(lowerline,yy+2)
         startPos = literalStart + 6 + length(litNext)
         literalStart = 0
         iterate
      end

      /* is it really a hex literal.... don't want "x" to be a variable */
      if  substr(line,yy+1,2) = 'X ' ,                                       /* if X<blank>                    then a hex literal */
       | (substr(line,yy+1,1) = 'X'  & datatype(substr(line,yy+1,2),'S')= 0) /* or X<?>     is not a symbol... then a hex literal */
      then do
         /* it's a binary/hex literal */
         litValue = litValue||'X'
         litNext = litNext + 1
         litValue.litNext = litValue /* save literal value */

         /* now replace literal with " 'LIT#' " in line/lowerLine */
         if literalStart = 1
         then do
            line      = "'LITX"||litNext strip(substr(line,yy+2))
            lowerLine = "'LITX"||litNext strip(substr(lowerLine,yy+2))
            startPos = 6 + length(litNext)
            iterate
         end

         line      = left(line,literalStart-1) "'LITX"litNext substr(line,yy+2)
         lowerline = left(line,literalStart-1) "'LITX"litNext substr(lowerline,yy+2)
         startPos = literalStart + 6 + length(litNext)
         literalStart = 0
         iterate
      end

      /* just a simple literal */
      litNext = litNext + 1
      litValue.litNext = litValue /* save literal value */

      if literalStart = 1
      then do
         if substr(line,yy+1) = '(' /* looks like a function? */
         then do /*function... remove left paren...add space before/after like 'FUN# ... */
            line      = "'FUN"||litNext strip(substr(line,yy+2))
            lowerLine = "'FUN"||litNext strip(substr(lowerLine,yy+2))
            startPos = 5 + length(litNext)
         end
         else do /* not a function... add space before/after              like 'LIT# ... */
            line      = "'LIT"||litNext strip(substr(line,yy+1))
            lowerLine = "'LIT"||litNext strip(substr(lowerLine,yy+1))
            startPos = 5 + length(litNext)
         end
         literalStart = 0
         iterate
      end

      /* insert literal in middle of line */
      if substr(line,yy+1,1) = '(' /* looks like a function? */
      then do /* function... remove left paren.. add space before/after like 'FUN# ... */
         line      = left(line,literalStart-1)      "'FUN"||litnext substr(line,yy+2)
         lowerLine = left(lowerLine,LiteralStart-1) "'FUN"||litnext substr(lowerLine,yy+2)
         startPos = literalStart + 5 + length(litNext)
      end
      else do /* not a function... add space before/after               like 'LIT# ... */
         line      = left(line,literalStart-1)      "'LIT"||litnext substr(line,yy+1)
         lowerLine = left(lowerLine,LiteralStart-1) "'LIT"||litnext substr(lowerLine,yy+1)
         startPos = literalStart + 5 + length(litNext)
      end
      literalStart = 0
      iterate
   end

   /* now comments have been removed */
   /* literals changed to 'LIT'      */
   if line = '' then return

   /* handle label(s), and if found, remove them from line */
   do forever
      line = strip(line)
      if line = '' then return

      if pos(':',line) = 0
      then leave

      parse var line varX ':' rest
      if words(varx) = 1
      then if datatype(varx,'s') = 1
         then do
            call c0470LabelDefine /* define this internal label */
            line = rest           /* remove label:              */
            iterate               /* continue looking for more labels */
         end
         else leave /* we've removed all labels, line variable set correctly */
      else leave    /* we've removed all labels, line variable set correctly */
   end
   line = strip(line)
   if line = '' then return



   /* ===>  comments, if any, now removed */
   /* ===>  literals changed to 'LIT'     */
   /* ===>  scientific notation #E# change to # before E   */
   /* ===>  scientific notation #E+# changed to # before E */
   /* ===>  scientific notation #E-# changed to # before E */
   call c0100ParseStatement
   return

c0100ParseStatement:
   /* handle statement */
   /* Note:   to handle if expression THEN statement      */
   /*                   or else statement                 */
   /*                   or when expression THEN statement */
   /*         we need the c0100var loop                   */
   /* look at line, rid us of scientific notation; don't want extra variable 'E' in xref */
   /* for scientic notation just get rid of E# or E+# or E-# (keep preceding #)          */
   /*                                                                                    */
   /* ---------------------------------------------------------------------------------- */

   /* handle first symbol in line:  */
   /*    1)  an assignment statement*/
   /*    2)  a rexx statement       */
   /*    3)  or a command for env.  */

   if debug = 'ON'
   then do
      say 'debug:     lowerLine="'lowerLine'"'
      say 'debug:          line="'line'"'
   end


   rexxStmt = ''     /* assume not processing a rexx statement  */
   if left(line,4) = "'LIT"
   then nop /* can't be assignment and/or rexx statement */
   else do
      x = verify(line'+',validSymbolChars,,1) /* find where it is no longer a symbol*/
      if x = 1 , /* = 1, it's not a symbol */
       | pos(left(line,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ_?!') = 0 /* variable/stem had to start with one of these*/
      then nop /* can't be an assignment stmt (has to start with a variable and/or stem */
      else do /* it's the start of a symbol & symbol looks like a variable and/or stem */
         /* we have start of a symbol   */

         /* but it could be an assignment statement */
         /*              or an rexx       statement */
         /*              or a command for envirnoment*/
         theSymbol = substr(line,1,x-1) /* we have stem and/or variable (or rexx stmt)*/
         if substr(line,x,1) = '='   , /* looks like variable/stem = something ? */
          & substr(line,x,2) <> '=='   /* ... except variable/stem == somthing is not an assignment */
         then do
            /* it's an assignment statement; handle it and return   */
            varx = theSymbol
            call c0500AddVarStemAssignment /* varx being assigned a value */

            line = strip(substr(line,x+1))
            if line <> ''
            then call c0300ParseRemaining /* expression to be evaluated */
            return
         end
         else if substr(line,x,1) = ' ' /* could be a rexx stmt or an assignment statement or command */
         then do
            y = verify(line'+',' ',,x)      /* find next position of non-blank after x */
            if substr(line,y,1) = '='     , /* looks like an assignment statement? */
               & substr(line,y,2) <> '=='   /* ... == (says its not)               */
            then do
               /* it's an assignment statement; handle it and return   */
               varx = theSymbol
               call c0500AddVarStemAssignment /* varx being assigned a value */

               line = strip(substr(line,y+1))
               if line <> ''
               then call c0300ParseRemaining /* expression to be evaluated */
               return
            end
         end

         /* could be a rexx statement */
         if rexxStmt.theSymbol = 1
         then rexxStmt = theSymbol /* it is, set rexxStmt to theSymbol */
      end
   end

   if rexxStmt <> ''
   then do /* we know we are processing a rexx statement. */
      /* start processing REXX statements */
      /* -------------------------------- */
      if rexxStmt = 'ADDRESS'
      then do
         parse var line . line /* remove ADDRESS */
         /* v1.02 fix address command */
         if left(line,6) = 'VALUE'
         then do
            varx = 'ADDRESS VALUE' subword(LineWithoutCommentsNlabels,3) /* set for c0480's use */
            call c0482AddrDefineValue    /* set up for special address xref */

            line = strip(substr(line,7)) /* remove "value" ... and parse everything else to add to xref */
            call c0300ParseRemaining     /* parse line for references */
            return
         end

         if line = ''
         then do
            varx = 'ADDRESS'                /* address command by itself   */
            call c0480AddrDefine            /* add environment to the xref */
            return
         end

         if substr(word(line,1),1,4) <> "'LIT"  /* if NOT a literal, must be a variable? */
         then do
            varx = 'ADDRESS' "'"word(line,1)"'" /* set environment (variable is really a "constant" when it comes to address cmd) */
            upper varx
            if word(line,2) <> '' then varx = varx '<cmd>'
            call c0480AddrDefine            /* add environment to the xref */

            parse var line . line    /* remove environment from line, it's not a variable and shouldn't be xreferenced as such*/
            if line <> ''                 /* if line contains a "command", parse remaining line for references */
            then call c0300ParseRemaining /* and parse remaining line for references */
            return
         end

         /* starts with a literal, 1st word in literal is the environment */
         if word(line,1) = "'LIT1"
         then do
            varx = word(substr(litvalue.1,2,length(litvalue.1)-2),1) /* extract 1st word from literal (for environment name) */
            upper varx
            parse varx varx potentialcmd        /* get environ potentialcmd */

            if potentialcmd = '' & word(line,2) = ''
            then varx = 'ADDRESS' "'"varx"'"         /* set environment name for xref*/
            else varx = 'ADDRESS' "'"varx"'" '<cmd>' /* set environment name for xref*/

            call c0480AddrDefine     /* add environment to the xref */

            call c0300ParseRemaining /* and parse remaining line for references */
            return
         end
         if word(line,1) = "'LITB1" | word(line,1) = "'LITX1"
         then do /* this is too weird, just use full constant value, as no one would do this anyway */
            upper litvalue.1
            if word(line,2) = ''
            then varx = 'ADDRESS' litvalue.1 '<cmd???>' /*set environment for address command */
            else varx = 'ADDRESS' litvalue.1 '<cmd>'    /*set environment for address command */
            call c0480AddrDefine       /* add environment to the xref */

            call c0300ParseRemaining /* and parse remaining line for references */
            return
         end
         return
      end
      else if rexxStmt = 'ARG'
      then do
         parse var line . template /* remove ARG */
         call c0325TemplateAssignments /* handle parse template */
         return
      end
      else if rexxStmt = 'CALL'
      then do
         parse var line . line /* remove 'call' from line */
         if left(line,4) = 'OFF'
         then return /* since valid syntax, must all be valid keywords, just return */
         if left(line,3) = 'ON' /* this may specify a "trapname" */
         then do
            parse var Line onx verbx namex trapname
            /* verbx must have been ERROR, FAILURE or HALT ... for rexx to like syntax */
            /* if trapname <> '' then namex must have been NAME ... for rexx to like syntax */
            if trapname <> ''
            then do
               if left(trapName,4) = "'LIT"
               then do
                  parse var trapName . 'LIT' litNum "'" .
                  varX = litValue.Litnum
               end
               else varX = strip(trapName)
               varx = varx '(CALL ON' verbx')'
               call c0400CallReference
               return /* and we're done here */
            end
            else do
               varx = verbx '(CALL ON' verbx')'
               call c0400CallReference
               return /* and we're done here */
            end
         end
         parse var line namex expression
         if left(namex,4) = "'LIT"
         then do
            parse var namex . 'LIT' litNum "'" .
            varX = litValue.LitNum
            line = strip(expression)
         end
         else do
            x = verify(line'+',validSymbolChars,,1) /* find where it is no longer a symbol*/
            varX = left(line,x-1)
            line = strip(substr(line,x))
         end
         call C0400CallReference /* reference call to routine in "varx" */

         call c0300ParseRemaining
         return
      end
      else if rexxStmt = 'DO'
      then do

         doLine = subword(line,2)  /* start with everything after "DO" */

         if doLine = '' | doline = 'FOREVER'
         then return  /* nothing more to do */

         if word(doline,1) = 'WHILE' ,
          | word(doline,1) = 'UNTIL'
         then do
            /* it began with WHILE expr or UNTIL expr; handle it quickly */
            parse var doline . line
            if line <> ''
            then call c0300ParseRemaining
            return
         end

         if subword(doline,1,2) = 'FOREVER WHILE' ,
          | subword(doline,1,2) = 'FOREVER UNTIL'
         then do
            /* remove 'forever while' or 'forever until' and process remaining expression */
            parse var doline . . line
            if line <> ''
            then call c0300ParseRemaining
            return
         end

         /* figure out if we have a conditional expression (and remove word) */
         /* ---------------------------------------------------------------- */
         x1 = wordpos('WHILE',doline 'WHILE') /* note:  illegal to have both WHILE and UNTIL in same do stmt */
         x2 = wordpos('UNTIL',doline 'UNTIL') /* note:  illegal to have both WHILE and UNTIL in same do stmt */

         if x1 < x2
         then doline = subword(doline,1,x1-1) subword(doline,x1+1) /* just make longer expression, remove WHILE */
         else if x1 > x2
         then doline = subword(doline,1,x2-1) subword(doline,x2+1) /* just make longer expression, remove UNTIL */


         /* now, let's look at 'repetitor */
         /* ----------------------------- */
         repetitor = doLine
         if repetitor = '' | repetitor = 'FOREVER'
         then return

         parse var repetitor namex '=' doRest
         if namex <> '' & f9920VerifyRexxSymbol(nameX,'S') = 1 ,
          & dorest <> ''                                       ,
          & left(strip(doRest),1) <> '=' /* variable/Stem '=' expri (not == expr) */
         then do
            /* we've got:  do name=expri <TO exprt> <BY exprb> <FOR exprf> */
            /* ... eliminate 'TO' 'BY' or 'FOR' */
            /* and use one big expression */

            /* namex used in an assignement */
            varx = namex
            call c0500AddVarStemAssignment /* add assignment reference */

            /* TO exprt (BY exprb) or (FOR exprf) can occur in any order */
            x = min(wordpos('TO',dorest' TO'),wordpos('BY',dorest' BY'),wordpos('FOR',dorest' FOR'))

            if x > words(dorest)
            then do
               line = strip(dorest)
               if line <> ''
               then call c0300ParseRemaining /* parse expri for references */
               return
            end

            doKeyword = word(dorest,x)    /* remember keyword (TO, BY or FOR */
            dorest = subword(dorest,1,x-1) subword(dorest,x+1) /* just remove keyword, make longer expression */

            /* find end of next expression, at unused 'TO' 'BY' or 'FOR' */
                 if doKeyword = 'TO'
            then x = min(wordpos('BY',dorest' BY'),wordpos('FOR',dorest' FOR'))
            else if doKeyword = 'BY'
            then x = min(wordpos('TO',dorest' TO'),wordpos('FOR',dorest' FOR'))
            else if doKeyword = 'FOR'
            then x = min(wordpos('TO',dorest' TO'),wordpos('BY',dorest' BY'))
            else x = words(dorest) + 1 /* this can't happen, but looks good */

            if x > words(dorest)
            then do /* just one more expression to process */
               line = strip(dorest)
               if line <> ''
               then call c0300ParseRemaining /* process this expression */
               return
            end

            /* multiple expressions */
            /* ... just remove keyword... and make a longer expression */
            doKeyword = doKeyword word(dorest,x)
            dorest = subword(dorest,1,x-1) subword(dorest,x+1) /* just remove keyword, make longer expression */

            /* find end of next expression, at unused 'TO' 'BY' or 'FOR' */
                 if wordpos('TO',doKeyword)  = 0 then x = wordpos('TO',dorest)
            else if wordpos('BY',doKeyword)  = 0 then x = wordpos('BY',dorest)
            else if wordpos('FOR',doKeyword) = 0 then x = wordpos('FOR',dorest)
            else                                      x = 0 /* just looks good */

            if x > 0
            then dorest = subword(dorest,1,x-1) subword(dorest,x+1) /* just remove keyword, make longer expression */

            line = strip(dorest)
            if line <> ''
            then call c0300ParseRemaining /* parse references to one big expression */
            return
         end
         else do
            line = strip(repetitor)
            if line = ''
            then return

            call c0300ParseRemaining /* parse line for references */
            return
         end
      end
      else if rexxStmt = 'END' /* end could be for "do" or for "select" */
      then do
         parse var line . line . /* remove 'end' */
         if line <> ''
         then call c0300ParseRemaining /* might have been:  end <name> */
         return
      end
      else if rexxStmt = 'DROP'
      then do
         parse var line . line
         line = translate(line,'  ','()') /* remove parens */
         call c0300ParseRemaining /* parse line for references */
         return
      end
      else if rexxStmt = 'EXIT'
      then do
         parse var line . line
         call c0300ParseRemaining /* parse line for references */
         return
      end
      else if rexxStmt = 'IF'
      then do
         parse var line . line
         call c0300ParseRemaining /* parse line for references */
         return
      end
      else if rexxStmt = 'THEN' /* it's either just "THEN" or "THEN ," */
      then return
      else if rexxStmt = 'ELSE' /* it's either just "ELSE" or "ELSE ," */
      then return
      else if rexxStmt = 'INTERPRET'
      then do
         parse var line . line
         call c0300ParseRemaining /* parse line for references */
         return
      end
      else if rexxStmt = 'ITERATE'
      then do
         parse var line . line
         call c0300ParseRemaining /* parse line for references */
         return
      end
      else if rexxStmt = 'LEAVE'
      then do
         parse var line . line
         call c0300ParseRemaining /* parse line for references */
         return
      end
      else if rexxStmt = 'NOP'
      then return
      else if rexxStmt = 'NUMERIC'
      then do
         parse var line word1 word2 word3 .

         if word2 word3 = 'FORM SCIENTIFIC'  then return
         if word2 word3 = 'FORM ENGINEERING' then return

         if word2 word3 = 'FORM VALUE'       then parse var line . . . line
         else if word2  = 'FORM'             then parse var line . . line
         else if word2  = 'DIGITS'           then parse var line . . line
         else if word2  = 'FUZZ'             then parse var line . . line
         else return /* this looks wrong, but can't happen with syntax checking*/

         call c0300ParseRemaining /* parse line for references */
         return
      end
      else if rexxStmt = 'OPTIONS'
      then return /* we don't handle the options statement */
      else if rexxStmt = 'PARSE'
      then do
         parse var line . line      /* remove 'parse' from line */

         if word(line,1) = 'UPPER'
         then parse var line . line /* remove 'upper' from line */

         if wordpos(word(line,1),'ARG EXTERNAL NUMERIC PULL SOURCE VERSION') > 0
         then do
            parse var line . template     /* get template */
            call c0325TemplateAssignments /* handle parse template */
            return
         end
         if word(line,1) = 'VALUE'
         then do
            /* parse ... VALUE expression WITH template */
            parse var line . expression ' WITH ' template
            line = expression
            call c0300ParseRemaining      /* handle references in expression */

            call c0325TemplateAssignments /* handle parse template */
            return
         end
         if word(line,1) = 'VAR'
         then do
            /* parse ... VAR name template */
            parse var line . name template
            line = name
            call c0300ParseRemaining      /* handle references in expression */

            call c0325TemplateAssignments /* handle parse template */
            return
         end
         return /* this would be invalid syntax (which can't happen) but it looks better */
      end
      else if rexxStmt = 'PROCEDURE'
      then do
         parse var line . line      /* remove 'procedure' from line */

         if word(line,1) = 'EXPOSE'
         then do
            parse var line . line /* remove 'expose' from line */
            line = translate(line,'  ','()') /* remove any parens from line */
            if line <> ''
            then do
               exposeRef = 1 /* turn on now */
               template = line
               call c0326TemplateList   /* handle references in rest of line */
               exposeRef = 0 /* turn off now */
            end
            return
         end
         return
      end
      else if rexxStmt = 'PULL'
      then do
         parse var line . template  /* remove 'pull' from line, put rest into template */
         if template <> ''
         then call c0325TemplateAssignments /* handle parse template */
         return
      end
      else if rexxStmt = 'PUSH'
      then do
         parse var line . line      /* remove 'push' from line */
         if line <> ''
         then call c0300ParseRemaining /* handle references in expression */
         return
      end
      else if rexxStmt = 'QUEUE'
      then do
         parse var line . line      /* remove 'queue' from line */
         if line <> ''
         then call c0300ParseRemaining /* handle references in expression */
         return
      end
      else if rexxStmt = 'RETURN'
      then do
         parse var line . line      /* remove 'return' from line */
         if line <> ''
         then call c0300ParseRemaining /* handle references in expression */
         return
      end
      else if rexxStmt = 'SAY'
      then do
         parse var line . line      /* remove 'say' from line */
         if line <> ''
         then call c0300ParseRemaining /* handle references in expression */
         return
      end
      else if rexxStmt = 'SELECT'
      then do
         parse var line . ' WHEN ' expression ' THEN ' statement
         if expression <> ''
         then do
            line = expression
            call c0300ParseRemaining /* handle references in expression */

            if statement <> ''
            then do
               line = statement
               call c0100ParseStatement /* recursive call to ourselves */
            end
         end
         return
      end
      else if rexxStmt = 'UPPER'
      then do
         parse var line . template /* get template */
         if template <> ''
         then call c0325TemplateAssignments /* handle parse template */
         return
      end
      else if rexxStmt = 'WHEN'
      then do
         parse var line . line /* remove 'when' from line */
         if line <> ''
         then call c0300ParseRemaining /* handle references in expression */
         return
      end
      else if rexxStmt = 'OTHERWISE'
      then return /* trace 's' puts 'select' by itself.  "when expression" by itself. "otherwise" by itself. */
      else if rexxStmt = 'SIGNAL'
      then do
         parse var line . line      /* remove 'signal' from line */
         parse var line word1 word2 word3 word4 word5
         if word1 = 'VALUE'
         then do
            parse var line . line /* remove 'value' */
            call c0300ParseRemaining /* handle references in expression */
            return
         end
         if word1 = 'OFF'
         then do
            parse var line . sType . /* sType will = ERROR, FAILURE, HALT, NOVALUE or SYNTAX */
            varX = sType '(SIGNAL OFF' stype')'
            call c0430SignalReference
            return
         end
         if word1 = 'ON'
         then do
            /* sType will = ERROR, FAILURE, HALT, NOVALUE or SYNTAX */
            /* if namex and/or trapname not null; then NAMEX=NAME and trapname will be routine for sType */
            parse var line . sType namex trapname
            if namex = 'NAME' & trapname <> ''
            then do
               varx = trapname '(SIGNAL ON' stype trapname')'
               call c0430SignalReference
            end
            else do
               varx = stype '(SIGNAL ON' stype')'
               call c0430SignalReference
            end
            return
         end
         /* line has label */
         parse var line varx .
         if varx <> ''
         then call c0430SignalReference /* generate reference for: signal labelname */
         return
      end
      else if rexxStmt = 'TRACE'
      then return
   end /* end of handling rexx commands */

   /* anything else is just an expression/command for the enviornment */
   call c0300ParseRemaining
   return

c0300ParseRemaining:
   /* this is an expression */
   /*    1.  let's remove operators  */
   /*    2.  let's remove functions  */
   /*    3.  let's remove literals   */
   /* then look for variables and reference them */

   /* remove the "easy" operators to remove */
   line = translate(line,'            ','+-*/%=<>,|&¬\;)')
   /*   say 'rexxline='rexxline 'line="'line'"' */

   /* now, (easier) find and remove literals and (literal)functions */
   /*   while removing 'LIT### or 'FUN### from expression           */
   /* ------------------------------------------------------------- */
   do while pos("'",line) > 0

      /* starting at "'" get LIT### or FUN### */
      /* ...and remove it from 'line'         */
      parse var line leftLine "'" litFun rightline
      line = leftLine rightLine

      /* either LIT### or FUN### */
      if left(litFun,3) = 'LIT'
      then iterate

      /* FUN### */
      parse var litfun . 4 functionNum .
      varx = litValue.functionNum /* reference the function name */
      call c0415FunctionReference
   end

   /* now, find variable/stem and/or built=in or internal functions */
   /* ------------------------------------------------------------- */
   line = strip(line)
   do forever
      if line = ''
      then return

      line = strip(line)
      if left(line,1) = '('
      then do
         line = strip(substr(line,2))
         iterate
      end

      x = min(pos(' ',line' '),pos('(',line'('))
      if substr(line,x,1) = '('
      then do                            /* token(something*/
         token = left(line,x)            /* token = token( */
         line  = strip(substr(line,x+1)) /* line  = something */
      end
      else parse var line token line     /* token something*/

      if right(token,1) = '('
      then do
         /* potential built-in and/or internal function */
         varX = substr(token,1,length(token)-1)
         if f9920VerifyRexxSymbol(varX,'S') = 1   /* valid symbol */
         then do
            /* token looks good */
            if pos('.',varX) = 0
            then do
               /* we have a built-in or internal function call */
               varx = substr(token,1,length(token)-1)
               call c0415FunctionReference
               line = strip(line)
               iterate
            end
            /* we have a stem variable followed by a ( paren */
            /* ... just ignore paren and handle stem         */
            call c0510AddVarStemReference
            line = strip(line)
            iterate
         end

         iterate
      end


      /* if token is a valid variable/stem then reference it */
      /* --------------------------------------------------- */
      varX = token
      if f9920VerifyRexxSymbol(varX,'S') = 1   /* valid symbol */
      then do
         call c0510AddVarStemReference /* add reference */
         line = strip(line)
         iterate
      end

      iterate
   end

   return

c0325TemplateAssignments:/* these variables are assigned values */
   /* this is an template   */
   /*    1.  let's remove operators  */
   /*    2.  let's remove literals   */
   /* then look for variables and reference them */

   /* remove the operators (but not parens) */
   template = translate(template,'              ','+-*/%=<>,|&;,')

   /* look for and remove (var) */
   /* these are references, not assignments */
   do while pos('(',template) > 0
      parse var template leftTemplate '(' expression ')' rightTemplate
      template = leftTemplate rightTemplate

      do while expression <> ''
         parse var expression word1 expression
         if left(word1,1) = "'"
         then iterate

         if f9920VerifyRexxSymbol(word1,'S') = 1 /* valid symbol? */
         then do
            varX = word1
            call c0510AddVarStemReference /* reference var */
         end
      end
   end

   /* we turned literals into 'LIT just ignore those */
   do while template <> ''
      parse var template word1 template
      if left(word1,1) = "'"
      then iterate
      if f9920VerifyRexxSymbol(word1,'S') = 1 /* valid symbol */
      then do
         /* we have a variable / stem reference */
         varX = word1
         call c0500AddVarStemAssignment /* this is assigned a value */
      end
   end
   return

c0326TemplateList:       /* these variables are referenced */
   /* this is an template   */
   /*    1.  let's remove operators  */
   /*    2.  let's remove literals   */
   /* then look for variables and reference them */

   /* remove the operators */
   template = translate(template,'                ','+-*/%=<>,|&;,()')


   /* we turned literals into 'LIT just ignore those */
   do while template <> ''
      parse var template word1 template
      if left(word1,1) = "'"
      then iterate
      if f9920VerifyRexxSymbol(word1,'S') = 1 /* valid symbol */
      then do
         /* we have a variable / stem reference */
         varX = word1
         call c0510AddVarStemReference  /* this variable is being referenced */
      end
   end
   return

   /* these routine handle references to a varx subroutine:  CALL varx        */
   /*                                 to a varx function:    varx()           */
   /*                                 to a signal:           SIGNAL varx      */
   /*                                 to a signal on:        SIGNAL ON  varx  */
   /*                                 to a signal off:       SIGNAL OFF varx  */
   /*                   or defining a label                                   */

c0400CallReference:
   /* make a reference for:  call varx */
   labelRefx = 'C('rexxline')'
   call c0450LabelReference
   return

c0415FunctionReference:
   /* make a reference for function:  varx() */
   LabelRefx = 'F('rexxline')'
   call c0450LabelReference
   return

c0430SignalReference:
   /* make a reference for signal  :  varx   */
   labelRefx = 'S('rexxline')'
   call c0450LabelReference
   return

c0450LabelReference:
   /* code to update label references for calls, functions and/or signals */
   varX = strip(varX)
   upper varX

   /* note:  all valid symbols including numbers, periods, etc, are used "as is" */
   /* this is a simple variable (label)*/
   if variablesIndx.varX = 0
   then do /* we need to add variable */
      variable = variable + 1
      variable.variable = varX
      variableLabelRef.variable = labelRefx
        /* we need to define quick lookup (index) to find this entry */
      variablesIndx.varX = variable        /* create quick index .Varx to # (variable) */

      if debug = 'ON'
      then say 'debug:  c0450LabelReference: ('labelRefx') label='varx

   end
   else do
      /* known simple var re-referenced */
      /*    this is illegal, but reference it anyway */
      /*    this is illegal, but reference it anyway */
      indx = variablesINdx.varX

      /* make sure we only add one RexxLine reference */
      if wordpos(labelRefx,variableLabelRef.indx) = 0
      then do
         variableLabelRef.indx = variableLabelRef.indx labelRefx

         if debug = 'ON'
         then say 'debug:  c0450LabelReference: ('labelRefx') label='varx
      end
   end
   return

c0470LabelDefine:
   /* code to define a label used in the rexx code */
   varX = strip(varX)
   upper varX
   if datatype(varX,'S') <> 1
   then return /* if not a symbol, return */

   /* but all symbols including .123 or X.Y.Z etc are allowed */
   /* this is a simple variable (label)*/
   if variablesIndx.varX = 0
   then do /* we need to add variable */
      variable = variable + 1
      variable.variable = varX             /* remember label */
      variableLabelDef.variable= rexxline  /* remember where defined          */
        /* we need to define quick lookup (index) to find this entry */
      variablesIndx.varX = variable        /* create quick index .Varx to # (variable) */

      if debug = 'ON'
      then say 'debug:  c0470LabelDefine: ('rexxline') label='varx
   end
   else do
      /* known simple var re-referenced */
      /*    it can be defined multiple times, but only first label used in call/function/signal */
      /*    will actually be used.                                                              */
      indx = variablesINdx.varX

      /* make sure we only add one RexxLine reference */
      if wordpos(rexxline,variableLabelDef.indx) = 0
      then do
         if words(variableLabelDef.indx) = 1
         then do
            /* start of (potentially) many duplicate labels */
            variableLabelDef.indx = variableLabelDef.indx ,
                                    '///Dup. IGNORED LABEL def''s:'
         end
         variableLabelDef.indx = variableLabelDef.indx rexxline

         if debug = 'ON'
         then say 'debug:  c0470LabelDefine: ('rexxline') label='varx
      end
   end
   return

   /* v1.02 update... c0480AddrDefine: added */
   /* -------------------------------------- */
c0480AddrDefine:
   /* code to define a address 'constant' used in the rexx code */
   /*   caller set varx to something like:  address 'TSO'              for:  address TSO               OR address 'TSO'          */
   /*   caller set varx to something like:  address 'TSO' expression   for:  address TSO anything      OR address 'TSO' anything */
   /*   caller set varx to something like:  address VALUE environment  for:  address VALUE environment                           */
   /*   caller set varx to something like:  address VALUE environment expression                                                 */
   /*                                                                  for:  address VALUE environement anything                 */

   if variablesIndx.varX = 0
   then do /* we need to add variable */
      variable = variable + 1
      variable.variable = varX            /* remember addr def */
      variableAddrDef.variable= rexxline  /* remember where defined          */
        /* we need to define quick lookup (index) to find this entry */
      variablesIndx.varX = variable        /* create quick index .Varx to # (variable) */

      if debug = 'ON'
      then say 'debug:  c0480AddrDefine: ('rexxline') addr='varx
   end
   else do
      /* add to references of this type of address command */
      indx = variablesINdx.varX
      variableAddrDef.indx = variableAddrDef.indx rexxline /* keep adding references */

      if debug = 'ON'
      then say 'debug:  c0480AddrDefine: ('rexxline') addr='varx
   end
   return

   /* v1.02 update... c0480AddrDefine: added */
   /* -------------------------------------- */
c0482AddrDefineValue:
   /* code to define a address value expression used in the rexx code */
   /*   caller set varx to something like:  address 'TSO'              for:  address TSO               OR address 'TSO'          */
   /*   caller set varx to something like:  address 'TSO' expression   for:  address TSO anything      OR address 'TSO' anything */
   /*   caller set varx to something like:  address VALUE environment  for:  address VALUE environment                           */
   /*   caller set varx to something like:  address VALUE environment expression                                                 */
   /*                                                                  for:  address VALUE environement anything                 */

   if variablesIndx.varX = 0
   then do /* we need to add variable */
      variable = variable + 1
      variable.variable = varX                 /* remember addr def */
      variableAddrDefValue.variable= rexxline  /* remember where defined          */
        /* we need to define quick lookup (index) to find this entry */
      variablesIndx.varX = variable        /* create quick index .Varx to # (variable) */

      if debug = 'ON'
      then say 'debug:  c0480AddrDefine: ('rexxline') addr='varx
   end
   else do
      /* add to references of this type of address command */
      indx = variablesINdx.varX
      variableAddrDefValue.indx = variableAddrDefValue.indx rexxline /* keep adding references */

      if debug = 'ON'
      then say 'debug:  c0480AddrDefine: ('rexxline') addr='varx
   end
   return


c0500AddVarStemAssignment:
   /* this could be a "simple" variable in varx or a "stem" variable being set */
   /* ... we need to keep track of assignments (and in case of a stem, also    */
   /* ... variables and/or constants referenced in the stem).                  */
   /* */
   varX = strip(varX)
   upper varX
   if pos('.',varX) = 0
   then do
      /* this is a simple variable */
      if variablesIndx.varX = 0
      then do /* we need to add variable */
         variable = variable + 1
         variable.variable = varX        /* remember variable name */
         variableSet.variable = rexxLine /* remember where it was set */
           /* we need to define quick lookup (index) to find this entry */
         variablesIndx.varX = variable        /* create quick index .Varx to # (variable) */

         if debug = 'ON'
         then say 'debug:  c0500AddVarStemAssignment: ('rexxline') var='varx
      end
      else do
         /* known simple var re-referenced */
         indx = variablesINdx.varX

         /* make sure we only add one RexxLine reference */
         if wordpos(rexxLine,variableSet.indx) = 0
         then do
            variableSet.indx = variableSet.indx rexxline

            if debug = 'ON'
            then say 'debug:  c0500AddVarStemAssignment: ('rexxline') var='varx
         end
      end
      return
   end

   /* this is a stem variable */
   periods = 0
   pPos = pos('.',varX)
   do while pPos <> 0
      periods = periods + 1
      pPos = pos('.',varX,pPos+1)
   end

   /* if part of stem is a hard coded # (other than zero), replace with # sign*/
   parse var varx psuedoVar '.' rest
   do while rest <> ''
      psuedoVar = psuedoVar'.'
      parse var rest stemPortion '.' rest
      if datatype(stemPortion,'W')
      then if stemPortion == '0'
         then psuedoVar = psuedoVar || '0'
         else psuedoVar = psuedoVar || '#'
      else psuedoVar = psuedoVar || stemPortion
   end
   if right(varx,1) = '.'
   then psuedoVar = psuedoVar'.'

   /* define psuedoVar for tracking stems */
   if stemIndx.psuedoVar = 0
   then do
      /* add to stem variables */
      stem = stem + 1
      stemVariable.stem = psuedoVar
      stemPeriods.stem  = periods
      stemRef.stem= ''
      StemAsg.stem= RexxLine
        /* we need to define quick lookup (index) to find this psuedoVar */
      stemIndx.psuedoVar = stem

      if debug = 'ON'
      then say 'debug:  c0500AddVarStemAssignment: ('rexxline') var='psuedoVar
   end
   else do
      /* known stem var re-referenced */
      indx = stemIndx.psuedoVar

      /* only one RexxLine assignment needed */
      if wordpos(rexxLine,stemAsg.indx) = 0
      then do
         stemAsg.indx= stemAsg.indx rexxLine

         if debug = 'ON'
         then say 'debug:  c0500AddVarStemAssignment: ('rexxline') var='psuedoVar
      end
   end

   /* now go thru stem's and "reference" those vars */
   parse var varX . '.' varX /* throw away top level */
   do while varX <> ''
      parse var varX simpleVar '.' varX /* get next potential stem var */
      if f9920VerifyRexxSymbol(simpleVar,'S') = 1 /* if a symbol and not a digit */
      then do
         /* add simple variable reference's from the stem */
         if variablesIndx.simpleVar = 0
         then do /* we need to add variable */
            variable = variable + 1
            variable.variable     = simpleVar   /* remember the name */
            variableStemSet.variable = rexxline /* remember where it was used to help set stem var */
              /* we need to define quick lookup (index) to find this simpleVar */
            variablesIndx.simpleVar = variable

            if debug = 'ON'
            then say 'debug:  (VarRef In stem) c0500AddVarStemAssignment: ('rexxline') var='simpleVar
         end
         else do
            /* known simple var re-referenced */
            indx = variablesINdx.simpleVar

            /* make sure we only add one RexxLine reference */
            if wordpos(rexxLine,variableStemRef.indx) = 0
            then do
               variableStemSet.indx = variableStemSet.indx rexxline

               if debug = 'ON'
               then say 'debug:  (VarRef in stem) c0500AddVarStemAssignment: ('rexxline') var='simpleVar
            end
         end
      end
   end
   return


c0510AddVarStemReference:
   /* this could be a "simple" variable in varx or a "stem" variable reference */
   /* ... we need to keep track of references  (and in case of a stem, also    */
   /* ... variables and/or constants referenced in the stem).                  */
   /* */
   varX = strip(varX)
   upper varX

   if pos('.',varX) = 0  /* not stem variable by definition */
   then do
      /* this is a simple variable */
      if variablesIndx.varX = 0
      then do /* we need to add variable */
         variable = variable + 1
         variable.variable = varX              /* remember the name */
         if exposeRef = 1
         then variableExposeRef.variable = rexxLine /* remember line # in reference */
         else variableRef.variable       = rexxLine /* remember line # in reference */
           /* we need to define quick lookup (index) to find this entry */
         variablesIndx.varX = variable        /* create quick index .Varx to # (variable) */

         if debug = 'ON'
         then say 'debug:  (Var.Ref) c0510AddVarStemReference: ('rexxline') var='varx
      end
      else do
         /* known simple var re-referenced */
         indx = variablesINdx.varX

         /* make sure we only add one RexxLine reference */
         if exposeref = 1
         then do
            if wordpos(rexxLine,variableExposeRef.indx) = 0
            then do
               variableExposeRef.indx = variableExposeRef.indx rexxline

               if debug = 'ON'
               then say 'debug:  (Var.Ref) c0510AddVarStemReference: ('rexxline') var='varx
            end
         end
         else do
            if wordpos(rexxLine,variableRef.indx) = 0
            then do
               variableRef.indx = variableRef.indx rexxline

               if debug = 'ON'
               then say 'debug:  (Var.Ref) c0510AddVarStemReference: ('rexxline') var='varx
            end
         end
      end
      return
   end

   /* this is a stem variable */
   periods = 0
   pPos = pos('.',varX)
   do while pPos <> 0
      periods = periods + 1
      pPos = pos('.',varX,pPos+1)
   end

   /* if part of stem is a hard coded # (other than zero), replace with # sign*/
   parse var varx psuedoVar '.' rest
   do while rest <> ''
      psuedoVar = psuedoVar'.'
      parse var rest stemPortion '.' rest
      if datatype(stemPortion,'W')
      then if stemPortion == '0'
         then psuedoVar = psuedoVar || '0'
         else psuedoVar = psuedoVar || '#'
      else psuedoVar = psuedoVar || stemPortion
   end
   if right(varx,1) = '.'
   then psuedoVar = psuedoVar'.'

   /* define psuedoVar for tracking stems */
   if stemIndx.psuedoVar = 0
   then do
      /* add to stem variables */
      stem = stem + 1
      stemVariable.stem = psuedoVar
      stemPeriods.stem  = periods
      if exposeRef = 1
      then stemExposeRef.stem = RexxLine
      else stemRef.stem       = RexxLine
        /* we need to define quick lookup (index) to find this psuedoVar */
      stemIndx.psuedoVar = stem

      if debug = 'ON'
      then say 'debug:  (StemRef) c0510AddVarStemReference: ('rexxline') var='psuedoVar
   end
   else do
      /* known stem var re-referenced */
      indx = stemIndx.psuedoVar

      /* only one RexxLine reference needed */
      if exposeRef = 1
      then do
         if wordpos(rexxLine,stemExposeRef.indx) = 0
         then do
            stemExposeRef.indx= stemExposeRef.indx rexxLine

            if debug = 'ON'
            then say 'debug:  (StemRef) c0510AddVarStemReference: ('rexxline') var='psuedoVar
         end
      end
      else do
         if wordpos(rexxLine,stemRef.indx) = 0
         then do
            stemRef.indx= stemRef.indx rexxLine

            if debug = 'ON'
            then say 'debug:  (StemRef) c0510AddVarStemReference: ('rexxline') var='psuedoVar
         end
      end
   end

   /* now go thru stem's and "reference" those vars */
   parse var varX . '.' varX /* throw away top level */
   do while varX <> ''
      parse var varX simpleVar '.' varX /* get next potential stem var */
      if f9920VerifyRexxSymbol(simpleVar,'S') = 1 /* if a symbol and not a digit */
      then do
         /* add simple variable reference's from the stem */
         if variablesIndx.simpleVar = 0
         then do /* we need to add variable */
            variable = variable + 1
            variable.variable     = simpleVar    /* remember the name */
            variableStemRef.variable = rexxline  /* used in stem */
              /* we need to define quick lookup (index) to find this simpleVar */
            variablesIndx.simpleVar = variable

            if debug = 'ON'
            then say 'debug:  (varRef in stem) c0510AddVarStemReference: ('rexxline') var='simpleVar
         end
         else do
            /* known simple var re-referenced */
            indx = variablesINdx.simpleVar

            /* make sure we only add one RexxLine reference */
            if wordpos(rexxLine,variableStemRef.indx) = 0
            then do
               variableStemRef.indx = variableStemRef.indx rexxline

               if debug = 'ON'
               then say 'debug:  (varRef in stem) C0510AddVarStemReference: ('rexxline') var='simpleVar
            end
         end
      end
   end
   return

c9900OutputResults:
   if debug = 'ON'
   then say 'debug:  before variable sort'
   maxVarLength = 0
   do sortedVariable = 1 by 1 for variable
      sortedVariable.sortedVariable = variable.sortedVariable /* copy variable name */
      if length(sortedVariable.sortedVariable) > maxVarLength
      then maxVarLength = length(sortedVariable.sortedVariable)
      if debug = 'ON'
      then say 'debug:  sortedVariable.'sortedVariable'='sortedVariable.sortedVariable
   end
   sortedVariable.0 = variable

   /* sort variables for xref listing */
   /* ------------------------------- */
   if omvsSeg = 1
   then y2=      BPXWUNIX('sort','sortedVariable.','sortedVariable.') /* fast omvs sort */
   else y2= f9910SlowSort('sort','sortedVariable.','sortedVariable.') /* slow rexx sort */

   if y2<> 0 then say 'error:  stemsort returned y2='y2'; omvsSeg='omvsSeg
   if debug = 'ON'
   then do
      say ' '
      say 'debug:  after variable sort'
      do sortedVariable = 1 by 1 for variable
         say 'debug:  SortedVariable.'sortedVariable'='SortedVariable.sortedVariable
      end
      say ' '
   end

   if debug = 'ON'
   then say 'debug:  before stem sort'
   maxStemLength = 0
   do sortedStemVariable = 1 by 1 for stem
      sortedStemVariable.sortedStemVariable = StemVariable.sortedStemVariable /* copy stem name */
      if length(sortedStemVariable.sortedStemVariable) > maxStemLength
      then maxStemLength = length(sortedStemVariable.sortedStemVariable)
      if debug = 'ON'
      then say 'debug:  sortedStemVariable.'sortedStemVariable'='sortedStemVariable.sortedStemVariable
   end
   sortedStemVariable.0 = stem

   /* sort stem variables for xref listing */
   /* ------------------------------------ */
   if omvsSeg = 1
   then y3=      BPXWUNIX('sort','sortedStemVariable.','sortedStemVariable.') /* fast omvs sort */
   else y3= f9910SlowSort('sort','sortedStemVariable.','sortedStemVariable.') /* slow rexx sort */

   if y3<> 0 then say 'error:  stemsort returned y3='y3'; omvsSeg='omvsSeg
   if debug = 'ON'
   then do
      say ' '
      say 'debug:  after stem sort'
      do sortedStemVariable = 1 by 1 for stem
         say 'debug:  SortedStemVariable.'sortedStemVariable'='SortedStemVariable.sortedStemVariable
      end
      say ' '
   end

   out = 0
   x = f9970Card(' ')
   x = f9970Card(' ')
   x = f9970Card(' ------------ now xreference begins -----------------------')
   x = f9970Card(' ------------ now xreference begins -----------------------')
   x = f9970Card(' ')
   x = f9970Card('                                                                 ')
   x = f9970Card('    xref (1 of 2) section 1 is for variables (not stem.''s)       ')
   x = f9970Card('    xref (1 of 2) section 1 is for variables (not stem.''s)       ')
   x = f9970Card('    ----------------------------------------------------------   ')
   x = f9970Card('                                                                 ')
   x = f9970Card('       variables/labels are in "upperCase" if variable was never ')
   x = f9970Card('                       assigned a value.                         ')
   x = f9970Card('                                                                 ')
   x = f9970Card('                        they are in "lowercase", otherwise.      ')
   x = f9970Card('                                                                 ')
   x = f9970Card('       variables/stems set via a command, like EXECIO for        ')
   x = f9970Card('                       example, where the stem is within quotes  ')
   x = f9970Card('                       will not be shown in the xref as either   ')
   x = f9970Card('                       an assignment or a reference.             ')
   x = f9970Card('                                                                 ')
   x = f9970Card('       Note special variables like:  RC, SIGL, can be assigned   ')
   x = f9970Card('                       values explictly.  But rexx can set them  ')
   x = f9970Card('                       as well implicitly.  Implicit assignments ')
   x = f9970Card('                       are not in the xref.                      ')
   x = f9970Card('    ----------------------------------------------------------   ')
   x = f9970Card('                                                                 ')
   x = f9970Card(' ')
   x = f9970Card(' ')
   /* variables used as constants */
   maxOutputVar = min(DefaultMaxOutputVar,maxVarLength+5) /* maxoutputvar was 30, 40 or 50 */
   do indx2 = 1 by 1 for variable
      /* get next sorted variable, then report it's information */
      sortedVariable =  SortedVariable.indx2
      indx = variablesIndx.sortedVariable /* use indx to info for this variable */

      if variableSet.indx <> ''     /* if assigned a value, make variable name "lowerCase */
      then tempname = translate(variable.indx,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')
      else if right(sortedVariable,1) = '+' /* v1.02 */
      then tempname = left(sortedVariable,length(sortedVariable)-1)
      else tempname = variable.indx /* else, keep upper case */

      if specialVar.sortedVariable > 0
      then do

         if variableSet.indx <> ''       , /* if special variable used in rexx somehow; mention it's special attributes */
          | variableRef.indx <> ''       , /* if special variable used in rexx somehow; mention it's special attributes */
          | variableExposeRef.indx <> '' , /* if special variable used in rexx somehow; mention it's special attributes */
          | variableStemSet.indx   <> '' , /* if special variable used in rexx somehow; mention it's special attributes */
          | variableStemRef.indx   <> ''   /* if special variable used in rexx somehow; mention it's special attributes */
         then x = f9930OutputVarInfo('SpecialVar(set no-XREF)',tempName,' *Special:',' No xref; set w/ADDR env cmd and/or REXX itself')

         if variableSet.indx <> ''
         then x = f9930OutputVarInfo('SpecialVar(set w/ code)',tempName,'Assigned :',variableSet.indx)

         if variableRef.indx <> ''
         then x = f9930OutputVarInfo('SpecialVar(used w/rexx)',tempName,'Reference:',variableRef.indx)

         if variableExposeRef.indx <> ''
         then x = f9930OutputVarInfo('SpecialVar(used w/rexx)',tempName,'Expose Ref:',variableExposeRef.indx)

         if variableStemSet.indx   <> ''
         then x = f9930OutputVarInfo('SpecialVar(w/stem set):',tempName,'w/Stem set',variableStemSet.indx)

         if variableStemRef.indx   <> ''
         then x = f9930OutputVarInfo('SpecialVar(w/stem ref):',tempName,'W/Stem ref',variableStemRef.indx)

         if variableLabelDef.indx  <> ''
         then x = f9930OutputVarInfo('Label (internal label) ',variable.indx,'Defined  :',variableLabelDef.indx)

         if variableLabelRef.indx  <> '' & variableLabelDef.indx <> ''
         then x = f9930OutputVarInfo('Label (int. label ref) ',variable.indx,'Reference:',variableLabelRef.indx)

         if variableLabelRef.indx  <> '' & variableLabelDef.indx = ''
         then x = f9930OutputVarInfo('BuiltoIn+/External use ',variable.indx,'Reference:',variableLabelRef.indx)

         /* v1.02 if an address reference, report it */
         if variableAddrDef.indx   <> ''
         then x = f9930OutputVarInfo('Address Envir.Constant)',variable.indx,'Reference:',variableAddrDef.indx)
         if variableAddrDefValue.indx <> ''
         then x = f9930OutputVarInfo('Address Envir.ValueExp)',variable.indx,'Reference:',variableAddrDefValue.indx)

         iterate

      end

      /* if not assigned a value... but referenced "as a variable" in rexx code... report it */
      if variableSet.indx = '' ,
       & ( variableRef.indx <> '' | variableStemSet.indx   <> '' | variableStemRef.indx   <> '' ,
          |variableExposeRef.indx <> '')
      then x = f9930OutputVarInfo('Variable (NEVER SET)   ',tempName,'Not Assgn:',' EITHER used as upper case value OR set via cmd')

      /* if assigned a value, report it */
      if variableSet.indx <> ''                                          /* assigned a value, report it */
      then x = f9930OutputVarInfo('Variable (set w/rexx)  ',tempName,'Assigned :',variableSet.indx)

      if variableRef.indx       <> '' ,
       | variableExposeRef.indx <> '' ,
       | variableStemSet.indx   <> '' ,
       | variableStemRef.indx   <> ''
      then do
         /* if variable refernce, report it*/
         if variableRef.indx <> ''
         then x = f9930OutputVarInfo('Variable (used in/rexx)',tempName,'Reference:',variableRef.indx)

         /* if variable expose refernce, report it*/
         if variableExposeRef.indx <> ''
         then x = f9930OutputVarInfo('Variable (used in/rexx)',tempName,'Expose Ref:',variableExposeRef.indx)

         /* if variable used in stem, report it */
         if variableStemSet.indx   <> ''
         then x = f9930OutputVarInfo('Variable (in Stem Set) ',tempName,'Assigned :',variableStemSet.indx)

         /* if variable used in stem, report it */
         if variableStemRef.indx   <> ''
         then x = f9930OutputVarInfo('Variable (in Stem Ref) ',tempName,'Reference:',variableStemRef.indx)
      end
      else if variableSet.Indx <> '' /* if wasn't referenced, but it was assigned a value */
      then x = f9930OutputVarInfo('Variable (NEVER USED)  ',tempName,'No Ref.  :',' If actually referenced, it must be via a cmd.')

      /* if it's an internal label, report it */
      if variableLabelDef.indx  <> ''
      then x = f9930OutputVarInfo('Label (internal label) ',variable.indx,'Defined  :',variableLabelDef.indx)

      /* if label (internal or external) is used, report it */
      if 7ariableLabelRef.indx  <> '' & variableLabelDef.Indx <> ''
      then x = f9930OutputVarInfo('Label (int. label ref) ',variable.indx,'Reference:',variableLabelRef.indx)
      else if variableLabelRef.indx  <> ''
      then x = f9930OutputVarInfo('Built-In+/External use ',variable.indx,'Reference:',variableLabelRef.indx)

      /* v1.02 if an address reference, report it */
      if variableAddrDef.indx   <> ''
      then x = f9930OutputVarInfo('Address Envir.Constant)',variable.indx,'Reference:',variableAddrDef.indx)
      if variableAddrDefValue.indx <> ''
      then x = f9930OutputVarInfo('Address Envir.ValueExp)',variable.indx,'Reference:',variableAddrDefValue.indx)


   end

   'EXECIO' out 'DISKW RESULTS (STEM OUT.'
   if rc <> 0
   then do
      say 'error writing to RESULTS ddname; rc='rc
      say 'exit 8'
      'EXECIO 0 DISKW RESULTS (FINIS'
      exit 8
   end

   /* variables used as variables */
   out = 0
   x = f9970Card('    xref (1 of 2) ends here                                      ')
   x = f9970Card('    xref (1 of 2) ends here                                      ')
   x = f9970Card('    -----------------------                                      ')
   x = f9970Card('                                                                 ')
   x = f9970Card('    xref (2 of 2) section 2 is for stem variable xreference.     ')
   x = f9970Card('    xref (2 of 2) section 2 is for stem variable xreference.     ')
   x = f9970Card('    ----------------------------------------------------------   ')
   x = f9970Card('       note:     Assignments/references to rexx stems            ')
   x = f9970Card('              is only for stem references in rexx code           ')
   x = f9970Card('              itself.                                            ')
   x = f9970Card('                                                                 ')
   x = f9970Card('                 Therefore, references to stem variables         ')
   x = f9970Card('              that are made INSIDE of quotes, say as             ')
   x = f9970Card('              part of an EXECIO command, will NOT show           ')
   x = f9970Card('              up in the XREF as they are part of a "string       ')
   x = f9970Card('              constant" and not used as a rexx variable or       ')
   x = f9970Card('              rexx stem directly.                                ')
   x = f9970Card('                                                                 ')
   x = f9970Card('                 This is because it often may not be obvious     ')
   x = f9970Card('              which address environment a command may (or may    ')
   x = f9970Card('              not) be valid in.  Or for us to know all the       ')
   x = f9970Card('              ways a rexx stem might be used.                    ')
   x = f9970Card('                                                                 ')
   x = f9970Card('    ----------------------------------------------------------   ')
   x = f9970Card('                                                                 ')
   x = f9970Card(' ')
   x = f9970Card(' ')
   x = f9970Card(' ')
   x = f9970Card(' ')
   x = f9970Card(' ')
   maxOutputVar = min(defaultMaxOutputVar,maxStemLength+5)
   do indx2 = 1 by 1 for stem
      /* get next sorted stem variable, then report it's information */
      sortedStemVariable =  SortedStemVariable.indx2
      indx = stemIndx.sortedStemVariable /* use indx to info for this variable */

      /* now report on it */
      tempname = stemVariable.indx /* get name of stem variable w/all variables*/
      parse var tempname buildname '.' rest
      stemName = buildName
      do while rest <> ''
         parse var rest tempname '.' rest
         x = variablesIndx.tempname
         if variableSet.x <> '' | specialVar.tempname = 1 /* upper case to lower case */
         then tempname = translate(tempname,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')
         buildname = buildname'.'tempname
      end
      if substr(stemVariable.indx,length(stemVariable.indx),1) = '.'
      then buildname = buildname'.'

      if specialStem.stemName
      then x = f9930OutputVarInfo('Stem-'stemPeriods.indx,buildname,' *Special:',' Assigned via an ADDR env cmd and/or REXX itself')

      if stemAsg.indx <> ' '
      then x = f9930OutputVarInfo('Stem-'stemPeriods.indx,buildname,'Assigned :',stemAsg.indx)

      if stemRef.indx <>  ' '
      then x = f9930OutputVarInfo('Stem-'stemPeriods.indx,buildname,'Reference:',stemRef.indx)

      if stemExposeRef.indx <>  ' '
      then x = f9930OutputVarInfo('Stem-'stemPeriods.indx,buildname,'Expose Ref:',stemExposeRef.indx)

      if out > 99
      then do
         'EXECIO' out 'DISKW RESULTS (STEM OUT.'
         if rc <> 0
         then do
            say 'error writing to ddname= RESULTS; rc='rc
            say 'exit 8'
            'EXECIO 0 DISKW RESULTS (FINIS'
            exit 8
         end
          out = 0
      end
   end
   'EXECIO' out 'DISKW RESULTS (STEM OUT.'
   out = 0
   x = f9970Card('    xref (2 of 2) ends here                                      ')
   x = f9970Card('    xref (2 of 2) ends here                                      ')
   x = f9970Card('    -----------------------                                      ')
   x = f9970Card(' ')
   x = f9970Card(' ')
   x = f9970Card(' ------------ tips for label references ----------------------------')
   x = f9970Card(' ------------ tips for label references ----------------------------')
   x = f9970Card('     tip:  c# is a ref to CALL stmt to this   internal/external name')
   x = f9970Card('     tip:  f# is a ref to FUNCTION call to    internal/external function')
   x = f9970Card('     tip:  s# is a ref to SIGNAL stmt to this internal label     ')
   x = f9970Card(' ')
   x = f9970Card(' ')
   x = f9970Card(' ------------ now xreference for stem variables (tips) -------------')
   x = f9970Card(' ------------ now xreference for stem variables (tips) -------------')
   x = f9970Card('     tip:     Note:- stem variables (after 1st period) are in lower case  ')
   x = f9970Card('     tip:          - stem "constants" (will be shown in UPPER case)       ')
   x = f9970Card('     tip:          - stem "constants" that are whole numbers (and not 0)  ')
   x = f9970Card('     tip:               will be summarized as a # sign (in place of       ')
   x = f9970Card('     tip:               individual digits/numbers) so it summarizes them. ')
   x = f9970Card('     tip:     What XREF for stems can help you fix:                       ')
   x = f9970Card('     tip:     -------------------------------------                       ')
   x = f9970Card('     tip:      - seeing a variable (lower case) used in a stem where you  ')
   x = f9970Card('     tip:       EXPECTED it to always be a constant.                      ')
   x = f9970Card('     tip:      - seeing a constant (upper case) used in a stem where you  ')
   x = f9970Card('     tip:       EXPECTED it to be a variable (maybe it was misspelled).   ')
   x = f9970Card('     tip:                                              )                  ')
   x = f9970Card('     tip:line sample rexx code (followed by sample xref)                  ')
   x = f9970Card('     tip:---- ------------                                                ')
   x = f9970Card('     tip:  1     x = "Richard"                                            ')
   x = f9970Card('     tip:  2     firstName.y.x.1 = "Hi"                                   ')
   x = f9970Card('     tip:  3     firstName.y.x.2 = "Buddy"                                ')
   x = f9970Card('     tip:  4     firstName.y.x.0 = 2                                      ')
   x = f9970Card('     tip:                                                                 ')
   x = f9970Card('     tip:sample xref listing                                              ')
   x = f9970Card('     tip:-----------                                                      ')
   x = f9970Card('     tip:  --xref section 1 (variables)                                   ')
   x = f9970Card('     tip:  --xref section 1 (variables)                                   ')
   x = f9970Card('     tip:                                                         ')
   x = f9970Card('     tip:Variable (set)         X               Assigned : 1      ')
   x = f9970Card('     tip:Variable(w/ stem use): X               Reference: 2 3 4  ')
   x = f9970Card('     tip:Constant(w/ stem use): Y               Reference: 2 3 4  ')
   x = f9970Card('     tip:                                                         ')
   x = f9970Card('     tip:  --xref section 2 (stem variables)                              ')
   x = f9970Card('     tip:  --xref section 2 (stem variables)                              ')
   x = f9970Card('     tip:                                                         ')
   x = f9970Card('     tip:Stem-3 FIRSTNAME.Y.x.#                 Assigned : 2 3    ')
   x = f9970Card('     tip:Stem-3 FIRSTNAME.Y.x.0                 Assigned : 4      ')
   x = f9970Card('     tip:                                       Reference: 2 3 4  ')
   x = f9970Card('     tip:     note:  Stem-3 refers to # of periods in the stem.           ')
   x = f9970Card('     tip:                                                                 ')
   x = f9970Card('     tip:  rexx tip: remember stem value on the right is "tricky":        ')
   x = f9970Card('     tip:        Given following rexx code:                               ')
   x = f9970Card('     tip:             x = "RICHARD.HUMPHRIS"                              ')
   x = f9970Card('     tip:             y = "RICHARD"                                       ')
   x = f9970Card('     tip:             z = "HUMPHRIS"                                      ')
   x = f9970Card('     tip:        References to a stem variable, as shown below, are       ')
   x = f9970Card('     tip:          referring to the SAME stem variable:                   ')
   x = f9970Card('     tip:             stem.x     refers to STEM.RICHARD.HUMPHRIS          ')
   x = f9970Card('     tip:             stem.y.z   refers to STEM.RICHARD.HUMPHRIS          ')
   x = f9970Card('     tip:        This is because x contains a period.  And because      ')
   x = f9970Card('     tip:          everything to the right of the first period is evaluated')
   x = f9970Card('     tip:          first.  Then the stem variable is "looked up".         ')
   x = f9970Card('     tip:                                                                 ')
   x = f9970Card('     tip:   rexx tip:  referencing pgm above, if you set variable "a"     ')
   x = f9970Card('     tip:         to a upper/lower case value.  The stem will NOT upper   ')
   x = f9970Card('     tip:         case it.                                                ')
   x = f9970Card('     tip:        So if assignment statement set "a" to "richard"          ')
   x = f9970Card('     tip:         then stem.y is NOT the same as stem.a                   ')
   x = f9970Card('     tip:        Because stem.y    refers to STEM.RICHARD                 ')
   x = f9970Card('     tip:        and     stem.a    refers to STEM.richard                 ')
   x = f9970Card('     tip:                                                                 ')
   'EXECIO' out 'DISKW RESULTS (STEM OUT. FINIS'
   if rc <> 0
   then do
      say 'error writing/closing ddname= RESULTS; rc='rc
      say 'exit 8'
      'EXECIO 0 DISKW RESULTS (FINIS'
      exit 8
   end
   return

f9910SlowSort:
   /* x = f9910SlowSort('sort','unsortedVariable.','sortedVariable.') */ /* slow rexx sort */
   /* ... */
   /* we don't have an omvs segment... so we have to do sort (slowly) using rexx code instead*/
   /* ---------------------------------------------------------------------------------------*/

   parse upper arg f9910_sort . , f9910_Stem1 . , f9910_Stem2 .

   /* need to verify 1st parm is "SORT" */
   /* --------------------------------- */
   if f9910_sort <> 'SORT'
   then return 1  /* error, 1st parm must be "sort" */

   /* need to verify f9910_stem1 is not null */
   /* -------------------------------------- */
   if f9910_Stem1 = ''
   then return 2  /* error, 2nd parm must be specified */

   /* need to verify f9910_stem1 is a valid symbol */
   /* -------------------------------------------- */
   if f9920VerifyRexxSymbol(f9910_Stem1,'S') <> 1
   then return 3                    /* invalid symbol */

   /* default stem2 and/or verify it's a symbol */
   /* ----------------------------------------- */
   if f9910_stem2 = ''
   then f9910_stem2 = f9910_stem1 /* default to stem1 */
   else do
      /* need to verify f9910_stem2 is a valid symbol */
      /* -------------------------------------------- */
      if f9920VerifyRexxSymbol(f9910_Stem2,'S') <> 1
      then return 3                    /* invalid symbol */
   end

   /* verify stem1.0 coutains a valid whole number >= 0 */
   /* ------------------------------------------------- */
   if value(f9910_stem1||'0') = ''
   then return 4
   if datatype(value(f9910_Stem1 || '0'),'W') = 0 | value(f9910_Stem1 || '0') < 0
   then return 4  /* error, stem 0 must be numeric and a whole number*/

   /* anything to sort? */
   /* ----------------- */
   if value(f9910_Stem1 || '0') = 0
   then do
      /* nothing to sort, return 0 */
      if f9910_Stem2 <> f9910_Stem1
      then x = value(f9910_Stem2 || '0','0') /* set f9910_stem2.0 = 0 */
      return 0
   end

   /* time to sort stems */
   /* ------------------ */
   top = value(f9910_Stem1||'0')
   if f9910_Stem2 <> f9910_Stem1
   then do
      /* 1st copy stem1 into stem2; as stem2 should get sorted output */
      do f9910_k = 0 by 1 while f9910_k <= top
         x = value(f9910_stem2||f9910_k,value(f9910_stem1||f9910_k))
      end
   end

   /* now sort stems in output stem f9910_stem2 */
   /* ----------------------------------------- */
   f9910_varX = top /* all stem rows need to be checked */
   do until f9910_varX < 2
      f9910_LastSwap = 1 /* set to 1, if never changed it's all sorted */
      f9910_varX_minus1 = f9910_varX - 1
      do f9910_VarY = 1 until f9910_VarY >= f9910_VarX_minus1
         if value(f9910_Stem2||f9910_VarY) > value(f9910_Stem2||f9910_VarY+1)
         then do
            swap = value(f9910_Stem2||f9910_VarY+1,value(f9910_Stem2||f9910_VarY))
            x    = value(f9910_Stem2||f9910_VarY,swap)
            f9910_LastSwap = f9910_VarY /* last swap occured here */
         end
      end
      f9910_VarX = f9910_LastSwap /* next loop, only have to check from 1 to here */
   end
   return 0

f9920VerifyRexxSymbol:
   /* datatype(var,'s') returns a 1 even for numeric symbols starting with 0-9 or a period */
   /*            ... so we need to consistently check if numeric (and if truly a symbol).  */

   arg f9920_symbol . , f9920_option .

   if f9920_option <> 'S'
   then do
      say "someone called function f9920VerifyRexxSymbol without the 'S' option"
      say 'function called from line' sigl
      say 'f9920_option = "'f9920_option'" expected "S"'
      say 'exiting w/rc=12'
      exit 12
   end

   if f9920_symbol = ''
   then return 0 /* not a symbol, return 0 */

   if datatype(f9920_symbol,'S') = 0
   then return 0 /* not a symbol, return 0 */

   if pos(left(f9920_symbol,1),'0123456789.') > 0
   then return 0 /* not a symbol (looks numeric), return 0 */
   return 1      /* this is a real rexx symbol */

f9930OutputVarInfo:
   parse arg f9930LHS, f9930Var, f9930RHS, f9930Ref

   if firstTime = 'FIRSTTIME'
   then do
      parse upper var f9930Var lastF9930Var '.' .
      firstTime = ''
   end

   if blankOption = 'BYVAR'
   then do
      parse upper var f9930Var leftSide '.' .
      if leftSide <> lastF9930Var
      then do /* add a blank line between variables */
         out = out + 1.
         out.out = ' '
         lastF9930Var = leftSide
      end
   end

   if length(f9930Var) > maxOutputVar
   then do  /* have var and contents on seperate lines */
      out = out + 1 /* output variable, of any length */
      out.out = f9930LHS f9930Var /* output long variable name */
      f9930Lhs = left('',length(f9930LHS))
      f9930Var = left('...',maxoutputvar)
   end
   else f9930var = left(f9930Var,maxoutputvar)

   spaceremaining = width - length(f9930lhs f9930var f9930rhs) - 3

   if length(f9930ref) < spaceRemaining
   then wordx = words(f9930ref)
   else wordx = words(left(f9930ref,spaceRemaining)) - 1

   if wordx < 1
   then wordx = 1

   leftwords = subword(f9930ref,1,wordx)
   f9930ref  = subword(f9930ref,wordx+1)

   out = out+1 /* output 1st (or 2nd) line */
   out.out = f9930LHS f9930var f9930rhs leftwords

   f9930Lhs = left('',length(f9930LHS))
   f9930Var = left('...',maxoutputvar)
   f9930Rhs = left('',length(f9930RHS))
   spaceremaining = width - length(f9930lhs f9930var f9930rhs) - 3

   do while f9930ref <> ''
      if length(f9930ref) < spaceRemaining
      then wordx = words(f9930ref)
      else wordx = words(left(f9930ref,spaceRemaining)) - 1

      if wordx < 1
      then wordx = 1

      leftwords = subword(f9930ref,1,wordx)
      f9930ref  = subword(f9930ref,wordx+1)

      out = out+1 /* output continuation lines*/
      out.out = f9930LHS f9930var f9930rhs leftwords
   end

   return 0


f9970Card:
   /* just output info */
   parse arg cardx
   /* we only need one out.out stem created for this call */
   out = out + 1
   out.out = cardx
   return 0

logicMsg:
   parse arg logicMsg1
   say 'LogicMsg001I line('sigl')' logicMsg1 /* give logic message w/line + msg */
   return
