/* rexx */
  trace 's'

/*  rexx member for scan/xref was: */
/*     "SFRH66.CNTL.RACFDB2.PDS(RACFDB2T)"      */
/*      ---------------------------------       */
/*  date/time of XREF was:                      */
/*     20231217 23:04:31                        */
/*      ---------------------------------       */

/*Rexx*/
/*                                                                 */
/*                               -----------                       */
/* ==> when edit'ing issue cmd:  hilite rexx                       */
/*                               -----------                       */
/*                                                                 */
/* written by:  - Peter Harroun   IBM Global Services-West (Boulder)*/
/*                                                                 */
/* modified by: - Richard Humphris  State of Indiana               */
/*                added db2 security support up to db2 v12.        */
/*                                                                 */
/*              - Christopher Tee, pointed out updateable views    */
/*                for insert/delete/update grants need an          */
/*                additional formatting for RACF.  This code has   */
/*                been added.                                      */
/*                - routine:  tab_priv for insert, delete and update*/
/*                     was modified to exclude grants on views.    */
/*                - routine:  tab_priv also called for:            */
/*                     'view_insert', 'view_delete' and            */
/*                     'view_update' to handle racf differences.   */
/*                                                                 */
/*    ***       - change-08/15/2023 added option RESET/NORESET     */
/* For:  RESET/NORESET option (default NORESET)  change-08/15/2023 */
/*              -  RESET (prior code, always generated a PERMIT    */
/*               with a RESET option (to throw away previous       */
/*               permits) followed by (new) permits.               */
/*                 RESET has become an option; and not the default.*/
/*              -  NORESET will not generate a PERMIT with a RESET.*/
/*               this will add new permits to any existing RDEF    */
/*               profile, but not delete any existing permits.     */
/*                 NORESET will be the default option.             */
/*                                                                 */
/*    ***       - change-07/25/2023 added more fixes to the code   */
/*                and more comments.                               */
/*                   - corrected code for package collid.*         */
/*                        where for grant to public used wrong     */
/*                        variable.                                */
/*                   - for package collid.specificName permits     */
/*                        simplified code to add generic permits   */
/*                        to the explicit package (this is so      */
/*                        racf works like db2).  Before code       */
/*                        could run for an excessive amt of time). */
/*                        This is a performance fix.               */
/*                   - for package collid.specificName permits     */
/*                        if permits in specific name were covered */
/*                        by the generic collid.* rdef, we will    */
/*                        no longer create the specific rdef and   */
/*                        let it default to the generic one.  Thus */
/*                        reducing racf maintenance in future.     */
/*                   - for package one of the rexx statements      */
/*                        generating permits was missing           */
/*                        "ACC(READ)".  This has been fixed.       */
/*                   - for more info, issue edit/browse cmd:       */
/*                        find 'change-07/25/2023'                 */
/*                                                                 */
/*    ***       - change-06/06/2023 added more fixes to the code   */
/*                and more comments.                               */
/*                   - for more info, issue edit/browse cmd:       */
/*                        find 'change-06/06/2023'                 */
/*                                                                 */
/* For:  PE/noPE option (default noPE)  change-06/06/2023          */
/*       PE seperates permits into the *$PE files.                 */
/*       noPE has RDEFs and PERMITS in the RDEF files.             */
/*                                                                 */
/*                                                                 */
/* For:  GENERIC/NoGENERIC option, add GenericNoAudit option       */
/*    GenericNoAudit ignores AUDITING column when generating       */
/*    table access rules.                                          */
/*       With Generic option, tables that are being audited are    */
/*    excluded from the generic table access.                      */
/*       With GenericNoAudit option, AUDITING column is ignored.   */
/*                                                                 */
/* For   GENERIC and GenericNoAudit processing:                    */
/*        if less than 100% of a schemas (for tables with schema)  */
/*    can be grouped into one default.  List the access for the    */
/*    top 4 contenders for the generic table access rules.         */
/*        And write the results to the OPTCLIST ddname.            */
/*                                                                 */
/* Now supports DB2 V12 and earlier.                               */
/*    = minus support for "ROLES".                                 */
/*                                                                 */
/* Generated rules are appropriate for zparm settings:             */
/*    AUTHEXIT_CACHEREFRESH=ALL,  (or =NONE)                       */
/*    AUTHEXIT_CHECK=DB2,                                          */
/*                                                                 */
/* Note:  either AUTHEXIT_CHECK=DB2 or AUTHEXIT_CHECK=PRIMARY      */
/*    (especially production db2's) you'd want plans/packages      */
/*    to be bound by a group-id (and not an individual userid).    */
/*    Otherwise, when the individual is "revoked" and/or "removed" */
/*    you may find plans to become unuseable (for example).        */
/*                                                                 */
/* Note: changing AUTHEXIT_CHECK= from DB2 to PRIMARY may result   */
/*    in additional racf work that this exec cannot provide.  See  */
/*    the DB2/RACF manual for more information.                    */
/*                                                                 */
/* --------------------------------------------------------------- */
/* For original code see:  RACFDB2                                 */
/* --------------------------------------------------------------- */
/*                                                                 */
/* %RACFDB2T owner ssid <classmnt> <model> <charopt> options       */
/*                      <  DSN   > <  2  >                         */
/*                      <  ---   > <  -  >                         */
/*                                                                 */
/*    example:                                                     */
/*         %RACFDB2T DB2ADM DB2X SQL NOWARN                        */
/*                                                                 */
/*         1)  SQL option selected (removed from arg line)         */
/*         2)  GENERIC/NOGENERIC not specified, default GENERIC    */
/*         2)  NOWARN option selected (removed from arg line)      */
/*                                                                 */
/*         resulting arg line:  %RACFDB2T DB2ADM DB2X              */
/*         3)  owner is DB2ADM                                     */
/*         4)  ssid  is DB2X                                       */
/*         5)  classmnt not specified, DSN is default              */
/*         6)  model    not specified, 2 is default                */
/*         7)  charopt  not specified, null is default.            */
/*                                                                 */
/*    Options you can specify:                                     */
/*    ----------------------------------------------------------   */
/*                       can appear anywhere; these options will   */
/*                       be "removed" from "arg line" so that      */
/*                       positional arguments (OWNER, SSID,        */
/*                       CLASSMNT, MODEL and CHAROPT) can be       */
/*                       specified (or not) without these options  */
/*                       effecting those positional args.          */
/*                                                                 */
/*       SQL/NOSQL  - SQL will add (comments) to output showing    */
/*               the sql this exec used to build the RDEF(s) and   */
/*               PERMITs we are creating.                          */
/*                  - default NOSQL                                */
/*                  - but SQL is nice too.                         */
/*                                                                 */
/*       GENERIC/NOGENERIC/GENERICNOAUDIT                          */
/*                  - GENERIC option will try and reduce the       */
/*               number of RDEF's needed for table access, etc.    */
/*               For example, if 90% of creator-x's tables give    */
/*               x,y and z DELETE access.  This it will create a   */
/*               generic RDEF for ssid.creator-x.*.DELETE for users*/
/*               x, y, z.  And create specific RDEF's for other    */
/*               tables created by sssid.creator-x.  Note:  for    */
/*               tables being audited, then specific RDEF's will   */
/*               always be created for those tables.               */
/*                                                                 */
/*                  - GenericNoAudit is like the generic option    */
/*               except GENERIC will exclude audit'ed tables from a*/
/*               generic RDEF (and always create a specific one for*/
/*               the audit'ed table.                               */
/*                                                                 */
/*               RDEFs can be reduced (eliminated) by a generic one*/
/*                  - Default:  GENERIC                            */
/*                                                                 */
/*        WARN/NOWARN                                              */
/*                  - WARN will generate RDEFs with the WARN       */
/*               option.  I don't think this is useful, really,    */
/*               but it is an option.  I recommend "NOWARN".       */
/*                  - WARN also allows access even when it shouldn't*/
/*               plus it does this before checking all the other   */
/*               'options' that might have provided access.  It    */
/*               just doesn't seem useful (to me) in the db2 world.*/
/*                  - Default:  NOWARN                             */
/*                                                                 */
/*        SlimAdm/NoSlimAdm                                        */
/*                  - SlimAdm will skip explicit permits on RDEFs  */
/*               if a userid is a SYSADM and already has the priv. */
/*               if a userid is a DBADM  and already has the priv. */
/*                                                                 */
/*                  - NoSlimAdm will create all permits even if id */
/*               is a SYSADM and already has the priv.             */
/*               is a DBADM  and already has the priv.             */
/*                                                                 */
/*                                                                 */
/*  "positional arguments"                                         */
/*  ----------------------                                         */
/*    owner (required)                                             */
/*        1-8 characters.  The userid and/or group id to be used   */
/*        when creating RDEF statements.  It will be the id used   */
/*        for the OWNER(id) in the RDEF.                           */
/*                                                                 */
/*    ssid  (required)                                             */
/*        1-4 character (db2) ssid to identify the db2 system to   */
/*        be converted to RACF.  This is used to connect to that   */
/*        db2 subsystem so that we can see the db2 security tables,*/
/*        etc..                                                    */
/*                                                                 */
/*    classmnt (optional)                                          */
/*        1-4 characters.  Default=DSN.  Unless modifying the      */
/*                         RACF security exit, you should specify  */
/*                         "DSN".                                  */
/*        Racf security exit is in hlq.SDSNSAMP(DSNXRXAC).         */
/*        Note:  at beginning of assembler code DSNXRXAC it        */
/*        sets &CLASSMNT to 'DSN'.  If you change the exit you     */
/*        will have to specify the same value you use in the RACF  */
/*        exit.                                                    */
/*                                                                 */
/*    model    (optional)                                          */
/*        1 character.  If specified, must be "1" or "2".          */
/*                      Defaults to '2'.  As does the RACF security*/
/*                      exit.                                      */
/*        Therefore, you should specify 2 unless you plan on       */
/*        modifying the RACF security exit to change it to '1'.    */
/*                                                                 */
/*        Source is in hlq.SDSNSAMP(DSNXRXAC) although if you      */
/*        modify it you should move source to a non-smp/e maintained*/
/*        library.                                                 */
/*                                                                 */
/*        setting to a 1 will generate model 1 rdefs/permits       */
/*        setting to a 2 will generate model 2 rdefs/permits       */
/*                                                                 */
/*                                                                 */
/*    Charopt  (optional)                                          */
/*        1 character.  If specified, must be 0-9, #, @ or $.      */
/*                      The RACF security exit defaults this to a  */
/*                      "1".                                       */
/*                      However, this exit accepts a null if       */
/*                         1) classmnt = 'DSN' (exit default)      */
/*                         2) model    = 2     (exit default)      */
/*                         3) charopt  = '' or 1 (1=exit default)  */
/*                      because the charopt is ignored when        */
/*                      classmnt = DSN and model = 2.              */
/*                                                                 */
/*                      In fact, if you specify a 1 (where         */
/*                      classmnt=DSN and model=2, we will change   */
/*                      charopt to a null (as expected by exit).   */
/*                                                                 */
/*                      IF classmnt set to other than DSN or       */
/*                      using model 1, then you will have to       */
/*                      modify the racf exit and then a non-null   */
/*                      charopt must be set in the exit and spec-  */
/*                      ified for this exec run.                   */
/*                                                                 */
/*        Source is in hlq.SDSNSAMP(DSNXRXAC) although if you      */
/*        modify it you should move source to a non-smp/e maintained*/
/*        library.                                                 */
/*                                                                 */
/*                                                                 */
/* --------------------------------------------------------------- */
/*                                                                 */
/* Error recovery improvements:                                    */
/* Error recovery improvements:                                    */
/*    1.  Default command enviornment changed to TSO               */
/*                                                                 */
/*        a.  This improves error recovery as "unknown" commands   */
/*           are reported under TSO.  Which were "ignored" under   */
/*           address 'dsnrexx'.                                    */
/*        b.  Actual db2 commands are executed explicity as:       */
/*                address 'dsnrexx' ...db2 command ...             */
/*                                                                 */
/*    2.  rexx syntax error recovery provided.  Instead of one     */
/*        line of code, it provides a glimpse into the rexx program*/
/*        around the line that got the syntax error.               */
/*                                                                 */
/*    3.  improvement when sql fails, as we can display sql in     */
/*        a nicer format.  (see "building SQL has changed).        */
/*                                                                 */
/* --------------------------------------------------------------- */
/*                                                                 */
/* Building sql has changed:                                       */
/* Building sql has changed:                                       */
/*                                                                 */
/*   BEFORE:                                                       */
/*   BEFORE:                                                       */
/*    Before we simply set a variable "SQL" to a sql statement.    */
/*    And the assignment statement typically was composed of       */
/*    multiple lines of sql code (ending with rexx commas to       */
/*    continue the rexx assignment statement.                      */
/*                                                                 */
/*    Then we called zsql to prepare and open the cursor, like     */
/*    this:                                                        */
/*                                                                 */
/*        sql = 'line of sql code'  ,                              */
/*              'line of sql code'  ,                              */
/*              '...             '  ,                              */
/*              'line of sql code'                                 */
/*        call zsql                                                */
/*                                                                 */
/*    But this had two problems:                                   */
/*                                                                 */
/*        a.  confusing, because sometimes commas were embedded    */
/*          and meant for SQL code.  And sometimes commas were     */
/*          "rexx commas" to continue the rexx assignement stmt.   */
/*                                                                 */
/*        b.  and if an error occured in zsql, the sql statement   */
/*          was hard to read as all the "line" formatting          */
/*          disappeared when rexx created the SQL variable.        */
/*                                                                 */
/*   NOW:                                                          */
/*   NOW:                                                          */
/*    This was solved by having seperate function calls to "sql"   */
/*    for each line of sql code.                                   */
/*                                                                 */
/*       aa. problem (a) is solved.  No confusing rexx commas to   */
/*          continue SQL statement.                                */
/*                                                                 */
/*       bb. no problems with an extra "ending" rexx comma or      */
/*          forgetting to add a rexx comma.                        */
/*                                                                 */
/*       cc. problem (b) is solved.  The sql function addes code   */
/*          to automatically allow error recovery to be able to    */
/*          produce more readable (formatted) sql code that was    */
/*          executed.  And it also provides all the rexx code      */
/*          involved with creating the sql statement ... including */
/*          condional rexx code which may have (or may not have)   */
/*          contributed to creating the entire sql statement.      */
/*                                                                 */
/*       dd.  The SQL option allows you to see the sql as comments */
/*          in the generated racf rules.  It allows you to see the */
/*          rexx code (with variables) and the final generated SQL>*/
/*          This is "especially" nice in that the rexx code may be */
/*          conditional code (with some optional clauses) that you */
/*          may (or may not) find in the generated sql code.  In   */
/*          addition, it is fairly easy to extract the generated   */
/*          code to run in SPUFI or QMF (etc) if you want to see   */
/*          what was actually returned to this rexx exec.          */
/*            In addition, the rexx code/sql code has line numbers */
/*          so you can easily find which statement in this rexx    */
/*          exec was executed.  Note:  as a lot of the code is     */
/*          written as a subroutine, the same sql may be executed  */
/*          more than once but checking a different authority; for */
/*          example:  routine sys_attr checks many different       */
/*          authorities like SYSADMAUTH, SYSOPRAUTH, SYSCTRLAUTH   */
/*          etc..                                                  */
/*                                                                 */
/*    So now the way or preparing a sql statement and opening a    */
/*    cursor looks like this:                                      */
/*        x=sql('New statement')      /* required for new stmt*/   */
/*        x=sql('line of sql code')                                */
/*        x=sql('line of sql code')                                */
/*        if something then x=sql('line of sql code')              */
/*        x=sql('line of sql code')                                */
/*        x=sql('line of sql code')                                */
/*        call zsql                                                */
/*                                                                 */
/*                                                                 */
/*    In addition.                                                 */
/*    ------------ before we only allowed one cursor to be open    */
/*    at a time.  Now, there is an option on the "New Statement"   */
/*    that allows you to specify a different cursor.               */
/*                                                                 */
/*    The default for x=sql("New Statement") is for cursor 1       */
/*                                                                 */
/*    BUT NOW you can explicitly specify cursor 1 like:            */
/*                    x=sql("New Statement; Stmt/Cursor=1')        */
/*                                                                 */
/*    OR you can specify a different cursor like:                  */
/*                    x=xql("New Statement; Stmt/Cursor=2')        */
/*                                                                 */
/*    The only restrictions are:                                   */
/*           1) Stmt/cursor=#:  the number must be between 1 to 100*/
/*           2) after the x=('New statement<; Stmt/cursor=#>')     */
/*          that you must add all sql statements for this cursor   */
/*          before "call zsql" which will create/open cursor for   */
/*          this statement.                                        */
/*           3) when calling prtsqlca it should specify which      */
/*          cursor the failing sqlerror is for.                    */
/*                                                                 */
/*        x=sql('New statement')      /* required for new stmt*/   */
/*    OR  x=sql('New statement; stmt/cursor=#')                    */
/*                                                                 */
/*    then...                                                      */
/*        x=sql('line of sql code')                                */
/*        x=sql('line of sql code')                                */
/*        if something then x=sql('line of sql code')              */
/*        x=sql('line of sql code')                                */
/*        x=sql('line of sql code')                                */
/*        call zsql                                                */
/*                                                                 */
/*                                                                 */
/* --------------------------------------------------------------- */
/*                                                                 */
/*  additional db2 priviledges added for conversion                */
/*  -----------------------------------------------                */
/*                                                                 */
/*    call sys_attr "SYSDBADM","SDBADMAUTH"                        */
/*    call sys_attr "DATAACCESS","DATAACCESSAUTH"                  */
/*    call sys_attr "ACCESSCTRL","ACCESSCTRLAUTH"                  */
/*                                                                 */
/*    (call db_option removed; no longer needed).                  */
/*                                                                 */
/*          Schema   privileges;  rh:  add schema privs class "SC" */
/*          ------------------------------------------------------ */
/*    call schema_attr "ALTERIN","ALTERINAUTH"                     */
/*    call schema_attr "CREATEIN","CREATEINAUTH"                   */
/*    call schema_attr "DROPIN","DROPINAUTH"                       */
/*                                                                 */
/*          resources                                              */
/*          ---------                                              */
/*    call sys_attr "SQLADM","SQLADMAUTH"                          */
/*    call sys_attr "CREATESECUREOBJECT","CREATESECUREAUTH"        */
/*    call sys_attr "DEBUGSESSION","DEBUGSESSIONAUTH"              */
/*    call sys_attr "EXPLAIN","EXPLAINAUTH"                        */
/*    call sys_attr "BSDS","BSDSAUTH"                              */
/*                                                                 */
/*          table privs                                            */
/*          -----------                                            */
/*    call tab_priv "TRIGGER","TRIGGERAUTH"                        */
/*    call tab_priv "UNLOAD","UNLOADAUTH"                          */
/*    call tab_priv "VIEW_INSERT","INSERTAUTH"                     */
/*    call tab_priv "VIEW_UPDATE","UPDATEAUTH"                     */
/*    call tab_priv "VIEW_DELETE","DELETEAUTH"                     */
/*                                                                 */
/*          add usage privs                                        */
/*          ---------------                                        */
/*    call use_priv "USAGE","J","JR" /* jar */                     */
/*    call use_priv "USAGE","D","UT" /* distinct type */           */
/*                                                                 */
/*          add global variable support                            */
/*          ---------------------------                            */
/*    call gv_attr "READ","READAUTH"                               */
/*    call gv_attr "WRITE","WRITEAUTH"                             */
/*                                                                 */
/*          add sequence support                                   */
/*          ---------------------------                            */
/*    call seq_attr "ALTER","ALTERAUTH"                            */
/*    call seq_attr "USAGE","USEAUTH"                              */
/*                                                                 */
/*          add stored procedure support                           */
/*          ----------------------------                           */
/*    call routine_attr "EXECUTE","EXECUTEAUTH","P"                */
/*                                                                 */
/*          add User defined function                              */
/*          ----------------------------                           */
/*    call routine_attr "EXECUTE","EXECUTEAUTH","F"                */
/*                                                                 */
/* --------------------------------------------------------------- */
/*                                                                 */
/* Additional RACF intelligence.                                   */
/* -----------------------------                                   */
/*                                                                 */
/*    Benefit 1:                                                   */
/*    ==========                                                   */
/*                                                                 */
/*    This can help you identify all the privs held by a userid    */
/* and/or a group, IF you run the exec with option "NoSlimAdm".    */
/*                                                                 */
/* As output in the ddname=OPT will contain a summary of userid's  */
/* and where they are used in permits (in the variety of output    */
/* files).  With option "SlimAdm" you won't see all the explicit   */
/* permits for a userid with SYSADM, but it will still have a      */
/* line in the DSNADM ddname to give it the SYSADM priv.           */
/*                                                                 */
/*                                                                 */
/*    Benefit 2:                                                   */
/*    ==========                                                   */
/*    If you supply the job with a unload of the RACF database     */
/* (where we collected userid/group information) and use that      */
/* dataset for (input) ddname=RACFSMRY ... then this exec will help*/
/* identify missing (obsolete) userids and/or groups that we would */
/* be generating permits for.                                      */
/*    If you wish to ignore any grants for these userids and/or    */
/* groups, you can then add them as "delete userid" entries in the */
/* input ddname=EXCLUDE                                            */
/*                                                                 */
/*    Benefit 3:                                                   */
/*    ==========                                                   */
/*    If you have a revoked RACF userid we will report that too.   */
/* Note:  if a plan is using the authority of a revoked userid then*/
/* that plan will be unuseable.  It's really better to bind plans  */
/* under a group userid, so the plan won't become unuseable if a   */
/* userid is revoked for any reason.                               */
/*                                                                 */
/*    Benefit 4:                                                   */
/*    ==========                                                   */
/*     1. we add comments under a permit to give you information   */
/* about a racf userid and/or group.                               */
/*                                                                 */
/*  Add code at beginning to read in ddname=RACFSMRY            */
/*  ... and create variables so that we know info about real    */
/*  ... racf userid's and groups ... so we know how valid or not*/
/*  ... commands would be (and add comments to racf commands OR */
/*  ... make racf "commands" into comments if they are not valid*/
/* --------------------------------------------------------------- */
/*                                                                 */
/* additional notes:                                               */
/*  - add comments to most RDEF's which go into RACF database      */
/*                                                                 */
/*  - (comments only) for PERMIT's with RACF userid/group info     */
/*                                                                 */
/*  - Treats most grants as READ (and virtually never uses ALTER)  */
/*    except for sysadm's.                                         */
/*                                                                 */
/*  - For implicit databases, only do grants for DSNDB04 as racf   */
/*    does all implicit database checking off of database DSNDB04  */
/*    (no matter what generated implicit database name db2 uses).  */
/*                                                                 */
/*  - add backstop (catch all) RDEF's so access attempts for       */
/*    non-specific access are rejected.  For example:              */
/*                                                                 */
/*       RDEF MDSNTB DSN2.*.*.ALTER UACC(NONE) AUDIT(ALL(READ)) -  */
/*          OWNER(xxx) -                                           */
/*          DATA('Backstop for ALTER on table(s) *.*')             */
/*       (and of course, we have no permits for this)              */
/*                                                                 */
/*                                                                 */
/*-------------------------                                    */
/*  a.  Try to eliminate creating RACF permits                 */
/*    1. for example, a user with SYSADM doesn't need (almost) */
/*      and other authorities.  (with option SlimAdm)          */
/*    2. for example, a user with dbadm doesn't need other db  */
/*      authorities.            (with option SlimAdm)          */
/*  b.  For Packadm, ignore collection id's that don't exist   */
/*    unless *SETS* or IVR*.                                   */
/*  c.  For tables.                                            */
/*         select distinct owner                               */
/*            from sysibm.syspackage                           */
/*            order by owner                                   */
/*      Then only generate table rules for owner's of packages */
/*      and/or valid racf userid's and/or groups; when specified*/
/*      in systabauth.                                         */
/*  c.  Add Java archive file support (OBTYPE='J') in          */
/*      SYSIBM.SYSRESAUTH                                      */
/*                                                             */
/*  d.  if user has say packadm on ISETS.* ... then any        */
/*      sepecific packadm rule will need to have that userid   */
/*      added to the rule for specific access.                 */
/*                                                             */
/*  e.  create files for RDEFS, by class.                      */
/*      create files for PERMITS, by class.                    */
/*      split rdefs/permits with continuation at ' DATA()      */
/*                                                             */
/*  f.  if table is granted to "public" for say "selectauth"   */
/*      then don't generate unneccessary permits for groups/   */
/*      users for the same table.                              */
/*                                                             */
/*  g.  add "warn/nowarn" option, where "NOWARN" is the default*/
/*      add "generic/nogeneric" option  "generic" s the default*/
/*                                                             */
/*  h.  add generic code for rules                             */
/*                                                             */
/*  */
/* set up error routines; and branch to "startup" */

   signal on syntax /* set trap for syntax errors */
signal startUp      /* "branch" over the syntax handling routine */

/* -------                 */
   syntax:
/* -------                 */
/* syntax:  error handling */
/*   rc    is set to the syntax error number;                        */
/*         ... equivelent to IRX00nnL as rc = 00, 01 to 99           */
/*   sigl  is set to the line number in error                        */
   say 'IRX00'right('00'rc,2)'I Error running exec' ,
              execName 'line' sigl':' errortext(rc)
   syntaxLow = max(sigl-7,1)            /* -7 before (or pgm start) */
   syntaxHigh= min(sigl+7,sourceline()) /* +7 after  (or pgm end)   */
   do syntaxII = syntaxLow to syntaxHigh/* -7 lines back to +7 lines*/
      if syntaxII <> sigl
      then say 'line   ' right(syntaxii,length(syntaxHigh))':' ,
                     sourceline(syntaxII)
      else say 'line==>' right(syntaxii,length(syntaxHigh))':' ,
                     sourceline(syntaxII)
   end

   /* close (most) open files */
   /* ----------------------- */
   do i = 1 by 1 for openDDs
      ddname = openDDs.i
      address 'TSO' "EXECIO" bufferRecs.ddname ,
          "DISKW" ddname '(FINIS STEM BUFFERX.'ddname'.'
      if rc <> 0
      then say 'error closing/writting to ddname='ddname ,
                                   ||';rc='rc
   end

   say 'exiting exec with rc=12'
   exit 12

/* --------                                                    */
   startUp: /* start of pgm... skipped error routine "syntax:" */
/* --------                                                    */

arg theargs
say 'called with args: "'strip(theArgs)'"'
pendingRc = 0
if wordpos('WARN',theargs) * wordpos('NOWARN',theargs) > 0
then do
   say 'syntax illegal, cannot have both "WARN" and "NOWARN"'
   pendingrc = 8
end
if wordpos('GENERIC',theargs) * wordpos('NOGENERIC',theargs) > 0
then do
   say 'syntax illegal, cannot have both "GENERIC" and "NOGENERIC"'
   pendingrc = 8
end
if wordpos('SQL',theargs) * wordpos('NOSQL',theargs) > 0
then do
   say 'syntax illegal, cannot have both "SQL" and "NOSQL"'
   pendingrc = 8
end
if wordpos('SLIMADM',theargs) * wordpos('NOSLIMADM',theargs) > 0
then do
   say 'syntax illegal, cannot have both "SlimAdm" and "NoSlimAdm"'
   pendingrc = 8
end

/* change-06/06/2023 add PE/noPE option */
if wordpos('PE',theargs) * wordpos('NOPE',theargs) > 0
then do
   say 'syntax illegal, cannot have both "PE" and "noPE" options'
   pendingrc = 8
end

/* change-08/15/2023 add RESET/noRESET option */
if wordpos('RESET',theargs) * wordpos('NORESET',theargs) > 0
then do
   say 'syntax illegal, cannot have both "RESET" and "noRESET" options'
   pendingrc = 8
end

if pendingrc = 8
then do
   say 'due to parm error, exiting now with rc=8'
   exit 8
end

optionsSpecified = 0
if wordpos('WARN',theargs) > 0
then do
   say 'RDEF''s and RALT''s will have the "WARNING" option'
   optionWarn = 'WARNING'
   /* remove (default) option */
   x = wordpos('WARN',theargs)
   if x = 1
   then theArgs = subword(theArgs,2)
   else theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   optionsSpecified = 1
end
else do
   optionWarn = '' /*default, no warning option */
   say 'NOWARN (default) in effect'
   if wordpos('NOWARN',theArgs) = 'NOWARN'
   then do
      /* remove (default) option */
      x = wordpos('NOWARN',theargs)
      if x = 1
      then theArgs = subword(theArgs,2)
      else theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
      optionsSpecified = 1
   end
end

genericOption = 'GENERIC' /* by default, we turn on generic option*/
if wordpos('NOGENERIC',theargs) > 0
then do
   genericOption = ''
   say 'NOGENERIC is in effect, only explicit rules will be created'
   /* remove (default) option */
   x = wordpos('NOGENERIC',theargs)
   if x = 1
   then theArgs = subword(theArgs,2)
   else theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   optionsSpecified = 1
end
else if wordpos('NOGENERICNOAUDIT',theargs) > 0
then do
   genericOption = 'GENERICNOAUDIT'
   say 'GENERICNOAUDIT is in effect, generic RDEF(s) for tables' ,
      'may be created, but AUDIT on tables is ignored'
   /* remove (default) option */
   x = wordpos('GENERICNOAUDIT',theargs)
   if x = 1
   then theArgs = subword(theArgs,2)
   else theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   optionsSpecified = 1
end
else do
   say 'GENERIC option in effect; to help simply rules'
   if wordpos('GENERIC',theArgs) > 0
   then do
      /* remove (default) option from args */
      x = wordpos('GENERIC',theargs)
      if x = 1
      then theArgs = subword(theArgs,2)
      else theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
      optionsSpecified = 1
   end
end

slimAdm = 1 /* by default turn on SLIMADM */
if wordpos('NOSLIMADM',theargs) > 0
then do
   slimAdm = 0
   say 'NoSlimAdm is in effect, will generate all permits for SYSADM'
   /* remove (default) option */
   x = wordpos('NOSLIMADM',theargs)
   if x = 1
   then theArgs = subword(theArgs,2)
   else theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   optionsSpecified = 1
end
else do
   say 'SlimAdm option in effect; to help simply rules'
   if wordpos('SLIMADM',theArgs) > 0
   then do
      /* remove (default) option from args */
      x = wordpos('SLIMADM',theargs)
      if x = 1
      then theArgs = subword(theArgs,2)
      else theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
      optionsSpecified = 1
   end
end

SqlOption = 'NOSQL'       /* by default, we turn off SQL option */
if wordpos('NOSQL',theargs) > 0
then do
   SqlOption = 'NOSQL'
   /* remove (default) option */
   x = wordpos('NOSQL',theargs)
   if x = 1
   then theArgs = subword(theArgs,2)
   else theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   optionsSpecified = 1
end
if wordpos('SQL',theargs) > 0
then do
   SqlOption = 'SQL'
   /* remove (default) option */
   x = wordpos('SQL',theargs)
   if x = 1
   then theArgs = subword(theArgs,2)
   else theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   optionsSpecified = 1
end
if SqlOption = 'SQL'
then say 'SQL option in effect; we will output SQL as comments'

/* change-06/06/2023 add PE/noPE option */
peOption = 'NOPE'        /* by default, we turn off PE option */
if wordpos('NOPE',theargs) > 0
then do
   peOption = 'NOPE'
   /* remove (default) option */
   x = wordpos('NOPE',theargs)
   if x = 1
   then theArgs = subword(theArgs,2)
   else theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   optionsSpecified = 1
end
if wordpos('PE',theargs) > 0
then do
   peOption = 'PE'
   /* remove (default) option */
   x = wordpos('PE',theargs)
   if x = 1
   then theArgs = subword(theArgs,2)
   else theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   optionsSpecified = 1
end
if peOption = 'PE'
then say 'PE option in effect; we will keep PERMITs and RDEFs seperate'
else say 'noPE option in effect; RDEF files will have RDEFS + permits'

/* change-08/15/2023 add RESET/noRESET option */
resetOption = 'NORESET'   /* by default, we turn off RESET option */
if wordpos('NORESET',theargs) > 0
then do
   resetOption = 'NORESET'
   /* remove (default) option */
   x = wordpos('NORESET',theargs)
   if x = 1
   then theArgs = subword(theArgs,2)
   else theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   optionsSpecified = 1
end
if wordpos('RESET',theargs) > 0
then do
   resetOption = 'RESET'
   /* remove (default) option */
   x = wordpos('RESET',theargs)
   if x = 1
   then theArgs = subword(theArgs,2)
   else theArgs = subword(theArgs,1,x-1) subword(theArgs,x+1)
   optionsSpecified = 1
end
if resetOption = 'RESET'
then say 'RESET option in effect; we will remove existing permits first'
else say 'noRESET option in effect; we will keep existing permits'

if optionsSpecified = 1
then do
   say 'args after removing options are'
   say '  "'strip(theArgs)'"'
   say ' '
end

/* Arg owner ssid classmnt model charopt . */
parse var TheArgs owner ssid classmnt model charopt .

/* use defaults for some values */
/* ---------------------------- */
if classmnt = '' then classmnt = 'DSN'
if model = ''    then model    = '2'
if classmnt = 'DSN' & model = 2 then charopt = ''

/* verification */
if owner = '' | length(owner) > 8 | ssid = '' | length(ssid) > 4
then do
   say 'parameter error, the owner and ssid are required parms'
   say '  and owner must be a 1=8 character userid or group name'
   say 'Owner specified as "'owner'"'
   say 'ssid  specified as "'ssid'"'
   exit 8
end
else do
   say 'Owner specified as "'owner'"'
   say 'ssid  specified as "'ssid'"'
end

if classmnt <> '' & length(classmnt) > 4
then do
   say ' '
   say 'classmnt specified as "'classmnt'" but cannot be > 4 chars'
   say 'classmnt you specify should match that specified in'
   say '   the racf exit code in DSNXRXAC.'
   say 'Note:  Default classmnt in DSNXRXAC is "DSN"'
   exit 8
end
else do
   say ' '
   say 'classmnt specified as "'classmnt'"'
   say 'classmnt you specify should match that specified in'
   say '   the racf exit code in DSNXRXAC.'
   say 'Note:  Default classmnt in DSNXRXAC is "DSN"'
end

if model = '' | model = '1' | model = '2'
then do
   say ' '
   say 'Model specified as "'model'"'
   say 'Model value you specifiy should match that specified in'
   say '   the racf exit code in DSNXRXAC.'
   say 'Note:  Default DSNXRXAC model is 2'
end
else do
   say ' '
   say 'parameter error, model specified as "'model'" but only 1 or 2',
       'is a valid value'
   say 'Model value you specifiy should match that specified in'
   say '   the racf exit code in DSNXRXAC.'
   say 'Note:  Default DSNXRXAC model is 2'
   exit 8
end

if classmnt = 'DSN' & model = 2
then do
   charopt = '' /*charopt not used by racf exit in this case */
   say ' '
   say "as classmnt='DSN' and model=2, charopt is set to null"
   say 'and ignored, just like what happens in racf exit'
   say 'when using those settings.'
end
else if length(charopt) = 1     ,
      & pos(charopt,'0123456789$@#') > 0
then do
   say ' '
   say 'charopt option specified as "'charopt'"'
   say 'Note:  must match the value you will specify in DSNXRXAC'
   say ' '
end
else do
   say ' '
   say 'charopt option specified as "'charopt'"'
   say 'but it must be one character long and be 0-9,#,$ or @ only'
   say 'and it must match the value you will specify in DSNXRXAC'
   exit 8
end

  /* Set addressability to DB2 Rexx function */
ADDRESS TSO "SUBCOM DSNREXX"
If RC = 1 Then S_RC = RXSUBCOM('ADD','DSNREXX','DSNREXX')
Else Do
  Say 'Can not access DB2 Rexx Function.  Ending...'
  Exit
End


  /* Get RACF information, so that we know (a lot), about the */
  /*    1) real users, that are currently active              */
  /*    2) real users, but that are revoked.                  */
  /*    3) users/groups that no longer exist.                 */
  /*    4) groups (and their members)                         */
  /* and write information out for our information.           */
  /* -------------------------------------------------------- */
call processRACFdata

address 'TSO'
address dsnrexx "CONNECT "ssid

   /* create exclude list */
   /* ------------------- */
exclude. = 0 /* default, don't exclude anyone */
exclude  = 0 /* list of userid's to exclude */
excludeIndx. = 0 /* default, don't exclude anyone */
replace.     = ''/* default, replace group */
deleteId.    = 0 /* default, don't delete anyone */
 /* DB2ENGNR is a sysadm with these userids ??? */
address 'TSO' 'EXECIO * DISKR EXCLIST (OPEN FINIS STEM EXCLIST.'
if rc <> 0
then exclist.0 = 0

   /* create grantee case */
   /* ------------------- */
granteeCase = 'case'
commaParen = '('
RemoveUserList = ''
do exclist = 1 by 1 for exclist.0
   parse var exclist.exclist word1 .
   if word1 = '' then iterate
   if left(word1,1) = '*' | left(word1,2) = '/*' then iterate

   /* addexclude, will also add to the granteeCase variable */
   x = addExclude(strip(exclist.exclist))

   /* examples:
     x = addExclude('SFR609  *DELETE') /* exclude list: delete SFR609 */
     x = addExclude('KEA406  DWS000MT') /*exclude list: replace KEA406*/
   */
end

if granteeCase = 'case'
then granteeCase = 'strip(upper(a.grantee)) as grantee'
else do
   granteeCase = granteeCase 'else strip(upper(a.grantee))'
   granteeCase = granteeCase 'end as grantee'
end

if RemoveUserList = ''
then nop
else RemoveUserList = RemoveUserList ')' /* end with right paren */

say ' '
say '  We will use the "removeUserList" variable, if non-blank '
say '  to ignore db2 grants to those userids in our SQL.'
say 'removeUserList="'removeUserList'"'
say ' '

   /* Set basic header */
hdr.0 = 6
hdr.1 = "/* DB2 to RACF conversion CLIST */"
hdr.2 = "/* input agruments              */"
hdr.3 = "/*     owner = '"owner"', ssid = '"ssid"'        */"
hdr.4 = "/*     classmnt = '"classmnt"', model='"model"'  */"
hdr.5 = "/*     charopt ='"charopt"'        */"
hdr.6 = "/* date="DATE() "time=" TIME() "*/"
hdr.7 = " "
do ii =1 by 1 for exclude
   hdr = ii + 7
   hdr.hdr = '  /* exclude userid: ' exclude.ii '*/'
end

openDDs = 0

/* resource definition output files */
/* -------------------------------- */
rdefClass =''; rdefDDname = 'RDEFMISC' /*default unknown rdefs */
rdefIndx. =rdefDDname /* default for unknown rdef class */
bufferRecs.rdefDDname = 0               /* lines in buffer */
openDDs = openDDs + 1; openDDs.openDDs = RdefDDname /* open DD names*/
Address TSO "EXECIO * DISKW" rdefDDname "(STEM hdr."

rdefClass ='DSNADM'; rdefDDname = 'RDEFADM'
RDEFIndx.rdefClass = rdefDDname
bufferRecs.rdefDDname = 0               /* lines in buffer */
openDDs = openDDs + 1; openDDs.openDDs = RdefDDname /* open DD names*/
Address TSO "EXECIO * DISKW" rdefDDname "(STEM HDR."

rdefClass ='MDSNCL'; rdefDDname = 'RDEFCL'
RDEFIndx.rdefClass = rdefDDname
bufferRecs.rdefDDname = 0               /* lines in buffer */
openDDs = openDDs + 1; openDDs.openDDs = RdefDDname /* open DD names*/
Address TSO "EXECIO * DISKW" rdefDDname "(STEM HDR."

rdefClass ='MDSNDB'; rdefDDname = 'RDEFDB'
RDEFIndx.rdefClass = rdefDDname
bufferRecs.rdefDDname = 0                   /* lines in buffer */
openDDs = openDDs + 1; openDDs.openDDs = RdefDDname /* open DD names*/
Address TSO "EXECIO * DISKW" rdefDDname "(STEM HDR."

rdefClass ='MDSNPK'; rdefDDname = 'RDEFPK'
RDEFIndx.rdefClass = rdefDDname
bufferRecs.rdefDDname = 0                   /* lines in buffer */
openDDs = openDDs + 1; openDDs.openDDs = RdefDDname /* open DD names*/
Address TSO "EXECIO * DISKW" rdefDDname "(STEM HDR."

rdefClass ='MDSNPN'; rdefDDname = 'RDEFPN'
RDEFIndx.rdefClass = rdefDDname
bufferRecs.rdefDDname = 0                   /* lines in buffer */
openDDs = openDDs + 1; openDDs.openDDs = RdefDDname /* open DD names*/
Address TSO "EXECIO * DISKW" rdefDDname "(STEM HDR."

rdefClass ='MDSNTB'; rdefDDname = 'RDEFTB'
RDEFIndx.rdefClass = rdefDDname
bufferRecs.rdefDDname = 0                   /* lines in buffer */
openDDs = openDDs + 1; openDDs.openDDs = RdefDDname /* open DD names*/
Address TSO "EXECIO * DISKW" rdefDDname "(STEM HDR."

rdefClass ='MDSNTS'; rdefDDname = 'RDEFTS'
RDEFIndx.rdefClass = rdefDDname
bufferRecs.rdefDDname = 0                   /* lines in buffer */
openDDs = openDDs + 1; openDDs.openDDs = RdefDDname /* open DD names*/
Address TSO "EXECIO * DISKW" rdefDDname "(STEM HDR."


/* resource permit     output files */
/* -------------------------------- */
pe$Class =''; pe$DDname = 'PE$MISC' /*default unknown permits */
pe$Indx. =pe$DDname /* default for unknown pe$ class */
bufferRecs.pe$DDname = 0                    /* lines in buffer */
openDDs = openDDs + 1; openDDs.openDDs = pe$DDname /* open DD names*/
Address TSO "EXECIO * DISKW" pe$DDname "(STEM hdr."

pe$Class ='DSNADM'; pe$DDname = 'PE$ADM'
pe$Indx.pe$Class = pe$DDname
bufferRecs.pe$DDname = 0                    /* lines in buffer */
openDDs = openDDs + 1; openDDs.openDDs = pe$DDname /* open DD names*/
Address TSO "EXECIO * DISKW" pe$DDname "(STEM HDR."

pe$Class ='MDSNCL'; pe$DDname = 'PE$CL'
pe$Indx.pe$Class = pe$DDname
bufferRecs.pe$DDname = 0                    /* lines in buffer */
openDDs = openDDs + 1; openDDs.openDDs = pe$DDname /* open DD names*/
Address TSO "EXECIO * DISKW" pe$DDname "(STEM HDR."

pe$Class ='MDSNDB'; pe$DDname = 'PE$DB'
pe$Indx.pe$Class = pe$DDname
bufferRecs.pe$DDname = 0                    /* lines in buffer */
openDDs = openDDs + 1; openDDs.openDDs = pe$DDname /* open DD names*/
Address TSO "EXECIO * DISKW" pe$DDname "(STEM HDR."

pe$Class ='MDSNPK'; pe$DDname = 'PE$PK'
pe$Indx.pe$Class = pe$DDname
bufferRecs.pe$DDname = 0                    /* lines in buffer */
openDDs = openDDs + 1; openDDs.openDDs = pe$DDname /* open DD names*/
Address TSO "EXECIO * DISKW" pe$DDname "(STEM HDR."

pe$Class ='MDSNPN'; pe$DDname = 'PE$PN'
pe$Indx.pe$Class = pe$DDname
bufferRecs.pe$DDname = 0                    /* lines in buffer */
openDDs = openDDs + 1; openDDs.openDDs = pe$DDname /* open DD names*/
Address TSO "EXECIO * DISKW" pe$DDname "(STEM HDR."

pe$Class ='MDSNTB'; pe$DDname = 'PE$TB'
pe$Indx.pe$Class = pe$DDname
bufferRecs.pe$DDname = 0                    /* lines in buffer */
openDDs = openDDs + 1; openDDs.openDDs = pe$DDname /* open DD names*/
Address TSO "EXECIO * DISKW" pe$DDname "(STEM HDR."

pe$Class ='MDSNTS'; pe$DDname = 'PE$TS'
pe$Indx.pe$Class = pe$DDname
bufferRecs.pe$DDname = 0                    /* lines in buffer */
openDDs = openDDs + 1; openDDs.openDDs = pe$DDname /* open DD names*/
Address TSO "EXECIO * DISKW" pe$DDname "(STEM HDR."

   /* Set Optional header (relies on hdr. above) */
hdr.1 = "/* Optional DB2 to RACF conversion CLIST */"
Address TSO "EXECIO * DISKW OPTCLST (STEM hdr."

uid      = 0 /* number of unique userids */
uidIndx. = 0 /* index to userids         */
classList= 0 /* number of unique classes; classlist.# = class */
ClassIndx.=0 /* to keep classList unique */
PermitsByClass. = 0 /* permitsByClass.class#.uid# = count */

clistx   = 0 /*      buffer CLIST   output */
optclstx = 0 /* also buffer OPTCLST output */
If owner="" Then Do
  Say "Owner must be specified"
  Exit
End
If ssid="" Then Do
  Say "SSID must be specified"
  Exit
End

/* ----------------                                       */
/* ----------------                                       */
   End_of_startup:
/* ----------------                                       */
/* ----------------                                       */
/*                                                        */
/*            1. options parsed.                          */
/*            2. racf database input, if any, parsed.     */
/*            3. ddname EXCLIST input read and parsed.    */
/*            4. output files opened                      */

/* ----------------------- */
/* ----------------------- */
   DB2_to_RACF_conversion:
/* ----------------------- */
/* ----------------------- */
/*                                                        */
/*   begin calling routines to read db2 auth tables       */
/*      and have them create necessary RDEFs, RALTs       */
/*      and/or permits.                                   */
/*                                                        */

/* set 'adminClass' to appropriate RACF class */
/* ------------------------------------------ */
If classmnt="" Then classmnt="DSN"
If model="" Then model=2

   /* Set class based on 'Classification Model' */
   /* If an invalid model, we default to II     */
If model=1 Then class=ssid"ADM"charopt
Else class=classmnt"ADM"charopt

adminClass = class

  /*---------------------------------------------------*/
  /* Start processing DB2 authorization tables         */
  /*---------------------------------------------------*/
xsysadmIndx. = 0
xsysadm      = 0
  /* adm privs:   class "DSNADM" */
  /* --------------------------- */
class = adminClass
call sys_attr "SYSADM","SYSADMAUTH"
call sys_attr "SYSOPR","SYSOPRAUTH"
call sys_attr "SYSCTRL","SYSCTRLAUTH"
call sys_attr "SYSDBADM","SDBADMAUTH" /* rich Humphris:  add auth*/
call sys_attr "DATAACCESS","DATAACCESSAUTH"/*r Humphris:  add auth*/
call sys_attr "ACCESSCTRL","ACCESSCTRLAUTH"/*r Humphris:  add auth*/

class = adminClass
call db_attr "DBADM","DBADMAUTH"

/* call db_option  ... call removed; racf fixed this problem */
/* --------------      ------------                          */

class = adminClass
call db_attr "DBMAINT","DBMAINTAUTH"
call db_attr "DBCTRL","DBCTRLAUTH"
class = adminClass
call packadm_attr "PACKADM"

   /* Schema   privileges;  rh:  add schema privs class "SC" */
   /* ------------------------------------------------------ */
/* schema_attr changes "class" */
call schema_attr "ALTERIN","ALTERINAUTH"    /* RH: add auth */
call schema_attr "CREATEIN","CREATEINAUTH"  /* RH: add auth */
call schema_attr "DROPIN","DROPINAUTH"      /* RH: add auth */

   /* Resource privileges class "SM" */
   /* ------------------------------ */
                                              /* RH: add auth */
If model=1 Then class="M"ssid"SM"charopt
Else class="M"classmnt"SM"charopt

/* sys_attr and bindagent use "SM" class (see above) */
call sys_attr "ARCHIVE","ARCHIVEAUTH"
call sys_attr "BINDADD","BINDADDAUTH"
call bindagent
call sys_attr "CREATEALIAS","CREATEALIASAUTH"
call sys_attr "CREATEDBA","CREATEDBAAUTH"
call sys_attr "CREATEDBC","CREATEDBCAUTH"
call sys_attr "CREATESG","CREATESGAUTH"
call sys_attr "DISPLAY","DISPLAYAUTH"
call sys_attr "MONITOR1","MON1AUTH"
call sys_attr "MONITOR2","MON2AUTH"
call sys_attr "RECOVER","RECOVERAUTH"
call sys_attr "STOPALL","STOPALLAUTH"
call sys_attr "STOSPACE","STOSPACEAUTH"
call sys_attr "SQLADM","SQLADMAUTH"           /* RH: add auth */
call sys_attr "TRACE","TRACEAUTH"
call sys_attr "CREATETMTAB","CREATETMTABAUTH"
call sys_attr "CREATESECUREOBJECT","CREATESECUREAUTH"/* RH: add auth */
call sys_attr "DEBUGSESSION","DEBUGSESSIONAUTH"/* RH: add auth */
call sys_attr "EXPLAIN","EXPLAINAUTH"        /* RH: add auth */
call sys_attr "BSDS","BSDSAUTH"              /* RH: add auth */

   /* collect data on Table privileges class "TB" */
   /* ------------------------------------------- */

/* table privs set class for "TB" (see routines below) */
call tab_priv "INIT","INIT"
call tab_priv "ALTER","ALTERAUTH"
call tab_priv "DELETE","DELETEAUTH"
call tab_priv "INDEX","INDEXAUTH"
call tab_priv "INSERT","INSERTAUTH"
call tab_priv "SELECT","SELECTAUTH"
call tab_priv "UPDATE","UPDATEAUTH"
call tab_priv "REFERENCES","REFERENCESAUTH"
call tab_priv "VIEW_INSERT","INSERTAUTH"
call tab_priv "VIEW_UPDATE","UPDATEAUTH"
call tab_priv "VIEW_DELETE","DELETEAUTH"

call tab_col  "REFERENCES"                  /* column reference priv*/

call tab_col  "UPDATECOLS"                  /* column update privs */

call tab_priv "TRIGGER","TRIGGERAUTH"    /* add new table priv */
call tab_priv "UNLOAD","UNLOADAUTH"      /* add new table priv */


   /* Database privileges class "DB" */
   /* ------------------------------ */
/* database privs set class for "DB" (see routines below) */
call def_priv "DB","CREATETAB","CREATETABAUTH","DB"
call def_priv "DB","CREATETS","CREATETSAUTH","DB"
call def_priv "DB","DISPLAYDB","DISPLAYDBAUTH","DB"
call def_priv "DB","DROP","DROPAUTH","DB"
call def_priv "DB","IMAGCOPY","IMAGCOPYAUTH","DB"
call def_priv "DB","LOAD","LOADAUTH","DB"
call def_priv "DB","REORG","REORGAUTH","DB"
call def_priv "DB","RECOVERDB","RECOVERDBAUTH","DB"
call def_priv "DB","REPAIR","REPAIRAUTH","DB"
call def_priv "DB","STARTDB","STARTDBAUTH","DB"
call def_priv "DB","STATS","STATSAUTH","DB"
call def_priv "DB","STOPDB","STOPAUTH","DB"

   /* Plan privileges */
/* plan privs set class for "PN" (see routines below) */
call def_priv "PN","BIND","BINDAUTH","PLAN"
call def_priv "PN","EXECUTE","EXECUTEAUTH","PLAN"

   /* Package privileges */
/* package privs set class for "PK" (see routines below) */
call pack_priv "BIND","BINDAUTH"
say 'pack_priv "BIND","BINDAUTH" ended at' time()
call pack_priv "EXECUTE","EXECUTEAUTH"
say 'pack_priv "EXECUTE","EXECUTEAUTH" ended at' time()
call pack_priv "COPY","COPYAUTH"
say 'pack_priv "COPY","COPYAUTH" ended at' time()

   /* Collection privileges */
/* collection privs set class for "CL" (see routines below) */
call cltn_priv "CREATEIN"

   /* Use BUFFERPOOL/STOGROUP/TABLESPACE privileges */
   /* Use jar and distinct type          privileges */

/* bp privs set class for "BP" (see routine below) */
call BP_use_priv "USE","B","BP"   /* Buffer Pool   */

/* storage group privs set class for "SG" (see routine below) */
call use_priv "USE","S","SG"   /* storage group */

/* TS privs set class for "TS" (see routine below) */
call use_priv "USE","R","TS"   /* tablespace */

/* JR privs set class for "JR" (see routine below) */
call use_priv "USAGE","J","JR" /* jar */

/* UT privs set class for "UT" (see routine below) */
call use_priv "USAGE","D","UT" /* distinct type */

   /* global variables    class "GV" */
   /* ------------------------------ */
                                              /* RH: add auth */
If model=1 Then class="M"ssid"GV"charopt
Else class="M"classmnt"GV"charopt

/* GV privs set class for "GV" (see routine below) */
call gv_attr "READ","READAUTH"    /* global variable/sysvariableauth*/
call gv_attr "WRITE","WRITEAUTH"  /* global variable/sysvariableauth*/

   /* syssequenceauth     class "GV" */
   /* ------------------------------ */
                                              /* RH: add auth */
If model=1 Then class="M"ssid"SQ"charopt
Else class="M"classmnt"SQ"charopt

/* SQ privs set class for "SQ" (see routine below) */
call seq_attr "ALTER","ALTERAUTH" /* seq priv/syssequenceauth*/
call seq_attr "USAGE","USEAUTH"   /* seq priv/syssequenceauth*/

   /* sysroutineauth     class "SP" */
   /* sysroutineauth     class "UF" */
   /* ------------------------------ */
                                              /* RH: add auth */
If model=1 Then class="M"ssid"SP"charopt
Else class="M"classmnt"SP"charopt

/* SP privs set class for "SP" (see routine below) */
call routine_attr "EXECUTE","EXECUTEAUTH","P" /*stored procedure */

If model=1 Then class="M"ssid"UF"charopt
Else class="M"classmnt"UF"charopt

/* UF privs set class for "UF" (see routine below) */
call routine_attr "EXECUTE","EXECUTEAUTH","F" /*user defined function*/

/* close open files */
/* ---------------- */
do i = 1 by 1 for openDDs
   ddname = openDDs.i
   address 'TSO' "EXECIO" bufferRecs.ddname ,
                    "DISKW" ddname '(FINIS STEM BUFFERX.'ddname'.'
   if rc <> 0
   then do
      say 'error closing/writting to ddname='ddname'; rc='rc
      say 'will exit with rc=8'
      pendingRc = 8
   end
end

/* userid's found were */
say 'userid''s we created racf cmds for were:'
optclstx = optclstx + 1
optclstx.optclstx = '   '
optclstx = optclstx + 1
optclstx.optclstx = ' /* userid''s we created racf cmds for were: */'
optclstx = optclstx + 1
optclstx.optclstx = '    /* userid''s in RACF database were:       */'
do ii = 1 by 1 for uid
   xxx = uid.ii
   if useridIndx.xxx = 0 /* if useridIndx is zero... */
   then iterate          /* ...must be a group, iterate */
   if excludeIndx.xxx > 0 /* if excluded, */
   then iterate           /* ...iterate      */

   uidx  = useridIndx.xxx
   if revoked.uidx <> 'No' /* if revoked */
   then iterate            /* ...iterate    */
   if revoked.uidx =  '?'  /* unknown?       */
   then iterate           /* ...iterate     */
   comm = userGroupInfo(xxx) /* Normal userid, give info */
   optclstx = optclstx + 1
   optclstx.optclstx = '   /* 'left(uid.ii,8) left(comm,70) '*/'
end
do ii = 1 by 1 for uid
   xxx = uid.ii
   if useridIndx.xxx = 0 /* if useridIndx is zero... */
   then iterate          /* must be a group, iterate */
   if excludeIndx.xxx > 0 /* if excluded, */
   then iterate           /* ...iterate      */

   uidx  = useridIndx.xxx
   if revoked.uidx =  'No' /* if not revoked */
   then iterate            /* ...iterate     */
   if revoked.uidx =  '?'  /* unknown?       */
   then iterate            /* ...iterate     */
   comm = userGroupInfo(xxx) /* Revoked userid, give info */
   optclstx = optclstx + 1
   optclstx.optclstx = '   /* 'left(uid.ii,8) left(comm,70) '*/'
end
optclstx = optclstx + 1
optclstx.optclstx = '    /* userid''s in RACF database but excluded: */'
do ii = 1 by 1 for uid
   xxx = uid.ii
   if useridIndx.xxx = 0 /* if useridIndx is zero... */
   then iterate          /* must be a group, iterate */
   if excludeIndx.xxx = 0 /* if not excluded, */
   then iterate           /* ...iterate       */

   uidx  = useridIndx.xxx
   if revoked.uidx <> 'No' /* if revoked */
   then iterate            /* ...iterate     */
   if revoked.uidx =  '?'  /* unknown?       */
   then iterate            /* ...iterate     */
   comm = userGroupInfo(xxx) /* excluded, not revoked, give info */
   optclstx = optclstx + 1
   optclstx.optclstx = '   /* 'left(uid.ii,8) left(comm,70) '*/'
end
do ii = 1 by 1 for uid
   xxx = uid.ii
   if useridIndx.xxx = 0 /* if useridIndx is zero... */
   then iterate          /* must be a group, iterate */
   if excludeIndx.xxx = 0 /* if not excluded, */
   then iterate           /* ...iterate       */

   uidx  = useridIndx.xxx
   if revoked.uidx=  'No' /* if NOT revoked */
   then iterate           /* ...iterate     */
   if revoked.uidx=  '?'  /* unknown?       */
   then iterate           /* ...iterate     */
   comm = userGroupInfo(xxx) /* excluded, Revoked userid, give info */
   optclstx = optclstx + 1
   optclstx.optclstx = '   /* 'left(uid.ii,8) left(comm,70) '*/'
end
do ii = 1 by 1 for uid
   xxx = uid.ii
   if useridIndx.xxx = 0 /* if useridIndx is zero... */
   then iterate          /* must be a group, iterate */
   if excludeIndx.xxx = 0 /* if not excluded, */
   then iterate           /* ...iterate       */

   uidx  = useridIndx.xxx
   if revoked.uidx<> '?'  /* unknown?       */
   then iterate           /* ...iterate     */
   comm = userGroupInfo(xxx) /* excluded, Revoked userid, give info */
   optclstx = optclstx + 1
   optclstx.optclstx = '   /* 'left(uid.ii,8) left(comm,70) '*/'
end
optclstx = optclstx + 1
optclstx.optclstx = ' '
optclstx = optclstx + 1
optclstx.optclstx = '    /* unknown userids */'
do ii = 1 by 1 for uid
   xxx = uid.ii
   if useridIndx.xxx = 0 /* if useridIndx is zero... */
   then iterate          /* must be a group, iterate */
   if excludeIndx.xxx = 1 /* if excluded, */
   then iterate           /* ...iterate   */

   uidx  = useridIndx.xxx
   if revoked.uidx<> '?'
   then iterate
   comm = userGroupInfo(xxx)
   optclstx = optclstx + 1
   optclstx.optclstx = '   /* 'left(uid.ii,8) left(comm,70) '*/'
end
optclstx = optclstx + 1
optclstx.optclstx = ' '
optclstx = optclstx + 1
optclstx.optclstx = '    /* groups used */'
do ii = 1 by 1 for uid
   xxx = uid.ii
   if useridIndx.xxx <> 0 /* if useridIndx is nonzero... */
   then iterate           /* must be a userid, iterate */

   comm = userGroupInfo(xxx) /* get group info, and output*/
   optclstx = optclstx + 1
   optclstx.optclstx = '   /* 'left(xxx,8) left(comm,70) '*/'

   /* set up to look at group membership */
   gix = groupIndx.xxx  /* get the index to group info */
   members = groupMembers.gix
   gstatus = groupMembersStatus.gix
   if members <> ''
   then do
      optclstx = optclstx + 1
      optclstx.optclstx = '     /* ---members of group are--- */'
   end
   do while members <> ''
      /* output membership details */
      parse var members member members /* strip off a member*/
      parse var gstatus stat   gstatus /* and a status */
      comm = userGroupInfo(member)
      optclstx = optclstx + 1
      if stat = 'No' | stat = '?'
      then optclstx.optclstx = '     /* 'left(member,8)'; 'comm '*/'
      else optclstx.optclstx = '     /* 'left(member,8) ,
                           'GroupRevokeStatus=' || stat'; 'comm' */'
   end
end
optclstx = optclstx + 1
optclstx.optclstx = ' '
optclstx = optclstx + 1
optclstx.optclstx = '    /* permits by class/userid */'

maxUidLength = 0
do uidNum = 1 by 1 for uid
   if length(uid.uidNum) > maxUidLength
   then maxUidLength = length(uid.uidNum)
end

do classnum = 1 by 1 for classList
   optclstx = optclstx + 1
   optclstx.optclstx = ' '
   optclstx = optclstx + 1
   optclstx.optclstx = '      /* permits by class='classlist.classnum ,
                       ' */'
   do uidnum = 1 by 1 for uid
      if permitsByClass.classnum.uidnum = 0 then iterate
      comm = userGroupInfo(uid.uidnum)
      optclstx = optclstx + 1
      optclstx.optclstx = format(permitsByClass.classnum.uidnum,8,0) ,
                          classlist.classnum '/' ,
                          left(uid.uidnum,maxUidLength) ,
                          left(comm,80)
      if optclstx > 100
      then do
         Address TSO "EXECIO" optClstx "DISKW OPTCLST (STEM OPTCLSTX."
         if rc <> 0
         then do
            say 'error writing/closing ddname=OPTCLST; rc='rc
            say 'will exit with rc=8'
            pendingRc = 8
         end
         optclstx = 0
      end
   end
end

/* add information about table permits that were ignored */
/* ----------------------------------------------------- */
optClstx = optclstx + 1
optCLstx.optClstx = ' '

optClstx = optclstx + 1
optCLstx.optClstx = ' users whose table permit access was ignored' ,
                    'because either:'
optClstx = optclstx + 1
optCLstx.optClstx = ' -------------------------------------------' ,
                 || '----------------'

optClstx = optclstx + 1
optCLstx.optClstx = '    1) the grantee wasn''t a owner of a package'

optClstx = optclstx + 1
optCLstx.optClstx = ' or 2) the grantee wasn''t a RACF current(valid)',
                    'userid'

optClstx = optclstx + 1
optCLstx.optClstx = ' or 3) the grantee wasn''t a RACF groupid'
optClstx = optclstx + 1
optCLstx.optClstx = ' -------------------------------------------' ,
                 || '----------------'
if ignoredTableGranteeList = ''
then do
   optClstX = optClstx + 1
   optClstx.optclstx = '***none found***'
end
else do
   do while ignoredTableGranteeList <> ''
      parse var ignoredTableGranteeList nextG ignoredTableGranteeList
      optClstX = optclstx + 1
      optClstx.optClstx = nextg 'ignored;' ignoredTableGrantee.nextg ,
                      'table permits not needed (insert, update, etc)'

      if optclstx > 100
      then do
         Address TSO "EXECIO" optClstx "DISKW OPTCLST (STEM OPTCLSTX."
         if rc <> 0
         then do
            say 'error writing/closing ddname=OPTCLST; rc='rc
            say 'will exit with rc=8'
            pendingRc = 8
         end
         optclstx = 0
      end
   end
end


/* add information about missing package owner userid/groups */
/* --------------------------------------------------------- */
optClstx = optclstx + 1
optCLstx.optClstx = ' '

optClstx = optclstx + 1
optCLstx.optClstx = ' package owner''s who are missing a racf'     ,
                    'userid and/or group; but have table permits'
optClstx = optclstx + 1
optCLstx.optClstx = ' ---------------------------------------' ,
                 || '-------------------------------------------'

if packageTableGranteeList = ''
then do
   optClstX = optClstx + 1
   optClstx.optclstx = '***none found***'
end
else do
   do while packageTableGranteeList <> ''
      parse var packageTableGranteeList nextG packageTableGranteeList
      optClstX = optclstx + 1
      optClstx.optClstx = nextg 'which needs racf userid/group id'

      if optclstx > 100
      then do
         Address TSO "EXECIO" optClstx "DISKW OPTCLST (STEM OPTCLSTX."
         if rc <> 0
         then do
            say 'error writing/closing ddname=OPTCLST; rc='rc
            say 'will exit with rc=8'
            pendingRc = 8
         end
         optclstx = 0
      end
   end
end

say ' '
Address TSO "EXECIO" optClstx "DISKW OPTCLST (FINIS STEM OPTCLSTX."
if rc <> 0
then do
   say 'error writing/closing ddname=OPTCLST; rc='rc
   say 'will exit with rc=8'
   pendingRc = 8
end

address dsnrexx "DISCONNECT"
/* Exit program here */
/* ----------------- */
Exit pendingRc

/* subroutines follow */
/* ------------------ */
schema_attr:
  Arg auth,col
  If model=1 Then class="M"ssid'SC'||charopt
  Else class="M"classmnt||'SC'||charopt

  extra = ''      /* default */
  dbowner = owner /* default */

  Rdef$Permit = 'RDEF' /* all output to rdef datasets */
                       /* --------------------------- */
  useClass = class

  /* create "backstop" so that everything else is rejected */
  /* ----------------------------------------------------- */
  cmd='/* create backstop RDEF (in schema_attr: routine) */'
  x = clistCard(cmd)

  If model=1 Then prof='*.'auth
  Else prof=ssid'.*.'auth

  extra = "DATA('"auth "for ssid("ssid") backstop schema(*)')"
  prof = left(prof,max(24,length(prof)))
  cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
      "OWNER("owner")" ,
      extra /*rph*/
  x = clistCard(cmd)

      /* Find all objects, and make commands to create profiles */
      /* for 'auth'. Then remove executor from access list.     */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT strip(a.SCHEMANAME) as name, 'READ'   as type")
  x=sql("FROM SYSIBM.SYSSCHEMAAUTH as a"                               )
  x=sql("WHERE a."col "<> ' '"                                         )
 if SlimAdm
 then do
  x=sql("  AND a.grantee not in"                                       )
  x=sql("     ("                                                       )
  x=sql("       select distinct b.grantee from sysibm.sysuserauth as b")
  x=sql("       where b.sysadmAuth <> ' '"                             )
  x=sql("      )"                                                      )
 end
  x=sql("  AND EXISTS"                                                 )
  x=sql("     ("                                                       )
  x=sql("       select 1 from sysibm.sysschemaauth as c"               )
  x=sql("       where c."col "<> ' '"                                  )
  x=sql("         and c.schemaName = a.schemaName"                     )
  x=sql("         and c.grantee in ('PUBLIC','PUBLIC*')"               )
  x=sql("      )"                                                      )
  if RemoveUserList <> ''
  then ,
  x=sql("  AND a.grantee not in" RemoveUserList                        )

  x=sql("UNION" ,                                                      )
  x=sql("SELECT DISTINCT strip(a.SCHEMANAME) as name, 'NONE'   as type")
  x=sql("FROM SYSIBM.SYSSCHEMAAUTH as a"                               )
  x=sql("WHERE a."col "<> ' '"                                         )
 if SlimAdm
 then do
  x=sql("  AND a.grantee not in"                                       )
  x=sql("     ("                                                       )
  x=sql("       select distinct b.grantee from sysibm.sysuserauth as b")
  x=sql("       where b.sysadmAuth <> ' '"                             )
  x=sql("      )"                                                      )
 end
  x=sql("  AND NOT EXISTS"                                             )
  x=sql("     ("                                                       )
  x=sql("       select 1 from sysibm.sysschemaauth as c"               )
  x=sql("       where c."col "<> ' '"                                  )
  x=sql("         and c.schemaName = a.schemaName"                     )
  x=sql("         and c.grantee in ('PUBLIC','PUBLIC*')"               )
  x=sql("      )"                                                      )
  if RemoveUserList <> ''
  then ,
  x=sql("  AND a.grantee not in" RemoveUserList                        )

  x=sql("order by name"                                                )

  call ZSQL

  rowsReturned = 0
  allPublic = 0  /* default is, of course, not all public */
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :name, :type"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var name name .
      parse upper var type type .
      If model=1 Then prof=name'.'auth
      Else prof=ssid'.'name'.'auth

      if name = '*' & type = 'READ'
      then allPublic = 1 /* yes, define everything as read */

      if allPublic
      then type = 'READ' /* override all schema's to public */

      extra = "DATA('"auth "for ssid("ssid") schema("name")')"
      if type = 'READ'
      then extra = "DATA('everyone has" ,
                      auth "for ssid("ssid") schema("name")')"
      prof = left(prof,max(24,length(prof)))

      /* normally, we have to create RDEF's but we already   */
      /*   created backstop profile.  So if name = '*' we'll */
      /*   have to modify if (RALT) instead of define it.    */

      if name = '*' /* generic profile already created? modify it*/
      then cmdx = 'RALT' /* modify 'backstop' */
      else cmdx = 'RDEF' /* define profile    */

      cmd=cmdx class prof" UACC("type") AUDIT(ALL(READ))",
          "OWNER("owner")" ,
          extra /*rph*/
      x = clistCard(cmd)

      cmd="PERMIT "prof" CLASS("class") RESET"
      if resetOption = 'RESET' then x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'

  Rdef$Permit = 'PERMIT'/*all output to PE   datasets */
                       /* --------------------------- */

      /* Find all objects, and make commands to create profiles */
      /* for 'auth'. Then remove executor from access list.     */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT name"                                         )
  x=sql("               ,grantee"                                      )
  x=sql("FROM ("                                                       )

  x=sql("   SELECT DISTINCT strip(a.SCHEMANAME) as name"               )
  x=sql("                  ,strip(a.grantee)    as grantee"            )
  x=sql("   FROM SYSIBM.SYSSCHEMAAUTH as a"                            )
  x=sql("   WHERE a."col "<> ' '"                                      )
 if SlimAdm
 then do
  x=sql("     AND a.grantee not in"                                    )
  x=sql("        ("                                                    )
  x=sql("          select distinct b.grantee"                          )
  x=sql("          from sysibm.sysuserauth as b"                       )
  x=sql("          where b.sysadmAuth <> ' '"                          )
  x=sql("         )"                                                   )
 end
  x=sql("     AND NOT EXISTS"                                          )
  x=sql("        ("                                                    )
  x=sql("          select 1 from sysibm.sysschemaauth as c"            )
  x=sql("          where c."col "<> ' '"                               )
  x=sql("            and (   c.schemaName = a.schemaName"              )
  x=sql("                 or c.schemaName = '*'"                       )
  x=sql("                 )"                                           )
  x=sql("            and c.grantee in ('PUBLIC','PUBLIC*')"            )
  x=sql("         )"                                                   )
  if RemoveUserList <> ''
  then ,
  x=sql("     AND a.grantee not in" RemoveUserList                     )
  x=sql("UNION"                                                        )
  x=sql("   SELECT DISTINCT strip(a.SCHEMANAME) as name"               )
  x=sql("                  ,strip(b.grantee)    as grantee"            )
  x=sql("   FROM SYSIBM.SYSSCHEMAAUTH as a"                            )
  x=sql("       ,SYSIBM.SYSSCHEMAAUTH as b"                            )
  x=sql("   WHERE a."col "<> ' '"                                      )
  x=sql("     and b."col "<> ' '"                                      )
  x=sql("     and b.schemaName = '*'"                                  )
 if SlimAdm
 then do
  x=sql("     AND b.grantee not in"                                    )
  x=sql("        ("                                                    )
  x=sql("          select distinct b2.grantee"                         )
  x=sql("          from sysibm.sysuserauth as b2"                      )
  x=sql("          where b2.sysadmAuth <> ' '"                         )
  x=sql("         )"                                                   )
 end
  x=sql("     AND NOT EXISTS"                                          )
  x=sql("        ("                                                    )
  x=sql("          select 1 from sysibm.sysschemaauth as c"            )
  x=sql("          where c."col "<> ' '"                               )
  x=sql("            and (   c.schemaName = a.schemaName"              )
  x=sql("                 or c.schemaName = '*'"                       )
  x=sql("                 )"                                           )
  x=sql("            and c.grantee in ('PUBLIC','PUBLIC*')"            )
  x=sql("         )"                                                   )
  if RemoveUserList <> ''
  then ,
  x=sql("     AND b.grantee not in" RemoveUserList                     )
  x=sql("   )"                                                         )

  x=sql("order by name, grantee"                                       )

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :name, :grantee"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var name name .
      parse upper var type type .
      If model=1 Then prof=name'.'auth
      Else prof=ssid'.'name'.'auth

      prof = left(prof,max(24,length(prof)))
      cmd="PERMIT" prof "CLASS("class") ACC(READ) ID("grantee")"
      x = clistCard(cmd)

    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'

  return

def_priv:
   /* database privs */
   /*                                                        */
   /*    call def_priv "DB","CREATETAB","CREATETABAUTH","DB" */
   /*    call def_priv "DB","CREATETS","CREATETSAUTH","DB"   */
   /*    call def_priv "DB","DISPLAYDB","DISPLAYDBAUTH","DB" */
   /*    call def_priv "DB","DROP","DROPAUTH","DB"           */
   /*    call def_priv "DB","IMAGCOPY","IMAGCOPYAUTH","DB"   */
   /*    call def_priv "DB","LOAD","LOADAUTH","DB"           */
   /*    call def_priv "DB","REORG","REORGAUTH","DB"         */
   /*    call def_priv "DB","RECOVERDB","RECOVERDBAUTH","DB" */
   /*    call def_priv "DB","REPAIR","REPAIRAUTH","DB"       */
   /*    call def_priv "DB","STARTDB","STARTDBAUTH","DB"     */
   /*    call def_priv "DB","STATS","STATSAUTH","DB"         */
   /*    call def_priv "DB","STOPDB","STOPAUTH","DB"         */

   /* Plan privileges */
   /*                                                        */
   /*    call def_priv "PN","BIND","BINDAUTH","PLAN"         */
   /*    call def_priv "PN","EXECUTE","EXECUTEAUTH","PLAN"   */
/*****************************************************************/
/* Get DB2 Default privileges (plans, db, etc.)                  */
/*****************************************************************/
  Arg type,auth,col,tab
  If model=1 Then class="M"ssid||type||charopt
  Else class="M"classmnt||type||charopt

  extra = ''      /* default */
  dbowner = owner /* default */

  Rdef$Permit = 'RDEF' /* all output to rdef datasets */
                       /* --------------------------- */
  useClass = class

  /* create "backstop" so that everything else is rejected */
  /* ----------------------------------------------------- */
  x = clistCard(' ')
  cmd='/* create backstop RDEF (in def_priv: routine) */'
  x = clistCard(cmd)

  If model=1 Then prof='*.'auth
  Else prof=ssid'.*.'auth

  if tab  = 'DB'
  then extra = "DATA('Backstop "auth "for ssid("ssid") database(*)')"
  else if tab  = 'PLAN'
  then extra = "DATA('Backstop "auth "for ssid("ssid") plan(*)'"

  prof = left(prof,max(24,length(prof)))
  cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
      "OWNER("owner")" ,
      extra /*rph*/
  x = clistCard(cmd)

      /* Find all objects, and make commands to create profiles */
      /* for 'auth'. Then remove executor from access list.     */
  /* if selecting from SYSIBM.SYSDBAUTH, exclude implicit db's*/
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT strip(a.NAME) as name"      )
  x=sql("   FROM SYSIBM.SYS"tab"AUTH as a"           )

 if tab = 'DB'
 then do
  x=sql("       ,SYSIBM.SYSDATABASE as b"            )
  x=sql("   WHERE a.name = b.name"                   )
  x=sql("     and b.implicit = 'N'"                  )
 end

  x=sql("   order by name"                           )

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :name"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var name name .
      If model=1 Then prof=name'.'auth
      Else prof=ssid'.'name'.'auth

      if tab  = 'DB'
      then extra = "DATA('"auth "for ssid("ssid") database(" ,
                          ||name"')" /* rph */
      else if tab  = 'PLAN'
      then extra = "DATA('"auth "for ssid("ssid") plan(" ,
                          ||name"')" /* rph */

      prof = left(prof,max(24,length(prof)))
      cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
          "OWNER("owner")" ,
          extra /*rph*/
      x = clistCard(cmd)

      cmd="PERMIT "prof" CLASS("class") RESET"
      if resetOption = 'RESET' then x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'

     /* If any of those were PUBLIC, change UACC to READ */
  /* if selecting from SYSIBM.SYSDBAUTH, exclude implicit db's*/
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT strip(a.NAME) as name"        )
  x=sql("   FROM SYSIBM.SYS"tab"AUTH as a"             )

 if tab = 'DB'
 then ,
  x=sql("       ,SYSIBM.SYSDATABASE AS b"              )

  x=sql("WHERE a.GRANTEE IN ('PUBLIC','PUBLIC*')"      )
  x=sql("  AND a."col"¬=' '"                           )

 if tab = 'DB'
 then do
  x=sql("  and a.name = b.name"                        )
  x=sql("  and b.implicit = 'N'"                       )
 end

  x=sql("order by name"                                )

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :name"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var name name .
      if tab  = 'DB'
      then extra = "DATA('Everyone has" auth "for ssid("ssid")",
                         "database("name"')" /* rph */
      else if tab  = 'PLAN'
      then extra = "DATA('Everyone has" auth "for ssid("ssid")" ,
                         "plan("name"')" /* rph */
      If model=1 Then prof=name'.'auth
      Else prof=ssid'.'name'.'auth
      prof = left(prof,max(35,length(prof)))
      cmd="RALT "class prof" UACC(READ)" extra
      x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'

  Rdef$Permit = 'PERMIT' /* all output to permit datasets */
                         /* --------------------------- */

     /* Get all ids (except PUBLIC) for access list */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT strip(a.NAME) as name," granteeCase           )
  x=sql("FROM SYSIBM.SYS"tab"AUTH as a"                                )

 if tab = 'DB'
 then ,
  x=sql("       ,SYSIBM.SYSDATABASE AS b"              )

  x=sql("WHERE a.GRANTEE NOT IN ('PUBLIC','PUBLIC*')"                  )
  x=sql("  AND a."col"<>' '"                                           )
 if SlimAdm
 then do
  x=sql("  AND a.grantee not in ("                                     )
  x=sql("       select distinct b.grantee from sysibm.sysuserauth as b")
  x=sql("       where b.sysadmAuth <> ' '" ,                           )
  x=sql("                       )"                                     )
 end

 if RemoveUserList <> ''
 then ,
  x=sql("  AND a.grantee not in" RemoveUserList                        )

 if tab = 'DB'
 then do
  x=sql("  and a.name = b.name"                        )
  x=sql("  and b.implicit = 'N'"                       )
 end

  x=sql("ORDER BY NAME, GRANTEE"                                       )

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :name, :grantee"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var name name .
      parse upper var grantee grantee .
      If model=1 Then prof=name'.'auth
      Else prof=ssid'.'name'.'auth
      prof = left(prof,max(35,length(prof)))
      access = 'ACC(READ)'
      cmd="PERMIT "prof" CLASS("class")" access "ID("grantee")"
      x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'

Return    /* def_priv */

tab_priv:
/*****************************************************************/
/* Get DB2 Tables privileges                                     */
/*****************************************************************/
  /* this routine is (still) necessary for the SQL and data collection*/
  /* ... but it will no longer generate the RACF commands.            */
  /* ... RACF commands will be generated by tab_privRH                */
  Arg auth,col


  If model=1 Then class="M"ssid"TB"charopt
  Else class="M"classmnt"TB"charopt

  Rdef$Permit = 'RDEF' /* all output to rdef datasets */
                       /* --------------------------- */
  useClass = class

  /* comment as to why we are re-issuing the same sql */
  /* ------------------------------------------------ */
  Rdef$Permit = 'RDEF' /* all output to rdef datasets */
                       /* --------------------------- */
     x = clistCard(' ')
     cmd='/* --------------------------------------------------- */'
     x = clistCard(cmd)
     cmd='/* Entering routine tab_priv: for auth='auth 'col='col '*/'
     x = clistCard(cmd)
     cmd='/* Entering routine tab_priv: for auth='auth 'col='col '*/'
     x = clistCard(cmd)
     cmd='/* --------------------------------------------------- */'
     x = clistCard(cmd)

  Rdef$Permit = 'PERMIT' /* all output to pe$ datasets */
                         /* -------------------------- */
     x = clistCard(' ')
     cmd='/* --------------------------------------------------- */'
     x = clistCard(cmd)
     cmd='/* Entering routine tab_priv: for auth='auth 'col='col '*/'
     x = clistCard(cmd)
     cmd='/* Entering routine tab_priv: for auth='auth 'col='col '*/'
     x = clistCard(cmd)
     cmd='/* --------------------------------------------------- */'
     x = clistCard(cmd)

  Rdef$Permit = 'RDEF' /* all output to rdef datasets */
                       /* --------------------------- */

  if auth = 'INIT' /*initialization */
  then do
     /* part of init... collect info on ignored table grantees */
     ignoredTableGrantee. = 0 /* by default, not in our list */
     ignoredTableGranteeList = '' /* be default list of ignored */
                                  /* grantee's                  */
     packageTableGrantee. = 0 /* by default, not in our list */
     packageTableGranteeList = '' /* be default list of missing */
                                  /* racf userid/groups         */

     /* unknown package.owner will = 0 */
     /*   known package.owner will = 1 */
     /* after 'init' finishes          */
     x = clistCard(' ')
     cmd='/* For tab_priv (init), we want to know package owners*/'
     x = clistCard(cmd)
     cmd='/*    used in future tab_priv calls.                  */'
     x = clistCard(cmd)
     x = clistCard(' ')

     x=sql('NEW statement') /* start new sql statement */
                            /* ----------------------- */
     x=sql("select distinct strip(upper(owner)) as owner"      )
     x=sql("   from sysibm.syspackage"                         )
     x=sql("   order by owner"                                 )

     call ZSQL

     packageOwner. = 0
     rowsReturned = 0
     Do Until SQLCODE \= 0
       address dsnrexx "EXECSQL FETCH C1 INTO :packageOwner"
       If SQLCODE = 0
       then do
          rowsReturned = rowsReturned + 1
          parse upper var packageOwner packageOwner .
          packageOwner.packageOwner = 1
       end
     End /* do until */
     call showRowCount /* show rowsReturned */
     If SQLCODE=0 | SQLCODE=100 Then nop
     Else call prtsqlca 'FETCH C1'
     address dsnrexx "EXECSQL CLOSE C1"
     If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'
     /* finished initiaiization - part 1 */

     /* part 2 - capture information about any updateable views */
     /*    if view is updateable, associate view name w/table name*/
     x = clistCard(' ')
     cmd='/* For tab_priv (init), get info on updatable views */'
     x = clistCard(cmd)
     cmd='/*    used in future tab_priv calls                 */'
     x = clistCard(cmd)
     x = clistCard(' ')

     x=sql('NEW statement') /* start new sql statement */
                            /* ----------------------- */
     x=sql('select distinct'                         )
     x=sql('    tb.creator  as viewCreator'          )
     x=sql('   ,tb.name     as viewName'             )
     x=sql('   ,dp.bcreator as tableCreator'         )
     x=sql('   ,dp.bname    as tableName'            )
     x=sql('from sysibm.systables  as tb'            )
     x=sql('    ,sysibm.sysviewdep as dp'            )
     x=sql("where tb.type = 'V'"                     )
     x=sql("  and dp.btype= 'T'"                     )
     x=sql("  and tb.creator = dp.dcreator"          )
     x=sql("  and tb.name    = dp.dname"             )
     x=sql("order by tb.creator"                     )
     x=sql("        ,tb.name"                        )
     x=sql("        ,dp.bcreator"                    )
     x=sql("        ,dp.bname"                       )

     call ZSQL

     view2table. = '' /* default it's not a view, set to null    */
                      /* for single table views...               */
                      /*        view2table.viewCreator.ViewName  */
                      /*             will be set to:             */
                      /*                tableCreator'.'tablename */
                      /* for multi-table views...                */
                      /*        view2table.viewCreator.ViewName  */
                      /*             will be set to:             */
                      /*                <null string>            */
     SingleTableInView.   = 0 /* by default = 0, not a view at all*/
                              /* set to 1, if a single table view*/
                              /* set to 2, if a  multi-table view*/
     lastCount = 0
     previousViewCreator  = ''
     previousViewName     = ''
     rowsReturned = 0
     Do Until SQLCODE \= 0
       address dsnrexx ,
       "EXECSQL FETCH C1 INTO :viewCreator,  :ViewName"  ,
                           ", :tableCreator, :TableName"
       If SQLCODE = 0
       then do
          rowsReturned = rowsReturned + 1
          parse upper var viewCreator viewCreator .
          parse upper var viewName    viewName    .
          parse upper var tableCreator tableCreator .
          parse upper var tableName    tableName    .
          if previousViewCreator = viewCreator ,
           & previousViewName    = viewName
          then do
             /* singleTableInView.viewCreator.ViewName should be */
             /*    = 0 (not a view at all, default)              */
             /*    = 1 (a single table view)                     */
             /*    = 2 (a multi-table  view)                     */
             SingleTableInView.viewCreator.viewName =2 /*mult. table */

             /* reset, view2Table stem to null */
             view2Table.viewCreator.viewName = ''
             iterate
          end

          /* singleTableInView.viewCreator.ViewName should be */
          /*    = 0 (not a view at all, default)              */
          /*    = 1 (a single table view)                     */
          /*    = 2 (a multi-table  view)                     */

          /* now assume, it's a single table view */
          SingleTableInView.viewCreator.viewName =1/*single table view*/

          /* remember previous view */
          previousViewCreator  = viewCreator
          previousViewName     = viewName

          /* for single table views, remember table creator + name*/
          view2Table.viewCreator.viewName = ,
                        tableCreator || '.' || tableName
          trace 'n'
          iterate
       end
     End /* do until */

     /*xxx*/ say 'singleTableInView.DISETS.VEAC0E="' ,
     /*xxx*/    ||singleTableInView.DISETS.VEAC0E'"'
     /*xxx*/ say 'view2Table.DISETS.VEAC0E="' ,
     /*xxx*/    ||view2Table.DISETS.VEAC0E'"'

     call showRowCount /* show rowsReturned */
     If SQLCODE=0 | SQLCODE=100 Then nop
     Else call prtsqlca 'FETCH C1'
     address dsnrexx "EXECSQL CLOSE C1"
     If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'


     /* finished initiaiization */
     x = clistCard(' ')
     cmd='/* For tab_priv auth='auth 'processing is complete */'
     x = clistCard(cmd)
     x = clistCard(' ')

     return
  end

  /* create "backstop" so that everything else is rejected */
  /* ----------------------------------------------------- */
  x = clistCard(' ')
  cmd='/* create backstop RDEF (in tab_priv: for auth='auth') */'
  x = clistCard(cmd)
  x = clistCard(' ')

  if auth = 'VIEW_INSERT' | auth = 'VIEW_UPDATE' | auth = 'VIEW_DELETE'
  then do /* we need backstop created for views as well */
     If model=1 Then prof='*.*.*.*'
     Else prof=ssid'.*.*.*.*'
     tcreator = strip(tcreator)
     ssidTable = prof
     prof=prof'.'substr(auth,6) /* strip off 'VIEW_' from auth */
     prof= left(prof,max(41,length(prof)))
     data='Backstop for' substr(auth,6) ,
                        'on view(s) *.*.*.*.'substr(auth,6)

     cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
         "OWNER("owner")" ,
           "DATA('"data"')"
     x = clistCard(' ')

     x = clistCard(cmd)
  end
  else do /* we need backstop for this auth */
     If model=1 Then prof='*.*'
     Else prof=ssid'.*.*'
     tcreator = strip(tcreator)
     ssidTable = prof
     prof=prof'.'auth
     prof= left(prof,max(41,length(prof)))
     data='Backstop for' auth 'on table(s) *.*.'auth

     cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
         "OWNER("owner")" ,
           "DATA('"data"')"
     x = clistCard(' ')

     x = clistCard(cmd)
  end

  FewTables4Creator. = 1 /* assume everything is explcit */
  if (genericOption = 'GENERIC' | genericOption = 'GENERICNOAUDIT') ,
   & auth <> 'VIEW_INSERT' , /* must be explicit; generic ignored */
   & auth <> 'VIEW_UPDATE' , /* must be explicit; generic ignored */
   & auth <> 'VIEW_DELETE'   /* must be explicit; generic ignored */
  then do /* identify some tables we believe could have generic rules*/
     x = clistCard(' ')
     cmd='/* collect info 4 GENERIC/GENERICNOAUDIT for auth='auth') */'
     x = clistCard(cmd)
     x = clistCard(' ')

     x=sql('NEW statement') /* start new sql statement */
                            /* ----------------------- */
     x=sql('   Select tcreator, grantee, count(*)'            )
     x=sql('   from (select distinct'                         )
     x=sql('             a.tcreator'                          )
     x=sql('            ,a.ttname'                            )
     x=sql("            ,'PUBLIC' as grantee"                 )
     x=sql('         from sysibm.systabauth as a'             )
     x=sql("         where a.granteetype=' '"                 )
     x=sql("           and a."col "<> ' '"                    )

    if auth = 'UPDATE'
    then ,
     x=sql("           and a.updateCols = ' '"                )

    if auth = 'REFERENCES'
    then ,
     x=sql("           and a.refCols = ' '"                   )

     x=sql("           and exists"                            )
     x=sql("             ("                                   )
     x=sql("              select 1"                           )
     x=sql("              from sysibm.systabauth as b"        )
     x=sql("              where b.granteeType = ''"           )
     x=sql("                and b."col "<> ' '"               )

    if auth = 'UPDATE'
    then ,
     x=sql("                and b.updateCols = ' '"           )

    if auth = 'REFERENCES'
    then ,
     x=sql("                and b.refCols = ' '"              )

     x=sql("                and a.tcreator = b.tcreator"      )
     x=sql("                and a.ttname   = b.ttname"        )
     x=sql("                and (   b.grantee = 'PUBLIC' "    )
     x=sql("                     or b.grantee = 'PUBLIC*'"    )
     x=sql("                    )"                            )
     x=sql("             )"                                   )
     x=sql("        )"                                        )
     x=sql('   group by tcreator, grantee'                    )
     x=sql('union'                                            )
     x=sql('   Select tcreator, grantee, count(*)'            )
     x=sql('   from (select distinct'                         )
     x=sql('             a.tcreator'                          )
     x=sql('            ,a.ttname'                            )
     x=sql("            ,'ATOTAL' as grantee"                 )
     x=sql('         from sysibm.systabauth as a'             )
     x=sql("         where a.granteetype=' '"                 )
     x=sql("           and a."col "<> ' '"                    )
     x=sql("        )"                                        )
     x=sql('   group by tcreator, grantee'                    )
     x=sql('order by tcreator, grantee'                       )

     call ZSQL

     lastCreator = ''
     lastCount = 0
     rowsReturned = 0
     Do Until SQLCODE \= 0
       address dsnrexx ,
       "EXECSQL FETCH C1 INTO :tcreator, :grantee, :countx"
       If SQLCODE = 0
       then do
          rowsReturned = rowsReturned + 1
          parse upper var tcreator tcreator .
          parse upper var grantee  grantee  .
          if tcreator = lastCreator
          then do /* we have total count + public tables */
             if lastCount = countx , /* all public tables? */
              & countx >= 5
             then do /* create a generic creator.*.priv uacc(Read)*/
                /* create generic one */
                /* ensure we don't create any more for creator*/
                fewTables4Creator.Tcreator = -1 /* indicate skip */

                If model=1 Then prof=Strip(tcreator)'.*'
                Else prof=ssid'.'Strip(tcreator)'.*'
                tcreator = strip(tcreator)
                ssidTable = prof
                prof=prof'.'auth
                prof= left(prof,max(41,length(prof)))
                data='Everyone has' auth 'on table(s)' tcreator'.*'

                x = clistCard(' ')
                cmd="RDEF "class prof" UACC(READ) AUDIT(ALL(READ))",
                    "OWNER("owner")" ,
                      "DATA('"data"')"

                x = clistCard(cmd)

                cmd="PERMIT "prof" CLASS("class") RESET"
                if resetOption = 'RESET' then x = clistCard(cmd)
                trace 'n'
                iterate
             end
             if lastCount < 5
             then fewTables4Creator.Lastcreator = 1
             else fewTables4Creator.Lastcreator = lastCount

             lastGrantee = grantee /* set to "PUBLIC" */

             trace 'n'
             iterate
          end
          else if lastGrantee = 'ATOTAL' /* no public tables then */
          then do
             if lastCount < 5
             then fewTables4Creator.Lastcreator = 1
             else fewTables4Creator.Lastcreator = lastCount
          end
          /* by implication (different creators) grantee is "ATOTAL"*/
          /* ...the current row is for "ATOTAL", save info.         */
          lastCreator = tcreator
          lastCount   = countx
          lastGrantee = grantee
          trace 'n'
          iterate /* we have "ATOTAL" count, look for "PUBLIC" */
       end
     End /* do until */
     call showRowCount /* show rowsReturned */
     If SQLCODE=0 | SQLCODE=100 Then nop
     Else call prtsqlca 'FETCH C1'
     address dsnrexx "EXECSQL CLOSE C1"
     If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'

     /* handle last pending row, if any*/
     if lastGrantee = 'ATOTAL' /* no public tables then */
     then do
        if lastCount < 5
        then fewTables4Creator.Lastcreator = 1
        else fewTables4Creator.Lastcreator = lastCount
     end
     trace 'n'

     /* finished identifying potential generic processing */
  end

/*sql="SELECT DISTINCT TCREATOR, TTNAME FROM SYSIBM.SYSTABAUTH", */
/*  "WHERE GRANTEETYPE=' '"                                    , */
/*  "ORDER BY TCREATOR, TTNAME"                                  */

  /* Find out if table is being audited, in addition to normal info*/
  /*     and tables that are public for 'col' (updateauth, etc)    */
  /*     for PUBLIC access:  generate RACF code now.               */
  /*     -----------------                                         */
  /* Note:  for tables with PUBLIC access ignore GENERIC and/or    */
  /*     GENERICNOAUDIT, and generate specific RDEF for public     */
  /*     access.                                                   */
  /* --------------------------------------------------------------*/
  x = clistCard(' ')
  cmd='/* Generate RDEF 4 tables with PUBLIC access 4 auth='auth' ) */'
  x = clistCard(cmd)
  cmd='/*    note:  additional grants for tables with public ) */'
  x = clistCard(cmd)
  cmd='/*          access will not be generated.               */'
  x = clistCard(cmd)
  x = clistCard(' ')

  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT A.TCREATOR, A.TTNAME, B.AUDITING, B.DBNAME" )
  x=sql("FROM SYSIBM.SYSTABAUTH AS A"                                )
  x=sql("    ,SYSIBM.SYSTABLES  AS B"                                )
  x=sql("WHERE A.GRANTEETYPE=' '"                                    )
  x=sql("  AND A.TCREATOR = B.CREATOR"                               )
  x=sql("  AND A.TTNAME   = B.NAME"                                  )
  x=sql("  AND A."col" <> ' '"                                       )

 if   auth='VIEW_INSERT' | auth='VIEW_UPDATE' | auth='VIEW_DELETE'
 then ,
  x=sql("  and b.type     = 'V'"                  )


 if auth = 'UPDATE'
 then ,
  x=sql("  AND A.UPDATECOLS = ' '"                                   )

 if auth = 'REFERENCES'
 then ,
  x=sql("  and A.refCols = ' '"                                      )

  x=sql("  AND exists ("                                             )
  x=sql("        select 1 from sysibm.systabauth as c"               )
  x=sql("           where c.tcreator = a.tcreator"                   )
  x=sql("             and c.ttname   = a.ttname"                     )
  x=sql("             and c."col" <> ' '"                            )

 if auth = 'UPDATE'
 then ,
  x=sql("             and c.UPDATECOLS = ' '"                        )

 if auth = 'REFERENCES'
 then ,
  x=sql("             and c.refCols = ' '"                           )

  x=sql("             and (   grantee = 'PUBLIC'"                    )
  x=sql("                  or grantee = 'PUBLIC*')"                  )
  x=sql("             )"                                             )
  x=sql("ORDER BY TCREATOR, TTNAME"                                  )

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx ,
    "EXECSQL FETCH C1 INTO :tcreator, :ttname, :auditing, :dbname"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var tcreator tcreator .
      parse upper var ttname   ttname   .
      parse upper var dbname   dbname   .

      if FewTables4Creator.tcreator =-1 /* skip; creator.* is     */
      then iterate                      /*       ...already generic*/

      if auth = 'VIEW_INSERT' ,
       | auth = 'VIEW_UPDATE' ,
       | auth = 'VIEW_DELETE'
      then do /* get profile for an updatable view */
         if singleTableInView.tcreator.ttname <> 1
         then iterate /* not a single table view */
         if view2table.tcreator.ttname = ''
         then iterate /* seems impossible, but skip this then */

         /* updatable view (and view from a single table) */
         /* get table creator.name (table) for view */
         tableCreatorDotName = view2table.tcreator.ttname

         If model=1 Then prof=tableCreatorDotName'.'tcreator'.'ttname
         Else prof=ssid'.'tableCreatorDotName'.'tcreator'.'ttname
         dbname = strip(dbname)
         if left(tcreator,3) = 'DSN'
         then dbowner = 'DB2ENGNR'
         tcreator = strip(tcreator)

         ssidTable = prof
         prof=prof'.'substr(auth,6)
         prof= left(prof,max(41,length(prof)))
         /* generate rdef's for 'PUBLIC' access                  */
         /* -----------------------------------                  */

         if auditing <> ' '
         then data='DB2 auditing view everyone has' substr(auth,6) ,
                   'on single-table view' tcreator'.'ttname
         else data='Everyone has' substr(auth,6) 'on single-table' ,
                   'view' tcreator"."strip(ttname)
      end
      else if singleTableInView.tcreator.ttname = 1 ,
            & (  auth = 'INSERT'                    ,
               | auth = 'UPDATE'                    ,
               | auth = 'DELETE'                    ,
              )
      then iterate /* let view_insert,view_update,View_delete handle*/
      else if singleTableInView.tcreator.ttname = 2 ,
            & (  auth = 'INSERT'                    ,
               | auth = 'UPDATE'                    ,
               | auth = 'DELETE'                    ,
              )
      then do /* generate rdef for multi-table view using i/u/d */
         If model=1 Then prof=Strip(tcreator)'.'Strip(ttname)
         Else prof=ssid'.'Strip(tcreator)'.'Strip(ttname)
         dbname = strip(dbname)
         if left(tcreator,3) = 'DSN'
         then dbowner = 'DB2ENGNR'
         tcreator = strip(tcreator)

         ssidTable = prof
         prof=prof'.'auth
         prof= left(prof,max(41,length(prof)))
         /* generate rdef's for 'PUBLIC' access                  */
         /* -----------------------------------                  */

         if auditing <> ' '
         then data='DB2 auditing on multi-table view' ,
                        strip(prof) 'everyone has' auth
         else data='Everyone has' auth 'on multi-table view' ,
                   tcreator"."strip(ttname)
      end
      else if singleTableInView.tcreator.ttname > 0
      then do /* get profile for view(s) */
         If model=1 Then prof=Strip(tcreator)'.'Strip(ttname)
         Else prof=ssid'.'Strip(tcreator)'.'Strip(ttname)
         dbname = strip(dbname)
         if left(tcreator,3) = 'DSN'
         then dbowner = 'DB2ENGNR'
         tcreator = strip(tcreator)

         ssidTable = prof
         prof=prof'.'auth
         prof= left(prof,max(41,length(prof)))
         /* generate rdef's for 'PUBLIC' access                  */
         /* -----------------------------------                  */

         if auditing <> ' '
         then data='DB2 auditing view' strip(prof) 'everyone has' auth
         else data='Everyone has' auth 'on view' ,
                   tcreator"."strip(ttname)
      end
      else do /* get profile for tables */
         If model=1 Then prof=Strip(tcreator)'.'Strip(ttname)
         Else prof=ssid'.'Strip(tcreator)'.'Strip(ttname)
         dbname = strip(dbname)
         if left(tcreator,3) = 'DSN'
         then dbowner = 'DB2ENGNR'
         tcreator = strip(tcreator)

         ssidTable = prof
         prof=prof'.'auth
         prof= left(prof,max(41,length(prof)))
         /* generate rdef's for 'PUBLIC' access                  */
         /* -----------------------------------                  */

         if auditing <> ' '
         then data='DB2 auditing on' strip(prof) 'everyone has' auth
         else data='Everyone has' auth 'on table' ,
                   tcreator"."strip(ttname)
      end

      x = clistCard(' ')
      cmd="RDEF "class prof" UACC(READ) AUDIT(ALL(READ))",
          "OWNER("owner")" ,
            "DATA('"data"')"

      x = clistCard(cmd)

      cmd="PERMIT "prof" CLASS("class") RESET"
      if resetOption = 'RESET' then x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'

   /* ------------------------------------------- */
   /* table info for generic processing           */
   /* but initialize requardless of genericOption */
   /* ------------------------------------------- */
  rphTable = 0
  rphtable. = ''            /* .# = creator.tablename */
  rphTableIndx. = 0         /* .creator.tablename = # */
  rphTableCreator = 0
  rphTableCreator. = ''     /* .#       = creator */
  rphTableCreatorIndx. = 0  /* .creator = list of table numbers*/
  rphTablePriv. = ''   /* .tableindx = list of userids */
  rphTableWGrant. = '' /* .tableindx = list of userids */
                       /* note: we no longer set this to anything */
                       /*       ...so although used in code later */
                       /*          this is always null            */
  rphTableAuditing. = ' '
  rphTableSchemaGranteeCount. = 0 /* # of times grantee used */
  rphTableSchemaGranteeList.  ='' /* list of grantees        */
   /* end table info */

  /* --------------------------------------------------------------*/
  /* Find out if table is being audited, in addition to normal info*/
  /*     for non "public" tables.                                  */
  /*         ------------                                          */
  /* --------------------------------------------------------------*/
  x = clistCard(' ')
  cmd='/* Get information about non-Public tables 4 auth='auth' ) */'
  x = clistCard(cmd)
  cmd='/*    note:  audit info will be ignored if option       */'
  x = clistCard(cmd)
  cmd='/*          GENERICNOAUDIT is in effect.                */'
  x = clistCard(cmd)
  cmd='/*    note:  RDEF''s may be generated for non-generic    */'
  x = clistCard(cmd)
  cmd='/*          option, or for updatable views, and some for*/'
  x = clistCard(cmd)
  cmd='/*          table creators (with too few tables) etc.   */'
  x = clistCard(cmd)
  cmd='/*    otherwise, RDEFs and PERMITs are delayed until     */'
  x = clistCard(cmd)
  cmd='/*    the routine collapse_tab_privRH: generates them.   */'
  x = clistCard(cmd)
  x = clistCard(cmd)
  cmd='/*    Note:  genericOption in effect is' genericOption '*/'
  x = clistCard(' ')

  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT A.TCREATOR, A.TTNAME, B.AUDITING"        )
  x=sql("FROM SYSIBM.SYSTABAUTH AS A"                             )
  x=sql("    ,SYSIBM.SYSTABLES  AS B"                             )
  x=sql("WHERE A.GRANTEETYPE=' '"                                 )
  x=sql("  AND A.TCREATOR = B.CREATOR"                            )
  x=sql("  AND A.TTNAME   = B.NAME"                               )
  x=sql("  AND A."col" <> ' '"                                    )

 if      auth='VIEW_INSERT' | auth='VIEW_UPDATE' | auth='VIEW_DELETE'
 then ,
  x=sql("  and b.type     = 'V'"                  )


 if auth = 'UPDATE'
 then ,
  x=sql("  AND A.UPDATECOLS = ' '"                               )

 if auth = 'REFERENCES'
 then ,
  x=sql("  and A.refCols = ' '"                                  )

  x=sql("  AND not exists ("                                     )
  x=sql("            select 1 from sysibm.systabauth as c"       )
  x=sql("               where c.tcreator = a.tcreator"           )
  x=sql("                 and c.ttname   = a.ttname"             )
  x=sql("                 and c."col" <> ' '"                    )

 if auth = 'UPDATE'
 then ,
  x=sql("             and c.UPDATECOLS = ' '"                    )

 if auth = 'REFERENCES'
 then ,
  x=sql("             and c.refCols = ' '"                       )

  x=sql("                 and (   c.grantee = 'PUBLIC'"          )
  x=sql("                      or c.grantee = 'PUBLIC*')"        )
  x=sql("                 )"                                     )
  x=sql("ORDER BY TCREATOR, TTNAME"                              )

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx ,
    "EXECSQL FETCH C1 INTO :tcreator, :ttname, :auditing"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1

      if genericOption = 'GENERICNOAUDIT'
      then auditing = ' ' /* ignore auditing w/GENERICNOAUDIT */

      parse upper var tcreator tcreator .
      parse upper var ttname   ttname   .
      if auth = 'VIEW_INSERT' ,
       | auth = 'VIEW_UPDATE' ,
       | auth = 'VIEW_DELETE'
      then do /* special profile needed */
         if singleTableInView.tcreator.ttname <> 1
         then iterate /* ignore multi-table views */

         if view2table.tcreator.ttname = ''
         then iterate /* unbelievable, but true */

         If model=1 Then prof=view2table.tcreator.ttname ,
                              || '.'tcreator'.'ttname
         Else prof=ssid'.'view2table.tcreator.ttname     ,
                              || '.'tcreator'.'ttname
         dbname = strip(dbname)
         tcreator = strip(tcreator)
         ssidTable = prof
         prof=prof'.'substr(auth,6)
         prof= left(prof,max(41,length(prof)))

         if auditing <> ' '
         then data='DB2 auditing single-table view' tcreator'.'ttname
         else data=substr(auth,6) 'privs on single-table view' ,
                                                    tcreator'.'ttname
      end
      else if (  auth = 'INSERT' ,
               | auth = 'UPDATE' ,
               | auth = 'DELETE' ,
              )                  ,
            & singleTableInView.tcreator.ttname = 1
      then iterate /* view_Insert/view_update/view_delete does this */
      else if singleTableInView.tcreator.ttname = 1
      then do /* view profile */
         If model=1 Then prof=Strip(tcreator)'.'Strip(ttname)
         Else prof=ssid'.'Strip(tcreator)'.'Strip(ttname)
         dbname = strip(dbname)
         tcreator = strip(tcreator)
         ssidTable = prof
         prof=prof'.'auth
         prof= left(prof,max(41,length(prof)))

         if auditing <> ' '
         then data='DB2 auditing single-table view' tcreator'.'ttname
         else data=auth 'privs on single-table view' tcreator'.'ttname
      end
      else if singleTableInView.tcreator.ttname = 2
      then do /* view profile */
         If model=1 Then prof=Strip(tcreator)'.'Strip(ttname)
         Else prof=ssid'.'Strip(tcreator)'.'Strip(ttname)
         dbname = strip(dbname)
         tcreator = strip(tcreator)
         ssidTable = prof
         prof=prof'.'auth
         prof= left(prof,max(41,length(prof)))

         if auditing <> ' '
         then data='DB2 auditing multi-table view' tcreator'.'ttname
         else data=auth 'privs on multi-table view' tcreator'.'ttname
      end
      else do /* table profile */
         If model=1 Then prof=Strip(tcreator)'.'Strip(ttname)
         Else prof=ssid'.'Strip(tcreator)'.'Strip(ttname)
         dbname = strip(dbname)
         tcreator = strip(tcreator)
         ssidTable = prof
         prof=prof'.'auth
         prof= left(prof,max(41,length(prof)))

         if auditing <> ' '
         then data='DB2 auditing table' tcreator'.'ttname
         else data=auth 'privs on table' tcreator'.'ttname
      end

      if FewTables4Creator.tcreator = -1 /* skip all for creator */
      then iterate

      if FewTables4Creator.tcreator = 1 /* no generic or no reason */
      then do                           /* or updateable view      */
         /* either genericOption <> 'GENERIC' or too few tables */
         /* in any case, generate explicit rule now.            */

         cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
             "OWNER("owner")" ,
             "DATA('"data"')"
         x = clistCard(cmd)

         cmd="PERMIT "prof" CLASS("class") RESET"
         if resetOption = 'RESET' then x = clistCard(cmd)
         iterate
      end

      /* potential to generate generic rules */
      /* So, update table and don't generate any rules yet*/
        /* table info */
      if rphTableIndx.ssidTable = 0
      then do
           /* add entry to rphTable (and indx) for table */
         rphTable = rphTable + 1
         rphTable.rphTable = ssidTable
         rphTableAuditing.rphTable = auditing
         rphTableIndx.ssidTable = rphTable
      end
      tableNumber = rphTableIndx.ssidTable

        /* creator info */
      if rphTableCreatorIndx.tcreator = 0
      then do
         rphTableCreator = rphTableCreator + 1
         rphTableCreator.rphTableCreator = tcreator
         rphTableCreatorIndx.tcreator = rphTableCreator
      end
      CreatorNumber = rphTableCreatorIndx.tcreator

      /* add to priv's we will use later */
      /* ------------------------------- */
      if wordpos(tableNumber,rphTableCreator.creatorNumber) = 0
      then rphTableCreator.creatorNumber = ,
              rphTableCreator.creatorNumber tableNumber /*add 2 list*/

    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'

  rdef$PERMIT = 'PERMIT'

     /* Get all ids (except PUBLIC) for access list */
     /* rph - let's just view G or Y as 'Y'.                    */
  x = clistCard(' ')
  cmd='/* Get grant info for non-Public tables 4 auth='auth' ) */'
  x = clistCard(cmd)
  cmd='/*    note:  audit info will be ignored if option       */'
  x = clistCard(cmd)
  cmd='/*          GENERICNOAUDIT is in effect.                */'
  x = clistCard(cmd)
  cmd='/*    note:  PERMIT generated for non-generic option,    */'
  x = clistCard(cmd)
  cmd='/*          or for updatable views, and some for table  */'
  x = clistCard(cmd)
  cmd='/*          creators (with too few tables) etc.         */'
  x = clistCard(cmd)
  cmd='/*    otherwise, RDEFs and PERMITs are delayed until     */'
  x = clistCard(cmd)
  cmd='/*    the routine collapse_tab_privRH: generates them.   */'
  x = clistCard(cmd)
  x = clistCard(' ')

     /* change-06/06/2023                                          */
     /* 1) added a union statement ... to ensure creator of view   */
     /*   and/or table always appears at least once in the result  */
     /*   set.                                                     */
     /*    a)  Note:  this ensure at least one row appears for     */
     /*       tcreator and tname.  Thus, if when grants are        */
     /*       collapsed, we are ensured a table/view with no grants*/
     /*       will get it's own RDEF and will NOT fall into the    */
     /*       "default RDEF "ssid.creator.*.UPDATE" for example.   */
     /*                                                            */
     /*    b)  Note:  Although RDEF is created for table, no       */
     /*       permits will be issued for the table/view creator as */
     /*       RACF always grants access for the table/view creator.*/
     /*       The excess grant will be eliminated from the result  */
     /*       set by doing a rexx "iterate" and ignoring that      */
     /*       grant/permit.                                        */
     /*                                                            */
     /*    c)  There was a missing predicate, which allowed excess */
     /*       grantee's in result set.  That has been eliminated.  */
     /*       See line below with comment "missing predicate".     */
     /*       Of course, looking in the RDEFTB dataset you will    */
     /*       see both the rexx lines below AND the resulting      */
     /*       sql that was actually "resolved" and executed.       */
     /*                                                            */
     /*    d)  Rexx code will ensure all single-table view RDEFs   */
     /*       are explicitly created for "VIEW_INSERT",            */
     /*       "VIEW_UPDATE" and "VIEW_DELETE" calls.  The primary  */
     /*       reason being that it is doubtful that it would reduce*/
     /*       any RDEFs anyway.  And therefore any additional      */
     /*       complications are simply avoided.                    */
     /*        However, single-table views ignored by INSERT,      */
     /*       UPDATE and DELETE calls; and will be handled by      */
     /*       VIEW_INSERT, VIEW_UPDATE and VIEW_DELETE instead.    */
     /*        Other calls like ALTER, SELECT, etc, treat any      */
     /*       single-table views like any other table access;      */
     /*       and they can participate in generic profiles, as     */
     /*       their RACF RDEFs are the same for those types of     */
     /*       access.                                              */
     /*                                                            */
     /*     e) Multi-table views are treated like regular tables   */
     /*       for all calls to tab_priv (except VIEW_INSERT,       */
     /*       VIEW_UPDATE and VIEW_DELETE).  This means they can   */
     /*       also participate in generic profiles.                */
     /*                                                            */
     /*     f) But RDEFs generated for views (multi-table views)   */
     /*       or single-table views will have comments identifing  */
     /*       them as such.  And RDEFs for tables will identify it */
     /*       as a table.                                          */
     /*                                                            */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT TCREATOR, TTNAME, GRANTEE"                   )
  x=sql("from ("                                                      )
  x=sql(" SELECT DISTINCT a.TCREATOR, a.TTNAME," granteeCase           )
  x=sql(" FROM SYSIBM.SYSTABAUTH as a"                                 )
  x=sql("     ,SYSIBM.SYSTABLES  as b"                                 )
  x=sql(" WHERE a.GRANTEE NOT IN ('PUBLIC','PUBLIC*') AND a."col"<>' '")
  x=sql("   AND a.GRANTEETYPE=' '"                                     )
  x=sql("   AND A."col" <> ' '"   /* missing predicate */              )

  x=sql("   AND a.TCREATOR = b.creator"                                )
  x=sql("   AND a.TTNAME   = b.name"                                   )

 if      auth='VIEW_INSERT' | auth='VIEW_UPDATE' | auth='VIEW_DELETE'
 then ,
  x=sql("   and b.type     = 'V'"                  )

 if auth = 'UPDATE'
 then ,
  x=sql("   AND A.UPDATECOLS = ' '"                                    )

 if auth = 'REFERENCES'
 then ,
  x=sql("   and A.refCols = ' '"                                       )

 if RemoveUserList <> ''
 then ,
  x=sql("   AND a.grantee not in" RemoveUserList                       )

  x=sql("   AND not exists ("                                          )
  x=sql("             select 1 from sysibm.systabauth as c"            )
  x=sql("                where c.tcreator = a.tcreator"                )
  x=sql("                  and c.ttname   = a.ttname"                  )
  x=sql("                  and c."col" <> ' '"                         )

 if auth = 'UPDATE'
 then ,
  x=sql("                  and c.UPDATECOLS = ' '"                     )

 if auth = 'REFERENCES'
 then ,
  x=sql("                  and c.refCols = ' '"                        )

  x=sql("                  and (   c.grantee = 'PUBLIC'"               )
  x=sql("                       or c.grantee = 'PUBLIC*')"             )
  x=sql("                  )"                                          )
  x=sql("UNION"                                                        )
  x=sql(" SELECT DISTINCT e.CREATOR as tcreator"                       )
  x=sql("                ,e.name    as ttname"                         )
  x=sql("                ,e.CREATOR as grantee"                        )
  x=sql(" from SYSIBM.SYSTABLES  as e"                                 )

 if      auth='VIEW_INSERT' | auth='VIEW_UPDATE' | auth='VIEW_DELETE'
 then ,
  x=sql(" where e.type     = 'V'"                  )

  x=sql(")"                                                            )
  x=sql("ORDER BY 1, 2, 3"                                             )

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :tcreator, :ttname, :grantee"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var tcreator tcreator .
      parse upper var ttname   ttname   .
      parse upper var grantee  grantee  .

      if grantee = '*DELETE' then iterate
      /* grantee is upper case and strip'ed, as per "granteecase" */
      if grantee = tcreator
      then nop /* always allow; but won't do actual permit */
      else if packageOwner.grantee = 0 , /*not a package owner */
            & useridIndx.grantee   = 0 , /*and not a racf userid/group*/
            & groupIndx.grantee    = 0   /*and not a racf userid/group*/
      then do      /* ignore garbage authid */
         if ignoredTableGrantee.grantee = 0 /* need to add to list */
         then do      /* add to our list                          */
            ignoredTableGrantee.grantee = 1 /* want to ignore quickly*/
            ignoredTableGranteeList = ignoredTableGranteeList ,
                                      grantee  /* add to list */
         end
         else ignoredTableGrantee.grantee=ignoredTableGrantee.grantee+1
         iterate   /* now iterate */
      end

      /* do package permit, but missing racf userid/group  */
      if packageOwner.grantee = 1 , /* a package owner     */
       & useridIndx.grantee   = 0 , /* and not a racf userid/group */
       & groupIndx.grantee    = 0 , /* and not a racf userid/group */
       & grantee <> tbcreator       /* package owner not tbcreator */
      then do      /* package owner will need a racfid */
         if packageTableGrantee.grantee = 0 /* need to add to list */
         then do      /* add to our list                          */
            packageTableGrantee.grantee = 1 /* want to ignore quickly*/
            packageTableGranteeList = packageTableGranteeList ,
                                      grantee  /* add to list */
         end
         else packageTableGrantee.grantee=packageTableGrantee.grantee+1
      end

      if auth = 'VIEW_INSERT' ,
       | auth = 'VIEW_UPDATE' ,
       | auth = 'VIEW_DELETE'
      then do /* updatable view */
         /* get table for view */
         if view2table.tcreator.ttname = ''
         then iterate /* seems impossible, but */

         parse var view2table theTBcreator '.' .

         If model=1 Then prof=view2table.tcreator.ttname ,
                               || '.'tcreator'.'ttname
         Else prof=ssid'.'view2table.tcreator.ttname     ,
                               || '.'tcreator'.'ttname
         tcreator = strip(tcreator)
         ssidTable = prof
         prof=prof'.'substr(auth,6)
         prof = left(prof,max(45,length(prof)))
      end
      else do /* table or non-updatable view */
         If model=1 Then prof=Strip(tcreator)'.'Strip(ttname)
         Else prof=ssid'.'Strip(tcreator)'.'Strip(ttname)
         tcreator = strip(tcreator)
         ssidTable = prof
         prof=prof'.'auth
         prof = left(prof,max(45,length(prof)))
      end

      if FewTables4Creator.tcreator = 1 /* no generic or no reason */
      then do                           /* ...or updateable view   */

        if tcreator = grantee
        then iterate /* don't need a permit */

        /* generate permit now */
        cmd="PERMIT "prof" CLASS("class") ACC(READ) ID("grantee")"
        x = clistCard(cmd)
        trace 'n'
        iterate
      end

      /* generic option in effect and we may be able to collapse rules*/
      /* collect info now; generate any permits/rdefs later           */
      /* note:  only normal tables or non-updatable view access */
      /*        will be processed here.                         */
           /* update priv */
      tableNumber = rphTableIndx.ssidTable

      /* skip special code for 'G', handle 'Y' and/or 'G' the same */
      rphTablePriv.tableNumber.auth = rphTablePriv.tableNumber.auth ,
                                            grantee

      /* count times a grantee was used for table schema */
      if rphTableSchemaGranteeCount.tcreator.grantee = 0
      then do
         rphTableSchemaGranteeCount.tcreator.grantee = 1
         rphTableSchemaGranteeList.tcreator = ,
                          rphTableSchemaGranteeList.tcreator grantee
      end
      else rphTableSchemaGranteeCount.tcreator.grantee = ,
                     rphTableSchemaGranteeCount.tcreator.grantee + 1
      trace 'n'
      iterate /* now skip code for 'G' or 'Y' */
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'

    /* with Grants */
       /* eliminate 2nd select.. we did everything in prev select */

  /* now generate racf code */
  if (genericOption = 'GENERIC' | genericOption = 'GENERICNOAUDIT') ,
   & auth <> 'VIEW_INSERT' , /* must be explicit; generic ignored */
   & auth <> 'VIEW_UPDATE' , /* must be explicit; generic ignored */
   & auth <> 'VIEW_DELETE'   /* must be explicit; generic ignored */
  then call collapse_tab_privRH     /* generate racf permits */
  else nop                          /* explicit permits done */

  rdef$PERMIT = 'RDEF' /* all output to RDEF datasets */
  useClass    = class

  x = clistCard(' ')
  cmd = '   /* tab_priv: processing complete for auth='auth '*/'
  x = clistCard(cmd)
  x = clistCard(' ')

  rdef$PERMIT = 'PERMIT' /* all output to PE$ datasets */

  x = clistCard(' ')
  cmd = '   /* tab_priv: processing complete for auth='auth '*/'
  x = clistCard(cmd)
  x = clistCard(' ')


  rdef$PERMIT = 'RDEF' /* all output to RDEF datasets */

return    /* tab_priv */

collapse_tab_privRH: /*     called by tab_priv (above) */
/*****************************************************************/
/* Get DB2 Tables privileges (collapse info)                     */
/*****************************************************************/
  rdef$PERMIT = 'RDEF' /* all output to RDEF datasets */
  useClass    = class

  x = clistCard(' ')
  cmd = '   /* Generic processing begins for remaining tables/views */'
  x = clistCard(cmd)
  cmd = '   /* Generic processing begins for remaining tables/views */'
  x = clistCard(cmd)
  cmd = '   /* "collapse_tab_privRH" will generate rdef/permits */'
  x = clistCard(cmd)
  cmd = '   /*    from collected info for table priv='auth '*/'
  x = clistCard(cmd)
  cmd = '   /*    for tables/views using GENERIC or GENERICNOAUDIT */'
  x = clistCard(cmd)
  x = clistCard(' ')

  rdef$PERMIT = 'PERMIT' /* all output to PE$ datasets */

  x = clistCard(' ')
  cmd = '   /* Generic processing begins for remaining tables/views */'
  x = clistCard(cmd)
  cmd = '   /* Generic processing begins for remaining tables/views */'
  x = clistCard(cmd)
  cmd = '   /* "collapse_tab_privRH" will generate rdef/permits */'
  x = clistCard(cmd)
  cmd = '   /*    from collected info for table priv='auth '*/'
  x = clistCard(cmd)
  cmd = '   /*    for tables/views using GENERIC or GENERICNOAUDIT */'
  x = clistCard(cmd)
  x = clistCard(' ')

  rdef$PERMIT = 'RDEF' /* all output to RDEF datasets */

  optClstX = optclstx + 1
  optClstx.optClstx = ' '

  optClstX = optclstx + 1
  optClstx.optClstx = 'Table schema information for auth='auth

  optClstX = optclstx + 1
  optClstx.optClstx = '-------------------------------------------'

  do creator = 1 by 1 for rphTableCreator
     /* go thru tables for this creator, and try to see what's in */
     /* common.                                                   */
     longPriv = 0
     longPriv.= ''
     longPrivIndx. = 0
     maxlong = 0
     maxlongindx = 0
        /* get table list */
     parse var rphTableCreator.creator tbcreator tables
     totalTables = 0
     savetables  = tables
     maxLong = 0

     if optclstx.optclstx <> '' /* only add one blank line */
     then do
        /* add a blank line */
        optClstX = optclstx + 1
        optClstx.optClstx = ' ' /* start schema info w/blank line */
     end
     do while tables <> ''
        parse var tables tableNumber tables
          /* use table info to get stats on priv's */
        priv = strip(rphTablePriv.tableNumber.auth)
        wgrant= '/' strip(rphTableWGrant.tableNumber.auth)
        allprivs = strip(priv wgrant)

        if allprivs = '/' then iterate /* ignore "nothing" */

        allprivs = priv wgrant
        trace 'n'
        totalTables = totalTables + 1  /* tables w/privs   */

        optClstX = optclstx + 1
        optClstx.optClstx = 'auth='auth 'TableSchema=' ,
                           ||tbcreator'.'rphTable.tableNumber

        if length(allPrivs) <= 220
        then hashKey = allPrivs /* hashkey = value */
        else do
           /* we need to use a shorter hash stem instead */
           tooLong = allPrivs
           parse var toolong 1 hashkey 201 toolong
           do while length(tooLong) > 0
              parse var tooLong 1 nextkey 201 tooLong
              hashkey = bitxor(hashkey,nextkey)
           end
           /* now have a potentially (non-unique) hashkey */
        end
        if longPrivIndx.hashkey = 0
        then do
           /* create a new node */
           longPriv = longPriv + 1
           longPriv.longpriv = allprivs
           longPrivCount.longpriv = 1
           LongPrivNextHash.longPriv = 0
           longPrivIndx.hashkey = longpriv
           if maxlong = 0
           then do
              maxlong = 1
              maxlongindx = tableNumber
           end
        end
        else do
           /* potentially two hashkeys for different allPrivs */
           privIndx = longPrivIndx.hashkey
           nextIndx = privIndx
           do while nextIndx <> 0 & longPriv.nextIndx <> allPrivs
              privIndx = nextIndx
              nextIndx = longPrivNextHash.privIndx
           end
           /* either at end of chain, or found matching value */
           if nextIndx = 0
           then do
              /* at end of chain (with no match); create new node */
              longPriv = longPriv + 1
              longPrivNextHash.privIndx = longPriv /* add new node */
                                                   /* ..to end of  */
                                                   /* ..chain.     */
              /* create new node */
              longPriv.longpriv = allprivs
              longPrivCount.longpriv = 1
              LongPrivNextHash.longPriv = 0
              /* don't set "longPrivIndx.hashkey" its set to 1st one*/
              if maxlong = 0
              then do
                 maxlong = 1
                 maxlongindx = tableNumber
              end
           end
           else do /* found matching node.  update count */
              /* nextIndx points to matching node */
              longPrivCount.nextIndx = longPrivCount.nextIndx + 1
              if longPrivCount.nextIndx > maxLong
              then do
                 maxlong = longPrivCount.nextIndx
                 maxlongindx = tableNumber
              end
           end
        end

     End

     if totalTables = 0
     then iterate

     /* output some stats */
     tempList = rphTableSchemaGranteeList.tbcreator
     if templist <> ''
     then do
        optClstX = optclstx + 1
        optClstx.optClstx = '  Grantees for schema(s) above are:'
     end
     do nw = 1 by 1 for words(rphTableSchemaGranteeList.tbcreator)
        gw = word(rphTableSchemaGranteeList.tbcreator,nw)
        if gw = tbcreator
        then iterate
        optClstX = optclstx + 1
        optClstx.optClstx = '   Grantee' gw 'had/has' ,
            rphTableSchemaGranteeCount.tbcreator.gw 'table permits'


        if optclstx > 100
        then do
           Address TSO "EXECIO" optClstx "DISKW OPTCLST (STEM OPTCLSTX."
           if rc <> 0
           then do
              say 'error writing/closing ddname=OPTCLST; rc='rc
              say 'will exit with rc=8'
              pendingRc = 8
           end
           optclstx = 0
        end
     end

     trace 'n'
     /* collected priv summary                   */
     /* ...now try to figure out whats in common */

     /* now generate the default (and then the specifics) */
     tableNumber = maxLongIndx
     priv = strip(rphTablePriv.tableNumber.auth)
     wgrant= '/' strip(rphTableWGrant.tableNumber.auth)
     allprivs = strip(priv wgrant)
     savepriv = allprivs

     if totalTables < 4                ,
      | (totalTables = 4 & maxlong < 3),
      | (totalTables = 5 & maxlong < 3),
      | (totalTables = 6 & maxlong < 3),
      | (totalTables = 7 & maxlong < 3),
      | (totalTables = 8 & maxlong < 4),
      | (totalTables = 9 & maxlong < 4),
      | (totalTables =10 & maxlong < 4),
      | (totalTables >10 & maxlong*100/totalTables < 30) ,
      | (totalTables >50 & maxlong*100/totalTables < 20)
     then savepriv = '' /* only specific rules */
     if savepriv <> ''
     then do /* generate a generic rule */

        Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
                               /* --------------------------- */

        cmd = '   /*      generic for privs='savepriv '*/'
        x = clistCard(cmd)

        tbcreator = strip(tbcreator)
        If model=1 Then prof=tbcreator'.*.'auth
        Else prof=ssid'.'tbcreator'.*.'auth
        prof= left(prof,max(41,length(prof)))
        dbname = strip(dbname)
        if word(allprivs,1) = 'PUBLIC'
        then do
           cmd="RDEF "class prof" UACC(READ) AUDIT(ALL(READ))",
               "OWNER("owner")" ,
               "DATA('Everyone has" auth 'on table(s)' tbcreator".*')"
           x = clistCard(cmd)

           cmd="PERMIT "prof" CLASS("class") RESET"
           if resetOption = 'RESET' then x = clistCard(cmd)
        end
        else do
           cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
               "OWNER("owner")" ,
               "DATA('Users with" auth 'on table(s)' tbcreator".*')"
           x = clistCard(cmd)

           cmd="PERMIT "prof" CLASS("class") RESET"
           if resetOption = 'RESET' then x = clistCard(cmd)
        end

        useClass = class
        Rdef$Permit = 'PERMIT' /* all output to permit datasets */
                               /* --------------------------- */
        per = format(maxlong / totalTables * 100,3,1)'%'
        cmd = '   /*    creator='tbcreator'.*.'auth maxlong 'of' ,
                             totaltables per '*/'
        x = clistcard(' ')
        x = clistCard(cmd)

        Rdef$Permit = 'RDEF'   /* all output to permit datasets */
                               /* --------------------------- */
        per = format(maxlong / totalTables * 100,3,1)'%'
        cmd = '   /*    creator='tbcreator'.*.'auth maxlong 'of' ,
                             totaltables per '*/'
        x = clistcard(' ')
        x = clistCard(cmd)

        Rdef$Permit = 'PERMIT' /* all output to permit datasets */
        /* add in default priv's */
        if word(allprivs,1) = 'PUBLIC'
        then parse var allprivs . allprivs
        wgrant = 0
        do while allprivs <> ''
           parse var allprivs nextpriv allprivs
           if nextpriv = '/'
           then do
              wgrant = 1
              iterate
           end
           grantee  = nextpriv
           if grantee = tbcreator /* grantee = creator ?           */
           then iterate           /* yes, skip unneccessary permit */
           if wgrant = 0
           then cmd="PERMIT "prof" CLASS("class") ACC(READ)",
             "ID("Translate(Strip(grantee))")"
           else cmd="PERMIT "prof" CLASS("class") ACC(ALTER)",
             "ID("Translate(Strip(grantee))")"
           x = clistCard(cmd)
        end
        /* finished generating the default table priv */
     end

     /* now generate the specific ones          */
     tables = saveTables
     do while tables <> ''
        Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
                               /* --------------------------- */

        parse var tables tableNumber tables
          /* use table info to get stats on priv's */
        priv = strip(rphTablePriv.tableNumber.auth)
        wgrant= '/' strip(rphTableWGrant.tableNumber.auth)
        allprivs = strip(priv wgrant)
        if allprivs = '/' & rphTableAuditing.tableNumber = ' '
        then iterate /* ignore "nothing" */
        if allprivs = savepriv ,              /* generic table?   */
         & rphTableAuditing.tableNumber = ' ' /* and NOT audited? */
        then iterate /* ...yes, let generic rule handle this table*/

        /* this table either: */
        /*    1) has different users w/privs than default    */
        /* or 2) this is a db2 audited table, and we should  */
        /*      not let it fall to the valid, but non-explict*/
        /*      generic rdef.  Spell it out.                 */

        prof=rphTable.tableNumber ||'.'auth

        parse var prof . '.' . '.' tbname /* get table name */
        if tbname = ''
        then parse var prof . '.' tbname

        prof= left(prof,max(41,length(prof)))

        if rphTableAuditing.tableNumber = ' ' ,
         & singleTableInView.tcreator.tbname = 0
        then , /* non-audit table */
           cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
               "OWNER("owner")" ,
               "DATA('"auth "privs for table" strip(prof)"')"
        else if singleTableInView.tcreator.tbname = 0
        then , /* audited table */
           cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
               "OWNER("owner")" ,
               "DATA('DB2 auditing table. " auth 'auth on table' ,
                     strip(prof)"')"
        else if rphTableAuditing.tableNumber = ' ' ,
         & singleTableInView.tcreator.tbname = 2
        then do
           cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
               "OWNER("owner")" ,
               "DATA('Users with" auth 'on multi-table view' ,
                     strip(prof)"')"
           x = clistCard(cmd)

           cmd="PERMIT "prof" CLASS("class") RESET"
           if resetOption = 'RESET' then x = clistCard(cmd)
        end
        else if singleTableInView.tcreator.tbname = 2
        then do
           cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
               "OWNER("owner")" ,
               "DATA('DB2 audit on," auth 'on multi-table view' ,
                     strip(prof)"')"
           x = clistCard(cmd)

           cmd="PERMIT "prof" CLASS("class") RESET"
           if resetOption = 'RESET' then x = clistCard(cmd)
        end
        else if rphTableAuditing.tableNumber = ' '  ,
        then do
           cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
               "OWNER("owner")" ,
               "DATA('Users with" auth 'on single-table view' ,
                     strip(prof)"')"
           x = clistCard(cmd)

           cmd="PERMIT "prof" CLASS("class") RESET"
           if resetOption = 'RESET' then x = clistCard(cmd)
        end
        else do
           cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
               "OWNER("owner")" ,
               "DATA('DB2 audit on," auth 'on single-table view' ,
                     strip(prof)"')"
           x = clistCard(cmd)

           cmd="PERMIT "prof" CLASS("class") RESET"
           if resetOption = 'RESET' then x = clistCard(cmd)
        end

        x = clistCard(cmd)

        cmd="PERMIT "prof" CLASS("class") RESET"
        if resetOption = 'RESET' then x = clistCard(cmd)

        Rdef$Permit = 'PERMIT' /* all output to permit datasets */
                               /* --------------------------- */

           /* audited tables get their own permits */
        wgrant = 0
        do while allprivs <> ''
           parse var allprivs nextpriv allprivs
           if nextpriv = '/'
           then do
              wgrant = 1
              iterate
           end
           grantee  = nextpriv

           if tbcreator = grantee
           then iterate /* skip permit, if creator = grantee */

           if wgrant = 0
           then cmd="PERMIT "prof" CLASS("class") ACC(READ)",
             "ID("Translate(Strip(grantee))")"
           else cmd="PERMIT "prof" CLASS("class") ACC(ALTER)",
             "ID("Translate(Strip(grantee))")"
           x = clistCard(cmd)
        end
        /* finished generating spec table privs */

     end
  End /* do while */
trace 'n'
Return    /* collapse_tab_privRH */

tab_col: /* note:  tab_upd  removed so that tab_col can handle  */
         /*                 both 'updatecol' and 'references'   */
         /*                 in addition.  table based authority */
         /*                 was removed.  Column based only.    */

         /* note:  tab_col  handles 'updatecol' and 'references'*/
         /*                 for column bases authority only.    */

         /* note:  these are very specific type authorities and */
         /*                 not good candidates for creating a  */
         /*                 general rule for.                   */
  parse upper arg auth . /* auth=UPDATE or AUTH=REFERENCES */


  If model=1 Then class="M"ssid"TB"charopt
  Else class="M"classmnt"TB"charopt

  Rdef$Permit = 'RDEF' /* all output to rdef datasets */
                       /* --------------------------- */
  useClass = class

  if auth = 'REFERENCES'
  then do
     privcols = 'REFCOLS'
     privauth = 'REFERENCESAUTH'
     privilegeValue = 'R'
  end
  else if auth = 'UPDATECOLS'
  then do
     privcols = 'UPDATECOLS'
     privauth = 'UPDATEAUTH'
     privilegeValue = ' '
  end

  /* comment as to why we are re-issuing the same sql */
  /* ------------------------------------------------ */
  Rdef$Permit = 'RDEF' /* all output to rdef datasets */
                       /* --------------------------- */

     x = clistCard(' ')
     cmd='/* --------------------------------------------------- */'
     x = clistCard(cmd)
     cmd='/* Entering routine tab_col: for auth='auth      '     */'
     x = clistCard(cmd)
     cmd='/* Entering routine tab_col: for auth='auth      '     */'
     x = clistCard(cmd)
     cmd='/* --------------------------------------------------- */'
     x = clistCard(cmd)

  Rdef$Permit = 'PERMIT' /* all output to rdef datasets */
                         /* --------------------------- */

    x = clistCard(' ')
    cmd='/* --------------------------------------------------- */'
    x = clistCard(cmd)
    cmd='/* Entering routine tab_col: for auth='auth      '     */'
    x = clistCard(cmd)
    cmd='/* Entering routine tab_col: for auth='auth      '     */'
    x = clistCard(cmd)
    cmd='/* --------------------------------------------------- */'
    x = clistCard(cmd)

  Rdef$Permit = 'RDEF' /* all output to rdef datasets */
                       /* --------------------------- */

  /* create "backstop" so that everything else is rejected */
  /* ----------------------------------------------------- */
  x = clistCard(' ')
  cmd='/* create backstop RDEF (in tab_col: routine) */'
  x = clistCard(cmd)

  If model=1 Then prof='*.*'
  Else prof=ssid'.*.*'
  prof=prof'.*.'auth
  prof= left(prof,max(41,length(prof)))

  cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
    "OWNER("owner")" ,
     "DATA('DB2-"ssid "backstop rdef table/column priv" privauth"')"
  x = clistCard(cmd)
  x = clistCard(' ')

      /************************************************/
      /* Now for Column-only                          */
      /************************************************/

      /* Find all objects, and make commands to create profiles */
      /* for column based authority */
  x = clistCard(' ')
  cmd='/* Find all objects for column based authority */'
  x = clistCard(cmd)

  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT T.TCREATOR, T.TTNAME, C.COLNAME")
  x=sql("FROM SYSIBM.SYSTABAUTH T     ")
  x=sql("    ,SYSIBM.SYSCOLAUTH C     ")
  x=sql("WHERE T.GRANTEETYPE=' '      ") /* authid (no roles or pgms*/
  x=sql("  AND C.GRANTEETYPE=' '      ") /* authid (no roles or pgms*/
  x=sql("  AND T.DATEGRANTED=C.DATEGRANTED")
  x=sql("  AND T.TIMEGRANTED=C.TIMEGRANTED")
  x=sql("  AND T.TTNAME     =C.TNAME  ")
  x=sql("  AND T.TCREATOR   =C.CREATOR")
  x=sql("  AND T."privcols" ='*'      ") /* handle update/references*/
  x=sql("  AND T."privauth"<>' '      ")  /* handle update/references*/
  x=sql("  AND T.GRANTEE   <>T.TCREATOR") /* and a reason for grant  */
  x=sql("  AND C.GRANTEE   <>C.CREATOR")  /* and a reason for grant  */
  x=sql("  AND C.PRIVILEGE  ='"privilegeValue"'")/* ...              */

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :tcreator, :ttname, :colname"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var tcreator tcreator .
      parse upper var ttname   ttname   .
      parse upper var colname  colname  .

      If model=1 Then prof=Strip(tcreator)'.'Strip(ttname)
      Else prof=ssid'.'Strip(tcreator)'.'Strip(ttname)
      prof=prof'.'Strip(colname)'.'auth
      prof= left(prof,max(41,length(prof)))

      cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
        "OWNER("owner")" ,
         "DATA('DB2-"ssid "rdef table/column priv" privauth"')"
      x = clistCard(cmd)

      cmd="PERMIT "prof" CLASS("class") RESET"
      if resetOption = 'RESET' then x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'

     /* If any of those were PUBLIC, change UACC to READ */
  x = clistCard(' ')
  cmd='/* Find if any of those were granted to PUBLIC */'
  x = clistCard(cmd)

  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT T.TCREATOR, T.TTNAME, C.COLNAME")
  x=sql("FROM SYSIBM.SYSTABAUTH T    ")
  x=sql("    ,SYSIBM.SYSCOLAUTH C    ")
  x=sql("WHERE T.GRANTEETYPE=' '     ") /* authid (no roles or pgms*/
  x=sql("  AND C.GRANTEETYPE=' '     ") /* authid (no roles or pgms*/
  x=sql("  AND T.DATEGRANTED=C.DATEGRANTED")
  x=sql("  AND T.TIMEGRANTED=C.TIMEGRANTED")
  x=sql("  AND T.TTNAME     =C.TNAME ")
  x=sql("  AND T.TCREATOR   =C.CREATOR")
  x=sql("  AND T.GRANTEE IN ('PUBLIC','PUBLIC*')")
  x=sql("  AND T."privcols" ='*'      ") /* handle update/references*/
  x=sql("  AND T."privauth"<>' '      ")  /* handle update/references*/
  x=sql("  AND C.PRIVILEGE  ='"privilegeValue"'")/* ...              */

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :tcreator, :ttname, :colname"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var tcreator tcreator .
      parse upper var ttname   ttname   .
      parse upper var colname  colname  .

      If model=1 Then prof=Strip(tcreator)'.'Strip(ttname)
      Else prof=ssid'.'Strip(tcreator)'.'Strip(ttname)
      prof=prof'.'Strip(colname)'.UPDATE'
      ssidTableCol = prof
      prof= left(prof,max(55,length(prof)))
      cmd="RALT "class prof" UACC(READ)" ,
         "DATA('Everyone has DB2-"ssid "rdef table/column priv')"
      x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'

     /* Get all ids (except PUBLIC) for access list */
     /*    #1 original sql code was wrong, but we're modifying it */
     /*  anyway.                                                  */
     /*      1)  predicate for T.UPDATEAUTH was wrong             */
     /*       but we've changed that predicate test to be more    */
     /*       generic and return more rows anyway.                */
     /*      2)  C.PRIVILEGE should be blank                      */
     /*    #2 now return T.UPDATEAUTH as well (as authx)          */
     /*    #3 add order by to return UPDATEAUTH="G" before "Y"    */
     /*      and handle both via fetches/code                     */
     /*    #4 rewrite rexx code for sql statement... just to make */
     /*  it readable.                                             */
     /*    #5 changed so either UPDATEAUTH or REFERENCESAUTH is   */
     /*  used.  as we've make this rountine handle both.          */
     /*    note: neither IBM nor we handle "ROLES" */
     /*    note: plans/packages don't need/have racf permits */

  Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
                         /* --------------------------- */

  x = clistCard(' ')
  cmd='/* Get all ids (except PUBLIC) for access list */'
  x = clistCard(cmd)

  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT T.TCREATOR, T.TTNAME, C.COLNAME" )
  x=sql("         ,strip(upper(t.grantee)) as ugrantee"   )
  x=sql("FROM SYSIBM.SYSTABAUTH T, "                      )
  x=sql("     SYSIBM.SYSCOLAUTH C  "                      )
  x=sql("WHERE T.TTNAME      = C.TNAME   "                )
  x=sql("  AND T.TCREATOR   <> T.GRANTEE "                )
  x=sql("  AND T.TCREATOR    = C.CREATOR "                )
  x=sql("  AND C.CREATOR    <> C.GRANTEE "                )
  x=sql("  AND T.GRANTEETYPE = ' '       "                )
  x=sql("  AND T.GRANTEETYPE = ' '  " )/* authid (no roles or pgms*/
  x=sql("  AND C.GRANTEETYPE = ' '  " )/* authid (no roles or pgms*/
  x=sql("  and T.DATEGRANTED = C.DATEGRANTED"             )
  x=sql("  And T.TIMEGRANTED = C.TIMEGRANTED"             )
  x=sql("  AND T.GRANTEE NOT IN ('PUBLIC','PUBLIC*')"     )
  x=sql("  AND T."privcols" ='*'      ") /* handle update/references*/
  x=sql("  AND T."privauth"<>' '      ")  /* handle update/references*/
  x=sql("  AND C.PRIVILEGE  ='"privilegeValue"'")  /* ...            */

 if removeUserList <> ''
 then do
  x=sql("  AND T.GRANTEE not in" RemoveUserList           )
  x=sql("  AND C.GRANTEE not in" RemoveUserList           )
 end

  x=sql("ORDER BY T.TCREATOR, T.TTNAME, C.COLNAME, ugrantee")

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx ,
    "EXECSQL FETCH C1 INTO :tcreator, :ttname, :colname, :grantee,"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var tcreator tcreator .
      parse upper var ttname   ttname   .
      parse upper var colname  colname  .

      If model=1 Then prof=Strip(tcreator)'.'Strip(ttname)
      Else prof=ssid'.'Strip(tcreator)'.'Strip(ttname)
      prof=prof'.'Strip(colname)'.'auth
      prof= left(prof,max(55,length(prof)))
      parse upper var grantee grantee . /* strip and upper case */

      access = 'ACC(READ)' /* all access read, not grant */
      cmd="PERMIT "prof" CLASS("class")" access "ID("grantee")"
      x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'

    /* With Grants */
       /* delete sql, already handled both ...AUTH=Y or AUTH=G */
    /* end "with grant */


  Rdef$Permit = 'RDEF' /* all output to rdef datasets */
                       /* --------------------------- */
  x = clistCard(' ')
  cmd = '   /* tab_col: processing complete for auth='auth '*/'
  x = clistCard(cmd)
  x = clistCard(' ')

  rdef$PERMIT = 'PERMIT'
  x = clistCard(' ')
  cmd = '   /* tab_col: processing complete for auth='auth '*/'
  x = clistCard(cmd)
  x = clistCard(' ')

Return    /* tab_upd */


use_priv:
/*****************************************************************/
/* Get DB2 USE privileges (stogroup, tablespace, jar, dist.type) */
/*****************************************************************/
  Arg auth,obtype,type
  If model=1 Then class="M"ssid||type||charopt
  Else class="M"classmnt||type||charopt

  Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
                         /* --------------------------- */
  useClass = class

  /* create "backstop" so that everything else is rejected */
  /* ----------------------------------------------------- */
  x = clistCard(' ')
  cmd='/* create backstop RDEF (in use_priv: routine) */'
  x = clistCard(cmd)

  if      obtype = 'S'
  then extra = "DATA('backstop for DB2-"ssid "stogroup')"
  else if obtype = 'R'
  then extra = "DATA('backstop for DB2-"ssid "tablespace')"
  else if obtype = 'J'
  then extra = "DATA('backstop for DB2-"ssid "jar')"
  else if obtype = 'D'
  then extra = "DATA('backstop for DB2-"ssid "distinct type')"
  else extra = ''

  if obtype = 'R'
  then prof = '*.*.'auth
  else prof = '*.'auth

  If model=1 Then prof=prof
             Else prof=ssid'.'prof
  prof= left(prof,max(20,length(prof)))

  cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
      "OWNER("owner")" ,
      extra /* rph */
  x = clistCard(cmd)
  x = clistCard(' ')

  /* for comments below */
  /* ------------------ */
  if      obtype = 'S'
  then extra = "DATA('DB2-"ssid "use priv for stogroup')"
  else if obtype = 'R'
  then extra = "DATA('DB2-"ssid "use priv for tablespace')"
  else if obtype = 'J'
  then extra = "DATA('DB2-"ssid "use priv for jar')"
  else if obtype = 'D'
  then extra = "DATA('DB2-"ssid "use priv for distinct type')"
  else extra = ''

      /* Find all objects, and make commands to create profiles */
      /* for 'auth'. Then remove executor from access list.     */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT NAME"                        )

    if obtype = 'R'
  then ,
  x=sql("               ,QUALIFIER"                   )

  x=sql("FROM SYSIBM.SYSRESAUTH"                      )
  x=sql("WHERE OBTYPE='"obtype"'"                     )

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    if obtype = 'R'
    then address dsnrexx "EXECSQL FETCH C1 INTO :name, :qualifier"
    else address dsnrexx "EXECSQL FETCH C1 INTO :name"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var name name .
      parse upper var qualifier qualifier . /* potentially dbname*/

      if obtype = 'R' then name = qualifier'.'name

      If model=1 Then prof=Strip(name)'.'auth
      Else prof=ssid'.'Strip(name)'.'auth
      prof= left(prof,max(20,length(prof)))
      cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
          "OWNER("owner")" ,
          extra /* rph */
      x = clistCard(cmd)

      cmd="PERMIT "prof" CLASS("class") RESET"
      if resetOption = 'RESET' then x = clistCard(cmd)
    End
  End /* do until */

  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'

     /* If any of those were PUBLIC, change UACC to READ */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT NAME"                   )

    if obtype = 'R'
  then ,
  x=sql("               ,QUALIFIER"              )

  x=sql("FROM SYSIBM.SYSRESAUTH"                 )
  x=sql("WHERE OBTYPE='"obtype"'"                )
  x=sql("  AND USEAUTH¬=' '"                     )
  x=sql("  AND GRANTEE IN ('PUBLIC','PUBLIC*')"  )

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    if obtype = 'R'
    then address dsnrexx "EXECSQL FETCH C1 INTO :name, :qualifier"
    else address dsnrexx "EXECSQL FETCH C1 INTO :name"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var name name .
      parse upper var qualifier qualifier . /* potentially dbname*/

      if obtype = 'R' then name = qualifier'.'name


      If model=1 Then prof=Strip(name)'.'auth
      Else prof=ssid'.'Strip(name)'.'auth
      prof= left(prof,max(35,length(prof)))
      cmd="RALT "class prof" UACC(READ)" ,
         "DATA('Everyone has" auth "priv on" name"')"
      x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'

  Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
                         /* --------------------------- */

     /* Get all ids (except PUBLIC) for access list */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT NAME"                              )
  x=sql("               ,strip(upper(grantee)) as ugrantee" )

    if obtype = 'R'
  then ,
  x=sql("               ,QUALIFIER"                         )

  x=sql("FROM SYSIBM.SYSRESAUTH"                            )
  x=sql("WHERE OBTYPE='"obtype"'"                           )
  x=sql("  AND USEAUTH<>' '"                                )
  x=sql("  AND GRANTEE NOT IN ('PUBLIC','PUBLIC*')"         )
 if SlimAdm
 then do
  x=sql("  AND GRANTEE NOT IN (select distinct grantee"     )
  x=sql("                      from sysibm.sysuserauth"     )
  x=sql("                      where sysadmauth <> ' '"     )
  x=sql("                     )"                            )
 end

  if removeUserList <> ''
  then ,
  x=sql("  AND GRANTEE not in" RemoveUserList               )

  x=sql("ORDER BY name, ugrantee"                           )

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    if obtype = 'R'
    then address dsnrexx "EXECSQL FETCH C1 INTO :name, :grantee" ,
                                             ", :qualifier"
    else address dsnrexx "EXECSQL FETCH C1 INTO :name, :grantee"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var name name .
      parse upper var grantee grantee .
      parse upper var qualifier qualifier . /* potentially dbname*/

      if obtype = 'R' then name = qualifier'.'name

      datacomment = ,
         "DATA('(READ); migrated" date('U')"')"

      If model=1 Then prof=Strip(name)'.'auth
      Else prof=ssid'.'Strip(name)'.'auth
      prof= left(prof,max(35,length(prof)))
      cmd="PERMIT "prof" CLASS("class") ACC(READ)",
        "ID("Strip(grantee)")" ,
        datacomment
      x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'
Return    /* use_priv */


BP_use_priv:
/*****************************************************************/
/* Get DB2 USE privileges (bufferpool, stogroup, tablespace)     */
/*****************************************************************/
  Arg auth,obtype,type
  If model=1 Then class="M"ssid||type||charopt
  Else class="M"classmnt||type||charopt

  Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
                         /* --------------------------- */
  useClass = class

  /* create "backstop" so that everything else is rejected */
  /* ----------------------------------------------------- */
  x = clistCard(' ')
  cmd='/* create backstop RDEF (in bp_use_priv: routine) */'
  x = clistCard(cmd)

  extra = "DATA('backstop for DB2-"ssid "bufferpool')"

  If model=1 Then prof='ALL.'auth
             Else prof=ssid'.ALL.'auth
  prof= left(prof,max(20,length(prof)))

  cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
      "OWNER("owner")" ,
      extra /* rph */
  x = clistCard(cmd)
  x = clistCard(' ')


      /* Find all objects (and whether PUBLIC or specific rules)*/
      /* Them create rdef's                                     */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT NAME, SPEC"                  )
  x=sql("from ("                                      )
  x=sql("     select distinct"                        )
  x=sql("        case when strip(a.name) = 'ALL' then '*'")
  x=sql("             else strip(a.name)"               )
  x=sql("             end             as name"        )
  x=sql("            ,'PUBLIC'        as spec"        )
  x=sql("        from sysibm.sysresauth a"            )
  x=sql("        where a.obtype='B' "                 )
  x=sql("          and a.useAuth <> ' '"              )
  x=sql("          and a.grantee in ('PUBLIC','PUBLIC*')")
  x=sql("    union"                                   )
  x=sql("     select distinct"                        )
  x=sql("        case when strip(b.name) = 'ALL' then '*'")
  x=sql("             else strip(b.name)"               )
  x=sql("             end             as name"        )
  x=sql("            ,'SPEC'          as spec"        )
  x=sql("        from sysibm.sysresauth b"            )
  x=sql("        where b.obtype='B' "                 )
  x=sql("          and b.useAuth <> ' '"              )
  x=sql("          and b.grantee"                     )
  x=sql("                not in ('PUBLIC','PUBLIC*')" )
  x=sql("          and not exists ("                  )
  x=sql("            select 1"                        )
  x=sql("            from sysibm.sysresauth c"        )
  x=sql("            where c.obtype='B' "             )
  x=sql("              and c.useAuth <> ' '"          )
  x=sql("              and c.grantee"                 )
  x=sql("                    in ('PUBLIC','PUBLIC*')" )
  x=sql("              and c.name = b.name"           )
  x=sql("                         )"                  )
  x=sql("     )"                                      )
  x=sql("order by name, spec"                         )

  call ZSQL

  rowsReturned = 0
  skiprest = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :name, :spec"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var name name .

      if name = '*'
      then name = 'ALL' /* we wanted this to be 1st in sort order*/

      if name = 'ALL' & spec = 'PUBLIC'
      then do /* special case; have to override backstop */
         If model=1 Then prof=Strip(name)'.'auth
         Else prof=ssid'.'Strip(name)'.'auth
         prof= left(prof,max(35,length(prof)))
         cmd="RALT "class prof" UACC(READ)" ,
            "DATA('Everyone has" auth "priv on ALL bufferpools')"
         x = clistCard(cmd)
         skiprest = 1 /* ignore other rows*/
         iterate
      end

      if skiprest = 1
      then iterate /* if everyone has access, skip the rest */

      If model=1 Then prof=Strip(name)'.'auth
      Else prof=ssid'.'Strip(name)'.'auth
      prof= left(prof,max(20,length(prof)))

      if spec = 'PUBLIC'
      then do
         cmd="RDEF "class prof" UACC(READ) AUDIT(ALL(READ))",
             "OWNER("owner")" ,
             "DATA('DB2-"ssid "Everyone has" auth "priv on" name"')"
      end
      else do
         /* for comments below */
         /* ------------------ */
         cmd = 'RDEF'
         if name = 'ALL'
         then cmd = 'RALT'
         cmd=cmd class prof" UACC(NONE) AUDIT(ALL(READ))",
             "OWNER("owner")" ,
             "DATA('DB2-"ssid "use priv for bufferpool" name"')"
      end

      x = clistCard(cmd)

      cmd="PERMIT "prof" CLASS("class") RESET"
      if resetOption = 'RESET' then x = clistCard(cmd)
    End
  End /* do until */

  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'

  if skiprest = 1 /* everyone has bufferpool use? */
  then return     /* yes, nothing else to do */

  Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
                         /* --------------------------- */
     /* Get all ids (except PUBLIC) for access list */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT NAME, UGRANTEE"                       )
  x=sql("from ("                                               )
  x=sql("   SELECT DISTINCT a.NAME                  as name"   )
  x=sql("                  ,strip(upper(a.grantee)) as ugrantee")
  x=sql("   FROM SYSIBM.SYSRESAUTH a"                          )
  x=sql("   WHERE a.OBTYPE='"obtype"'"                         )
  x=sql("     AND a.USEAUTH<>' '"                              )
  x=sql("     AND not exists ("                                )
  x=sql("            select 1"                                 )
  x=sql("            from sysibm.sysresauth b"                 )
  x=sql("            where a.obtype = b.obtype"                )
  x=sql("              and a.obtype = '"obtype"'"              )
  x=sql("              and a.name   = b.name"                  )
  x=sql("              and a.useauth <> ' '"                   )
  x=sql("              and b.useauth <> ' '"                   )
  x=sql("              and b.grantee in ('PUBLIC','PUBLIC*')"  )
  x=sql("                    )"                                )
 if SlimAdm
 then do
  x=sql("     AND a.GRANTEE NOT IN (select distinct grantee"   )
  x=sql("                           from sysibm.sysuserauth"   )
  x=sql("                           where sysadmauth <> ' '"   )
  x=sql("                          )"                          )
 end

  if removeUserList <> ''
  then ,
  x=sql("     AND GRANTEE not in" RemoveUserList               )

  x=sql("  UNION"                                              )

  x=sql("   SELECT DISTINCT a.NAME                  as name"   )
  x=sql("                  ,strip(upper(b.grantee)) as ugrantee")
  x=sql("   FROM SYSIBM.SYSRESAUTH A"                          )
  x=sql("       ,SYSIBM.SYSRESAUTH B"                          )
  x=sql("   WHERE A.OBTYPE='"obtype"'"                         )
  x=sql("     AND a.USEAUTH<>' '"                              )
  x=sql("     AND not exists ("                                )
  x=sql("            select 1"                                 )
  x=sql("            from sysibm.sysresauth c"                 )
  x=sql("            where a.obtype = c.obtype"                )
  x=sql("              and a.obtype = '"obtype"'"              )
  x=sql("              and a.name   = c.name"                  )
  x=sql("              and a.useauth <> ' '"                   )
  x=sql("              and c.useauth <> ' '"                   )
  x=sql("              and c.grantee in ('PUBLIC','PUBLIC*')"  )
  x=sql("                    )"                                )
  x=sql("     and b.OBTYPE='"obtype"'"                         )
  x=sql("     AND b.USEAUTH<>' '"                              )
  x=sql("     AND a.name   <> 'ALL'"                           )
  x=sql("     AND b.name    = 'ALL'"                           )
 if SlimAdm
 then do
  x=sql("     AND b.GRANTEE NOT IN (select distinct grantee"   )
  x=sql("                           from sysibm.sysuserauth"   )
  x=sql("                           where sysadmauth <> ' '"   )
  x=sql("                          )"                          )
 end

  if removeUserList <> ''
  then ,
  x=sql("     AND b.GRANTEE not in" RemoveUserList             )

  x=sql("     )"                                               )
  x=sql("ORDER BY name, ugrantee"                              )

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :name, :grantee"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var name name .
      parse upper var grantee grantee .

      datacomment = ,
         "DATA('(READ); migrated" date('U')"')"

      If model=1 Then prof=Strip(name)'.'auth
      Else prof=ssid'.'Strip(name)'.'auth
      prof= left(prof,max(35,length(prof)))
      cmd="PERMIT "prof" CLASS("class") ACC(READ)",
        "ID("Strip(grantee)")" ,
        datacomment
      x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'
  return
Return    /* use_priv */

pack_priv:
/*****************************************************************/
/* Get DB2 Package privileges                                    */
/*    This gets tricky, because SYSPACKAUTH has COLLID and       */
/* can have * for NAME (Package ID).  We must define all the     */
/* permits with * first, then PERMIT FROM(xx.*) as well as the   */
/* normal permits.                                               */
/*                                                               */
/*    We also ignore any row where GRANTEETYPE='P' (for access)  */
/*                                                               */
/*    Note, PERMIT FROM(xx.*) can cause a lot of warnings because*/
/* of, in effect, duplicate 'permits' for grantee's already in   */
/* a specific profile.  Therefore, select has been changed so    */
/* that for a specific profile, we only add the missing permits  */
/* expliticly instead.                                           */
/*****************************************************************/
  Arg auth,col
  If model=1 Then class="M"ssid"PK"charopt
  Else class="M"classmnt"PK"charopt


  handledCollid.  = 0 /* 0 = explicit; 1 = collid.* to public */

  IgnoreCollid = ''
  CollidComma  = ' '

  Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
                         /* --------------------------- */

  useClass    = class    /* direct comments to this class */
                         /* ----------------------------- */

  /* create "backstop" so that everything else is rejected */
  /* ----------------------------------------------------- */
  x = clistCard(' ')
  cmd='/* create backstop RDEF (in pack_priv: routine) */'
  x = clistCard(cmd)

  If model=1 Then prof='*.*'
  Else prof=ssid'.*.*'
  prof=prof'.'auth
  prof= left(prof,max(41,length(prof)))
  data='Backstop for' auth 'on collid/pkg *.*'

  x = clistCard(' ')
  cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
      "OWNER("owner")" ,
        "DATA('"data"')"
  x = clistCard(cmd)
  x = clistCard(' ')

          /* identify some pkges we believe could have generic rules*/
          /* look at packages + packauth to return the following    */
          /* for each collid, if appropriate.                       */
          /*                                                        */
          /* "all*pkgs" will only appear for collid.* to public     */
          /*           (sometime appears)                           */
          /*                                                        */
          /* "allspec"  will only appear if at least one pkg was    */
          /*           granted to public (sometimes appears)        */
          /*                                                        */
          /* "pkgTotal" will give us a count of distinct packages   */
          /*           for a given collid (always appears)          */
          /*                                                        */
          /* -----------------------------------------------------  */
          /* collid, "all*pkgs", 1: for grant collid.* to PUBLIC    */
          /*                                                        */
          /* collid, "allspec", count(*) of distinct packages       */
          /*                        for grant collid.pkg to PUBLIC  */
          /*                                                        */
          /* collid, "pkgTotal", count(*) for all distinct packages */
          /*                                                        */
          /* -----------------------------------------------------  */
  x = clistCard("/* PackPriv.  GenericOption SQL */")
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql(" Select collid, 'PKGTOTAL' as nameX, count(*)"   )
  x=sql('    from (select distinct'                       )
  x=sql('               collid'                           )
  x=sql('              ,name'                             )
  x=sql('          from sysibm.syspackage'                )
  x=sql('         )'                                      )
  x=sql('    group by collid'                             )
  x=sql('union'                                           )
  x=sql(" Select collid, 'ALL*PKGS' as nameX, count(*)"   )
  x=sql("    from ("                                      )
  x=sql("          select distinct a.collid"              )
  x=sql("          from sysibm.syspackauth as a"          )
  x=sql("          where a.granteeType = ' '"             )
  x=sql("            and a.name        = '*'"             )
  x=sql("            and a."col "<>' '"                   )
  x=sql("            and exists"                          )
  x=sql("               ("                                )
  x=sql("                select 1"                        )
  x=sql("                from sysibm.syspackauth as b"    )
  x=sql("                where b.granteeType = ''"        )
  x=sql("                  and b.name   = '*'"            )
  x=sql("                  and b.collid = a.collid"       )
  x=sql("                  and b."col "<> ' '"            )
  x=sql("                  and (   b.grantee = 'PUBLIC' " )
  x=sql("                       or b.grantee = 'PUBLIC*'" )
  x=sql("                      )"                         )
  x=sql("               )"                                )
  x=sql("         )"                                      )
  x=sql('    group by collid'                             )
  x=sql('union'                                           )
  x=sql(" Select collid, 'ALLSPEC ' as namex, count(*)"   )
  x=sql(' from (select distinct'                          )
  x=sql('           k.collid'                             )
  x=sql('          ,k.name'                               )
  x=sql("        from sysibm.syspackage as k"             )
  x=sql("       where exists"                             )
  x=sql("           ("                                    )
  x=sql("           select 1"                             )
  x=sql("           from sysibm.syspackauth as d"         )
  x=sql("           where d.granteeType = ''"             )
  x=sql("             and d."col "<> ' '"                 )
  x=sql("             and d.collid = k.collid"            )
  x=sql("             and d.name = k.name"                )
  x=sql("             and (   d.grantee = 'PUBLIC' "      )
  x=sql("                  or d.grantee = 'PUBLIC*'"      )
  x=sql("                 )"                              )
  x=sql("           )"                                    )
  x=sql("      )"                                         )
  x=sql(' group by collid'                                )
  x=sql('order by collid, nameX'                          )

  call ZSQL

  lastCollid = ''
  lastAllpkgCount = 0
  lastAllspecCount= 0
  lastPkgCount    = 0
  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :collid, :nameX, :countx"
    If SQLCODE = 0
    then do
       rowsReturned = rowsReturned + 1
       parse upper var collId collId .
       parse upper var namex  namex  .
       if handledCollid.collid = 1
       then iterate /* ALL*PKGS = one generic collid.* public*/

       if namex = 'ALL*PKGS'
       then do
          /* generate generic RDEF */

          /* change-07/25/2023 fixed to use "collid" instead */
          /*                   of lastCollid                 */
          handledCollid.collid = 1 /* indicate we handled it */
          ignoreCollid = ignoreCollid collidComma"'"Collid"'"

          collidComma  = ',' /*seperate with comma's going forward*/

          If model=1 Then prof=Collid'.*'
          Else prof=ssid'.'Collid'.*'
          prof=prof'.'auth
          prof= left(prof,max(41,length(prof)))
          data='Everyone has' auth 'on collid' Collid'.*'

          x = clistCard(' ')
          cmd="RDEF "class prof" UACC(READ) AUDIT(ALL(READ))",
              "OWNER("owner")" ,
                "DATA('"data"')"

          x = clistCard(cmd)

          cmd="PERMIT "prof" CLASS("class") RESET"
          if resetOption = 'RESET' then x = clistCard(cmd)
          iterate
       end
       if collid <> lastCollid
       then do
                  /* just re=init for next time */
                  /* could be that we had PUBLIC grants */
                  /* ... but for a collection with no   */
                  /*    packages.  So we will ignore it */
          lastCollid = collid /* update last Collid */
          if nameX = 'ALLSPEC'
          then lastAllSpecCount = countx
          iterate
       end

       /* same collid w/two rows, if we got here.               */
       /*                                                       */
       /* As any row with "ALL*PKGS" prevented us from getting  */
       /* here, this must be "PKGTOTAL" after we saw an         */
       /* "ALLSPEC" row.                                        */
       /*                                                       */
       /* Note:  not only was "ALL*PKGS" handled above, if any. */
       /*    but that would also ensure handleCollid.collid=1   */
       /*    and all subsequent rows for that collid were       */
       /*    ignored (via an iterate) before we ever got here.  */
       /*                                                       */
       /*                                                       */
       lastPkgCount = countx

       /* this was last row for this collid (namex = PKGTOTAL) */
       if lastAllSpecCount = lastPkgCount ,
              & lastPkgCount   > 3
       then do /* create a generic creator.*.priv uacc(Read)*/
          /* all packages have PUBLIC access for this collid */

          handledCollid.lastCollid= 1 /* indicate we handled it */
          ignoreCollid = ignoreCollid collidComma"'"lastCollid"'"

          collidComma  = ',' /*seperate with comma's going forward*/

          If model=1 Then prof=lastCollid'.*'
          Else prof=ssid'.'lastCollid'.*'
          prof=prof'.'auth
          prof= left(prof,max(41,length(prof)))
          data='Everyone has' auth 'on collid' lastCollid'.*'

          x = clistCard(' ')
          cmd="RDEF "class prof" UACC(READ) AUDIT(ALL(READ))",
              "OWNER("owner")" ,
                "DATA('"data"')"

          x = clistCard(cmd)

          cmd="PERMIT "prof" CLASS("class") RESET"
          if resetOption = 'RESET' then x = clistCard(cmd)
       end
               /* as thiw row was "PKGTOTAL" ...       */
       iterate /* next row will be start of new collid */
    end
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'

  trace 'n'

  if ignoreCollid <> ''
  then ignoreCollid = '('ignoreCollid')'

      /* Find ALL packages with explicit names (to public) that  */
      /* we need to create rdef's for.                           */
      /* Note:  ignoreCollid will exclude all collid.* RDEF's    */
      /*    we created above.                                    */
  x = clistCard("/* PackPriv.  SQL (all) explicit public */")
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT COLLID, NAME"                 )
  x=sql("  FROM SYSIBM.SYSPACKAUTH"                    )
  x=sql("  WHERE" col "<> ' '"                         )
  x=sql("    and granteetype = ' '"                    )
  x=sql("    and grantee in ('PUBLIC','PUBLIC*')"      )

  if ignoreCollid <> ''
  then ,
  x=sql('    and COLLID NOT IN' ignoreCollid )/* eliminate these */

  x=sql("ORDER by COLLID, NAME"                        )

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :collid, :name"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var collId collId .
      parse upper var name   name   .

      If model=1 Then prof=Strip(collid)'.'Strip(name)'.'auth
      Else prof=ssid'.'Strip(collid)'.'Strip(name)'.'auth
      prof= left(prof,max(35,length(prof)))
      cmd="RDEF "class prof" UACC(READ) AUDIT(ALL(READ))",
          "OWNER("owner")" ,
         "DATA('Everyone has" ssid auth "for pkg" strip(collid)'.' ,
             || strip(name)"')"
      x = clistCard(cmd)

      cmd="PERMIT "prof" CLASS("class") RESET"
      if resetOption = 'RESET' then x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'

         /* change-07/25/2023 reduce number of rdefs by making   */
         /*                   sure we actually need an explicit  */
         /*                   one.                               */
      /* Find ALL (explicit) packages that have at least one     */
      /* unique grant/permit that isn't in generic collid.*      */
  x = clistCard("/* PackPriv.  SQL 3 (all) explicit non-public */")
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT a.COLLID, a.NAME"    )
  x=sql("    FROM SYSIBM.SYSPACKAUTH as a"    )
  x=sql("    WHERE a."col "<> ' '"            )
  x=sql("      and a.granteetype = ' '"       )

  if ignoreCollid <> ''
  then ,
  x=sql('    and a.COLLID NOT IN' ignoreCollid)/* eliminate these */

  if removeUserList <> ''
  then ,
  x=sql("    and a.GRANTEE not in" RemoveUserList   )

  x=sql("    and not exists /* ignore rdef for public */"   )
  x=sql("       ("                                          )
  x=sql("        select 1"                                  )
  x=sql("        from sysibm.sysPackAuth as b"              )
  x=sql("        where b."col "<> ' '"                      )
  x=sql("          and b.granteeType = ' '"                 )
  x=sql("          and b.collid = a.collid"                 )
  x=sql("          and b.name   = a.name"                   )
  x=sql("          and b.grantee in ('PUBLIC','PUBLIC*')"   )
  x=sql("       )"                                          )

  x=sql("    and exists /* must have grant not in pkg.* */" )
  x=sql("       ("                                          )
  x=sql("        select 1"                                  )
  x=sql("        from sysibm.sysPackAuth as c"              )
  x=sql("        where c."col "<> ' '"                      )
  x=sql("          and c.granteeType = ' '"                 )
  x=sql("          and c.collid = a.collid"                 )
  x=sql("          and c.name   = a.name"                   )
  x=sql("          and c.grantee not in ("                  )
  x=sql("            select d.grantee"                      )
  x=sql("            from sysibm.sysPackAuth as d"          )
  x=sql("            where d."col "<> ' '"                  )
  x=sql("              and d.granteeType = ' '"             )
  x=sql("              and d.collid = c.collid"             )
  x=sql("              and d.name   = '*'"                  )
  x=sql("              and d.name  <> c.name"               )

  if removeUserList <> ''
  then ,
  x=sql("              and d.GRANTEE not in" RemoveUserList )
  x=sql("                               )"                  )
  x=sql("       )"                                          )
  x=sql("ORDER by COLLID, NAME"                             )
  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :collid, :name"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var collid collid .
      parse upper var name   name   .

      If model=1 Then prof=collid'.'name'.'auth
      Else prof=ssid'.'collid'.'name'.'auth
      prof= left(prof,max(35,length(prof)))
      cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
          "OWNER("owner")" ,
         "DATA('DB2-"ssid auth "for pkg ssid.collection.pkgname')"
      x = clistCard(cmd)

      cmd="PERMIT "prof" CLASS("class") RESET"
      if resetOption = 'RESET' then x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'


  Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
                         /* --------------------------- */

  /* change-07/25/2023 --- new sql statement to just collect */
  /*                       any grants for all collid.        */
  /*                       We will use them later            */

  x = clistCard("/* PackPriv.  SQL 4.1 get collid.* permits */")
  x=sql("New Statement")
  x=sql("SELECT DISTINCT a.collid, a.name, a.grantee" )
  x=sql("    FROM SYSIBM.SYSPACKAUTH as a"    )
  x=sql("    WHERE a."col "<> ' '"            )
  x=sql("      and a.name   = '*'"            )
  x=sql("      and a.granteetype = ' '"       )

  if ignoreCollid <> ''
  then ,
  x=sql('    and a.COLLID NOT IN' ignoreCollid)/* eliminate these */

  if removeUserList <> ''
  then ,
  x=sql("    and a.GRANTEE not in" RemoveUserList   )

  x=sql("    and not exists /* ignore rdef for public */"   )
  x=sql("       ("                                          )
  x=sql("        select 1"                                  )
  x=sql("        from sysibm.sysPackAuth as b"              )
  x=sql("        where b."col "<> ' '"                      )
  x=sql("          and b.granteeType = ' '"                 )
  x=sql("          and b.collid = a.collid"                 )
  x=sql("          and b.name   = a.name"                   )
  x=sql("          and b.grantee in ('PUBLIC','PUBLIC*')"   )
  x=sql("       )"                                          )

  x=sql("ORDER by COLLID, NAME, GRANTEE"                    )

  call ZSQL

  grantInGeneric.= 0
  rowsReturned = 0
  Do Until SQLCODE \= 0
     address dsnrexx "EXECSQL FETCH C1 INTO :collid, :name, :grantee"
     If SQLCODE = 0
     then do
        rowsReturned = rowsReturned + 1
        parse upper var collid  collid  .
        parse upper var grantee grantee .
        grantInGeneric.collid.0 = grantInGeneric.collid.0 + 1
        grantInGeneric = grantInGeneric.collid.0
        grantInGeneric.collid.grantInGeneric = grantee
     end
  end
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'


  x = clistCard("/* PackPriv.  SQL 4.2 (all) permit '*' non-public */")

  /* change-07/25/2023 --- modifed sql statement to collect  */
  /*                       any grants for a specific package */
  /*                       in a collid (that aren't in       */
  /*                       collid.*)                         */
  /*                                                         */
  /*                       If none are found, we won't need  */
  /*                       need to generate any permits.  If */
  /*                       some are found, also add the      */
  /*                       generic permits to this explicit  */
  /*                       profile.                          */

     /* Get all ids (except PUBLIC) for access list to '*' packs */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT a.COLLID, a.NAME, a.grantee"       )
  x=sql("    FROM SYSIBM.SYSPACKAUTH as a"    )
  x=sql("    WHERE a."col "<> ' '"            )
  x=sql("      and a.granteetype = ' '"       )

  if ignoreCollid <> ''
  then ,
  x=sql('    and a.COLLID NOT IN' ignoreCollid)/* eliminate these */

  if removeUserList <> ''
  then ,
  x=sql("    and a.GRANTEE not in" RemoveUserList   )

  x=sql("    and not exists /* ignore rdef for public */"   )
  x=sql("       ("                                          )
  x=sql("        select 1"                                  )
  x=sql("        from sysibm.sysPackAuth as b"              )
  x=sql("        where b."col "<> ' '"                      )
  x=sql("          and b.granteeType = ' '"                 )
  x=sql("          and b.collid = a.collid"                 )
  x=sql("          and b.name   = a.name"                   )
  x=sql("          and b.grantee in ('PUBLIC','PUBLIC*')"   )
  x=sql("       )"                                          )

  x=sql("    and a.grantee in   /* grant not in pkg.* */"   )
  x=sql("       ("                                          )
  x=sql("        select c.grantee"                          )
  x=sql("        from sysibm.sysPackAuth as c"              )
  x=sql("        where c."col "<> ' '"                      )
  x=sql("          and c.granteeType = ' '"                 )
  x=sql("          and c.collid = a.collid"                 )
  x=sql("          and c.name   = a.name"                   )
  x=sql("          and c.grantee not in ("                  )
  x=sql("            select d.grantee"                      )
  x=sql("            from sysibm.sysPackAuth as d"          )
  x=sql("            where d."col "<> ' '"                  )
  x=sql("              and d.granteeType = ' '"             )
  x=sql("              and d.collid = c.collid"             )
  x=sql("              and d.name   = '*'"                  )
  x=sql("              and d.name  <> c.name"               )

  if removeUserList <> ''
  then ,
  x=sql("              and d.GRANTEE not in" RemoveUserList )
  x=sql("                               )"                  )
  x=sql("       )"                                          )
  x=sql("ORDER by COLLID, NAME, GRANTEE"                    )

  call ZSQL

  rowsReturned = 0
  lastCollid = ''
  lastname   = ''
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :collid, :name, :grantee"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var collid collid .
      parse upper var name name .
      parse upper var grantee grantee .
      if lastCollid <> collid
      then do /* set up for switch */
         lastCollid = collid /* we switched collids */
         lastName = ''       /* ...implies, we switched names too */
      end

      if lastName <> name
      then do
         /* add grants from collid.* to this (explict) collid.name */
         If model=1 Then prof=collid'.'name'.'auth
         Else prof=ssid'.'collid'.'name'.'auth
         prof= left(prof,max(55,length(prof)))
         if grantInGeneric.collid.0 > 0 & name <> '*'
         then do i4 = 1 by 1 for grantInGeneric.collid.0
            cmd="PERMIT "prof" CLASS("class") ACC(READ)" ,
                              "ID("grantInGeneric.collid.i4")"
            x = clistCard(cmd)
         end
         lastName = name /* but only add them once per name */
      end
      If model=1 Then prof=collid'.'name'.'auth
      Else prof=ssid'.'collid'.'name'.'auth
      prof= left(prof,max(55,length(prof)))
      cmd="PERMIT "prof" CLASS("class") ACC(READ) ID("grantee")"
      x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'

  /* change-07/25/2023 "sql 5" which caused problems removed */
  /*                       also permit missing acc(read) was */
  /*                       in the sql 5 code.                */
  /*                   "sql 4.1 and 4.2 replaced that.       */

Return     /* pack_priv */

cltn_priv:
/*****************************************************************/
/* Get DB2 Collection privileges                                 */
/*    This gets tricky, because SYSRESAUTH with OBTYPE='C'       */
/* can have * for NAME (Collection ID).  We must define all      */
/* the permits with * first, then PERMIT FROM(xx.*) as well as  */
/* the normal permits.                                           */
/*                                                               */
/*    Note, PERMIT FROM(xx.*) can cause a lot of warnings because*/
/* of, in effect, duplicate 'permits' for grantee's already in   */
/* a specific profile.  Therefore, select has been changed so    */
/* that for a specific profile, we only add the missing permits  */
/* expliticly instead.                                           */
/*****************************************************************/
  Arg auth
     /* Note: auth is always CREATEIN for Collections */
  If model=1 Then class="M"ssid"CL"charopt
  Else class="M"classmnt"CL"charopt

  Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
                         /* --------------------------- */
  useClass = class

  /* create "backstop" so that everything else is rejected */
  /* ----------------------------------------------------- */
  x = clistCard(' ')
  cmd='/* create backstop RDEF (in cltn_priv: routine) */'
  x = clistCard(cmd)

  If model=1 Then prof="*."auth
  Else prof=ssid".*."auth
  prof= left(prof,max(25,length(prof)))
  cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
    "OWNER("owner")" ,
     "DATA('Backstop DB2-"ssid auth "priv for collection')"
  x = clistCard(cmd)
  x = clistCard(' ')

      /* Find all objects, and make commands to create profiles */
      /* for 'auth'. Then remove executor from access list.     */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT NAME, SPEC"                  )
  x=sql("from ("                                      )
  x=sql("     select distinct a.name as name"         )
  x=sql("                  ,'PUBLIC' as spec"         )
  x=sql("        from sysibm.sysresauth a"            )
  x=sql("        where a.obtype='C' "                 )
  x=sql("          and a.QUALIFIER='        '"        )
  x=sql("          and a.grantee in ('PUBLIC','PUBLIC*')")
  x=sql("    union"                                   )
  x=sql("     select distinct b.name as name"         )
  x=sql("                  ,'SPEC'   as spec"         )
  x=sql("        from sysibm.sysresauth b"            )
  x=sql("        where b.obtype='C' "                 )
  x=sql("          and b.QUALIFIER='        '"        )
  x=sql("          and b.grantee"                     )
  x=sql("                not in ('PUBLIC','PUBLIC*')" )
  x=sql("          and not exists ("                  )
  x=sql("            select 1"                        )
  x=sql("            from sysibm.sysresauth c"        )
  x=sql("            where c.obtype='C' "             )
  x=sql("              and b.QUALIFIER='        '"    )
  x=sql("              and c.grantee"                 )
  x=sql("                    in ('PUBLIC','PUBLIC*')" )
  x=sql("              and c.name = b.name"           )
  x=sql("                         )"                  )
  x=sql("     )"                                      )
  x=sql("order by name, spec"                         )

  call ZSQL

  /* now create collections */
  rowsReturned = 0
  skiprest = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :name, :spec"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var name name .

      if name = '*' & spec = 'PUBLIC'
      then do /* special case; have to override backstop */
         If model=1 Then prof=Strip(name)"."auth
         Else prof=ssid"."Strip(name)"."auth
         prof= left(prof,max(25,length(prof)))
         cmd="RALT "class prof" UACC(READ) AUDIT(ALL(READ))",
           "OWNER("owner")" ,
            "DATA('DB2-"ssid "Everyone has CREATE 4 all collections')"
         x = clistCard(cmd)

         cmd="PERMIT "prof" CLASS("class") RESET"
         if resetOption = 'RESET' then x = clistCard(cmd)
         skiprest = 1
         iterate
      end

      if skiprest = 1
      then iterate

      cmd = 'RDEF'
      if name = '*' then cmd = 'RALT'

      If model=1 Then prof=Strip(name)"."auth
      Else prof=ssid"."Strip(name)"."auth
      prof= left(prof,max(25,length(prof)))

      if spec = 'PUBLIC'
      then do
         cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
           "OWNER("owner")" ,
            "DATA('DB2-"ssid "Everyone has create priv')" /* rph */
         x = clistCard(cmd)
      end
      else do
         cmd = 'RDEF'
         if name = '*' then cmd = 'RALT'
         cmd=cmd class prof" UACC(NONE) AUDIT(ALL(READ))",
           "OWNER("owner")" ,
            "DATA('DB2-"ssid auth "priv for collection')" /* rph */
         x = clistCard(cmd)
      end

      cmd="PERMIT "prof" CLASS("class") RESET"
      if resetOption = 'RESET' then x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'

  if skiprest = 1 /*everyone has create collection priv? */
  then return     /*yes, nothing else to do              */

  Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
                         /* --------------------------- */

     /* Get all ids (except PUBLIC) for access list create       */
     /* add ids granted to create *                              */
     /* ...other than sysadmins                                  */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT NAME, UGRANTEE"                       )
  x=sql("from ("                                               )
  x=sql("   SELECT DISTINCT a.NAME                  as name"   )
  x=sql("                  ,strip(upper(a.grantee)) as ugrantee")
  x=sql("   FROM SYSIBM.SYSRESAUTH a"                          )
  x=sql("   WHERE a.OBTYPE='C'"                                )
  x=sql("     AND a.QUALIFIER='        '"                      )
  x=sql("     AND a.USEAUTH<>' '"                              )
  x=sql("     AND not exists ("                                )
  x=sql("            select 1"                                 )
  x=sql("            from sysibm.sysresauth b"                 )
  x=sql("            where a.obtype = b.obtype"                )
  x=sql("              and a.obtype = 'C'"                     )
  x=sql("              and a.QUALIFIER='        '"             )
  x=sql("              and b.QUALIFIER='        '"             )
  x=sql("              and a.name   = b.name"                  )
  x=sql("              and a.useauth <> ' '"                   )
  x=sql("              and b.useauth <> ' '"                   )
  x=sql("              and b.grantee in ('PUBLIC','PUBLIC*')"  )
  x=sql("                    )"                                )
 if SlimAdm
 then do
  x=sql("     AND a.GRANTEE NOT IN (select distinct grantee"   )
  x=sql("                           from sysibm.sysuserauth"   )
  x=sql("                           where sysadmauth <> ' '"   )
  x=sql("                          )"                          )
 end

  if removeUserList <> ''
  then ,
  x=sql("     AND GRANTEE not in" RemoveUserList               )

  x=sql("  UNION"                                              )

  x=sql("   SELECT DISTINCT a.NAME                  as name"   )
  x=sql("                  ,strip(upper(b.grantee)) as ugrantee")
  x=sql("   FROM SYSIBM.SYSRESAUTH A"                          )
  x=sql("       ,SYSIBM.SYSRESAUTH B"                          )
  x=sql("   WHERE A.OBTYPE='C'"                                )
  x=sql("     AND a.QUALIFIER='        '"                      )
  x=sql("     AND b.QUALIFIER='        '"                      )
  x=sql("     AND a.USEAUTH<>' '"                              )
  x=sql("     AND not exists ("                                )
  x=sql("            select 1"                                 )
  x=sql("            from sysibm.sysresauth c"                 )
  x=sql("            where a.obtype = c.obtype"                )
  x=sql("              and a.obtype = 'C'"                     )
  x=sql("              and a.QUALIFIER='        '"             )
  x=sql("              and c.QUALIFIER='        '"             )
  x=sql("              and a.name   = c.name"                  )
  x=sql("              and a.useauth <> ' '"                   )
  x=sql("              and c.useauth <> ' '"                   )
  x=sql("              and c.grantee in ('PUBLIC','PUBLIC*')"  )
  x=sql("                    )"                                )
  x=sql("     and b.OBTYPE='C'"                                )
  x=sql("     AND b.USEAUTH<>' '"                              )
  x=sql("     AND a.name   <> '*'"                             )
  x=sql("     AND b.name    = '*'"                             )
 if SlimAdm
 then do
  x=sql("     AND b.GRANTEE NOT IN (select distinct grantee"   )
  x=sql("                           from sysibm.sysuserauth"   )
  x=sql("                           where sysadmauth <> ' '"   )
  x=sql("                          )"                          )
 end

  if removeUserList <> ''
  then ,
  x=sql("     AND b.GRANTEE not in" RemoveUserList             )

  x=sql("     )"                                               )
  x=sql("ORDER BY name, ugrantee"                              )

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :name, :grantee"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var name name .

      If model=1 Then prof=Strip(name)"."auth
      Else prof=ssid"."Strip(name)"."auth
      prof= left(prof,max(35,length(prof)))
      datacomment = "DATA('has" auth "priv')"
      cmd="PERMIT "prof" CLASS("class") ACC(READ)",
        "ID("Strip(grantee)")" ,
        datacomment
      x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1'
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1'

Return    /* cltn_priv */

sys_attr:
/*****************************************************************/
/* Get DB2 system administrative authorities                     */
/*****************************************************************/
  Arg auth,col
  If model=1 Then prof=auth
  Else prof=ssid"."auth

  Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
                         /* --------------------------- */
  useClass = class

     /* First determine if it is given to PUBLIC */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT COUNT(*)"           )
  x=sql("FROM SYSIBM.SYSUSERAUTH"   )
  x=sql("WHERE GRANTEE='PUBLIC'"    )
  x=sql("  AND "col"¬=' '"          )

  call ZSQL

  rowsReturned = 0
  address dsnrexx "EXECSQL FETCH C1 INTO :totalCount"
  If SQLCODE \= 0 Then call prtsqlca 'FETCH C1 '

  rowsReturned = rowsReturned + 1

  call showRowCount /* show rowsReturned */
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1 '


     /* If there are no rows, it is not public */
 If totalCount = 0
 then do
     /* Define base profile */
  uac = 'NONE'
  prof= left(prof,max(25,length(prof)))
  cmd="RDEF "class prof" UACC("uac") OWNER("owner") AUDIT(ALL(READ))" ,
         "DATA('DB2-"ssid "subsystem" auth"-priviledge')" /* rph */
  x = clistCard(cmd)
 end
 else do
     /* Define base profile */
  uac = 'READ'
  prof= left(prof,max(25,length(prof)))
  cmd="RDEF "class prof" UACC("uac") OWNER("owner") AUDIT(ALL(READ))" ,
         "DATA('Everyone has" ssid auth"-priv on subsystem')"
  x = clistCard(cmd)
 end


     /* Remove executor from access list */
  cmd="PERMIT "prof" CLASS("class") RESET"
  if resetOption = 'RESET' then x = clistCard(cmd)

  Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
                         /* --------------------------- */

     /* Get all ids (except PUBLIC) for access list */
     /* ...for grantee with both PRIV = G and Y ... only*/
     /* ...process one for G                            */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT" granteeCase             )
  x=sql("FROM SYSIBM.SYSUSERAUTH as a"            )
  x=sql("WHERE a."col"<>' '"                      )
  x=sql("  AND a.GRANTEE¬='PUBLIC'"               )

if col <> 'SYSADMAUTH' & SlimAdm
then do
  x=sql("  and a.GRANTEE not in ("                )
  x=sql("     select distinct b.grantee"          )
  x=sql("        from sysibm.sysuserauth as b"    )
  x=sql("        where b.sysadmauth <> ' '"       )
  x=sql("                       )"                )
end

  if removeUserList <> ''
  then ,
  x=sql("  AND a.GRANTEE not in" RemoveUserList   )

  x=sql("order by grantee"                        )

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :grantee"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      if grantee = '*DELETE' then iterate
      if auth = 'SYSADM' /* priv must = 'G' */
      then cmd="PERMIT "prof" CLASS("class") ACC(ALTER) ID("grantee")"
      else , /* just use read */
           cmd="PERMIT "prof" CLASS("class") ACC(READ)  ID("grantee")"

      x = clistCard(cmd) /* actually generate priv */

      if auth = 'SYSADM'
      then do
         xsysadm = xsysadm + 1
         xsysadm.xsysadm = grantee     /* remember who has sysadm */
         xsysadmIndx.grantee = xsysadm /* quick index as well     */
      end
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1 '
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1 '

Return     /* sys_attr */


gv_attr:
/*****************************************************************/
/* Get DB2 global variable authorities                           */
/*****************************************************************/
  Arg auth,col
  If model=1 Then prof=auth
  Else prof=ssid"."auth

  Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
                         /* --------------------------- */
  useClass = Class

  /* create "backstop" so that everything else is rejected */
  /* ----------------------------------------------------- */
  x = clistCard(' ')
  cmd='/* create backstop RDEF (in gv_attr: routine) */'
  x = clistCard(cmd)

  data = 'backstop DB2-'ssid auth'-priv on *.*'

  if model=1
  then prof =      '*.*.'auth
  else prof = ssid'.*.*.'auth

  prof= left(prof,max(45,length(prof)))
  cmd="RDEF "class prof "UACC(NONE) OWNER("owner")" ,
         "AUDIT(ALL(READ))" ,
         "DATA('"data"')"
  x = clistCard(cmd)

     /* First determine if it is given to PUBLIC */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql(" SELECT distinct a.schema, a.name, 'PUBLIC' as gtype" )
  x=sql("   FROM SYSIBM.SYSVARIABLEAUTH as a"                  )
  x=sql("   WHERE a.GRANTEE='PUBLIC'"                          )
  x=sql("     and a."col"¬=' '"                                )
  x=sql("     and a.granteeType = ' '"                         )
  x=sql("UNION"                                                )
  x=sql(" SELECT distinct b.schema, b.name, 'OTHER ' as gtype" )
  x=sql("   FROM SYSIBM.SYSVARIABLEAUTH as b"                  )
  x=sql("   WHERE b."col"¬=' '"                                )
  x=sql("     and b.granteeType = ' '"                         )
  x=sql("     and not exists"                                  )
  x=sql("        ("                                            )
  x=sql("          select 1"                                   )
  x=sql("          FROM SYSIBM.SYSVARIABLEAUTH as c"           )
  x=sql("          WHERE c."col"¬=' '"                         )
  x=sql("            and c.granteeType = ' '"                  )
  x=sql("            and c.GRANTEE='PUBLIC'"                   )
  x=sql("            and c.schema = b.schema"                  )
  x=sql("            and c.name   = b.name"                    )
  x=sql("        )"                                            )
  x=sql("ORDER BY schema, name, gtype"                         )
  call ZSQL

  rowsReturned = 0
  do UNTIL sqlcode <> 0
     address dsnrexx "EXECSQL FETCH C1 INTO :schema, :name, :gtype"
     if sqlcode = 0
     then do
        rowsReturned = rowsReturned + 1
        parse upper var schema schema .
        parse upper var name   name   .
        if model=1
        then prof =        schema'.'name'.'auth
        else prof = ssid'.'schema'.'name'.'auth

        if gtype = 'PUBLIC'
        then do
           uac = 'UACC(READ)'
           data = 'DB2-'ssid 'Everyone has' auth'-priv on' ,
              schema'.'name
        end
        else do
           uac = 'UACC(NONE)'
           data = 'DB2-'ssid auth'-priv on' ,
              schema'.'name
        end
           /* Define base profile */
        prof= left(prof,max(45,length(prof)))
        cmd="RDEF "class prof uac "OWNER("owner")" ,
               "AUDIT(ALL(READ))" ,
               "DATA('"data"')"
        x = clistCard(cmd)
           /* Remove executor from access list */
        cmd="PERMIT "prof" CLASS("class") RESET"
        if resetOption = 'RESET' then x = clistCard(cmd)
     end
  end
  call showRowCount /* show rowsReturned */
  If SQLCODE = 0 | sqlcode = 100
  then nop
  else call prtsqlca 'FETCH C1 '
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1 '

  Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
                         /* --------------------------- */

     /* Get all ids (except PUBLIC) for access list */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT a.schema"                        )
  x=sql("               ,a.name"                          )
  x=sql("               ,"granteecase                     )
  x=sql("   FROM SYSIBM.SYSVARIABLEAUTH as a"             )
  x=sql("   WHERE a."col"¬=' '"                           )
  x=sql("     and a.granteeType = ' '"                    )
  x=sql("     and not exists"                             )
  x=sql("        ("                                       )
  x=sql("          select 1"                              )
  x=sql("          FROM SYSIBM.SYSVARIABLEAUTH as c"      )
  x=sql("          WHERE c."col"¬=' '"                    )
  x=sql("            and c.granteeType = ' '"             )
  x=sql("            and c.GRANTEE='PUBLIC'"              )
  x=sql("            and c.schema = a.schema"             )
  x=sql("            and c.name   = a.name"               )
  x=sql("        )"                                       )

 if col <> 'SYSADMAUTH' & SlimAdm
 then do
  x=sql("     and a.GRANTEE not in"                       )
  x=sql("        ("                                       )
  x=sql("        select distinct d.grantee"               )
  x=sql("           from sysibm.sysUserAUTH as d"         )
  x=sql("           where d.sysadmauth <> ' '"            )
  x=sql("        )"                                       )
 end

 if removeUserList <> ''
 then ,
  x=sql("     AND a.GRANTEE not in" RemoveUserList        )

  x=sql("ORDER BY schema, name, grantee"                  )

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :schema, :name, :grantee"
    If SQLCODE = 0
    then do
       rowsReturned = rowsReturned + 1
       parse upper var schema schema .
       parse upper var name   name   .

       if model=1
       then prof =        schema'.'name'.'auth
       else prof = ssid'.'schema'.'name'.'auth
       prof= left(prof,max(45,length(prof)))
       cmd="PERMIT "prof" CLASS("class") ACC(READ) ID("grantee")"

       x = clistCard(cmd) /* actually generate priv */
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1 '
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1 '

Return     /* gv_attr */

seq_attr:
/*****************************************************************/
/* Get DB2 sequence authorities                                  */
/*****************************************************************/
  Arg auth,col
  If model=1 Then prof=auth
  Else prof=ssid"."auth

  Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
                         /* --------------------------- */
  useClass = class

  /* create "backstop" so that everything else is rejected */
  /* ----------------------------------------------------- */
  x = clistCard(' ')
  cmd='/* create backstop RDEF (in seq_attr: routine) */'
  x = clistCard(cmd)

  if model=1
  then prof =      '*.*.'auth
  else prof = ssid'.*.*.'auth

  data = 'Backstop DB2-'ssid auth'-priv on *.*'
     /* Define base profile */
  prof= left(prof,max(45,length(prof)))
  cmd="RDEF "class prof "UACC(NONE) OWNER("owner")" ,
         "AUDIT(ALL(READ))" ,
         "DATA('"data"')"
  x = clistCard(cmd)
  x = clistCard(' ')

     /* First determine if it is given to PUBLIC */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("  SELECT distinct a.schema, a.name, 'PUBLIC' as gtype"   )
  x=sql("     FROM SYSIBM.SYSSEQUENCEAUTH as a"                   )
  x=sql("     WHERE a.GRANTEE='PUBLIC'"                           )
  x=sql("       and a."col"¬=' '"                                 )
  x=sql("       and a.granteeType = ' '"                          )
  x=sql("UNION"                                                   )
  x=sql("  SELECT distinct b.schema, b.name, 'OTHER ' as gtype"   )
  x=sql("     FROM SYSIBM.SYSSEQUENCEAUTH as b"                   )
  x=sql("     WHERE b."col"¬=' '"                                 )
  x=sql("       and b.granteeType = ' '"                          )
  x=sql("       and not exists"                                   )
  x=sql("          ("                                             )
  x=sql("            select 1"                                    )
  x=sql("            FROM SYSIBM.SYSSEQUENCEAUTH as c"            )
  x=sql("            WHERE c."col"¬=' '"                          )
  x=sql("              and c.granteeType = ' '"                   )
  x=sql("              and c.GRANTEE='PUBLIC'"                    )
  x=sql("              and c.schema = b.schema"                   )
  x=sql("              and c.name   = b.name"                     )
  x=sql("          )"                                             )
  x=sql("ORDER BY schema, name, gtype"                            )

  call ZSQL

  rowsReturned = 0
  do UNTIL sqlcode <> 0
     address dsnrexx "EXECSQL FETCH C1 INTO :schema, :name, :gtype"
     if sqlcode = 0
     then do
        rowsReturned = rowsReturned + 1
        parse upper var schema schema .
        parse upper var name   name   .
        if model=1
        then prof =        schema'.'name'.'auth
        else prof = ssid'.'schema'.'name'.'auth

        if gtype = 'PUBLIC'
        then do
           uac = 'UACC(READ)'
           data = 'DB2-'ssid 'Everyone has' auth'-priv on' ,
              schema'.'name
        end
        else do
           uac = 'UACC(NONE)'
           data = 'DB2-'ssid auth'-priv on' ,
              schema'.'name
        end
           /* Define base profile */
        prof= left(prof,max(45,length(prof)))
        cmd="RDEF "class prof uac "OWNER("owner")" ,
               "AUDIT(ALL(READ))" ,
               "DATA('"data"')"
        x = clistCard(cmd)
           /* Remove executor from access list */
        cmd="PERMIT "prof" CLASS("class") RESET"
        if resetOption = 'RESET' then x = clistCard(cmd)
     end
  end
  call showRowCount /* show rowsReturned */
  If SQLCODE = 0 | sqlcode = 100
  then nop
  else call prtsqlca 'FETCH C1 '
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1 '


  Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
                         /* --------------------------- */

     /* Get all ids (except PUBLIC) for access list */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT a.schema"                       )
  x=sql("               ,a.name"                         )
  x=sql("               ,"granteecase                    )
  x=sql("   FROM SYSIBM.SYSSEQUENCEAUTH as a"            )
  x=sql("   WHERE a."col"¬=' '"                          )
  x=sql("     and a.granteeType = ' '"                   )
  x=sql("     and not exists"                            )
  x=sql("        ("                                      )
  x=sql("          select 1"                             )
  x=sql("          FROM SYSIBM.SYSSEQUENCEAUTH as c"     )
  x=sql("          WHERE c."col"¬=' '"                   )
  x=sql("            and c.granteeType = ' '"            )
  x=sql("            and c.GRANTEE='PUBLIC'"             )
  x=sql("            and c.schema = a.schema"            )
  x=sql("            and c.name   = a.name"              )
  x=sql("        )"                                      )

 if col <> 'SYSADMAUTH' & SlimAdm
 then do
  x=sql( "    and a.GRANTEE not in ("                    )
  x=sql( "       select distinct d.grantee"              )
  x=sql( "          from sysibm.sysUserAUTH as d"        )
  x=sql( "          where d.sysadmauth <> ' '"           )
  x=sql( "                         )"                    )
 end

 if removeUserList <> ''
 then ,
  x=sql( "    AND a.GRANTEE not in" RemoveUserList       )

  x=sql( "  ORDER BY schema, name, grantee"              )

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :schema, :name, :grantee"
    If SQLCODE = 0
    then do
       rowsReturned = rowsReturned + 1
       parse upper var schema schema .
       parse upper var name   name   .
       if model=1
       then prof =        schema'.'name'.'auth
       else prof = ssid'.'schema'.'name'.'auth
       prof= left(prof,max(45,length(prof)))
       cmd="PERMIT "prof" CLASS("class") ACC(READ) ID("grantee")"

       x = clistCard(cmd) /* actually generate priv */
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1 '
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1 '

Return     /* seq_attr */

routine_attr:
/*****************************************************************/
/* handle stored procedures and UDF (user defined functions)     */
/*****************************************************************/
  Arg auth,col,SP$UDF
  If model=1 Then prof=auth
  Else prof=ssid"."auth

  Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
                         /* --------------------------- */
  useClass = class

  /* create "backstop" so that everything else is rejected */
  /* ----------------------------------------------------- */
  x = clistCard(' ')
  cmd='/* create backstop RDEF (in routine_attr: routine) */'
  x = clistCard(cmd)

  if model=1
  then prof =      '*.*.'auth
  else prof = ssid'.*.*.'auth

  data = 'Backstop DB2-'ssid auth'-priv on *.*'
     /* Define base profile */
  prof= left(prof,max(45,length(prof)))
  cmd="RDEF "class prof "UACC(NONE) OWNER("owner")" ,
         "AUDIT(ALL(READ))" ,
         "DATA('"data"')"
  x = clistCard(cmd)
  x = clistCard(' ')

     /* First determine if it is given to PUBLIC */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql(" SELECT distinct a.schema, a.specificname, 'PUBLIC' as gtype")
  x=sql(" FROM SYSIBM.SYSROUTINEAUTH as a"                            )
  x=sql(" WHERE a.GRANTEE='PUBLIC'"                                   )
  x=sql("   and a."col"¬=' '"                                         )
  x=sql("   and a.granteeType = ' '"                                  )
  x=sql("   and a.routineType = '"sp$udf"'"                           )
  x=sql("UNION"                                                       )
  x=sql(" SELECT distinct b.schema, b.specificname, 'OTHER ' as gtype")
  x=sql(" FROM SYSIBM.SYSROUTINEAUTH as b"                            )
  x=sql(" WHERE b."col"¬=' '"                                         )
  x=sql("   and b.granteeType = ' '"                                  )
  x=sql("   and b.routineType = '"sp$udf"'"                           )
  x=sql("   and not exists"                                           )
  x=sql("      ("                                                     )
  x=sql("        select 1"                                            )
  x=sql("        FROM SYSIBM.SYSROUTINEAUTH as c"                     )
  x=sql("        WHERE c."col"¬=' '"                                  )
  x=sql("          and c.granteeType = ' '"                           )
  x=sql("          and c.routineType = '"sp$udf"'"                    )
  x=sql("          and c.GRANTEE='PUBLIC'"                            )
  x=sql("          and c.schema = b.schema"                           )
  x=sql("          and c.specificname = b.specificname"               )
  x=sql("      )"                                                     )
  x=sql("ORDER BY schema, specificname, gtype"                        )

  call ZSQL

  rowsReturned = 0
  do UNTIL sqlcode <> 0
     address dsnrexx "EXECSQL FETCH C1 INTO :schema, :name, :gtype"
     if sqlcode = 0
     then do
        rowsReturned = rowsReturned + 1
        parse upper var schema schema .
        parse upper var name   name   .
        if model=1
        then prof =        schema'.'name'.'auth
        else prof = ssid'.'schema'.'name'.'auth

        if gtype = 'PUBLIC'
        then do
           uac = 'UACC(READ)'
           data = 'DB2-'ssid 'Everyone has' auth'-priv on' ,
              schema'.'name
        end
        else do
           uac = 'UACC(NONE)'
           data = 'DB2-'ssid auth'-priv on' ,
              schema'.'name
        end
           /* Define base profile */
        prof= left(prof,max(45,length(prof)))
        cmd="RDEF "class prof uac "OWNER("owner")" ,
               "AUDIT(ALL(READ))" ,
               "DATA('"data"')"
        x = clistCard(cmd)
           /* Remove executor from access list */
        cmd="PERMIT "prof" CLASS("class") RESET"
        if resetOption = 'RESET' then x = clistCard(cmd)
     end
  end
  call showRowCount /* show rowsReturned */
  If SQLCODE = 0 | sqlcode = 100
  then nop
  else call prtsqlca 'FETCH C1 '
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1 '

  Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
                         /* --------------------------- */


     /* Get all ids (except PUBLIC) for access list */

     /* Get all ids (except PUBLIC) for access list */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT a.schema"                           )
  x=sql("               ,a.specificname"                     )
  x=sql("               ,"granteecase                        )
  x=sql("   FROM SYSIBM.SYSROUTINEAUTH as a"                 )
  x=sql("   WHERE a."col"¬=' '"                              )
  x=sql("     and a.granteeType = ' '"                       )
  x=sql("     and a.routineType = '"sp$udf"'"                )
  x=sql("     and not exists"                                )
  x=sql("        ("                                          )
  x=sql("          select 1"                                 )
  x=sql("          FROM SYSIBM.SYSROUTINEAUTH as c"          )
  x=sql("          WHERE c."col"¬=' '"                       )
  x=sql("            and c.granteeType = ' '"                )
  x=sql("            and c.routineType = '"sp$udf"'"         )
  x=sql("            and c.GRANTEE='PUBLIC'"                 )
  x=sql("            and c.schema = a.schema"                )
  x=sql("            and c.specificname = a.specificname"    )
  x=sql("        )"                                          )
 if SlimAdm
 then do
  x=sql("     and a.GRANTEE not in ("                        )
  x=sql("        select distinct d.grantee"                  )
  x=sql("           from sysibm.sysUserAUTH as d"            )
  x=sql("           where d.sysadmauth <> ' '"               )
  x=sql("                          )"                        )
 end

 if removeUserList <> ''
 then ,
  x=sql("     AND a.GRANTEE not in" RemoveUserList           )

  x=sql("ORDER BY schema, specificname, grantee"             )

  call ZSQL

  rowsReturned = 0

  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :schema, :name, :grantee"
    If SQLCODE = 0
    then do
       rowsReturned = rowsReturned + 1
       parse upper var schema schema .
       parse upper var name   name   .

       if model=1
       then prof =        schema'.'name'.'auth
       else prof = ssid'.'schema'.'name'.'auth

       prof= left(prof,max(45,length(prof)))
       cmd="PERMIT "prof" CLASS("class") ACC(READ) ID("grantee")"

       x = clistCard(cmd) /* actually generate priv */
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1 '

  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1 '


     /* Get all ids in schema.* that need to be in a*/
     /* specific profile.                           */

  if granteeCaseBB = 'GRANTEECASEBB' /* only need to set once */
  then granteeCaseBB = changestr('a.',granteecase,'bb.')

  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT aa.schema"                           )
  x=sql("               ,aa.specificname"                     )
  x=sql("               ,"granteecaseBB                      )
  x=sql("   FROM ("                                          )
  x=sql("         SELECT DISTINCT a.schema"                  )
  x=sql("                        ,a.specificname"            )
  x=sql("            FROM SYSIBM.SYSROUTINEAUTH as a"                 )
  x=sql("            WHERE a."col"¬=' '"                              )
  x=sql("              and a.specificname <> '*'"                     )
  x=sql("              and a.granteeType = ' '"                       )
  x=sql("              and a.routineType = '"sp$udf"'"                )
  x=sql("              and not exists"                                )
  x=sql("                 ("                                          )
  x=sql("                   select 1"                                 )
  x=sql("                   FROM SYSIBM.SYSROUTINEAUTH as c"          )
  x=sql("                   WHERE c."col"¬=' '"                       )
  x=sql("                     and c.granteeType = ' '"                )
  x=sql("                     and c.routineType = '"sp$udf"'"         )
  x=sql("                     and c.GRANTEE='PUBLIC'"                 )
  x=sql("                     and c.schema = a.schema"                )
  x=sql("                     and c.specificname = a.specificname"    )
  x=sql("                 )"                                          )
  x=sql("        ) as aa"                                    )
  x=sql("        ,sysibm.sysroutineAuth as bb"               )
  x=sql("   where aa.schema = bb.schema"                     )
  x=sql("     and bb.specificName = '*'"                     )
  x=sql("     and bb."col"<>' '"                             )
 if SlimAdm
 then do
  x=sql("     and bb.GRANTEE not in ("                       )
  x=sql("        select distinct d.grantee"                  )
  x=sql("           from sysibm.sysUserAUTH as d"            )
  x=sql("           where d.sysadmauth <> ' '"               )
  x=sql("                           )"                       )
 end

 if removeUserList <> ''
 then ,
  x=sql("     AND bb.GRANTEE not in" RemoveUserList          )

  x=sql("     AND bb.GRANTEE not in ("                       )
  x=sql("        select distinct dd.grantee"                 )
  x=sql("           from sysibm.sysroutineauth as cc"        )
  x=sql("               ,sysibm.sysroutineauth as dd"        )
  x=sql("           where cc.schema = aa.schema"             )
  x=sql("             and dd.schema = aa.schema"             )
  x=sql("             and cc.specificName = aa.SpecificName" )
  x=sql("             and dd.specificName = '*'"             )
  x=sql("             and cc."col "<> ' '"                   )
  x=sql("             and dd."col "<> ' '"                   )
  x=sql("             and cc.grantee = dd.grantee"           )
  x=sql("                           )"                       )

  x=sql("ORDER BY schema, specificname, grantee"             )

  call ZSQL

  Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
                         /* --------------------------- */

  pastSchema = ''
  pastName   = ''
  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :schema, :name, :grantee"
    If SQLCODE = 0
    then do
       rowsReturned = rowsReturned + 1
       parse upper var schema schema .
       parse upper var name   name   .

       if model=1
       then prof =        schema'.'name'.'auth
       else prof = ssid'.'schema'.'name'.'auth

       prof= left(prof,max(45,length(prof)))
       cmd="PERMIT "prof" CLASS("class") ACC(READ) ID("grantee")"

       x = clistCard(cmd) /* actually generate priv */
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1 '

  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1 '

Return     /* routine_attr */

bindagent:
/*****************************************************************/
/* Get DB2 system BINDAGENT authority                            */
/*****************************************************************/

  Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
                         /* --------------------------- */
  useClass = class

  cmd='/* create backstop RDEF (in bindagent: routine) */'
  x = clistCard(cmd)

  If model=1 Then prof='*.BINDAGENT'
  Else prof=ssid'.*.BINDAGENT'
  prof= left(prof,max(25,length(prof)))
  cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
      "OWNER("owner")" ,
    "DATA('DB2-"ssid "backstop bindagent profile')"
  x = clistCard(cmd)

     /* Create (ssid.)grantor.BINDAGENT profile for each GRANTOR */
     /* And remove executor from access list */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */

  x=sql("SELECT DISTINCT strip(upper(grantor)) as ugrantor"  )
  x=sql("FROM SYSIBM.SYSUSERAUTH"                            )
  x=sql("WHERE BINDAGENTAUTH¬=' '"                           )

 if removeUserList <> ''
 then ,
  x=sql("  AND GRANTEE not in" RemoveUserList                )

  x=sql("ORDER by ugrantor"                                  )

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :grantor"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      If model=1 Then prof=Strip(grantor)'.BINDAGENT'
      Else prof=ssid'.'Strip(grantor)'.BINDAGENT'
      prof= left(prof,max(25,length(prof)))
      cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
          "OWNER("owner")" ,
        "DATA('DB2-"ssid "bindagent profile for grantor" grantor"')"
      x = clistCard(cmd)

      cmd="PERMIT "prof" CLASS("class") RESET"
      if resetOption = 'RESET' then x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1 '
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE \= 0 Then call prtsqlca 'CLOSE C1 '

     /* Change UACC if it is given to PUBLIC */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT strip(upper(GRANTOR)) as ugrantor"  )
  x=sql("FROM SYSIBM.SYSUSERAUTH"                            )
  x=sql("WHERE BINDAGENTAUTH¬=' '"                           )
  x=sql("  AND GRANTEE='PUBLIC'"                             )
  x=sql("ORDER by ugrantor"                                  )

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :grantor"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      If model=1 Then prof=Strip(grantor)'.BINDAGENT'
      Else prof=ssid'.'Strip(grantor)'.BINDAGENT'
      prof= left(prof,max(35,length(prof)))
      cmd="RALT " class prof" UACC(READ)" ,
        "DATA('"ssid grantor "gave everyone bindagent priv')"
      x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1 '
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE\=0 Then call prtsqlca 'CLOSE C1'

  Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
                         /* --------------------------- */

     /* Get all ids (except PUBLIC) for access list */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  X=SQL("SELECT DISTINCT strip(upper(a.grantor)) as ugrantor"  )
  X=SQL("               ,"granteeCase                          )
  X=SQL("FROM SYSIBM.SYSUSERAUTH as a"                         )
  X=SQL("WHERE a.BINDAGENTAUTH<>' '"                           )
  X=SQL("  AND A.GRANTEE¬='PUBLIC'"                            )
 if SlimAdm
 then do
  X=SQL("  AND a.GRANTEE NOT IN ("                             )
  X=SQL("            SELECT DISTINCT B.GRANTEE"                )
  X=SQL("            FROM SYSIBM.SYSUSERAUTH as b"             )
  X=SQL("            WHERE B.SYSADMAUTH <> ' '"                )
  X=SQL("                       )"                             )
 end
  X=SQL("  and not exists ("                                   )
  X=SQL("            select 1"                                 )
  X=SQL("            from sysibm.sysuserauth as c"             )
  X=SQL("            WHERE a.grantor = c.grantor"              )
  X=SQL("              and c.grantee = 'PUBLIC'"               )
  X=SQL("                 )"                                   )

 if removeUserList <> ''
 then ,
  X=SQL("  AND a.GRANTEE not in" RemoveUserList                )

  X=SQL("order by ugrantor, grantee"                           )

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :grantor, :grantee"
    If SQLCODE=0 Then Do
      rowsReturned = rowsReturned + 1
      if grantee = '*DELETE' then iterate

      access = 'ACC(READ)'

      If model=1 Then prof=grantor'.BINDAGENT'
      Else prof=ssid'.'grantor'.BINDAGENT'
      prof= left(prof,max(35,length(prof)))
      cmd="PERMIT "prof" CLASS("class")" access "ID("grantee")"
      x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1 '
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE\=0 Then call prtsqlca 'CLOSE C1'

Return     /* bindagent */

db_attr:
/*****************************************************************/
/* Get DB2 database administrative authorities                   */
/*****************************************************************/
  Arg auth,col

  Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
                         /* --------------------------- */
  useClass = class

      /* Find all databases, and make commands to create profiles */
      /* for 'auth'. Then remove executor from access list.       */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT a.NAME FROM SYSIBM.SYSDBAUTH as a"     )
  x=sql("   WHERE a.NAME in"                                    )
  x=sql("        ("                                             )
  x=sql("         select distinct c.name"                       )
  x=sql("         from sysibm.sysdatabase as c"                 )
  x=sql("         where c.implicit <> 'Y'"                      )
  x=sql("        )"                                             )

 if removeUserList <> ''
 then ,
  x=sql("     AND a.GRANTEE not in" RemoveUserList              )

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :name"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var name name .
      If model=1 Then prof=Strip(name)'.'auth
      Else prof=ssid'.'Strip(name)'.'auth
      prof= left(prof,max(25,length(prof)))
      cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
          "OWNER("owner")" ,
         "DATA('DB2-"ssid "database-"name auth"-priviledge')" /* rph */
      x = clistCard(cmd)

      cmd="PE "prof" CLASS("class") RESET"
      if resetOption = 'RESET' then x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1 '
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE\=0 Then call prtsqlca 'CLOSE C1'

     /* If any of those were PUBLIC, change UACC to READ */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("select distinct name"                             )
  x=sql("from ("                                           )
  x=sql("        SELECT DISTINCT a.NAME"                   )
  x=sql("        FROM SYSIBM.SYSDBAUTH as a"               )
  x=sql("        WHERE a.GRANTEE='PUBLIC'"                 )
  x=sql("          and a."col "<> ' '"                     )
  x=sql("          and a.NAME in"                          )
  x=sql("                ("                                )
  x=sql("                 select distinct c.name"          )
  x=sql("                 from sysibm.sysdatabase as c"    )
  x=sql("                 where c.implicit <> 'Y'"         )
  x=sql("                )"                                )
  x=sql("      UNION"                                      )
  x=sql("        SELECT 'DSNDB04' as name"                 )
  x=sql("        FROM SYSIBM.SYSDBAUTH as b"               )
  x=sql("        WHERE b.GRANTEE='PUBLIC'"                 )
  x=sql("          and b."col "<> ' '"                     )
  x=sql("          and b.NAME in"                          )
  x=sql("                ("                                )
  x=sql("                 select distinct e.name"          )
  x=sql("                 from sysibm.sysdatabase as e"    )
  x=sql("                 where e.implicit = 'Y'"          )
  x=sql("                )"                                )
  x=sql("      )"                                          )
  x=sql("order by name"                                    )

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :name"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var name name .
      If model=1 Then prof=Strip(name)'.'auth
      Else prof=ssid'.'Strip(name)'.'auth
      prof= left(prof,max(35,length(prof)))
      cmd="RALT "class prof" UACC(READ)" ,
         "DATA('Everyone has" ssid ,
               "database-"name auth"-priviledge')" /* rph */
      x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1 '
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE\=0 Then call prtsqlca 'CLOSE C1'

  Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
                         /* --------------------------- */

     /* Get all ids (except PUBLIC) for access list */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT name, grantee"                        )
  x=sql("FROM ("                                               )
  x=sql("   SELECT DISTINCT a.NAME," granteeCase               )
  x=sql("   FROM SYSIBM.SYSDBAUTH as a"                        )
  x=sql("   WHERE a."col "<> ' '"                              )
  x=sql("     AND a.GRANTEE <> a.GRANTOR"                      )
 if SlimAdm
 then do
  x=sql("     and a.GRANTEE not in ("                          )
  x=sql("        select distinct b.grantee"                    )
  x=sql("           from sysibm.sysuserauth as b"              )
  x=sql("           where b.sysadmauth <> ' '"                 )
  x=sql("                        )"                            )
 end
  x=sql("     and not exists ("                                )
  x=sql("        select 1"                                     )
  x=sql("           from sysibm.sysdbauth as c"                )
  x=sql("           where c.name  = a.name"                    )
  x=sql("             and c."col "<> ' '"                      )
  x=sql("             and c.grantee = 'PUBLIC'"                )
  x=sql("                    )"                                )
  x=sql("     and a.name in  ("                                )
  x=sql("        select distinct e.name"                       )
  x=sql("           from sysibm.sysdatabase as e"              )
  x=sql("           where e.name  = a.name"                    )
  x=sql("             and e.implicit <> 'Y'"                   )
  x=sql("                    )"                                )

 if col <> 'DBADMAUTH' & SlimAdm
 then do
  x=sql("     and a.GRANTEE not in ("                          )
  x=sql("        select distinct d.grantee"                    )
  x=sql("           from sysibm.sysdbauth as d"                )
  x=sql("           where d.dbadmauth <> ' '"                  )
  x=sql("             and d.name = a.name"                     )
  x=sql("                        )"                            )
 end

 if removeUserList <> ''
 then ,
  x=sql("     AND a.GRANTEE not in" RemoveUserList             )

 if granteeCaseF = 'GRANTEECASEF' /* only need to set once */
 then granteeCaseF = changestr('a.',granteecase,'f.')

  x=sql("     )" ) /* end of "FROM ( ... )"  */
  x=sql("UNION"                                               )
  x=sql("SELECT DISTINCT 'DSNDB04' as name"                 )
  x=sql("            ," granteeCaseF                        )
  x=sql("FROM SYSIBM.SYSDBAUTH as f"                        )
  x=sql("WHERE f."col "<> ' '"                              )
  x=sql("  AND f.GRANTEE <> f.GRANTOR"                      )
 if SlimAdm
 then do
  x=sql("  and f.GRANTEE not in ("                          )
  x=sql("     select distinct g.grantee"                    )
  x=sql("        from sysibm.sysuserauth as g"              )
  x=sql("        where g.sysadmauth <> ' '"                 )
  x=sql("                     )"                            )
 end
  x=sql("  and not exists ("                                )
  x=sql("     select 1"                                     )
  x=sql("        from sysibm.sysdbauth as h"                )
  x=sql("        where h.name  = f.name"                    )
  x=sql("          and h."col "<> ' '"                      )
  x=sql("          and h.grantee = 'PUBLIC'"                )
  x=sql("                 )"                                )
  x=sql("  and f.name in  ("                                )
  x=sql("     select distinct i.name"                       )
  x=sql("        from sysibm.sysdatabase as i"              )
  x=sql("        where i.name  = f.name"                    )
  x=sql("          and i.implicit = 'Y'"                    )
  x=sql("                 )"                                )


 if col <> 'DBADMAUTH' & slimadm
 then do
  x=sql("  and f.GRANTEE not in ("                             )
  x=sql("     select distinct k.grantee"                       )
  x=sql("        from sysibm.sysdbauth as k"                   )
  x=sql("        where k.dbadmauth <> ' '"                     )
  x=sql("        and k.name = f.name"                          )
  x=sql("                       )"                             )
 end

 if removeUserList <> ''
 then ,
  x=sql("  AND f.GRANTEE not in" RemoveUserList                )

  x=sql("Order by name, grantee"                               )
  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :name, :grantee"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var name name .

      if grantee = '*DELETE' then iterate

      access = 'ACC(READ)'

      If model=1 Then prof=Strip(name)'.'auth
      Else prof=ssid'.'Strip(name)'.'auth
      prof= left(prof,max(35,length(prof)))
      cmd="PERMIT "prof" CLASS("class")" access "ID("grantee")"
      x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1 '
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE\=0 Then call prtsqlca 'CLOSE C1'

Return

db_option:
/*****************************************************************/
/* For DBADM write optional commands for profile with no DBname  */
/*****************************************************************/
  /* this fixed an issue that RACF now handles; ... delete code */

Return

packadm_attr:
/*****************************************************************/
/* Get DB2 PACKADM                                               */
/*****************************************************************/
  Arg auth

  Rdef$Permit = 'RDEF'   /* all output to RDEF   datasets */
                         /* --------------------------- */
  useClass = class

  /* create "backstop" so that everything else is rejected */
  /* ----------------------------------------------------- */
  x = clistCard(' ')
  cmd='/* create backstop RDEF (in packadm_attr: routine) */'
  x = clistCard(cmd)

  If model=1 Then prof="*."auth
  Else prof=ssid".*."auth
  prof= left(prof,max(25,length(prof)))
  cmd="RDEF "class prof" UACC(NONE) AUDIT(ALL(READ))",
    "OWNER("owner")" ,
     "DATA('Backstop DB2-"ssid auth "priv for packadm')"
  x = clistCard(cmd)
  x = clistCard(' ')

      /* Find all collections, and make commands to create profiles */
      /* for 'auth'. Then remove executor from access list.         */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT NAME, SPEC"                  )
  x=sql("from ("                                      )
  x=sql("     select distinct a.name as name"         )
  x=sql("                  ,'PUBLIC' as spec"         )
  x=sql("        from sysibm.sysresauth a"            )
  x=sql("        where a.obtype='C' "                 )
  x=sql("          and a.QUALIFIER='PACKADM '"        )
  x=sql("          and a.grantee in ('PUBLIC','PUBLIC*')")
  x=sql("          and (   a.name in ("               )
  x=sql("                     select distinct collid" )
  x=sql("                     from sysibm.syspackage" )
  x=sql("                            )"               )
  x=sql("               or a.name like ('%ISETS%')"   )
  x=sql("               or a.name like ('IVR%')"      )
  x=sql("               or a.name = '*'"              )
  x=sql("              )"                             )
  x=sql("    union"                                   )
  x=sql("     select distinct b.name as name"         )
  x=sql("                  ,'SPEC'   as spec"         )
  x=sql("        from sysibm.sysresauth b"            )
  x=sql("        where b.obtype='C' "                 )
  x=sql("          and b.QUALIFIER='PACKADM '"        )
  x=sql("          and b.grantee"                     )
  x=sql("                not in ('PUBLIC','PUBLIC*')" )
  x=sql("          and (   b.name in ("               )
  x=sql("                     select distinct collid" )
  x=sql("                     from sysibm.syspackage" )
  x=sql("                            )"               )
  x=sql("               or b.name like ('%ISETS%')"   )
  x=sql("               or b.name like ('IVR%')"      )
  x=sql("               or b.name = '*'"              )
  x=sql("              )"                             )
  x=sql("          and not exists ("                  )
  x=sql("            select 1"                        )
  x=sql("            from sysibm.sysresauth c"        )
  x=sql("            where b.obtype='C' "             )
  x=sql("              and c.obtype='C' "             )
  x=sql("              and b.QUALIFIER='PACKADM '"    )
  x=sql("              and c.QUALIFIER='PACKADM '"    )
  x=sql("              and c.grantee"                 )
  x=sql("                    in ('PUBLIC','PUBLIC*')" )
  x=sql("              and c.name = b.name"           )
  x=sql("                         )"                  )
  x=sql("     )"                                      )
  x=sql("order by name, spec"                         )

  call ZSQL

  rowsReturned = 0
  skipRest = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :name, :spec"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var name name .

      if name = '*' & spec = 'PUBLIC'
      then do /* special case; have to override backstop */
         If model=1 Then prof=Strip(name)"."auth
         Else prof=ssid"."Strip(name)"."auth
         prof= left(prof,max(35,length(prof)))
         cmd="RALT "class prof" UACC(READ) AUDIT(ALL(READ))",
           "OWNER("owner")" ,
            "DATA('DB2-"ssid "Everyone has PACKADM for collection-*')"
         x = clistCard(cmd)

         cmd="PERMIT "prof" CLASS("class") RESET"
         if resetOption = 'RESET' then x = clistCard(cmd)
         skiprest = 1
         iterate
      end

      if skiprest = 1
      then iterate

      cmd = 'RDEF'
      if name = '*' then cmd = 'RALT'

      If model=1 Then prof=Strip(name)'.'auth
      Else prof=ssid'.'Strip(name)'.'auth
      prof= left(prof,max(35,length(prof)))

      if spec = 'PUBLIC'
      then do
         cmd=cmd class prof" UACC(READ) AUDIT(ALL(READ))" ,
                                                     "OWNER("owner")" ,
           "DATA('DB2-"ssid "Everyone has packadm for-"name"')" /*rph*/
         x = clistCard(cmd)
      end
      else do
         cmd=cmd class prof" UACC(NONE) AUDIT(ALL(READ))" ,
                                                     "OWNER("owner")" ,
           "DATA('DB2-"ssid "PACKADM for-"name"')" /*rph*/
         x = clistCard(cmd)
      end

      cmd="PERMIT "prof" CLASS("class") RESET"
      if resetOption = 'RESET' then x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1 '
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE\=0 Then call prtsqlca 'CLOSE C1'

  if skipRest = 1 /* if everyone has access */
  then return     /* then, we're done.      */

  Rdef$Permit = 'PERMIT' /* all output to PERMIT datasets */
                         /* --------------------------- */

     /* Get all ids (except PUBLIC) for access list */
  x=sql('NEW statement') /* start new sql statement */
                         /* ----------------------- */
  x=sql("SELECT DISTINCT NAME, UGRANTEE"                       )
  x=sql("from ("                                               )
  x=sql("   SELECT DISTINCT a.NAME                  as name"   )
  x=sql("                  ,strip(upper(a.grantee)) as ugrantee")
  x=sql("   FROM SYSIBM.SYSRESAUTH a"                          )
  x=sql("   WHERE a.OBTYPE='C'"                                )
  x=sql("     AND a.QUALIFIER='PACKADM '"                      )
  x=sql("     AND a.USEAUTH<>' '"                              )
  x=sql("     AND not exists ("                                )
  x=sql("            select 1"                                 )
  x=sql("            from sysibm.sysresauth b"                 )
  x=sql("            where a.obtype = b.obtype"                )
  x=sql("              and a.obtype = 'C'"                     )
  x=sql("              and a.QUALIFIER='PACKADM '"             )
  x=sql("              and b.QUALIFIER='PACKADM '"             )
  x=sql("              and a.name   = b.name"                  )
  x=sql("              and a.useauth <> ' '"                   )
  x=sql("              and b.useauth <> ' '"                   )
  x=sql("              and b.grantee in ('PUBLIC','PUBLIC*')"  )
  x=sql("                    )"                                )
  x=sql("     AND (   a.NAME IN ("                             )
  x=sql("                        SELECT DISTINCT COLLID"       )
  x=sql("                        FROM SYSIBM.SYSPACKAGE"       )
  x=sql("                       )"                             )
  x=sql("          OR a.NAME LIKE ('%SETS%')"                  )
  x=sql("          OR a.NAME LIKE ('IVR%')"                    )
  x=sql("          OR a.NAME = '*'"                            )
  x=sql("         )"                                           )
 if SlimAdm
 then do
  x=sql("     AND a.GRANTEE NOT IN (select distinct grantee"   )
  x=sql("                           from sysibm.sysuserauth"   )
  x=sql("                           where sysadmauth <> ' '"   )
  x=sql("                          )"                          )
 end

  if removeUserList <> ''
  then ,
  x=sql("     AND GRANTEE not in" RemoveUserList               )

  x=sql("  UNION"                                              )

  x=sql("   SELECT DISTINCT a.NAME                  as name"   )
  x=sql("                  ,strip(upper(b.grantee)) as ugrantee")
  x=sql("   FROM SYSIBM.SYSRESAUTH A"                          )
  x=sql("       ,SYSIBM.SYSRESAUTH B"                          )
  x=sql("   WHERE A.OBTYPE='C'"                                )
  x=sql("     AND a.QUALIFIER='PACKADM '"                      )
  x=sql("     AND b.QUALIFIER='PACKADM '"                      )
  x=sql("     AND a.USEAUTH<>' '"                              )
  x=sql("     AND not exists ("                                )
  x=sql("            select 1"                                 )
  x=sql("            from sysibm.sysresauth c"                 )
  x=sql("            where a.obtype = c.obtype"                )
  x=sql("              and a.obtype = 'C'"                     )
  x=sql("              and a.QUALIFIER='PACKADM '"             )
  x=sql("              and c.QUALIFIER='PACKADM '"             )
  x=sql("              and a.name   = c.name"                  )
  x=sql("              and a.useauth <> ' '"                   )
  x=sql("              and c.useauth <> ' '"                   )
  x=sql("              and c.grantee in ('PUBLIC','PUBLIC*')"  )
  x=sql("                    )"                                )
  x=sql("     and b.OBTYPE='C'"                                )
  x=sql("     AND b.USEAUTH<>' '"                              )
  x=sql("     AND a.name   <> '*'"                             )
  x=sql("     AND b.name    = '*'"                             )
  x=sql("     AND (   a.NAME IN ("                             )
  x=sql("                        SELECT DISTINCT COLLID"       )
  x=sql("                        FROM SYSIBM.SYSPACKAGE"       )
  x=sql("                       )"                             )
  x=sql("          OR a.NAME LIKE ('%SETS%')"                  )
  x=sql("          OR a.NAME LIKE ('IVR%')"                    )
  x=sql("         )"                                           )
 if SlimAdm
 then do
  x=sql("     AND b.GRANTEE NOT IN (select distinct grantee"   )
  x=sql("                           from sysibm.sysuserauth"   )
  x=sql("                           where sysadmauth <> ' '"   )
  x=sql("                          )"                          )
 end

  if removeUserList <> ''
  then ,
  x=sql("     AND b.GRANTEE not in" RemoveUserList             )

  x=sql("     )"                                               )
  x=sql("ORDER BY name, ugrantee"                              )

  call ZSQL

  rowsReturned = 0
  Do Until SQLCODE \= 0
    address dsnrexx "EXECSQL FETCH C1 INTO :name, :grantee"
    If SQLCODE = 0 Then Do
      rowsReturned = rowsReturned + 1
      parse upper var name name .

      if grantee = '*DELETE' then iterate

      access = 'ACC(READ)'

      If model=1 Then prof=Strip(name)'.'auth
      Else prof=ssid'.'Strip(name)'.'auth
      prof= left(prof,max(55,length(prof)))
      cmd="PERMIT "prof" CLASS("class")" access "ID("grantee")"
      x = clistCard(cmd)
    End
  End /* do until */
  call showRowCount /* show rowsReturned */
  If SQLCODE=0 | SQLCODE=100 Then nop
  Else call prtsqlca 'FETCH C1 '
  address dsnrexx "EXECSQL CLOSE C1"
  If SQLCODE\=0 Then call prtsqlca 'CLOSE C1'

Return

OneLineSQL:
  /* used only for one line of sql code zsql, where we declare */
  /* a cursor for use... before we prepare/open cursor for a   */
  /* sql statement.                                            */
  /*                                                           */
  /* We didn't want to use prtsqlca for error recovery before  */
  /* the sql statement was even prepared.  So this is called   */
  /* like this (from zsql):                                    */
  /*                                                           */
  /*        call OneLineSQL "EXECSQL DECLARE C1 CURSOR FOR S1" */
  /*                                                           */
  parse arg oneLineSQLcode
  address dsnrexx oneLineSqlCode /* execute it */
  if sqlcode = 0
  then return

  /* error recovery for simple sql */
  err_sw = "1"
  say ' '
  say ' '
  say ' '
  say '** --------------------'
  say '** start error analysis'
  say '** --------------------'
  say ' '
  Say '** Error SQL statement'
  Say '** failing SQL statement follows:'
  say oneLineSQLcode
  say '** end failing SQL statement'
  say ' '
  Say 'SQLCODE = 'SQLCODE
  Say 'SQLERRMC = 'SQLERRMC
  Say 'SQLERRP = 'SQLERRP
  Say 'SQLERRD = 'SQLERRD.1',',
              || SQLERRD.2',',
              || SQLERRD.3',',
              || SQLERRD.4',',
              || SQLERRD.5',',
              || SQLERRD.6

  Say 'SQLWARN = 'SQLWARN.1',',
              || SQLWARN.2',',
              || SQLWARN.3',',
              || SQLWARN.4',',
              || SQLWARN.5',',
              || SQLWARN.6',',
              || SQLWARN.7',',
              || SQLWARN.8',',
              || SQLWARN.9',',
              || SQLWARN.10

  Say 'SQLSTATE= 'SQLSTATE

  say 'called from line' sigl
  say ' '
  say 'code near call to OneLineSql'
  say ' '
  prbl = sigl

  syntaxLow = max(prbL-12,1)           /*-12 before (or pgm start */
  syntaxHigh= min(prbL+4,sourceline()) /* +4 after  (or pgm end   */
  do syntaxII = syntaxLow to syntaxHigh/* show subset of lines    */
     if syntaxII <> prbL
     then say 'line   ' right(syntaxii,length(syntaxHigh))':' ,
                  sourceline(syntaxII)
     else say 'line==>' right(syntaxii,length(syntaxHigh))':' ,
                  sourceline(syntaxII)
  end
  say ' '


  /* close (most) open files */
  /* ----------------------- */
  do i = 1 by 1 for openDDs
     ddname = openDDs.i
     address 'TSO' "EXECIO" bufferRecs.ddname ,
                     "DISKW" ddname '(FINIS STEM BUFFERX.'ddname'.'
     if rc <> 0
     then say 'error closing/writting to ddname='ddname ,
                                  ||';rc='rc
  end
  Exit 999

ZSQL:
  zsqlSigl = sigl /* helps prtsqlca give us info */
  err_sw = "0"

  /* normally:   declare c1 cursor for s1"      */
  /* but may be: declare c2 cursor for s2", etc */
  call OneLineSQL "EXECSQL DECLARE C"sqlStmtValue ,
                          "CURSOR FOR S"sqlStmtValue
  /*trace 'n'*/

  if sqlOption = 'SQL'
  then do /* "display" sql statement in output */
     if datatype(zsqlsigl,'W')
     then do
        cmd='/* **rexx code generating SQL statement began at' ,
            sqlstmt.sqlStmtValue.startSQLcaller ,
            'ended at'                          ,
            sqlstmt.sqlStmtValue.lastSQLcaller  ,
            ' */'
        x=clistCard(cmd)
        x=clistCard(' ')
        cmd='/*   ** rexx code follows:  */'
        x=clistCard(cmd)
        iiiStart = sqlstmt.sqlStmtValue.startSQLcaller
        iiiEnd   = sqlstmt.sqlStmtValue.lastSQLcaller
        do iii = iiiStart by 1 to iiiEnd
           cmd= '/*'   iii'-->'sourceline(iii) '*/'
           x=clistCard(cmd)
        end
        cmd='/*   ** End of rexx code ** */'
        x=clistCard(cmd)
        x=clistCard(' ')
        cmd='/* **resolved rexx SQL code; statement began at' ,
            sqlstmt.sqlStmtValue.startSQLcaller ,
            'ended at'                          ,
            sqlstmt.sqlStmtValue.lastSQLcaller  ,
            ' */'
        x=clistCard(cmd)
        x=clistCard(' ')
        cmd='/*   ** resolved SQL code follows:  */'
        x=clistCard(cmd)
        iiiStart = sqlstmt.sqlStmtValue.startSQLcaller
        iiiEnd   = sqlstmt.sqlStmtValue.lastSQLcaller
        do iii = iiiStart by 1 to iiiEnd
           /* ex:  SQLSTMT0.iii = 0 */
           /*   or SQLSTMT1.iii = 0 */
           /*   or etc.         = 0 */
           /* --------------------- */
           if value('sqlStmt'sqlStmtValue'SiglIndx.'iii) = 0
           then iterate
           mmm = value('sqlStmt'sqlStmtValue'SiglIndx.'iii)
           rsql = sqlStmt.sqlStmtValue.mmm
           do while length(rsql) > 72
              rsql1 = left(rsql,72)
              rsql  = substr(rsql,73)
              cmd= '/*'   iii'-->'rsql1'<-- */'
              x=clistCard(cmd)
           end
           cmd= '/*'   iii'-->'left(rsql,72)'<-- */'
           x=clistCard(cmd)
        end
        cmd='/*   ** End of resolved SQL code ** */'
        x=clistCard(cmd)
        x=clistCard(' ')

     end
  end
  /* generate "sql" statement from sqlstmt. */
  GenSql = ''
  do iii=1 by 1 for sqlstmt.sqlStmtValue.0
     GenSql = genSql sqlstmt.sqlStmtValue.iii
  end
  x = value('GenSql'sqlStmtValue,genSql) /* set GENSQL1, etc */
  address dsnrexx "EXECSQL PREPARE S"sqlStmtValue /* s# */ ,
                             "INTO :outsqlca FROM :gensql"
  If SQLCODE \= 0 Then call prtsqlca 'PREPARE S'sqlStmtValue

  address dsnrexx "EXECSQL OPEN C"sqlStmtValue
  If SQLCODE \= 0 Then call prtsqlca 'OPEN C'sqlStmtValue

  zsqlSigl = ''   /* zsql no longer active */
Return  /* zsql */

prtsqlca:
  trace 'n'
  err_sw = "1"
  say ' '
  say ' '
  say ' '
  say '** --------------------'
  say '** start error analysis'
  say '** --------------------'
  say ' '
  Say '** Error SQL statement - ' arg(1)

  parse upper arg word1 word2 word3
  if word1 = 'PREPARE'
  then parse upper arg . ' S'stmtCursorNum .
  else parse upper arg . ' C'stmtCursorNum .

  Say '** failing SQL statement follows:'
  say value('GenSql'stmtCursorNum) /* Gensql1 or GenSql2, etc */
  say '** end failing SQL statement'
  say ' '
  if datatype(zsqlsigl,'W')
  then do
     say '** rexx code generating failing statement began at' ,
         sqlstmt.stmtCursorNum.startSQLcaller ,
         'ended at'                           ,
         sqlstmt.stmtCursorNum.lastSQLcaller
     say ' '
     say '** rexx code follows:'
     iiiStart = sqlstmt.stmtCursorNum.StartSQLcaller
     iiiEnd   = sqlstmt.stmtCursorNum.lastSQLcaller
     do iii = iiiStart by 1 to iiiEnd
        say iii'-->'sourceline(iii)
     end
     say '** end of rexx code **'
     say ' '
     say '/* **resolved rexx SQL code; statement began at' ,
         sqlstmt.stmtCursorNum.startSQLcaller ,
         'ended at'                           ,
         sqlstmt.stmtCursorNum.lastSQLcaller  ,
         ' */'
     say ' '
     say '/*   ** resolved SQL code follows:  */'
     iiiStart = sqlstmt.stmtCursorNum.StartSQLcaller
     iiiEnd   = sqlstmt.stmtCursorNum.lastSQLcaller
     do iii = iiiStart by 1 to iiiEnd
        if value('sqlStmt'stmtCursorNum'SiglIndx.'iii) = 0
        then iterate
        mmm = value('sqlStmt'stmtCursorNum'SiglIndx.'iii)
        rsql = sqlStmt.stmtCursorNum.mmm
        do while length(rsql) > 72
           rsql1 = left(rsql,72)
           rsql  = substr(rsql,73)
           say  '/*'   iii'-->'rsql1'<-- */'
        end
        say  '/*'   iii'-->'left(rsql,72)'<-- */'
     end
     say '/*   ** End of resolved SQL code ** */'
     say ' '
  end
  Say 'SQLCODE = 'SQLCODE
  Say 'SQLERRMC = 'SQLERRMC
  Say 'SQLERRP = 'SQLERRP
  Say 'SQLERRD = 'SQLERRD.1',',
              || SQLERRD.2',',
              || SQLERRD.3',',
              || SQLERRD.4',',
              || SQLERRD.5',',
              || SQLERRD.6

  Say 'SQLWARN = 'SQLWARN.1',',
              || SQLWARN.2',',
              || SQLWARN.3',',
              || SQLWARN.4',',
              || SQLWARN.5',',
              || SQLWARN.6',',
              || SQLWARN.7',',
              || SQLWARN.8',',
              || SQLWARN.9',',
              || SQLWARN.10

  Say 'SQLSTATE= 'SQLSTATE

  if zsqlsigl = 'ZSQLSIGL' | zsqlsigl = ''
  then prbL= sigl
  else do
     prbL = zsqlSigl
     say ' '
     say 'problem detected in ZSQL: routine'
  end
  say ' '
  say 'code near call to ZSQL: and/or call to PRTSQLCA at' prbL
  say ' '

  syntaxLow = max(prbL-12,1)           /*-12 before (or pgm start */
  syntaxHigh= min(prbL+4,sourceline()) /* +4 after  (or pgm end   */
  do syntaxII = syntaxLow to syntaxHigh/* show subset of lines    */
     if syntaxII <> prbL
     then say 'line   ' right(syntaxii,length(syntaxHigh))':' ,
                  sourceline(syntaxII)
     else say 'line==>' right(syntaxii,length(syntaxHigh))':' ,
                  sourceline(syntaxII)
  end
  say ' '
  say '** scroll up to "** start error analysis" to see start of'
  say '** ... the diagnostic messages for this problem.        '

  /* close (most) open files */
  /* ----------------------- */
  do i = 1 by 1 for openDDs
     ddname = openDDs.i
     address 'TSO' "EXECIO" bufferRecs.ddname ,
                     "DISKW" ddname '(FINIS STEM BUFFERX.'ddname'.'
     if rc <> 0
     then say 'error closing/writting to ddname='ddname ,
                                  ||';rc='rc
  end
  Exit 999
Return

clistcard:
  /* if called to write a blank line                         */
  /* then do                                                 */
  /*    if caller set useClass to a class (ex: MDSNPK)       */
  /*    then it will directed to that classes outut file.    */
  /*    if caller set rdef$permit to 'RDEF' or "PERMIT'      */
  /*    then it will direct line to RDEF or PE$ class file.  */
  /*    otherwise, it will use prior useClass + rdef$PERMIT  */
  /* end                                                     */
  /* else do                                                 */
  /*    for actual RDEF and PERMIT's it will update useClass */
  /*    and rdef$Permit variables automatically, to direct   */
  /*    output.                                              */
  /* end                                                     */
  parse arg clistcard
  ccData = ''

  if clistcard = ''
  then nop
  else if left(word(clistcard,1),4) = 'RDEF' ,
        | left(word(clistcard,1),4) = 'RALT'
  then do
     rdef$PERMIT = 'RDEF' /* override, just in case */
     parse upper var clistcard . useClass .
     clistCard = clistcard optionWarn
  end
  else if word(clistcard,words(clistCard)) = 'RESET'
  then do
     rdef$PERMIT = 'RDEF' /* override, just in case */
     parse upper var clistcard . 'CLASS(' useClass ')' .
  end
  else if pos(' CLASS(',clistCard) > 0
  then do
     rdef$PERMIT = 'PERMIT' /* override, just in case */
     parse upper var clistcard . 'CLASS(' useClass ')' .
  end
  else if rdef$permit = 'RDEF$PERMIT'
  then rdef$permit = 'RDEF'

  /* change-06/06/2023 add PE/noPE option */
  /*                                      */
  /* choose output dataset (to RDEF or PE dataset)                */
  /* ---------------------------------------------                */
  /* if rdef$permit = RDEF,  line should be written to rdef ddname*/
  /* else (rdef$permit = permit)                                  */
  /*    if peOption = PE,    line should be written to pe   ddname*/
  /*    else                 line re-routed to write 2 rdef ddname*/

  if rdef$permit = 'RDEF'
     then ddname = rdefIndx.useClass /* rdef output to rdef ddnames*/
  else do
     if peOption = 'PE' /* PE or NOPE (noPE); change-06/06/2023 */
     then ddname = pe$Indx.useClass  /*   PE option, pe output to pe  */
     else ddname = rdefIndx.useClass /* noPE option, pe output to rdef*/
  end

  if pos(' ID(',clistcard) > 0
  then do /* keep track of unique userid's */
     parse var clistcard frontHalf 'ID(' uidx ')' backhalf
     uidx = strip(uidx)

     if deleteId.uidx = 1
     then return 0 /* we want this userid deleted */

     if excludeIndx.uidx > 0
     then do
        /* userid is excluded; replace w/the replacement id/group */
        replace = excludeIndx.uidx
        uidx    = replace.replace
        clistcard = frontHalf 'ID('uidx')' backhalf
     end

     /* while we are here, add to # of unique userid's we know about*/
     if uidIndx.uidx = 0
     then do /* this is an unknown userid, add to our list */
        uid = uid + 1  /* we got another one */
        uid.uid = uidx /* add to list of sequential userid's */
        uidIndx.uidx = uid /* now add quick lookup for this userid */
     end
     if (  word(clistcard,1) = 'PERMIT' ,
         | word(clistcard,1) = 'PE'     ,
        )                               ,
     then do/* lets count permits by useclass by uidx */
        if classIndx.useclass = 0
        then do /* add to classlist */
           classList = classList + 1
           classList.classList = useClass
           classIndx.useClass  = classList
        end
        classIndx = classIndx.useClass
        uidIndx   = uidIndx.uidx
        PermitsByClass.classIndx.uidIndx = ,
                   PermitsByClass.Classindx.uidIndx + 1
     end
     if (  word(clistcard,1) = 'PERMIT' ,
         | word(clistcard,1) = 'PE'     ,
        )                               ,
        & pos(' DATA(',clistcard) = 0
     then do
        ccData = userGroupInfo(uidx)
        ccData = "DATA('"ccData"')"
     end
     else if (  word(clistcard,1) = 'PERMIT' ,
              | word(clistcard,1) = 'PE'     ,
             )                               ,
        & pos(' DATA(',clistcard) > 0
     then do
        if groupIndx.uidx > 0
        then do
           /* replace with group info */
           parse var clistcard clistcard ' DATA(' .
           ccData = userGroupInfo(uidx)
           ccData = "DATA('"ccData"')"
        end
        else if useridIndx.uidx > 0
        then do
           /* prefix with "user xyz;" */
           parse var clistcard clistCard " DATA('" ccData "'" .
           ccData = "DATA('user" uidx";" ccData"')"
        end
        else do
           /* replace with unknown user info */
           parse var clistcard clistCard ' DATA(' .
           ccData = userGroupInfo(uidx)
           ccData = "DATA('"ccData"')"
        end
     end
  end
  else uidx = ''

  clistx = bufferRecs.ddname + 1

  if word(clistcard,1) = '/*' | clistcard = ''
  then bufferX.ddname.clistx = clistcard
  else if word(clistcard,1) = 'RDEF' ,
        | word(clistcard,1) = 'RALT'
  then do

     bufferX.ddname.clistx = ' ' /* insert blank line */
     clistx = clistx + 1 /* now add RDEF card */

     bufferX.ddname.clistx = ,
              left(word(clistcard,1),10) subword(clistcard,2)
     if pos(' DATA(',bufferX.ddname.clistx) > 0
     then do
        parse var bufferX.ddname.clistx bufferX.ddname.clistx ,
           ' DATA(' rest
        bufferX.ddname.clistx = bufferX.ddname.clistx '-'
        if length(bufferx.DDname.clistx) > 120
        then do
           if pos(' UACC(',bufferx.DDname.clistx) > 0
           then do
              parse var bufferx.DDname.clistx bufferx.DDname.clistx ,
                 ' UACC(' uacc
              bufferx.DDname.clistx = bufferx.DDname.clistx '-'
              clistx = clistx + 1
              bufferx.DDname.clistx = left('',11) 'UACC('uacc
           end
           else if pos(' CLASS(',bufferx.DDname.clistx) > 0
           then do
              parse var bufferx.DDname.clistx bufferx.DDname.clistx ,
                 ' CLASS(' class
              bufferx.DDname.clistx = bufferx.DDname.clistx '-'
              clistx = clistx + 1
              bufferx.DDname.clistx = left('',11) 'CLASS('class
           end
        end
        clistx = clistx + 1
        bufferX.ddname.clistx = left('',11) 'DATA('rest
     end
  end
  else if ccData = ''
  then do                /* add permit, etc */

     bufferX.ddname.clistx = ' '
     clistx = clistx + 1

     bufferX.ddname.clistx = ,
              left('   'word(clistcard,1),length(class)+11) ,
                      subword(clistcard,2)
     if pos(' DATA(',bufferX.ddname.clistx) > 0
     then do
        parse var bufferX.ddname.clistx bufferX.ddname.clistx ,
           ' DATA(' rest
        bufferX.ddname.clistx = bufferX.ddname.clistx
        if length(bufferx.DDname.clistx) > 120
        then do
           if pos(' UACC(',bufferx.DDname.clistx) > 0
           then do
              parse var bufferx.DDname.clistx bufferx.DDname.clistx ,
                 ' UACC(' uacc
              bufferx.DDname.clistx = bufferx.DDname.clistx '-'
              clistx = clistx + 1
              bufferx.DDname.clistx = left('',11) 'UACC('uacc
           end
           else if pos(' CLASS(',bufferx.DDname.clistx) > 0
           then do
              parse var bufferx.DDname.clistx bufferx.DDname.clistx ,
                 ' CLASS(' class
              bufferx.DDname.clistx = bufferx.DDname.clistx '-'
              clistx = clistx + 1
              bufferx.DDname.clistx = left('',11) 'CLASS('class
           end
        end
        clistx = clistx + 1
        bufferX.ddname.clistx = left('',11) '/*' left(rest,90) '*/'
     end
  end
  else do                /* add permit, etc */

     bufferX.ddname.clistx = ' '
     clistx = clistx + 1

     bufferX.ddname.clistx = ,
              left('   'word(clistcard,1),length(class)+11) ,
                      subword(clistcard,2)
     if length(bufferx.DDname.clistx) > 120
     then do
        if pos(' UACC(',bufferx.DDname.clistx) > 0
        then do
           parse var bufferx.DDname.clistx bufferx.DDname.clistx ,
              ' UACC(' uacc
           bufferx.DDname.clistx = bufferx.DDname.clistx '-'
           clistx = clistx + 1
           bufferx.DDname.clistx = left('',11) 'UACC('uacc
        end
        else if pos(' CLASS(',bufferx.DDname.clistx) > 0
        then do
           parse var bufferx.DDname.clistx bufferx.DDname.clistx ,
              ' CLASS(' class
           bufferx.DDname.clistx = bufferx.DDname.clistx '-'
           clistx = clistx + 1
           bufferx.DDname.clistx = left('',11) 'CLASS('class
        end
     end
     clistx = clistx + 1
     bufferX.ddname.clistx = '        ' '/*' left(ccData,90) '*/'
  end

  if clistx > 100
  then do /* need to start writting out some of the buffer */
     Address TSO "EXECIO" clistx ,
                       "DISKW" ddname "(STEM bUFFERX."ddname"."
     if rc <> 0
     then do
        say 'error writting to ddname' ddname'; rc='rc
        if pendingrc = 0
        then do
           say 'will exit with rc=8'
           pendingrc = 8
        end
     end
     clistx = 0 /* reset number of recs in buffer to zero */
     bufferRecs.ddname = 0
  end
  else bufferRecs.ddname = clistx

  return 0

optClstCard:
  parse arg clistcard
  ccData = ''
  if pos(' ID(',clistcard) > 0
  then do /* keep track of unique userid's */
     parse var clistcard frontHalf 'ID(' uidx ')' backhalf
     uidx = strip(uidx)

     if deleteId.uidx = 1
     then return 0 /* we want this userid deleted */

     if excludeIndx.uidx > 0
     then do
        /* userid is excluded; replace w/the replacement id/group */
        replace = excludeIndx.uidx
        uidx    = replace.replace
        clistcard = frontHalf 'ID('uidx')' backhalf
     end

     /* while we are here, add to # of unique userid's we know about */
     if uidIndx.uidx = 0
     then do /* this is an unknown userid, add to our list */
        uid = uid + 1  /* we got another one */
        uid.uid = uidx /* add to list of sequential userid's */
        uidIndx.uidx = uid /* now add quick lookup for this userid */
     end
     if (  word(clistcard,1) = 'PERMIT' ,
         | word(clistcard,1) = 'PE'     ,
        )                               ,
        & pos(' DATA(',clistcard) = 0
     then do
        ccData = userGroupInfo(uidx)
        ccData = "DATA('"ccData"')"
     end
     else if (  word(clistcard,1) = 'PERMIT' ,
              | word(clistcard,1) = 'PE'     ,
             )                               ,
        & pos(' DATA(',clistcard) > 0
     then do
        if groupIndx.uidx > 0
        then do
           /* replace with group info */
           parse var clistcard clistcard ' DATA(' .
           ccData = userGroupInfo(uidx)
           ccData = "DATA('"ccData"')"
        end
        else if useridIndx.uidx > 0
        then do
           /* prefix with "user xyz;" */
           parse var clistcard clistCard " DATA('" ccData "'" .
           ccData = "DATA('user" uidx";" ccData"')"
        end
        else do
           /* replace with unknown user info */
           parse var clistcard clistCard ' DATA(' .
           ccData = userGroupInfo(uidx)
           ccData = "DATA('"ccData"')"
        end
     end
  end
  else uidx = ''
  optClstx = optClstx + 1
  if left(word(clistcard,1),2) = '/*' | clistcard = ''
  then optClstx.optClstx = clistcard
  else if word(clistcard,1) = 'RDEF'
  then do
     optClstx.optClstx = ' ' /* insert blank line */
     optClstx = optClstx + 1 /* now add RDEF card */
     optClstx.optClstx = left(word(clistcard,1),10) subword(clistcard,2)
     parse var optClstX.optClstx optClstX.optClstx ,
        ' DATA(' rest
     optClstX.optClstx = optClstX.optClstx '-'
     optClstx = optClstx + 1 /* now add data card */
     optClstX.optClstx = left('',11) 'DATA('rest
  end
  else do                    /* add permit card, etc*/
     optClstx.optClstx = left('   'word(clistcard,1),length(class)+11) ,
                           subword(clistcard,2) ccData
     parse var optClstX.optClstx optClstX.optClstx ,
        ' DATA(' rest
     if rest <> ''
     then do
        optClstX.optClstx = optClstX.optClstx '-'
        optClstx = optClstx + 1 /* now add data card */
        optClstX.optClstx = left('',11) 'DATA('rest
     end
  end
  return 0

addExclude:
  /* if we are changing userids, that happens in a case statement */
  /* if we are rejecting userids (deletes) that goes in a "not in"*/
  /*    list                                                      */
  parse upper arg excludeId groupid .
  exclude = exclude + 1
  exclude.exclude = excludeId
  replace.exclude = groupid
  excludeIndx.excludeId = exclude
  if groupid = '*DELETE'
  then do
     /* *DELETE(s) go into a "NOT IN ('id1','id2','id3'... list */
     deleteId.excludeId = 1
     RemoveUserList = removeUserList commaParen||"'"excludeId"'"
     commaParen = ',' /* switch from ( to , */
  end
  else granteeCase = granteeCase , /* changes go into case stmt */
               "when upper(a.grantee) = '"excludeId"' then '"groupid"'"
  return 0


userGroupInfo:
  parse upper arg userORgroup .
  if useridIndx.userORgroup > 0
  then do
     /* we have user info */
     uix = useridIndx.userORgroup
     userRef.uix = 1
     userORgroup = left(userORgroup,max(8,length(userorGroup)))
     if revoked.uix = 'No'
     then return 'User='userOrGroup'; d-grp='left(usersDgroup.uix,8) ,
                ||'; migDate='date('U') ,
                ||'; name='strip(usersName.uix)
     return 'User='userOrGroup'; d-grp='left(usersDgroup.uix,8) ,
                ||'; revoke='revoked.uix'; name='strip(usersName.uix)
  end
  else if groupIndx.userORgroup > 0
  then do
     /* we have group info */
     gix = groupIndx.userORgroup
     groupRef.gix = 1
     userORgroup = left(userORgroup,max(8,length(userorGroup)))
     return 'Group='userORgroup'; desc='groupdesc.gix
  end
  else do
     /* we have no info */
      /* now remember some information about the user */
     userid = userid.0
     userid = userid + 1
     userid.0 = userid
     useridIndx.UserORgroup = userid
     userid.userid = UserORgroup
     revoked.userid= '?'
     usersName.userid = 'Not in Racf'
     usersDGroup.userid = '?'
     usersGroups.userid = 0  /* collect user groups with 0205's*/

     uix = userid
     userRef.uix = 1
     userORgroup = left(userORgroup,max(8,length(userorGroup)))
     return 'User='userOrGroup'; d-grp='left(usersDgroup.uix,8)';',
                    'revoke='revoked.uix'; name='strip(usersName.uix)
  end

changestr:
  /* function to replace string (1st parm) */
  /*          in haystack string(2nd parm) */
  /*           w/string         (3rd parm) */
  cNeedleParm1   = arg(1) /* string (needle) to replace */
  cHaystackParm2 = arg(2) /* haystack to be updated.   */
  cReplacementParm3 = arg(3) /* replacement string*/

  cTempHaystack = cHaystackParm2 /* use as temp string */
  cReturnValue = '' /* uas as string to build up */

  if length(cNeedleParm1) = 0/* if parm1 is null                 */
  then return cHaystackParm2 /* then return parm2, nothing to do */

  x = pos(cNeedleParm1,cTempHaystack) /* find needle in haystack*/
  do while x > 0
     if x > 1
     then do
        cReturnValue = cReturnValue || left(cTempHaystack,x-1) ,
                                    || cReplacementParm3
        cTempHaystack = substr(cTempHaystack,length(cNeedleParm1)+x)
     end
     else do /* x = 1 */
        cReturnValue = cReturnValue || cReplacementParm3
        cTempHaystack = substr(cTempHaystack,length(cNeedleParm1)+x)
     end
     x = pos(cNeedleParm1,cTempHaystack) /* find needle in remaining*/
                                         /* haystack, if any        */
  end
  cReturnValue = cReturnValue || cTempHaystack
  return cReturnValue

sql:
   /* function.  collects sql statement in readable form */
   /*    ...we'll set (and append) to stem SQLSTMT       */
   /*    which will be executed later                    */
   /* if called with argument "new statement" we will    */
   /*    set stem SQLSTMT.0 = 0                          */
   /*    set stem SQLSTMT.startSQLcaller = sigl          */
   /* otherwise                                          */
   /*    we will increament SQLSTMT.0 and set next line  */
   /*    SQLSTMT.# to the callers argument               */
   /*    set stem SQLSTMT.lastSQLcaller = sigl           */
   parse upper arg sql1 sql2 ';' option '=' value .
   if sql1 sql2 = 'NEW STATEMENT'
   then do
      if option = 'STMT/CURSOR'
      then do
         if value = ''
         then do
            parse upper arg passedArgs
            say 'invalid function call to SQL from' sigl
            say 'args ='passedArgs
            say 'but missing # for STMT/CURSOR option'
            exit 12
         end
         if datatype(value,'W') = 0 ,
          | value < 1 | value > 100
         then do
            parse upper arg passedArgs
            say 'invalid function call to SQL from' sigl
            say 'args ='passedArgs
            say 'but STMT/CURSOR value "'value'" is invalid'
            exit 12
         end
         sqlStmtValue = value
      end
      else if option <> ''
      then do
         parse upper arg passedArgs
         say 'invalid function call to SQL from' sigl
         say 'args ='passedArgs
         say 'but option "'option'" after ";" is invalid'
         say 'expected option "; STMT/CURSOR=#'
         exit 12
      end
      else do
         sqlStmtValue = 1 /* default stmt/cursor to use */
      end

      SQLSTMT.sqlStmtValue.0 = 0
      SQLSTMT.sqlStmtValue.StartSQLcaller = sigl /* New Statement line*/
      x = value('sqlStmt'SqlStmtValue'SiglIndx.',0)
      return 0
   end
   sqlstmt = sqlstmt.SqlStmtValue.0 + 1
   parse arg sqlStmtLine
   sqlstmt.SqlStmtValue.0 = sqlstmt
   sqlstmt.SqlStmtValue.sqlstmt = sqlStmtLine /* save sql code*/

      /*Note:                                   */
      /* sigl = callers line # (in rexx code)   */
      /* sqlstmt = line # of sql code (1 to n)  */
      /*                                        */
      /*Set :                                   */
      /* sqlStmt||sqlStmtValue||SiglIndx.sigl   = sqlstmt     */
      /*                                                      */
      /*Usage:                                                */
      /* which lines of rexx code actually used in sql stmt.  */
      /*                                                      */

      /* set it here */
   x = value('sqlstmt'sqlStmtValue'SiglIndx.'sigl,sqlStmt)
   sqlstmt.SqlStmtValue.LastSQLCaller = sigl    /* last call to sql: */
   return 0

  /* Get RACF information, so that we know (a lot), about the */
  /*    1) real users, that are currently active              */
  /*    2) real users, but that are revoked.                  */
  /*    3) users/groups that no longer exist.                 */
  /*    4) groups (and their members)                         */
  /* and write information out for our information.           */
  /* -------------------------------------------------------- */
processRACFdata:
   /* read in our RACF summary */
   address TSO 'EXECIO 100 DISKR RACFSMRY (STEM RACFSMRY.'
   if rc <> 0
   then do
      say 'RACFSMRY dd not available; rc='rc
      say 'we will just exit now with rc=8'
      address tso 'EXECIO 0 DISKR RACFSMRY (FINIS'
      exit 8
   end
   racfsmryRc = rc

   racfsmryRc = 0
   racfsmry = 0 /* logical ptr into the RACFSMRY. buffer */
   group = 0
   groupIndx. = 0
   groupName. = ''
   groupDesc. = ''
   groupRef.  = 0
   userid = 0
   useridIndx. = 0
   userId.   = ''
   userRef.  = 0
   dateS = date('s')
   parse var dateS 1 yyyy 5 mm 7 dd
   currentDate = yyyy'-'mm'-'dd

   /* invent special userid's PUBLIC and *PUBLIC */
   racfUserid = 'PUBLIC'
   revoke     = 'NO'
   usersName  = ''
   usersDefaultGroup = ''
   usersLastDate = ''
   usersLastTime = ''
     /* add "user" PUBLIC */
   userid = userid + 1
   useridIndx.racfUserid = userid
   userid.userid = racfUserid
   revoked.userid= revoke
   usersName.userid = usersName
   usersDGroup.userid = usersDefaultGroup
   usersGroups.userid = 0  /* collect user groups with 0205's*/
   usersLastDate.userid = usersLastDate
   usersLastTime.userid = usersLastTime

   do forever /* process all logical recs in RACFSMRY. buffers */
      racfsmry = racfsmry + 1 /* get next logical record */
      if racfsmry > racfsmry.0 /* need another buffer? */
      then do /* yes, get another buffer */
         if racfsmryRc <> 0
         then leave /* either we working on last buffer, or bad rc */
         address tso 'EXECIO 100 DISKR RACFSMRY (STEM RACFSMRY.'
         racfsmryRc = rc
         racfsmry = 0 /* reset logical buffer pointer */
         iterate
      end
      /* we have a good racfsmry pointer into the buffer */
      parse var racfsmry.racfsmry ,
         1 racftype ,
         5 .
      if racftype = '0100' /* we need to look at a racf group */
      then do
         parse var racfsmry.racfsmry ,
            . /* ignore first word, it's 0100 */ ,
            groupName superGrpName createDate groupOwner groupUacc . ,
            58 groupDesc 313 . 314 groupModel groupUniversal .
         if groupIndx.groupname = 0 /* they are all unique, but check*/
         then do /* unknown, add to rexx stems */

            /* change single to double single quotes in GroupDesc */
            groupDesc = strip(groupDesc)
            if pos("'",GroupDesc) > 0
            then do /* change single to double single quotes */
               parse var GroupDesc GroupDesc "'" rest
               do forever
                  GroupDesc = GroupDesc"''"
                  if left(rest,1) = "'"
                  then rest = substr(rest,2) /* double single quotes*/
                  if rest = '' then leave
                  if pos("'",rest) = 0
                  then do
                     groupdesc= GroupDesc || rest
                     leave
                  end
                  parse var rest leftside "'" rest
                  GroupDesc = GroupDesc || leftside
                  iterate
               end
            end

            /* now remember some information about the group */
            group = group + 1 /* it's a new group */
            groupIndx.groupName = group /* update index, to find us */
            groupName.group = groupName /* groupname.# = groupname  */
            /* save details, in case we want to know later */
            superGrpName.group = SuperGrpname
            groupCreateDate.group = createDate
            groupOwner.group      = groupOwner
            groupUacc.group       = groupUacc
            groupDesc.group       = strip(groupDesc)
            groupModel.group      = strip(groupModel)
            groupUniversal.group  = groupUniversal
            groupMembers.group    = ''
            groupMembersStatus.group = ''
         end
         else nop /* this will never happen, just documenting */
      end

      else if racftype = '0200' /* we are looking at a user record */
      then do /* handle type 0200 "user basic data record (0200)   */
         /* these are really big... here we will just ignore a lot */
         /* of the 0200 record                                     */
         parse var racfsmry.racfsmry ,
            . /* ignore first word, it's 0200 */ ,
            racfUserid ,
            userCreateDate ,
            UseridOwner    ,
            . /* let's ignore stuff for a while */ ,
            50 revoke ,
            54 . /* ignore some more */ ,
            75 usersName ,
            96 UsersDefaultGroup ,
           105 UsersLastTime ,
               UsersLastDate ,
           124 . /* ignore some more */ ,
           458 usersRevokeDate ,
           469 usersResumedate ,
           480 .

         /* according to RACF, revoke setting is meaningless */
         /* ... and dates are what is important.             */
         if      usersRevokeDate = ''
         then revoke = 'No' /* no revoke date = no revoke */


         else if usersResumeDate = '' /* no intention to resume */
         then do /* either Revoke "pending" or Revoked "now"   */
            if currentDate < usersRevokeDate
            then revoke = 'Pending'
            else revoke = 'Yes'
         end

         else do
            /* dates are NOT null, figure it out */

            /* we have two dates (revoke and resume) */
            if currentDate >= usersResumedate
            then ResumeNow = 1 /* resume time has come */
            else ResumeNow = 0 /* ... not yet          */

            if currentDate >= usersRevokeDate
            then RevokeNow = 1 /* revoke time has come */
            else revokeNow = 0 /* ...not yet           */

            /* check resumedNow and RevokeNow and dates */
            /* ---------------------------------------- */
            if revokeNow = 0        /* revoke in future? */
            then revoke = 'Pending' /* yes, revoke is pending */

            else if revokeNow = 1 ,  /* revoke now            */
                  & resumeNow = 0    /* but resume in future? */
            then revoke = 'Yes'      /* ...yeah, we're revoked*/

            else do /* revokeNow = 1 and resumeNow = 1*/
               /* time to revoke or resume user, check dates */
               if usersResumeDate > usersRevokeDate
               then revoke = 'No' /* resumed... (revoke meaningless)*/
               else revoke = 'Yes'/* revoked... (resume meaningless)*/
            end

         end
         /* revoke has been set to "Yes", "No" or "Pending" */

         /* change single quote to double single quotes in usersName */
         if pos("'",usersName) > 0
         then do /* change single to double single quotes */
            parse var usersname usersName "'" rest
            do forever
               usersName = usersName"''"
               if left(rest,1) = "'"
               then rest = substr(rest,2) /* already double single ' */
               if rest = '' then leave
               if pos("'",rest) = 0
               then do
                  username = usersname || rest
                  leave
               end
               parse var rest leftside "'" rest
               usersName = usersName || leftside
               iterate
            end
         end

         /* now remember some information about the user */
         userid = userid + 1
         useridIndx.racfUserid = userid
         userid.userid = racfUserid
         revoked.userid= revoke
         usersName.userid = usersName
         usersDGroup.userid = usersDefaultGroup
         usersGroups.userid = 0  /* collect user groups with 0205's*/
         usersLastDate.userid = usersLastDate
         usersLastTime.userid = usersLastTime
      end

      else if racftype = '0205' /* looking at user (group) connect */
      then do
         /* these are really big... here we will just ignore a lot */
         /* of the 0200 record                                     */
         parse var racfsmry.racfsmry ,
            . /* ignore first word, it's 0200 */ ,
            racfUserid ,
            racfGroup ,
            racfConnectedDate ,
            racfGroupOwner ,
            . ,
            racfLastConnectDate ,
            . ,
            109 . ,
            racfGroupRevokeDate ,
            racfGroupResumeDate ,
            .

         uidx = useridIndx.racfUserid
         /* according to RACF, revoke setting is meaningless */
         /* ... and dates are what is important.             */
         if      racfGroupRevokeDate = ''
         then revoke = 'No' /* no revoke date = no revoke */


         else if racfGroupResumeDate = '' /* no intention to resume */
         then do /* either Revoke "pending" or Revoked "now"   */
            if currentDate < racfGroupRevokeDate
            then revoke = 'Pending'
            else revoke = 'Yes'
         end

         else do
            /* dates are NOT null, figure it out */

            /* we have two dates (revoke and resume) */
            if currentDate >= racfGroupResumeDate
            then ResumeNow = 1 /* resume time has come */
            else ResumeNow = 0 /* ... not yet          */

            if currentDate >= racfGroupRevokeDate
            then RevokeNow = 1 /* revoke time has come */
            else revokeNow = 0 /* ...not yet           */

            /* check resumedNow and RevokeNow and dates */
            /* ---------------------------------------- */
            if revokeNow = 0        /* revoke in future? */
            then revoke = 'Pending' /* yes, revoke is pending */

            else if revokeNow = 1 ,  /* revoke now            */
                  & resumeNow = 0    /* but resume in future? */
            then revoke = 'Yes'      /* ...yeah, we're revoked*/

            else do /* revokeNow = 1 and resumeNow = 1*/
               /* time to revoke or resume user, check dates */
               if racfGroupResumeDate > racfGroupRevokeDate
               then revoke = 'No' /* resumed... (revoke meaningless)*/
               else revoke = 'Yes'/* revoked... (resume meaningless)*/
            end

         end
         /* revoke has been set to "Yes", "No" or "Pending" */

         /* now add user to this group */
         groupIndx = groupIndx.racfGroup /* find index to group */
         if groupIndx <> 0
         then do /* if group exists, add member info */
            groupMembers.groupIndx = groupMembers.GroupIndx racfUserid
            groupMembersStatus.groupIndx = ,
                                   groupMembersStatus.groupIndx revoke
         end
      end
   end

   if racfsmryRc <> 2
   then do
      say 'EXECIO to read from RACFSMRY failed with rc='rc
      say 'will exit rc=8'
      address 'TSO' 'EXECIO 0 DISKR RACFSMRY (FINIS'
      exit 8
   end
   address 'TSO' 'EXECIO 0 DISKR RACFSMRY (FINIS'
   userid.0 = userid
   say ' '
   say 'ProcessRACFdata routine has found:'
   say '   # of RACF userids = 'userid
   say '   # of RACF groups  = 'group
   say '   These will be important as we look at db2 grants'
   say ' '
   if userid.0 = 0 & group = 0
   then do
      say 'With zero userid and/or group information, this output'
      say 'will be missing valuable RACF permits, etc.'
   end
   return

ShowRowCount:
   if sqlOption <> 'SQL'
   then return

   x = clistcard(' ')

   cmd = '    /* rowsReturned =' rowsReturned '*/'
   x = clistcard(cmd)

   cmd = '    /* --------------' RowsReturned '*/'
   x = clistcard(cmd)

   x = clistcard(' ')
   return

ShowRowCount2:
   if sqlOption <> 'SQL'
   then return

   x = clistcard(' ')

   cmd = '    /* rowsReturnedC2 =' rowsReturnedC2 '*/'
   x = clistcard(cmd)

   cmd = '    /* ----------------' rowsReturnedC2 '*/'
   x = clistcard(cmd)

   x = clistcard(' ')
   return
