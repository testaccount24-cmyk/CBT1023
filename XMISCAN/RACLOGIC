/* rexx */
  trace 's'

/*  rexx member for scan/xref was: */
/*     "SFRH66.CNTL.RACFDB2.PDS(RACLOGIC)"      */
/*      ---------------------------------       */
/*  date/time of XREF was:                      */
/*     20231217 23:04:52                        */
/*      ---------------------------------       */

/* rexx */
/* ***************************************************************** */
/* raclogic - rexx exec                                              */
/* ***************************************************************** */
/*                                                                   */
/* purpose:  Only for human's to read the RDEFs and PERMITs in a     */
/*    way that makes it easier for us to process.                    */
/*                                                                   */
/*    It is totally unneccesary to use this rexx exec.  Or to run    */
/*    the job RACLOG$T which invokes this rexx exec.                 */
/*                                                                   */
/*    However, the output will group the RDEFs and it's associated   */
/*    permits togeather.  Which will help anyone who wishes to       */
/*    validate the RACF output.                                      */
/*                                                                   */
/*    Note:  for MDSNPK, priviledges granted to collid.* will be     */
/*    added to any specific collid.packagename for BIND, COPY,       */
/*    EXECUTE, etc. priviledges.                                     */
/*                                                                   */
/* ***************************************************************** */
/*                                                                   */
/*    Sometimes a group of rdef's will be generated, followed by     */
/* a group of permits for those rdefs.                               */
/*                                                                   */
/*    This will resequence output (and delete comments) so that      */
/* any permits for an rdef will be grouped with that rdef.           */
/*                                                                   */
/* ***************************************************************** */
/*    input1 should contain permits, maybe from PE$TB for example    */
/*    input2 should contain permits, maybe from PE$TB for example    */
/*    input3 should contain RDEFs,   maybe from RDEFTB for example   */
/*                                                                   */
/*      --                                                           */
/*      or they call all be the same file when (noPE was specified)  */
/*      --                                                           */
/*      So, wehen the noPE option is used, then:                     */
/*    input1 should contain permits, maybe from RDEFTB for example   */
/*    input2 should contain permits, maybe from RDEFTB for example   */
/*    input3 should contain RDEFs,   maybe from RDEFTB for example   */
/*                                                                   */
/*    The reason for 2 PE files is that sometimes permits are        */
/*    not generated by the same sql statement, so we need to two     */
/*    input streams to match them all up.                            */
/*                                                                   */
/*    output gets the RDEF and PERMITs in logical groupings without  */
/*          comments.                                                */
/*                                                                   */
/*          This doesn't change any functionality, but makes it      */
/*         easier for humans to understand rdef/permits.             */
/*                                                                   */
/*          The other value is if you want to compare output from    */
/*         one version to another, it also simplifies things.        */
/*                                                                   */
/*                                                                   */
/* ***************************************************************** */
address 'TSO'

'EXECIO 0 DISKW OUTPUT (OPEN' /* open output file */
outputRc = rc
output = 0 /* no records currently in output buffer */

'EXECIO 100 DISKR INPUT1 (OPEN STEM INPUT1.' /* read block of recs */
input1Rc = rc
input1   = 0 /* no input1 records processed yet */

'EXECIO 100 DISKR INPUT2 (OPEN STEM INPUT2.' /* read block of recs */
input2rc = rc
input2   = 0 /* no input2 records processed yet */

'EXECIO 100 DISKR INPUT3 (OPEN STEM INPUT3.' /* read block of recs */
input3rc = rc
input3   = 0 /* no input2 records processed yet */

if (input1rc <> 0 & input1rc <> 2) , /*   bad open for input1 */
 | (input2rc <> 0 & input2rc <> 2) , /*or bad open for input2 */
 | (input3rc <> 0 & input3rc <> 2) , /*or bad open for input2 */
 | outputRc <> 0                     /*or bad open for output */
then do /* open problems */
   if outputRc <> 0
   then say 'Open for ddname=OUTPUT failed with rc='outputRc
   if input1Rc <> 0 & input1Rc <> 2
   then say 'Open for ddname=INPUT1 failed with rc='input1Rc
   if input2Rc <> 0 & input2Rc <> 2
   then say 'Open for ddname=INPUT2 failed with rc='input2Rc
   if input3Rc <> 0 & input3Rc <> 2
   then say 'Open for ddname=INPUT3 failed with rc='input3Rc
   'EXECIO 0 DISKW OUTPUT (FINIS'
   'EXECIO 0 DISKR INPUT1 (FINIS'
   'EXECIO 0 DISKR INPUT2 (FINIS'
   'EXECIO 0 DISKR INPUT3 (FINIS'
   say 'aborting due to open failures, with rc=8'
   exit 8
end

rdef = ''
data = ''
permit = ''
totalInput1 = 0
totalInput2 = 0
totalInput3 = 0
/* read input1 skipping ... and only stop skipping when we get to a  */
/*                          real permit that we need to output the   */
/*                          rdef first                               */
do forever
   input1 = input1 + 1  /* get next input1 rec to process */
   if input1 > input1.0 /* out of recs in input1 buffer? */
   then do
      if input1Rc = 2 /* out of records in input1 file? */
      then leave      /* ...yes, leave loop now */
      'EXECIO 100 DISKR INPUT1 (STEM INPUT1.'
      input1 = 0
      input1Rc = rc
      if input1Rc = 0 | input1Rc = 2
      then iterate /* we have a block of recs to process, iterate */

      /* report i/o error and close files */
      say 'Read for ddname=INPUT1 failed with rc='input1Rc
      'EXECIO' output 'DISKW OUTPUT (stem output. FINIS'
      'EXECIO 0 DISKR INPUT1 (FINIS'
      'EXECIO 0 DISKR INPUT2 (FINIS'
      'EXECIO 0 DISKR INPUT3 (FINIS'
      say 'aborting now with rc=8'
      exit 8
   end
   totalInput1 = totalInput1 + 1
   word1 = word(input1.input1,1)
   if word1 = '' then iterate
   if left(word1,2) = '/*'    then iterate
   if word1 = 'RDEF'          then iterate
   if left(word1,5) = 'DATA(' then iterate
   if word1 = 'PERMIT' & wordpos('RESET',input1.input1) > 0
   then iterate
   if word1 = 'PE'     & wordpos('RESET',input1.input1) > 0
   then iterate
   if word1 = 'PERMIT'
   then do
      /* we found a explicit permit */
      /* so set the "permitProfileKey" so we can find a matching rdef */
      /* ...and leave so we can find rdef in next loop.               */
      parse var input1.input1 . permitProfileKey1 .
      startPermit1 = totalinput1
      break1 = totalinput1 /* initialize */
      leave
   end
   if word1 = 'PE'
   then do
      /* we found a explicit permit */
      /* so set the "permitProfileKey" so we can find a matching rdef */
      /* ...and leave so we can find rdef in next loop.               */
      parse var input1.input1 . permitProfileKey1 .
      startPermit1 = totalinput1
      break1 = totalinput1 /* initialize */
      leave
   end
end
if input1 > input1.0 & input1rc <> 2
then do
   /* fatal error, close files and exit */
   say 'Reading from ddname=INPUT2 the EXECIO failed with rc='input2Rc
   say 'closing files and exiting w/rc = 8'
   'EXECIO 0 DISKR INPUT1 (FINIS'
   'EXECIO 0 DISKR INPUT2 (FINIS'
   'EXECIO 0 DISKR INPUT3 (FINIS'
   'EXECIO' output 'DISKW OUTPUT (STEM OUTPUT. FINIS'
   exit 8
end
if input1 > input1.0 & input1rc = 2
then permitProfileKey1= '' /* we found no pending permit, just write */
                           /* everything that's left                 */

/* read input2 skipping ... first position ourselves at same record  */
/*                          as input1.  Then skip past rows returned,*/
/*                          then find the next permit (group).       */
if input1rc = 2 & input1 > input1.0 /* at eof on input1? */
then do
   /* just simulate eof on input2, no need to read file */
   input2rc = 2
   input2 = input2.0 + 1
   permitProfileKey2 = ''
end
else do
   /* otherwise, we need to reposition to totalinput1 position */
   /* ... and then to line "rowsReturned".                     */
   do forever
      input2 = input2 + 1  /* get next input2 rec to process */
      if input2 > input2.0 /* out of recs in input2 buffer? */
      then do
         if input2Rc = 2 /* out of records in input2 file? */
         then leave      /* ...yes, leave loop now */
         'EXECIO 100 DISKR INPUT2 (STEM INPUT2.'
         input2 = 0
         input2Rc = rc
         if input2Rc = 0 | input2Rc = 2
         then iterate /* we have a block of recs to process, iterate */

         /* report i/o error and close files */
         say 'Read for ddname=INPUT2 failed with rc='input2Rc
         'EXECIO' output 'DISKW OUTPUT (stem output. FINIS'
         'EXECIO 0 DISKR INPUT1 (FINIS'
         'EXECIO 0 DISKR INPUT2 (FINIS'
         'EXECIO 0 DISKR INPUT3 (FINIS'
         say 'aborting now with rc=8'
         exit 8
      end
      totalInput2 = totalInput2 + 1
      if totalInput2 < totalInput1 then iterate /*position to input1 */

      /* start looking for "rows returned, only after we're past the */
      /* input1 position.                                            */
      word2 = word(input2.input2,2)
      if word2 = 'rowsReturned' then leave
   end
   /* now we want to position input2 to 2nd group of permits */
   /* ...past those input1 is looking at.                    */
   do forever
      input2 = input2 + 1  /* get next input2 rec to process */
      if input2 > input2.0 /* out of recs in input2 buffer? */
      then do
         if input2Rc = 2 /* out of records in input2 file? */
         then leave      /* ...yes, leave loop now */
         'EXECIO 100 DISKR INPUT2 (STEM INPUT2.'
         input2 = 0
         input2Rc = rc
         if input2Rc = 0 | input2Rc = 2
         then iterate /* we have a block of recs to process, iterate */

         /* report i/o error and close files */
         say 'Read for ddname=INPUT2 failed with rc='input2Rc
         'EXECIO' output 'DISKW OUTPUT (stem output. FINIS'
         'EXECIO 0 DISKR INPUT1 (FINIS'
         'EXECIO 0 DISKR INPUT2 (FINIS'
         'EXECIO 0 DISKR INPUT3 (FINIS'
         say 'aborting now with rc=8'
         exit 8
      end
      totalInput2 = totalInput2 + 1
      word1 = word(input2.input2,1)
      if word1 = '' then iterate
      if left(word1,2) = '/*'    then iterate
      if word1 = 'RDEF'          then iterate
      if left(word1,5) = 'DATA(' then iterate
      if word1 = 'PERMIT' & wordpos('RESET',input2.input2) > 0
      then iterate
      if word1 = 'PE'     & wordpos('RESET',input2.input2) > 0
      then iterate
      if word1 = 'PERMIT'
      then do
         /* we found a explicit permit */
         /* so set the "permitProfileKey2"...to find a matching rdef */
         /* ...and leave so we can find rdef in next loop.           */
         parse var input2.input2 . permitProfileKey2 .
         startPermit2 = totalinput2
         break2 = totalinput2 /* initialize */
         leave
      end
      if word1 = 'PE'
      then do
         /* we found a explicit permit */
         /* so set the "permitProfileKey2"...to find a matching rdef */
         /* ...and leave so we can find rdef in next loop.           */
         parse var input2.input2 . permitProfileKey2 .
         startPermit2 = totalinput2
         break2 = totalinput2 /* initialize */
         leave
      end
   end
end
if input2 > input2.0 & input2rc <> 2
then do
   /* fatal error, close files and exit */
   say 'Reading from ddname=INPUT2 the EXECIO failed with rc='input2Rc
   say 'closing files and exiting w/rc = 8'
   'EXECIO 0 DISKR INPUT1 (FINIS'
   'EXECIO 0 DISKR INPUT2 (FINIS'
   'EXECIO 0 DISKR INPUT3 (FINIS'
   'EXECIO' output 'DISKW OUTPUT (STEM OUTPUT. FINIS'
   exit 8
end
if input2 > input2.0 & input2rc = 2
then permitProfileKey2= '' /* we found no pending permit, just write */
                           /* everything that's left                 */

/* -------------------------------------------------------------------*/
/* at this time, INPUT1 will be positioned at the 1st group of permits*/
/* at this time, INPUT2 will be positioned at the 2nd group of permits*/
/* and input3, we will use to find rdefs                              */
/* -------------------------------------------------------------------*/

/* ------------------------------------------------------------------ */
/* now start the process to find and output rdefs, ralts, and permits */
/* ------------------------------------------------------------------ */
do while (input1rc = 0 | input2rc = 0 | input3rc = 0),/*input has data*/
       | input1rc = 2 & input1 <= input1.0 ,/* input1 not at eof)    */
       | input2rc = 2 & input2 <= input2.0 ,/* input2 not at eof)  */
       | input3rc = 2 & input3 <= input3.0  /* input3 not at eof) */
                                            /*  ...but pending eof   */
   /* while we have data in buffers, we may have an actual PERMIT   */
   /*    PERMIT pending in input1.input1 (or at eof on input1)      */
   /*    PERMIT pending in input2.input2 (or at eof on input2)      */
   /* we need to write out all RDEF/DATA/PERMIT's in input3 until we*/
   /*    find a matching RDEF/DATA/PERMIT for input1/input2 permit  */

   do while input3rc = 0 | (input3rc = 2 & input3 <= input3.0)
      /* keep writting out rdef/data/pemit (reset) sequences we find*/
      /*    in input3.input3                                        */
      /* stop when last sequence (we put in output buffer) matches  */
      /*    the pending (explicit) permit we have in input1.input1  */
      /*                                       or in input2.input2  */

      /* output buffer management, nothing to do with loop logic */
      if output > 100 /* output buffer too full?              */
      then do         /* ...yes, then empty output buffer now */
         /* let's write out an output buffer */
         'EXECIO' output 'DISKW OUTPUT (STEM OUTPUT.'
         output = 0
         outputRc = rc
         if outputRc > 0
         then do
            say 'Error writting to ddname=OUTPUT, rc='outputrc
            say 'aborting now'
            'EXECIO 0 DISKR INPUT1 (FINIS'
            'EXECIO 0 DISKR INPUT2 (FINIS'
            'EXECIO 0 DISKR INPUT3 (FINIS'
            'EXECIO 0 DISKW OUTPUT (FINIS'
            exit 8
         end
         /* output buffer emptied, next buffer ready */
      end

      input3 = input3 + 1  /* get next input3 record to process */
      if input3 > input3.0 /* out of recs in input3 buffer? */
      then do
         if input3Rc = 2 /* out of records in input3 file? */
         then leave      /* ...yes, leave loop now */

         /* get another buffer of input3 records */
         'EXECIO 100 DISKR INPUT3 (STEM INPUT3.'
         input3 = 0 /* no records processed in new buffer */
         input3Rc = rc /* remember execio rc for input2 */
         if input3Rc = 0 | input3Rc = 2 /* ensure good rc on execio */
         then iterate /* we have a block of recs to process */

         /* report i/o error and close files */
         say 'Read for ddname=INPUT3 failed with rc='input3Rc
         'EXECIO' output 'DISKW OUTPUT (stem output. FINIS'
         'EXECIO 0 DISKR INPUT1 (FINIS'
         'EXECIO 0 DISKR INPUT2 (FINIS'
         'EXECIO 0 DISKR INPUT3 (FINIS'
         say 'aborting now with rc=8'
         exit 8
         leave /* leave if bad input2Rc */
      end

      /* we have input record in input2.input2 */
      totalInput3 = totalInput3 + 1 /* count total input3 recs seen*/

      /* set word1 for this input record... to speed tests */
      word1 = word(input3.input3,1)
      if word1 = '' then iterate
      if left(word1,2) = '/*' then iterate
      if word1 = 'RDEF'
      then do
         /* output RDEF record (in RDEF, DATA, PERMIT w/RESET sequence*/
         parse var input3.input3 . rdefClass rdefProfileKey .
         output = output + 1; output.output = input3.input3
         iterate /* now get data card in sequence */
      end

      if word1 = 'RALT'
      then do
         /* output RALT record (in RALT, DATA sequence */
         parse var input3.input3 . rdefClass rdefProfileKey .
         output = output + 1; output.output = input3.input3
         iterate /* now get data card in sequence */
      end

      if left(word1,5) = 'DATA('
      then do
         /* output DATA record (in RDEF, DATA, PERMIT w/RESET sequence*/
         output = output + 1; output.output = input3.input3
         iterate /* now get permit w/ reset in sequence */
      end

      if word1 = 'PERMIT' & wordpos('RESET',input3.input3) > 0
      then do
         /* reset profile found */
         output = output + 1; output.output = input3.input3

         /* now after outputing RDEF/DATA/PERMIT w/RESET sequence */
         /* check to see if this rdef is for our pending permit   */
         /* from input1.input1                                    */
         if rdefProfileKey = permitProfileKey1 ,
          | rdefProfileKey = permitProfileKey2
         then leave   /* time 2 write real permits 4 this profile_key */
         else iterate /* not right rdef/data/permit seq, keep looking */
                      /* ... and keep writing out the next rdef/data/ */
                      /* ... permit sequence(s) until we find a match.*/
      end

      if word1 = 'PE'     & wordpos('RESET',input3.input3) > 0
      then do
         /* reset profile found */
         output = output + 1; output.output = input3.input3

         /* now after outputing RDEF/DATA/PERMIT w/RESET sequence */
         /* check to see if this rdef is for our pending permit   */
         /* from input1.input1                                    */
         if rdefProfileKey = permitProfileKey1 ,
          | rdefProfileKey = permitProfileKey2
         then leave   /* time 2 write real permits 4 this profile_key */
         else iterate /* not right rdef/data/permit seq, keep looking */
                      /* ... and keep writing out the next rdef/data/ */
                      /* ... permit sequence(s) until we find a match.*/
      end
   end

   /* if files are out of data, leave now */
   if (input3Rc = 2 & input3 > input3.0) ,
    & (input2Rc = 2 & input2 > input2.0) ,
    & (input1Rc = 2 & input1 > input1.0)
   then leave

   /* start writting out matching permits for rdef from input1 file */
   if rdefProfileKey = permitProfileKey1/* if match, write permit  */
   then do
      match = 'INPUT1'
      output = output + 1; output.output = input1.input1
   end
   else if rdefProfileKey = permitProfileKey2 /*if match, write permit*/
   then do
      match = 'INPUT2'
      output = output + 1; output.output = input2.input2
   end
   else if permitProfileKey1 = '',/* we're at eof, that's ok */
         & permitProfileKey2 = '' /* we're at eof, that's ok */
   then nop
   else do
      /* logically this can't happen, we have an explicit permit */
      /* with no matching rdef                                   */
      if permitProfileKey1 <> ''
      then do
       say 'logic error, permit at line' totalInput1 'in ddname=INPUT1:'
       say 'permitProfileKey1="'permitProfileKey1'"'
       say 'startPermit1='startPermit1
       say 'input1.'input1 '='input1.input1
       say 'But no matching RDEF found in ddname=INPUT3'
       say 'closing files, and exiting with rc=8'
      end
      if permitProfileKey2 <> ''
      then do
       say ' '
       say 'logic error, permit at line' totalInput2 'in ddname=INPUT2:'
       say 'permitProfileKey2="'permitProfileKey2'"'
       say 'startPermit2='startPermit2
       say 'input2.'input2 '='input2.input2
       say 'But no matching RDEF found in ddname=INPUT3'
       say 'closing files, and exiting with rc=8'
      end
      'EXECIO 0 DISKR INPUT1 (FINIS'
      'EXECIO 0 DISKR INPUT2 (FINIS'
      'EXECIO 0 DISKR INPUT3 (FINIS'
      'EXECIO' output 'DISKW OUTPUT (STEM OUTPUT. FINIS'
      exit 8
   end

   /* now write out other matching permits (until eof) or until we */
   /* find a new non-matching permit                               */
   if match = 'INPUT1'
   then do
      skip = 0 /* skipping not in effect */
      do while input1rc = 0 | (input1rc = 2 & input1 <= input1.0)
         input1 = input1 + 1 /* bump to next record in input1 buffer */
         if input1 > input1.0 /*input1 buffer empty? */
         then do              /*...yes, we need another buffer */
            if input1Rc = 2          /* if already pending eof */
            then do                  /* then it's real EOF now */
               permitProfileKey1= ''
               leave /* exit this do while loop */
            end

            /* read in next buffer of input records */
            'EXECIO 100 DISKR INPUT1 (STEM INPUT1.'
            input1 = 0     /* reset our buffer point */
            input1Rc = rc  /* save rc                */
            if input1Rc = 0 | input1Rc = 2 /* if good rc, iterate*/
            then iterate                   /*                    */

            /* report i/o error and close files */
            say 'Read for ddname=INPUT1 failed with rc='input1Rc
            'EXECIO' output 'DISKW OUTPUT (stem output. FINIS'
            'EXECIO 0 DISKR INPUT1 (FINIS'
            'EXECIO 0 DISKR INPUT2 (FINIS'
            'EXECIO 0 DISKR INPUT3 (FINIS'
            say 'aborting now with rc=8'
            exit 8
         end
         totalInput1 = totalInput1 + 1
         if totalInput1 = break2 /* we've reached the other */
         then do                 /* ...other group of  permits*/
            skip = 1 /* start skipping until we see 'rowsReturned' */
            iterate
         end

         if skip = 1,/* skipping in effect until we see "rowsReturned"*/
          & totalInput1 < startPermit2
         then iterate /*skip until we match current set of permits */

         if skip = 1 /* skipping in effect until we see "rowsReturned"*/
         then if word(input1.input1,2) = 'rowsReturned'
            then do
               skip = 2 /* we no longer need to worry about skipping*/
               iterate  /* stop on next valid permit                */
            end
            else iterate /* continue skipping */
         else if word(input1.input1,2) = 'rowsReturned'
            then do
               skip = 2 /* we will need to reset our startPermit1   */
               iterate  /* stop on next valid permit                */
            end
            else nop    /* continue processing permits normally */

         word1 = word(input1.input1,1)
         if word1 <> 'PERMIT' & word1 <> 'PE' then iterate
         if wordpos('RESET',input1.input1) > 0 then iterate

         if skip = 2
         then do
            startPermit1 = totalInput1 /* start of new permits */
            parse var input1.input1 . permitProfileKey1 .

            /* we may increase StartPermit1 multiple times, but we  */
            /* need to have input2 break on either our prior (lower)*/
            /* break1, or we may be forced to set a new break1      */
            if break1 < startPermit2
            then break1 = startPermit1/* we need to set new break for */
                                      /* input2.                      */

            skip = 0
         end

         parse var input1.input1 . permitProfileKey1 .
         if rdefProfileKey = permitProfileKey1
         then do
            output = output + 1; output.output=input1.input1
            iterate /* maybe another permit can be written for rdef,*/
                    /* keep reading                                 */
         end
         else if rdefProfileKey = permitProfileKey2
         then do
            match = 'INPUT2' /* also matches INPUT2 process that */
            output = output + 1; output.output = input2.input2
            leave            /* leave the input1 do loop         */
         end
         else leave /* exit this "do while" loop; ...               */
                    /* we have another pending permit 2 find rdef for*/
      end
   end
   if match = 'INPUT2'
   then do
      skip = 0 /* skipping not in effect */
      do while input2rc = 0 | (input2rc = 2 & input2 <= input2.0)
         input2 = input2 + 1 /* bump to next record in input2 buffer */
         if input2 > input2.0 /*input2 buffer empty? */
         then do              /*...yes, we need another buffer */
            if input2Rc = 2          /* if already pending eof */
            then do                  /* then it's real EOF now */
               permitProfileKey2= ''
               leave /* exit this do while loop */
            end

            /* read in next buffer of input records */
            'EXECIO 100 DISKR INPUT2 (STEM INPUT2.'
            input2 = 0     /* reset our buffer point */
            input2Rc = rc  /* save rc                */
            if input2Rc = 0 | input2Rc = 2 /* if good rc, iterate*/
            then iterate                   /*                    */

            /* report i/o error and close files */
            say 'Read for ddname=INPUT2 failed with rc='input2Rc
            'EXECIO' output 'DISKW OUTPUT (stem output. FINIS'
            'EXECIO 0 DISKR INPUT1 (FINIS'
            'EXECIO 0 DISKR INPUT2 (FINIS'
            'EXECIO 0 DISKR INPUT3 (FINIS'
            say 'aborting now with rc=8'
            exit 8
         end
         totalInput2 = totalInput2 + 1
         if totalInput2 = break1      /* we've reached the other */
         then do                      /* ...other group of  permits*/
            skip = 1 /* start skipping until we see 'rowsReturned' */
            iterate
         end

         if skip = 1,/* skipping in effect until we see "rowsReturned"*/
          & totalInput2 < startPermit1
         then iterate /*skip until we match current set of permits */

         if skip = 1 /* skipping in effect until we see "rowsReturned"*/
         then if word(input2.input2,2) = 'rowsReturned'
            then do
               skip = 2 /* we no longer need to worry about skipping*/
               iterate  /* stop on next valid permit                */
            end
            else iterate /* continue skipping */
         else if word(input2.input2,2) = 'rowsReturned'
            then do
               skip = 2 /* we need to reset our startPermit2        */
               iterate  /* stop on next valid permit                */
            end
            else nop    /* continue processing permits normally */

         word1 = word(input2.input2,1)
         if word1 <> 'PERMIT' & word1 <> 'PE' then iterate
         if wordpos('RESET',input2.input2) > 0 then iterate

         if skip = 2
         then do
            startPermit2 = totalInput2 /* start of new permits */
            parse var input2.input2 . permitProfileKey2 .

            /* we may increase StartPermit2 multiple times, but we  */
            /* need to have input1 break on either our prior (lower)*/
            /* break2, or we may be forced to set a new break2      */
            if break2 < startPermit1
            then break2 = startPermit2/* we need to set new break for */
                                      /* input1                       */
            skip = 0
         end

         parse var input2.input2 . permitProfileKey2 .
         if rdefProfileKey = permitProfileKey2
         then do
            output = output + 1; output.output=input2.input2
            iterate /* maybe another permit can be written for rdef,*/
                    /* keep reading                                 */
         end
         else leave /* exit this "do while" loop; ...               */
                    /* we have another pending permit 2 find rdef for*/
      end
   end
   /* loop to find another RDEF */
end

pendingrc = 0
if input1rc <> 2
then do
   say 'Error reading data from ddname=INPUT1 (after reading' ,
         totalInput1 'records) rc='input1rc
   pendingrc = 8
end
'EXECIO 0 DISKR INPUT1 (FINIS'

if input2rc <> 2
then do
   say 'Error reading data from ddname=INPUT2 (after reading' ,
         totalInput2 'records) rc='input2rc
   pendingRc = 8
end
'EXECIO 0 DISKR INPUT2 (FINIS'

if input3rc <> 2
then do
   say 'Error reading data from ddname=INPUT3 (after reading' ,
         totalInput3 'records) rc='input3rc
   pendingRc = 8
end
'EXECIO 0 DISKR INPUT3 (FINIS'

'EXECIO' output 'DISKW OUTPUT (STEM OUTPUT. FINIS'
outputrc = rc
if outputRc <> 0
then do
   say 'Error writing to ddname=OUTPUT; rc='outputRc
   exit 8
end
if pendingrc = 8
then exit 8
exit 0
